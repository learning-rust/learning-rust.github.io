title: ç”Ÿå‘½å‘¨æœŸ - Lifetimes
---

å½“æˆ‘ä»¬åœ¨å¤„ç†å¼•ç”¨ç›¸å…³çš„æƒ…å†µæ—¶ï¼Œæˆ‘ä»¬éœ€è¦ç¡®ä¿æ‰€å¼•ç”¨çš„æ•°æ®åœ¨æˆ‘ä»¬å¼•ç”¨çš„è¿‡ç¨‹ä¸­ä¸€ç›´å­˜åœ¨ã€‚

æƒ³è±¡ä¸€ä¸‹ï¼Œ

* æˆ‘ä»¬æœ‰ä¸€ä¸ªå˜é‡ç»‘å®šï¼Œâ€œ**a**â€ï¼›
* æˆ‘ä»¬ä½¿ç”¨å¦ä¸€ä¸ªå˜é‡ç»‘å®šâ€œxâ€å¼•ç”¨äº†â€œaâ€ä¸­çš„æ•°æ®ã€‚æˆ‘ä»¬å¿…é¡»ä¿è¯åœ¨ä½¿ç”¨â€œxâ€çš„æ•´ä¸ªè¿‡ç¨‹ä¸­ï¼Œâ€œaâ€çš„æ•°æ®å¿…é¡»**ç”Ÿå­˜**ç€ã€‚

> ğŸ” **å†…å­˜ç®¡ç†**æ˜¯ä¸€ç§å¯¹äºç”µè„‘å†…å­˜èµ„æºè¿›è¡Œç®¡ç†çš„æœºåˆ¶ã€‚ç›´åˆ°1990å¹´ä»£ä¸­æœŸï¼Œå¤§å¤šæ•°çš„ç¼–ç¨‹è¯­è¨€ä½¿ç”¨çš„æ˜¯**æ‰‹åŠ¨å†…å­˜ç®¡ç†**ï¼Œè¿™å°±è¦æ±‚**ç¨‹åºå‘˜æ‰‹åŠ¨**æŒ‡å®šå¹¶å›æ”¶ä¸å†éœ€è¦ä½¿ç”¨çš„å¯¹è±¡/åƒåœ¾ã€‚å¤§çº¦åœ¨1959å¹´ï¼ŒJohn McCarthyå‘æ˜äº†**åƒåœ¾å›æ”¶ï¼ˆGCï¼‰**æœºåˆ¶ï¼Œä¸€ç§**è‡ªåŠ¨åŒ–çš„å†…å­˜ç®¡ç†ï¼ˆAMMï¼‰**æœºåˆ¶ã€‚å®ƒä¼šè‡ªåŠ¨è¯†åˆ«å¹¶é‡Šæ”¾æ— ç”¨çš„å†…å­˜ç©ºé—´è€Œæ— éœ€å†ä¾èµ–ç¨‹åºå‘˜çš„æ‰‹å·¥æ“ä½œã€‚æ­¤å¤–ï¼Œ**Objective-C and Swift**ç­‰è¯­è¨€ä¹Ÿé€šè¿‡**è‡ªåŠ¨å¼•ç”¨è®¡æ•° - Automatic Reference Counting**\(ARC\)æœºåˆ¶æ¥å®ç°ç±»ä¼¼çš„åŠŸèƒ½ã€‚

## ä½•ä¸ºç”Ÿå‘½å‘¨æœŸ?

åœ¨Rustä¸­ï¼Œ

* ä¸€ä¸ªèµ„æºåŒä¸€æ—¶é—´åªèƒ½æœ‰**ä¸€ä¸ªæ‰€æœ‰è€…**ã€‚å½“å®ƒ**ç¦»å¼€å½“å‰åŸŸ**ï¼ŒRustå°±ä¼šåœ¨å†…å­˜ä¸­å°†å…¶åˆ é™¤ã€‚
* å½“æˆ‘ä»¬æƒ³è¦é‡ç”¨åŒä¸€èµ„æºæ—¶ï¼Œæˆ‘ä»¬ä¼šä½¿ç”¨**å¼•ç”¨**å®ƒæˆ–**å€Ÿç”¨**å®ƒçš„å†…å®¹ã€‚
* å½“æˆ‘ä»¬å¤„ç†**å¼•ç”¨**æ—¶ï¼Œæˆ‘ä»¬éœ€è¦æŒ‡å®š**ç”Ÿå‘½å‘¨æœŸå£°æ˜**ï¼Œä»¥æç¤º**ç¼–è¯‘å™¨**è¿™äº›è¢«å¼•ç”¨çš„èµ„æº**åº”å½“å­˜æ´»å¤šä¹…**ã€‚
* â­ ï¸ä½†æ˜¯è¿‡å¤šçš„ç”Ÿå‘½å‘¨æœŸå£°æ˜ä¼šè®©**ä»£ç å˜å¾—å†—é•¿**ï¼Œä¸ºäº†ä½¿**é€šå¸¸æƒ…å†µä¸‹çš„ç¼–ç¨‹**æ›´åŠ äººæ€§åŒ–ï¼ŒRustå…è®¸åœ¨å®šä¹‰`fn`æ—¶å¯¹ç”Ÿå‘½å‘¨æœŸå£°æ˜è¿›è¡Œçœç•¥ã€‚è¿™ç§æƒ…å†µä¸‹ï¼Œç¼–è¯‘å™¨ä¼š**æ¨æ–­**ç›¸åº”çš„ç”Ÿå‘½å‘¨æœŸå£°æ˜ã€‚

ç”Ÿå‘½å‘¨æœŸå£°æ˜ä¼šåœ¨**ç¼–è¯‘æ—¶è¿›è¡Œä»·å·®**ã€‚ç¼–è¯‘å™¨ä¼šåœ¨ç¬¬ä¸€æ¬¡å’Œæœ€åä¸€æ¬¡ä½¿ç”¨æ•°æ®æ—¶è¿›è¡Œæ£€æŸ¥ã€‚æ ¹æ®è¿™ä¸€ç»“æœï¼ŒRuståœ¨**è¿è¡Œæ—¶**ä¼šå¯¹å†…å­˜è¿›è¡Œç®¡ç†ã€‚è¿™ä¹Ÿæ˜¯å¯¼è‡´Rustç¼–è¯‘æ—¶é—´ç•¥é•¿çš„ä¸»è¦åŸå› ã€‚

> * ä¸åŒäºCæˆ–C++ï¼ŒRust**é€šå¸¸**ä¸éœ€è¦æ˜ç¡®çš„ä¸»åŠ¨ä¸¢å¼ƒæ•°æ®ï¼›
> * ä¸åŒäºåƒåœ¾å›æ”¶ï¼ŒRustå¹¶ä¸ä¼šåœ¨ä¸€ä¸ªæ•°æ®æ²¡æœ‰å¼•ç”¨çš„æƒ…å†µä¸‹æ”¶å›æ‰€åˆ†é…çš„å†…å­˜;
> * Rustä¼šåœ¨æ•°æ®ç¦»å¼€åŸŸçš„æ—¶å€™å›æ”¶æ‰€å±å†…å­˜å¹¶å¼ºåˆ¶ä¿è¯åç»­ä¸å†æœ‰å¯¹äºè¿™ä¸€æ®µæ•°æ®çš„å¼•ç”¨ã€‚

## ä½¿ç”¨ç”Ÿå‘½å‘¨æœŸ

ç”Ÿå‘½å‘¨æœŸå£°æ˜ç”±ä¸€ä¸ªå•å¼•å·æ‰€æ ‡è®°ã€‚é€šå¸¸çš„ä¹ æƒ¯æ˜¯ä½¿ç”¨ä¸€ä¸ªå°å†™å­—æ¯ä½œä¸ºå‘½åï¼Œä¸€èˆ¬ä»`'a`å¼€å§‹ï¼Œå¹¶åœ¨**éœ€è¦å¤šä¸ªç”Ÿå‘½å‘¨æœŸå£°æ˜æ—¶æŒ‰å­—æ¯è¡¨å‘åæ’åˆ—**ã€‚

ä½•æ—¶ä½¿ç”¨å¼•ç”¨ï¼š

### 01. å£°æ˜å‡½æ•°æ—¶

* å…¥å‚æˆ–å‡ºå‚ä¸­ä½¿ç”¨å¼•ç”¨ï¼Œåº”å½“åœ¨`&`ç¬¦å·åé™„åŠ ç”Ÿå‘½å‘¨æœŸå£°æ˜ï¼Œå¦‚ï¼š`..(x: &'a str)` , `..(x: &'a mut str)`
* åœ¨å‡½æ•°ååï¼Œæˆ‘ä»¬åº”ç»™å‡ºä¸€ä¸ªå£°æ˜å‘¨æœŸå‘½åä½œä¸ºæ³›å‹å£°æ˜ï¼Œå¦‚ï¼š`fn foo<'a>(..)` , `fn foo<'a, 'b>(..)`

```rust
// æ²¡æœ‰è¾“å…¥ï¼Œä½†è¿”å›ä¸€ä¸ªå¼•ç”¨
fn function<'a>() -> &'a str {}

// å•ä¸€å…¥å‚
fn function<'a>(x: &'a str) {}

// å•ä¸€å…¥å‚ï¼Œå•ä¸€ç»“æœï¼ŒäºŒè€…ç”Ÿå‘½å‘¨æœŸç›¸åŒï¼Œä¸”ç»“æœçš„ç”Ÿå‘½å‘¨æœŸè‡³å°‘ä¸å…¥å‚ç›¸åŒ
fn function<'a>(x: &'a str) -> &'a str {}

// å¤šä¸ªå…¥å‚ï¼Œä»…æœ‰ä¸€ä¸ªå…¥å‚å’Œè¿”å›ç»“æœä½¿ç”¨åŒä¸€ç”Ÿå‘½å‘¨æœŸï¼Œå³è¿”å›å€¼è‡³å°‘ä¸å‚æ•°yçš„ç”Ÿå‘½å‘¨æœŸç›¸åŒ
fn function<'a>(x: i32, y: &'a str) -> &'a str {}

// å¤šä¸ªå…¥å‚ï¼Œæ‰€æœ‰å…¥å‚å’Œç»“æœçš„å£°æ˜å‘¨æœŸå‡ç›¸åŒï¼Œå³è¿”å›å€¼è‡³å°‘ä¸xå’Œyå­˜æ´»çš„ä¸€æ ·ä¹…
fn function<'a>(x: &'a str, y: &'a str) -> &'a str {}

// å¤šä¸ªå…¥å‚ï¼Œå…¥å‚çš„ç”Ÿå‘½å‘¨æœŸä¸åŒï¼Œè¿”å›å€¼çš„ç”Ÿå‘½å‘¨æœŸè‡³å°‘å¤§äºç­‰äºå‚æ•°xğŸ”
fn function<'a, 'b>(x: &'a str, y: &'b str) -> &'a str {}
```

### 02. ç»“æ„ä½“å’Œæšä¸¾å£°æ˜æ—¶

* å¼•ç”¨ç±»å‹çš„å…ƒç´ åº”è¯¥åœ¨`&`ç¬¦å·åé™„åŠ ç”Ÿå‘½å‘¨æœŸå£°æ˜ï¼›
* åœ¨ç»“æ„ä½“æˆ–æšä¸¾çš„åç§°åï¼Œåº”ä»¥æ³›å‹çš„å½¢å¼å¢åŠ ç”Ÿå‘½å‘¨æœŸç±»å‹ã€‚

```rust
// å•ä¸€å…ƒç´ ï¼Œæ•°æ®xåº”è¯¥è‡³å°‘åœ¨ç»“æ„ä½“å­˜åœ¨çš„æ—¶å€™éƒ½å­˜æ´»
struct Struct<'a> {
    x: &'a str
}

// å¤šä¸ªå…ƒç´ ï¼Œxå’Œyåœ¨ç»“æ„ä½“å­˜åœ¨æ—¶éƒ½åº”å­˜æ´»
struct Struct<'a> {
    x: &'a str,
    y: &'a str
}


// å•ä¸€å…ƒç´ å˜ä½“
// å˜ä½“å­˜åœ¨çš„æ—¶é—´åº”è¯¥è‡³å°‘ä¸æšä¸¾ä¸€æ ·é•¿
enum Enum<'a> {
    Variant(&'a Type)
}
```

### 03. å¢åŠ å®ç°å’Œç‰¹æ€§æ—¶

```rust
struct Struct<'a> {
    x: &'a str
}
    impl<'a> Struct<'a> {
        fn function<'a>(&self) -> &'a str {
            self.x
        }
    }


struct Struct<'a> {
    x: &'a str,
    y: &'a str
}
    impl<'a> Struct<'a> {
        fn new(x: &'a str, y: &'a str) -> Struct<'a> { // åœ¨newå‡½æ•°åå¹¶ä¸éœ€è¦å†æ¬¡æŒ‡å®š<'a>ï¼Œå› ä¸ºåœ¨implåå·²ç»æœ‰æ‰€æŒ‡æ˜
          Struct {
              x : x,
              y : y
          }
        }
    }


// ğŸ”
impl<'a> Trait<'a> for Type
impl<'a> Trait for Type<'a>
```

### 04. åŒæ³›å‹ä¸€èµ·ä½¿ç”¨

```rust
// ğŸ”
fn function<F>(f: F) where for<'a> F: FnOnce(&'a Type)
struct Struct<F> where for<'a> F: FnOnce(&'a Type) { x: F }
enum Enum<F> where for<'a> F: FnOnce(&'a Type) { Variant(F) }
impl<F> Struct<F> where for<'a> F: FnOnce(&'a Type) { fn x(&self) -> &F { &self.x } }
```

## å£°æ˜å‘¨æœŸçœç•¥

å¦‚å‰æ‰€è¿°ï¼Œä¸ºäº†ä»¤**é€šå¸¸æƒ…å†µ**ä¸‹çš„å¼€å‘æ›´åŠ äººæ€§åŒ–ï¼ŒRustå…è®¸åœ¨å¼€å‘æ—¶è¿›è¡Œç”Ÿå‘½å‘¨æœŸå£°æ˜çš„çœç•¥ï¼Œè¿™ä¸€è¿‡ç¨‹å³æ˜¯**ç”Ÿå‘½å‘¨æœŸçœç•¥**ã€‚

ğŸ’¡ For the moment Rust supports Lifetime Elisions only on `fn` definitions. But in the future it will support for `impl` headers as well.

Lifetime annotations of `fn` definitions can be elided  
if its **parameter list** has either,

* **only one input parameter passes by reference**.
* a parameter with **either** `&self` **or** **&mut self** reference.

```rust
fn triple(x: &u64) -> u64 { //only one input parameter passes by reference
    x * 3
}


fn filter(x: u8, y: &str) -> &str { // only one input parameter passes by reference
    if x > 5 { y } else { "invalid inputs" }
}


struct Player<'a> {
    id: u8,
    name: &'a str
}
    impl<'a> Player<'a> { //so far Lifetime Elisions are allowed only on fn definitions; but in the future they might support on impl headers as well.
        fn new(id: u8, name: &str) -> Player { //only one input parameter passes by reference
            Player {
                id : id,
                name : name
            }
        }

        fn heading_text(&self) -> String { // a fn definition with &self (or &mut self) reference
            format!("{}: {}", self.id, self.name)
        }
    }

fn main() {
    let player1 = Player::new(1, "Serena Williams");
    let player1_heading_text = player1.heading_text()
    println!("{}", player1_heading_text);
}
```

> ğŸ’¡ In the Lifetime Elision process of fn definitions,
>
> * Each parameter passes by reference is got a distinct lifetime annotation.
>     ex. `..(x: &str, y: &str)` â†’ `..<'a, 'b>(x: &'a str, y: &'b str)`
> * If the parameter list has only one parameter passes by reference, that lifetime is assigned to all elided lifetimes in the return values of that function.
>     ex. `..(x: i32, y: &str) -> &str` â†’ `..<'a>(x: i32, y: &'a str) -> &'a str`
> * Even it has multiple parameters pass by reference, if one of them has &self or &mut self, the lifetime of self is assigned to all elided output lifetimes.
>     ex. `impl Impl{ fn function(&self, x: &str) -> &str {} }` â†’
>     `impl<'a> Impl<'a>{ fn function(&'a self, x: &'b str) -> &'a str {} }`
> * For all other cases, we have to write lifetime annotations manually.

## `'static` Annotations

`'static` lifetime annotation is a **reserved** lifetime annotation. These **references are valid for the entire program**. They are saved in the data segment of the binary and the data referred to will never go out of scope.

```rust
static N: i32 = 5; //A constant with 'static lifetime

let a = "Hello, world."; //a: &'static str


fn index() -> &'static str { //No need to mention <'static> ; fn index Ì¶<Ì¶'Ì¶sÌ¶tÌ¶aÌ¶tÌ¶iÌ¶cÌ¶>Ì¶ 
	"Hello, world!"
}
```

## Few more examples about usage of Rust lifetimes.

```rust
fn greeting<'a>() -> &'a str {
  "Hi!"
}


fn fullname<'a>(fname: &'a str, lname: &'a str) -> String {
  format!("{} {}", fname, lname)
}


struct Person<'a> {
    fname: &'a str,
    lname: &'a str
}
  impl<'a> Person<'a> {
      fn new(fname: &'a str, lname: &'a str) -> Person<'a> { //no need to specify <'a> after new; impl already has it
          Person {
              fname : fname,
              lname : lname
          }
      }

      fn fullname(&self) -> String {
          format!("{} {}", self.fname , self.lname)
      }
  }

fn main() {
    let player = Person::new("Serena", "Williams");
    let player_fullname = player.fullname();

    println!("Player: {}", player_fullname);
}
```
