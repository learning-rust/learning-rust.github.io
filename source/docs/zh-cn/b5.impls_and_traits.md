title: å®žçŽ°ä¸Žç‰¹æ€§ - Impls & Traits
---

ðŸ’¡ å½“æˆ‘ä»¬è®¨è®º**ç±»Cç»“æž„**æ—¶ï¼Œæ›¾æåˆ°å®ƒä¸Žé¢å‘å¯¹è±¡è¯­è¨€ä¸­çš„**ç±»**å¾ˆç›¸ä¼¼ï¼Œä½†æ˜¯**ä¸åŒ…å«ç±»åŠå…¶å®žä¾‹çš„æ–¹æ³•**ã€‚**å®žçŽ°**æ˜¯ç”¨æ¥ä¸ºRustçš„ç»“æž„ä½“å’Œæžšä¸¾**å®šä¹‰æ–¹æ³•**çš„æ“ä½œã€‚

ðŸ’¡ **ç‰¹æ€§ - Traits**æ˜¯ä¸€ç±»ä¸Žé¢å‘å¯¹è±¡è¯­è¨€ä¸­çš„æŽ¥å£æ¯”è¾ƒ**ç±»ä¼¼**çš„æ¦‚å¿µï¼Œä»–ä»¬ç”¨æ¥å®šä¹‰ä¸€ä¸ªç±»åž‹å¿…é¡»åŠ ä»¥å®žçŽ°çš„æ–¹æ³•ã€‚ä¸€ä¸ªç±»åž‹å¯ä»¥å®žçŽ°å¤šç§ç‰¹æ€§ã€‚

â­ï¸ï¸ ä½†æ˜¯ï¼Œç‰¹æ€§**å¯ä»¥åŒ…å«æ–¹æ³•çš„é»˜è®¤å®žçŽ°**ã€‚è¿™äº›é»˜è®¤å®žçŽ°å¯ä»¥åœ¨ç±»åž‹è¿›è¡Œç‰¹æ€§çš„å…·ä½“å®žçŽ°æ—¶åŠ ä»¥è¦†ç›–ã€‚

### æ— ç‰¹å®šç‰¹æ€§çš„å®žçŽ°

```rust
struct Player {
    first_name: String,
    last_name: String,
}

impl Player {
    fn full_name(&self) -> String {
        format!("{} {}", self.first_name, self.last_name)
    }
}

fn main() {
    let player_1 = Player {
        first_name: "Rafael".to_string(),
        last_name: "Nadal".to_string(),
    };

    println!("Player 01: {}", player_1.full_name());
}

// â­ï¸ å®žçŽ°å¿…é¡»å’Œç±»åž‹æœ¬èº«åœ¨åŒä¸€ä¸ªcrateåŒ…ä¸­

// ðŸ’¡ æ­¤å¤–ï¼Œåœ¨Rustä¸­ï¼Œå¯ä»¥ä¸ºä»¥å­˜åœ¨çš„æ•°æ®ç±»åž‹ï¼Œå¦‚i8ã€f64ç­‰å®žçŽ°æ–°çš„ç‰¹æ€§ã€‚
// åŒæ ·åœ°ï¼Œä¹Ÿå¯å¯¹äºŽä½ æ–°åˆ›çš„ç±»åž‹å®žçŽ°å·²æœ‰çš„ç‰¹æ€§ã€‚
// ä½†æˆ‘ä»¬ä¸èƒ½å¯¹å·²æœ‰ç±»åž‹çš„å·²æœ‰ç‰¹æ€§å¢žåŠ æ—¢æœ‰å®žçŽ°ã€‚
```

### ç‰¹æ€§ä¸Žå®žçŽ°ï¼Œä¸åŒ…å«é»˜è®¤æ–¹æ³•

```rust
struct Player {
    first_name: String,
    last_name: String,
}

trait FullName {
    fn full_name(&self) -> String;
}

impl FullName for Player {
    fn full_name(&self) -> String {
        format!("{} {}", self.first_name, self.last_name)
    }
}

fn main() {
    let player_2 = Player {
        first_name: "Roger".to_string(),
        last_name: "Federer".to_string(),
    };

    println!("Player 02: {}", player_2.full_name());
}

// ðŸ”Ž é™¤å‡½æ•°å¤–ï¼Œä¸€ä¸ªç‰¹æ€§ä¹Ÿå¯ä»¥åŒ…å«å¸¸é‡å’Œç±»åž‹
```

### å¸¦æœ‰é»˜è®¤æ–¹æ³•çš„å®žçŽ°å’Œç‰¹æ€§

```rust
trait Foo {
    fn bar(&self);
    fn baz(&self) { println!("We called baz."); }
}
```

â­ï¸ å¦‚ä½ æ‰€è§ï¼ŒæŸäº›æ–¹æ³•çš„é¦–ä¸ªå‚æ•°å¯èƒ½æ˜¯ä¸€ä¸ªç‰¹å®šçš„å€¼ - å³**ç±»åž‹æœ¬èº«**ã€‚å®ƒå¯èƒ½æ˜¯**self, &self, æˆ–&mut self**ä¸­çš„ä¸€ä¸ªï¼šå½“éœ€è¦å–å¾—æ ˆä¸Šçš„å€¼è‡ªèº«æ—¶ï¼Œä½¿ç”¨ *self*ï¼Œæ­¤æ—¶ä¼šå–å¾—å€¼çš„æ‰€æœ‰æƒï¼›å½“å…¶æŒ‡ä»£ä¸€ä¸ªå¼•ç”¨æ—¶ï¼Œä½¿ç”¨ *&self*ï¼›å½“å®ƒä½œä¸ºä¸€ä¸ªå¯å˜å¼•ç”¨æ—¶ï¼Œä½¿ç”¨ *&mut self*

### å®žçŽ°å…³è”å‡½æ•°

å…¶ä»–ä¸€äº›è¯­è¨€å¯èƒ½ä¼šæ”¯æŒ**é™æ€æ–¹æ³•**ã€‚é€šè¿‡è¿™ä¸€é€”å¾„ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ç±»æœ¬èº«**ç›´æŽ¥è°ƒç”¨æ–¹æ³•**è€Œæ— éœ€åˆ›å»ºä¸€ä¸ªç±»çš„å®žä¾‹ã€‚åœ¨Rustä¸­ï¼Œæˆ‘ä»¬ç§°ä¹‹ä¸º**å…³è”å‡½æ•° - Associated Functions**ã€‚æˆ‘ä»¬ä½¿ç”¨ **::** è€Œä¸æ˜¯.æ¥è°ƒç”¨æŸä¸€ç»“æž„ä½“çš„å…³è”å‡½æ•°ã€‚
ä¾‹å¦‚ï¼š `Person::new(â€œElon Musk Jrâ€);`


```rust
struct Player {
    first_name: String,
    last_name: String,
}

impl Player {
    fn new(first_name: String, last_name: String) -> Player {
        Player {
            first_name : first_name,
            last_name : last_name,
        }
    }

    fn full_name(&self) -> String {
        format!("{} {}", self.first_name, self.last_name)
    }
}

fn main() {
    let player_name = Player::new("Serena".to_string(), "Williams".to_string()).full_name();
    println!("Player: {}", player_name);
}

// We have used :: notation for `new()` and . notation for `full_name()`

// ðŸ”Ž Also in here, instead of using new() and full_name() separately as two expressions, 
// we can use Method Chaining. ex. `player.add_points(2).get_point_count();`
```

### Traits with generics

```rust
trait From<T> {
    fn from(T) -> Self;
}
    impl From<u8> for u16 {
        //...
    }
    impl From<u8> for u32{
        //...
    }
    
// Should specify after the trait name like generic functions
```

### Traits inheritance

```rust
trait Person {
    fn full_name(&self) -> String;
}

    trait Employee : Person { // Employee inherits from person trait
      fn job_title(&self) -> String;
    }

    trait ExpatEmployee : Employee + Expat { // ExpatEmployee inherits from Employee and Expat traits
      fn additional_tax(&self) -> f64;
    }
```

### Trait objects

ðŸ”Ž While Rust favors static dispatch, it also supports dynamic dispatch through a mechanism called â€˜trait objects.â€™

> [ðŸ…†](https://en.wikipedia.org/wiki/Dynamic_dispatch) **Dynamic dispatch** is the process of selecting which implementation of a polymorphic operation (method or function) to call at run time.


```rust
trait GetSound {
    fn get_sound(&self) -> String;
}

struct Cat {
    sound: String,
}
    impl GetSound for Cat {
        fn get_sound(&self) -> String {
            self.sound.clone()
        }
    }

struct Bell {
    sound: String,
}
    impl GetSound for Bell {
        fn get_sound(&self) -> String {
            self.sound.clone()
        }
    }


fn make_sound<T: GetSound>(t: &T) {
    println!("{}!", t.get_sound())
}

fn main() {
    let kitty = Cat { sound: "Meow".to_string() };
    let the_bell = Bell { sound: "Ding Dong".to_string() };

    make_sound(&kitty); // Meow!
    make_sound(&the_bell); // Ding Dong!
}
```
