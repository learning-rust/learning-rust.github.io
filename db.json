{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/browserconfig.xml","path":"browserconfig.xml","modified":1,"renderable":0},{"_id":"source/favicon.ico","path":"favicon.ico","modified":1,"renderable":0},{"_id":"source/footer.ejs","path":"footer.ejs","modified":1,"renderable":0},{"_id":"source/header.ejs","path":"header.ejs","modified":1,"renderable":0},{"_id":"source/icon.png","path":"icon.png","modified":1,"renderable":0},{"_id":"source/logo.png","path":"logo.png","modified":1,"renderable":0},{"_id":"source/logo.svg","path":"logo.svg","modified":1,"renderable":0},{"_id":"source/robots.txt","path":"robots.txt","modified":1,"renderable":0},{"_id":"source/tile.png","path":"tile.png","modified":1,"renderable":0},{"_id":"source/tile-wide.png","path":"tile-wide.png","modified":1,"renderable":0},{"_id":"themes/navy/source/css/navy.styl","path":"css/navy.styl","modified":1,"renderable":1},{"_id":"themes/navy/source/js/lang_select.js","path":"js/lang_select.js","modified":1,"renderable":1},{"_id":"themes/navy/source/js/mobile_nav.js","path":"js/mobile_nav.js","modified":1,"renderable":1},{"_id":"themes/navy/source/js/toc.js","path":"js/toc.js","modified":1,"renderable":1},{"_id":"source/docs/images/rust_playground.png","path":"docs/images/rust_playground.png","modified":1,"renderable":0},{"_id":"source/docs/images/learning_rust_medium.png","path":"docs/images/learning_rust_medium.png","modified":1,"renderable":0}],"Cache":[{"_id":"source/browserconfig.xml","hash":"fbbe41933e15560e7852d721804f026586ee912f","modified":1537969649328},{"_id":"source/favicon.ico","hash":"63e4879d10467b4bc481a208c3a64649242a1420","modified":1537969649341},{"_id":"source/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1537969649341},{"_id":"source/header.ejs","hash":"f11e05683613fadbe26d60c0e4caa17446a3f753","modified":1537969649342},{"_id":"source/icon.png","hash":"2e2866bf9acc59972ff373313a4a55d63a99d5fa","modified":1537969649342},{"_id":"source/index.jade","hash":"4ff791b949071d063b26b0a1536a368f54ac26a3","modified":1547916800797},{"_id":"source/logo.png","hash":"f0d614f11bc0fcb08aa9dd002267c06e76c12cdd","modified":1537969649342},{"_id":"source/logo.svg","hash":"5e0c7d1865879f49f310bd47a09b97963c48b301","modified":1537969649343},{"_id":"source/robots.txt","hash":"99982b66ad7cd8004bc97a41ee92a7fb05c986ab","modified":1537969649343},{"_id":"source/tile.png","hash":"f0d614f11bc0fcb08aa9dd002267c06e76c12cdd","modified":1537969649344},{"_id":"source/tile-wide.png","hash":"24120ca25a08d3dce34608fd99dcfda0955fc6b9","modified":1537969649344},{"_id":"source/_data/languages.yml","hash":"f6ca069b95ecc899c54143606db156542cb65431","modified":1553007031969},{"_id":"source/docs/a1.why_rust.md","hash":"46fd6f1eff1fe4e77241ac86858757bdd8147524","modified":1553007039948},{"_id":"source/docs/a10.control_flows.md","hash":"a81c53d4cbc76ee86ab0a155b18f3499a97063bf","modified":1553007039949},{"_id":"source/docs/a2.installation.md","hash":"dc91c028e1cd343c3b0fce6666688306888fb0f1","modified":1553007039949},{"_id":"source/_data/menu.yml","hash":"4d92fec119c237b2c0d0ad45e66f5dac7bd50c59","modified":1537969649328},{"_id":"source/_data/sidebar.yml","hash":"30003bad5ccd07fb53f8818b866b864e51fc5683","modified":1547916800790},{"_id":"source/docs/a4.cargo,crates_and_basic_project_structure.md","hash":"a5f8ebb53a4bf0f8dbd2c9f9f4456200a76ca703","modified":1553007039949},{"_id":"source/docs/a5.comments_and_documenting_the_code.md","hash":"461058b592719c8abb75a5b2f36338f6b91f2a38","modified":1553007039950},{"_id":"source/docs/a6.variable_bindings,constants_and_statics.md","hash":"d6c11d390a72880f20f0923d6d3b202f22d3bd41","modified":1553007039950},{"_id":"source/docs/a7.functions.md","hash":"dae58c82383375279e8f54eef12870e2bcec6575","modified":1553007039950},{"_id":"source/docs/a3.hello_world.md","hash":"d7ba8f42c87485c4a46b64cc6e5c85b71da5c727","modified":1547916800790},{"_id":"source/docs/a8.primitive_data_types.md","hash":"dc271542b84bdbd3b83ef1883f1f6ad3d5edc91a","modified":1553007039951},{"_id":"source/docs/a9.operators.md","hash":"58353dc54c5b9f989e124fe472f14e752cc7c1e4","modified":1553007039951},{"_id":"source/docs/b1.vectors.md","hash":"816fffba05d7a10a0d0478ef390b7e637cb09756","modified":1553007039951},{"_id":"source/docs/b2.structs.md","hash":"9692c38ae9e3b923fcbaebdc1daa4c5c425e972b","modified":1553007039952},{"_id":"source/docs/b3.enums.md","hash":"e89cff8f895ecbee890c4f760c89dbf5b8c9557d","modified":1553007039952},{"_id":"source/docs/b4.generics.md","hash":"e4751cbc623a0c183464eb5101938afb2b367828","modified":1553007039952},{"_id":"source/docs/b5.impls_and_traits.md","hash":"fde00c7b4a159fe843cabf78c00fcc78c38232e4","modified":1553007039953},{"_id":"source/docs/c1.ownership.md","hash":"0858097c16363be947ee029d6c433f4e7fa09ed5","modified":1553007039953},{"_id":"source/docs/c2.borrowing.md","hash":"c7ae57d6cb813490d5821ac02817a4ebab954e2b","modified":1553007039953},{"_id":"source/docs/c3.lifetimes.md","hash":"0efd4513e5b88efe78bc96ab93e7079263a476b7","modified":1553007039954},{"_id":"source/docs/d1.code_organization.md","hash":"3ce2928b3b1e95401fa3af7d3acfed9a583ae8e7","modified":1553007039954},{"_id":"source/docs/d2.functions.md","hash":"efa339c80519f45f0245d58e2f14c954e4c96720","modified":1553007039955},{"_id":"source/docs/d3.modules.md","hash":"f7e570107ec6874fd6c3422979e4dba76f176acd","modified":1553007039955},{"_id":"source/docs/d4.crates.md","hash":"70f63469b3f614d30a262d93395fcdc1ab8720c7","modified":1553007039956},{"_id":"source/docs/d5.workspaces.md","hash":"842b95ef4c92031ee7af09eb79b41dd63d57c7e9","modified":1553007039956},{"_id":"source/docs/d6.use.md","hash":"3ffd95fc893279655db6e9dcb148485fb55a361e","modified":1553007039957},{"_id":"source/docs/e2.panicking.md","hash":"6b2844ea66522a4372891eaa7e13a88b93b77343","modified":1553007039959},{"_id":"source/docs/d7.std_primitives_and_preludes.md","hash":"fc9f042e91986731cd43e9c74ab929ebc409c80a","modified":1553007039957},{"_id":"source/docs/e1.smart_compiler.md","hash":"a765f01346a5b7052bb974e40125612ff08d3a73","modified":1553007039958},{"_id":"source/docs/e4.unwrap_and_expect.md","hash":"0e5e14e3a98b108773c4c194cda34123c74dff00","modified":1553007039960},{"_id":"source/docs/e3.option_and_result.md","hash":"b3ef6835add898de9683c53870935e638a97fb45","modified":1547916800795},{"_id":"source/docs/e5.error_and_none_propagation.md","hash":"591b7dd8c21f51c027b7b4726d30f3c37f7a11a6","modified":1547916800795},{"_id":"source/docs/e6.combinators.md","hash":"8ca64b34f06204e310df613e190fa44ff6ed2dcf","modified":1547916800795},{"_id":"source/docs/e7.custom_error_types.md","hash":"f0b538c4c2f56ac48a06ec534784414bc1a3d659","modified":1547916800795},{"_id":"source/docs/index.md","hash":"bf823c5b239bbbd03d0863fd9a4275f82f30eb67","modified":1547916800797},{"_id":"source/zh-cn/index.jade","hash":"a75a061d696d4c48814d07bc627d36ee51ce2e7c","modified":1553007031988},{"_id":"themes/navy/languages/zh-cn.yml","hash":"940e0d9b2330d05f69f4f3f0d18632ada54ebcc7","modified":1553007031988},{"_id":"themes/navy/languages/en.yml","hash":"bf72903ca6d77c193681ee8c6d2f4c3f45003bfd","modified":1547916800797},{"_id":"themes/navy/layout/index.swig","hash":"c52c941a231710700aeafd4866d964c069afb6a6","modified":1537969649345},{"_id":"themes/navy/layout/layout.swig","hash":"ef28a5f5fc3258622e72ee3a836ff8cf415fb790","modified":1537969649345},{"_id":"themes/navy/layout/page.swig","hash":"85ac992e8fc5a6577f434c65f6f71fa021a36114","modified":1537969649346},{"_id":"source/docs/zh-cn/a1.why_rust.md","hash":"7b700fa56f98732688b5b55a066fbce5f6887611","modified":1553007031980},{"_id":"source/docs/zh-cn/a10.control_flows.md","hash":"01d70eb768bcb3aa3ce826ed4ceccad2f1993f35","modified":1553007031980},{"_id":"source/docs/zh-cn/a2.installation.md","hash":"97d351de0abc4659a389a168eda0ec85bef24aae","modified":1553007031980},{"_id":"source/docs/zh-cn/a3.hello_world.md","hash":"a532fdaed694777f9d2e73c007235d444d02be90","modified":1553007031981},{"_id":"source/docs/zh-cn/a4.cargo,crates_and_basic_project_structure.md","hash":"016872103e1ca87ed242f380796b80fd030feadf","modified":1553007031982},{"_id":"source/docs/zh-cn/a5.comments_and_documenting_the_code.md","hash":"ed9000ecb788923d5bb8e2bc9655237af39c6fbd","modified":1553007045775},{"_id":"source/docs/zh-cn/a6.variable_bindings,constants_and_statics.md","hash":"c817d6e22779dffe02e72336e8838f695a7b6539","modified":1553007045775},{"_id":"source/docs/zh-cn/a7.functions.md","hash":"ccf6381f015ece607907261b8aed8198edf106f6","modified":1553007031982},{"_id":"source/docs/zh-cn/a8.primitive_data_types.md","hash":"30305ebe7287398654305451db20f230cf52ea45","modified":1553007031983},{"_id":"source/docs/zh-cn/a9.operators.md","hash":"12522be27f4d522ee96cfda556900ca02e6b98ad","modified":1553007031983},{"_id":"source/docs/zh-cn/b1.vectors.md","hash":"501b1a01586ec2832730d851f3712a2f2c644fff","modified":1553007031983},{"_id":"source/docs/zh-cn/b2.structs.md","hash":"cf526b9c92b58916f8bb9402bb3e09a2f027ded6","modified":1553007031983},{"_id":"source/docs/zh-cn/b3.enums.md","hash":"1fbb49355b7efdaf29140e3fbf178592eae60362","modified":1553007031983},{"_id":"source/docs/zh-cn/b4.generics.md","hash":"169ff9b1a0d44b9a53e7435163d4e5a41aeb5378","modified":1553007031984},{"_id":"source/docs/zh-cn/b5.impls_and_traits.md","hash":"ca56634d1900c7acf0cb95547c99620594fe7dd2","modified":1553007031984},{"_id":"source/docs/zh-cn/c1.ownership.md","hash":"d07cd45fb444b328287c31f52e77a44894d43167","modified":1553007031984},{"_id":"source/docs/zh-cn/c2.borrowing.md","hash":"0e9c6ef9b0dbbc0ec7b21bf48857ec719748680a","modified":1553007031984},{"_id":"source/docs/zh-cn/c3.lifetimes.md","hash":"201c598dd8a745bd7ec70080401eab323a730f83","modified":1553007031985},{"_id":"source/docs/zh-cn/d1.code_organization.md","hash":"244e1e3c0e860b9f37f6e5816811ffaf54efb33e","modified":1553007031985},{"_id":"source/docs/zh-cn/d2.functions.md","hash":"f7980784d321a7c82e5c439ff4b637c15841886e","modified":1553007031985},{"_id":"source/docs/zh-cn/d3.modules.md","hash":"09cb368ddd985465950df006dba5625b3f8d1b21","modified":1553007031985},{"_id":"source/docs/zh-cn/d4.crates.md","hash":"cec2915e8677b9eb9b848afb28d3742112ea72d7","modified":1553007031986},{"_id":"source/docs/zh-cn/d5.workspaces.md","hash":"8b6ea3fd7457ede0f13c61a098314fa2350399a0","modified":1553007031986},{"_id":"source/docs/zh-cn/d6.use.md","hash":"31a4e957de4a9b5536ec5d78d12f04edde6e386f","modified":1553007031986},{"_id":"source/docs/zh-cn/d7.std_primitives_and_preludes.md","hash":"8c5ef8f5c191f518dfcd7de1ac4682b12d47c272","modified":1553007031986},{"_id":"source/docs/zh-cn/index.md","hash":"b69b14f0bdc74a4d29983d7c14d4f6baa80f41ca","modified":1553007031987},{"_id":"themes/navy/layout/partial/footer.swig","hash":"9c7c019889a8aafb129b651d1f296fd589741919","modified":1547916800798},{"_id":"themes/navy/layout/partial/after_footer.swig","hash":"0cdfcc5b1be944b906a59d25e84f55a35a179c28","modified":1537969649346},{"_id":"themes/navy/layout/partial/google_analytics.swig","hash":"44869c53540e7dfc6dfde2550e3bb94e0693c8a6","modified":1537969649347},{"_id":"themes/navy/layout/partial/head.swig","hash":"b4838ad7bb5be71d97dbf94d7afcc45a324ee914","modified":1547916800798},{"_id":"themes/navy/layout/partial/header.swig","hash":"ceb929b9688b7295652ea5e778e627b6edb88a32","modified":1547916800798},{"_id":"themes/navy/layout/partial/mobile_nav.swig","hash":"78b20fe48e8de9e1ecc07399c9278ed4e0c404f9","modified":1537969649347},{"_id":"themes/navy/layout/partial/post.swig","hash":"27b0b027a12215a4b05eec31a4868448a5c7d16e","modified":1537969649348},{"_id":"themes/navy/layout/partial/share.swig","hash":"43087d425d24eb2c59ad850a68d4528f43f9842d","modified":1537969649348},{"_id":"themes/navy/layout/partial/sidebar.swig","hash":"6bb7120a1ab8eadf5089d16f63100ce7f36d7343","modified":1537969649348},{"_id":"themes/navy/source/css/_variables.styl","hash":"70a2675653277dd86d178b25c7ad50de0902583a","modified":1537969649351},{"_id":"themes/navy/source/css/navy.styl","hash":"82192ed1cf748fa515751b52c6c6240e22f32439","modified":1537969649352},{"_id":"themes/navy/source/js/lang_select.js","hash":"f3d61d478e8f7e6d9d661e5e83fdc4450a012e67","modified":1537969649352},{"_id":"themes/navy/source/js/mobile_nav.js","hash":"f4976aef22eb1e5e06b20c7735f7d3ef29b8956e","modified":1537969649352},{"_id":"themes/navy/source/js/toc.js","hash":"d95c8db8caddf36cada66acf03a2377d28e9c107","modified":1537969649353},{"_id":"source/docs/images/rust_playground.png","hash":"c3b021fb45cb2ebdc7689ba7fe809841c9f4af03","modified":1537969649341},{"_id":"themes/navy/source/css/_partial/base.styl","hash":"c4f8602ab539480b5b3c6ebaa8c368432ca5ca7b","modified":1537969649349},{"_id":"themes/navy/source/css/_partial/footer.styl","hash":"ba0a2262f0d5cf982ad1149be8f05331f492aaff","modified":1537969649349},{"_id":"themes/navy/source/css/_partial/header.styl","hash":"b84db68c0c3cc37a9bedb7f82cf563e676dd495b","modified":1537969649349},{"_id":"themes/navy/source/css/_partial/highlight.styl","hash":"f03294c7392e0c371a5f7150fe7c4e436fd361fe","modified":1537969649350},{"_id":"themes/navy/source/css/_partial/index.styl","hash":"bae9cbbde385ba4303e60c1f5e69464059478ad2","modified":1537969649350},{"_id":"themes/navy/source/css/_partial/mobile_nav.styl","hash":"7fd521d9f54865a17af453ac94dcd6b4ae420ccb","modified":1537969649351},{"_id":"themes/navy/source/css/_partial/sidebar.styl","hash":"bd44876a668ec1337d7b39be3f47e99bd95b3e3e","modified":1537969649351},{"_id":"themes/navy/source/css/_partial/page.styl","hash":"7da422e27ecc807b881b880202ae76656f2a39c3","modified":1537969649351},{"_id":"source/docs/images/learning_rust_medium.png","hash":"8e64be2d9da4e336b00a14703b3228b975588d05","modified":1547916800796}],"Category":[],"Data":[{"_id":"languages","data":{"en":"English","zh-cn":"Chinese"}},{"_id":"menu","data":{"docs":"/docs/a1.why_rust.html"}},{"_id":"sidebar","data":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}],"Page":[{"layout":"index","description":"Hexo is a fast, simple & powerful blog framework powered by Node.js.","subtitle":"Learning Rust","_content":"ul#intro-feature-list\n  li.intro-feature-wrap\n    .intro-feature\n      .intro-feature-icon\n        i.fa.fa-street-view\n      h3.intro-feature-title\n        a(href='/docs/a1.why_rust.html') Basics\n      p.intro-feature-desc Installation, Hello World, Cargo, Crates, Variable bindings, Functions, Primitive Data Types, Operators & Control Flows.\n  li.intro-feature-wrap\n    .intro-feature\n      .intro-feature-icon\n        i.fa.fa-road\n      h3.intro-feature-title\n        a(href='/docs/b1.vectors.html') Beyond the Basics\n      p.intro-feature-desc Vectors, Structs, Enums, Generics, Impls & Traits.\n  li.intro-feature-wrap\n    .intro-feature\n      .intro-feature-icon\n        i.fa.fa-plane\n      h3.intro-feature-title\n        a(href='/docs/c1.ownership.html') The Tough Part\n      p.intro-feature-desc Ownership, Borrowing, Lifetimes & Lifetime Elision.\n  li.intro-feature-wrap\n    .intro-feature\n      .intro-feature-icon\n        i.fa.fa-space-shuttle\n      h3.intro-feature-title\n        a(href='/docs/d1.code_organization.html') Let's Get It Started\n      p.intro-feature-desc Modules, Crates, Workspaces, std modules and Preludes.\n  li.intro-feature-wrap\n    .intro-feature\n      .intro-feature-icon\n        i.fa.fa-user-astronaut\n      h3.intro-feature-title\n        a(href='/docs/e1.smart_compiler.html') Error Handling\n      p.intro-feature-desc Smart compiler, Panicking, Option & Result, Unwrap & Expect, Error & None propagation, Combinators and Custom Error Types.\n  li.intro-feature-wrap\n    .intro-feature\n      .intro-feature-icon\n        i.fa.fa-meteor\n      h3.intro-feature-title\n        a(href='#') Stay tuned!\n      p.intro-feature-desc More things are coming in 2019. Stay in touch!\n","source":"index.jade","raw":"layout: index\ndescription: Hexo is a fast, simple & powerful blog framework powered by Node.js.\nsubtitle: Learning Rust\n---\nul#intro-feature-list\n  li.intro-feature-wrap\n    .intro-feature\n      .intro-feature-icon\n        i.fa.fa-street-view\n      h3.intro-feature-title\n        a(href='/docs/a1.why_rust.html') Basics\n      p.intro-feature-desc Installation, Hello World, Cargo, Crates, Variable bindings, Functions, Primitive Data Types, Operators & Control Flows.\n  li.intro-feature-wrap\n    .intro-feature\n      .intro-feature-icon\n        i.fa.fa-road\n      h3.intro-feature-title\n        a(href='/docs/b1.vectors.html') Beyond the Basics\n      p.intro-feature-desc Vectors, Structs, Enums, Generics, Impls & Traits.\n  li.intro-feature-wrap\n    .intro-feature\n      .intro-feature-icon\n        i.fa.fa-plane\n      h3.intro-feature-title\n        a(href='/docs/c1.ownership.html') The Tough Part\n      p.intro-feature-desc Ownership, Borrowing, Lifetimes & Lifetime Elision.\n  li.intro-feature-wrap\n    .intro-feature\n      .intro-feature-icon\n        i.fa.fa-space-shuttle\n      h3.intro-feature-title\n        a(href='/docs/d1.code_organization.html') Let's Get It Started\n      p.intro-feature-desc Modules, Crates, Workspaces, std modules and Preludes.\n  li.intro-feature-wrap\n    .intro-feature\n      .intro-feature-icon\n        i.fa.fa-user-astronaut\n      h3.intro-feature-title\n        a(href='/docs/e1.smart_compiler.html') Error Handling\n      p.intro-feature-desc Smart compiler, Panicking, Option & Result, Unwrap & Expect, Error & None propagation, Combinators and Custom Error Types.\n  li.intro-feature-wrap\n    .intro-feature\n      .intro-feature-icon\n        i.fa.fa-meteor\n      h3.intro-feature-title\n        a(href='#') Stay tuned!\n      p.intro-feature-desc More things are coming in 2019. Stay in touch!\n","date":"2019-01-19T16:53:20.797Z","updated":"2019-01-19T16:53:20.797Z","path":"index.html","title":"","comments":1,"_id":"cjtfwbiyn0000dwgpv1rke8wk","content":"<ul id=\"intro-feature-list\"><li class=\"intro-feature-wrap\"><div class=\"intro-feature\"><div class=\"intro-feature-icon\"><i class=\"fa fa-street-view\"></i></div><h3 class=\"intro-feature-title\"><a href=\"/docs/a1.why_rust.html\">Basics</a></h3><p class=\"intro-feature-desc\">Installation, Hello World, Cargo, Crates, Variable bindings, Functions, Primitive Data Types, Operators & Control Flows.</p></div></li><li class=\"intro-feature-wrap\"><div class=\"intro-feature\"><div class=\"intro-feature-icon\"><i class=\"fa fa-road\"></i></div><h3 class=\"intro-feature-title\"><a href=\"/docs/b1.vectors.html\">Beyond the Basics</a></h3><p class=\"intro-feature-desc\">Vectors, Structs, Enums, Generics, Impls & Traits.</p></div></li><li class=\"intro-feature-wrap\"><div class=\"intro-feature\"><div class=\"intro-feature-icon\"><i class=\"fa fa-plane\"></i></div><h3 class=\"intro-feature-title\"><a href=\"/docs/c1.ownership.html\">The Tough Part</a></h3><p class=\"intro-feature-desc\">Ownership, Borrowing, Lifetimes & Lifetime Elision.</p></div></li><li class=\"intro-feature-wrap\"><div class=\"intro-feature\"><div class=\"intro-feature-icon\"><i class=\"fa fa-space-shuttle\"></i></div><h3 class=\"intro-feature-title\"><a href=\"/docs/d1.code_organization.html\">Let's Get It Started</a></h3><p class=\"intro-feature-desc\">Modules, Crates, Workspaces, std modules and Preludes.</p></div></li><li class=\"intro-feature-wrap\"><div class=\"intro-feature\"><div class=\"intro-feature-icon\"><i class=\"fa fa-user-astronaut\"></i></div><h3 class=\"intro-feature-title\"><a href=\"/docs/e1.smart_compiler.html\">Error Handling</a></h3><p class=\"intro-feature-desc\">Smart compiler, Panicking, Option & Result, Unwrap & Expect, Error & None propagation, Combinators and Custom Error Types.</p></div></li><li class=\"intro-feature-wrap\"><div class=\"intro-feature\"><div class=\"intro-feature-icon\"><i class=\"fa fa-meteor\"></i></div><h3 class=\"intro-feature-title\"><a href=\"#\">Stay tuned!</a></h3><p class=\"intro-feature-desc\">More things are coming in 2019. Stay in touch!</p></div></li></ul>","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<ul id=\"intro-feature-list\"><li class=\"intro-feature-wrap\"><div class=\"intro-feature\"><div class=\"intro-feature-icon\"><i class=\"fa fa-street-view\"></i></div><h3 class=\"intro-feature-title\"><a href=\"/docs/a1.why_rust.html\">Basics</a></h3><p class=\"intro-feature-desc\">Installation, Hello World, Cargo, Crates, Variable bindings, Functions, Primitive Data Types, Operators & Control Flows.</p></div></li><li class=\"intro-feature-wrap\"><div class=\"intro-feature\"><div class=\"intro-feature-icon\"><i class=\"fa fa-road\"></i></div><h3 class=\"intro-feature-title\"><a href=\"/docs/b1.vectors.html\">Beyond the Basics</a></h3><p class=\"intro-feature-desc\">Vectors, Structs, Enums, Generics, Impls & Traits.</p></div></li><li class=\"intro-feature-wrap\"><div class=\"intro-feature\"><div class=\"intro-feature-icon\"><i class=\"fa fa-plane\"></i></div><h3 class=\"intro-feature-title\"><a href=\"/docs/c1.ownership.html\">The Tough Part</a></h3><p class=\"intro-feature-desc\">Ownership, Borrowing, Lifetimes & Lifetime Elision.</p></div></li><li class=\"intro-feature-wrap\"><div class=\"intro-feature\"><div class=\"intro-feature-icon\"><i class=\"fa fa-space-shuttle\"></i></div><h3 class=\"intro-feature-title\"><a href=\"/docs/d1.code_organization.html\">Let's Get It Started</a></h3><p class=\"intro-feature-desc\">Modules, Crates, Workspaces, std modules and Preludes.</p></div></li><li class=\"intro-feature-wrap\"><div class=\"intro-feature\"><div class=\"intro-feature-icon\"><i class=\"fa fa-user-astronaut\"></i></div><h3 class=\"intro-feature-title\"><a href=\"/docs/e1.smart_compiler.html\">Error Handling</a></h3><p class=\"intro-feature-desc\">Smart compiler, Panicking, Option & Result, Unwrap & Expect, Error & None propagation, Combinators and Custom Error Types.</p></div></li><li class=\"intro-feature-wrap\"><div class=\"intro-feature\"><div class=\"intro-feature-icon\"><i class=\"fa fa-meteor\"></i></div><h3 class=\"intro-feature-title\"><a href=\"#\">Stay tuned!</a></h3><p class=\"intro-feature-desc\">More things are coming in 2019. Stay in touch!</p></div></li></ul>"},{"title":"Why Rust?","_content":"\n## History of Rust\nRust was initially designed and developed by Mozilla employee **Graydon Hoare** as a personal project. Mozilla began sponsoring the project in 2009 and announced it in 2010. But the first stable release, Rust 1.0 was released on May 15, 2015.\n\n## Initial Goals\nThe goal of Rust is to be a good programming language for creating highly concurrent, safe and performant systems.\n\n> \"Rust is a systems programming language focused on three goals: safety, speed, and concurrency.\"  \n> \\_\\_ Rust Documentation\n\nRust is very young and very modern language. It is a **compiled programming language** and it uses [LLVM](https://en.wikipedia.org/wiki/LLVM) on the backend. Also, Rust is a **multi-paradigm programming language**, which supports imperative procedural, concurrent actor, object-oriented and pure functional styles. It also supports generic programming and metaprogramming, in both static and dynamic styles.\n\n> üîé One of Rust‚Äôs most unique and compelling features is [Ownership](c1.ownership.html), which is used to achieve memory safety. Rust creates memory pointers optimistically, checks memory pointers‚Äô limited accesses at compile-time with the usage of [References and Borrowing](c2.borrowing.html). And it does automatic compile-time memory management by checking the [Lifetimes](c3.lifetimes.html).\n\n## Influences\nIts design elements came from a wide range of sources.\n\n* Abstract Machine Model: **C**\n* Data types: **C, SML, OCaml, Lisp, Limbo**\n* Optional Bindings: **Swift**\n* Hygienic Macros: **Scheme**\n* Functional Programming: **Haskell, OCaml, F\\#**\n* Attributes: **ECMA**-335\n* Memory Model and Memory Management: **C++, ML Kit, Cyclone**\n* Type Classes: **Haskell**\n* Crate: Assembly in the **ECMA**-335 CLI model\n* Channels and Concurrency: **Newsqueak, Alef, Limbo**\n* Message passing and Thread failure: **Erlang**\n\nand etc.\n\n\nRust **doesn't use an automated garbage collection** system\\(GC\\) by default.\n\nRust compiler observes the code **at compile-time** and helps to [**prevent many types of errors**](https://doc.rust-lang.org/error-index.html) that are possible to write in C, C++ like programming languages.\n","source":"docs/a1.why_rust.md","raw":"title: Why Rust?\n---\n\n## History of Rust\nRust was initially designed and developed by Mozilla employee **Graydon Hoare** as a personal project. Mozilla began sponsoring the project in 2009 and announced it in 2010. But the first stable release, Rust 1.0 was released on May 15, 2015.\n\n## Initial Goals\nThe goal of Rust is to be a good programming language for creating highly concurrent, safe and performant systems.\n\n> \"Rust is a systems programming language focused on three goals: safety, speed, and concurrency.\"  \n> \\_\\_ Rust Documentation\n\nRust is very young and very modern language. It is a **compiled programming language** and it uses [LLVM](https://en.wikipedia.org/wiki/LLVM) on the backend. Also, Rust is a **multi-paradigm programming language**, which supports imperative procedural, concurrent actor, object-oriented and pure functional styles. It also supports generic programming and metaprogramming, in both static and dynamic styles.\n\n> üîé One of Rust‚Äôs most unique and compelling features is [Ownership](c1.ownership.html), which is used to achieve memory safety. Rust creates memory pointers optimistically, checks memory pointers‚Äô limited accesses at compile-time with the usage of [References and Borrowing](c2.borrowing.html). And it does automatic compile-time memory management by checking the [Lifetimes](c3.lifetimes.html).\n\n## Influences\nIts design elements came from a wide range of sources.\n\n* Abstract Machine Model: **C**\n* Data types: **C, SML, OCaml, Lisp, Limbo**\n* Optional Bindings: **Swift**\n* Hygienic Macros: **Scheme**\n* Functional Programming: **Haskell, OCaml, F\\#**\n* Attributes: **ECMA**-335\n* Memory Model and Memory Management: **C++, ML Kit, Cyclone**\n* Type Classes: **Haskell**\n* Crate: Assembly in the **ECMA**-335 CLI model\n* Channels and Concurrency: **Newsqueak, Alef, Limbo**\n* Message passing and Thread failure: **Erlang**\n\nand etc.\n\n\nRust **doesn't use an automated garbage collection** system\\(GC\\) by default.\n\nRust compiler observes the code **at compile-time** and helps to [**prevent many types of errors**](https://doc.rust-lang.org/error-index.html) that are possible to write in C, C++ like programming languages.\n","date":"2019-03-19T14:50:39.948Z","updated":"2019-03-19T14:50:39.948Z","path":"docs/a1.why_rust.html","comments":1,"layout":"page","_id":"cjtfwbiz60001dwgp0sfyimjw","content":"<h2 id=\"History-of-Rust\"><a href=\"#History-of-Rust\" class=\"headerlink\" title=\"History of Rust\"></a>History of Rust</h2><p>Rust was initially designed and developed by Mozilla employee <strong>Graydon Hoare</strong> as a personal project. Mozilla began sponsoring the project in 2009 and announced it in 2010. But the first stable release, Rust 1.0 was released on May 15, 2015.</p>\n<h2 id=\"Initial-Goals\"><a href=\"#Initial-Goals\" class=\"headerlink\" title=\"Initial Goals\"></a>Initial Goals</h2><p>The goal of Rust is to be a good programming language for creating highly concurrent, safe and performant systems.</p>\n<blockquote>\n<p>‚ÄúRust is a systems programming language focused on three goals: safety, speed, and concurrency.‚Äù<br>__ Rust Documentation</p>\n</blockquote>\n<p>Rust is very young and very modern language. It is a <strong>compiled programming language</strong> and it uses <a href=\"https://en.wikipedia.org/wiki/LLVM\" target=\"_blank\" rel=\"noopener\">LLVM</a> on the backend. Also, Rust is a <strong>multi-paradigm programming language</strong>, which supports imperative procedural, concurrent actor, object-oriented and pure functional styles. It also supports generic programming and metaprogramming, in both static and dynamic styles.</p>\n<blockquote>\n<p>üîé One of Rust‚Äôs most unique and compelling features is <a href=\"c1.ownership.html\">Ownership</a>, which is used to achieve memory safety. Rust creates memory pointers optimistically, checks memory pointers‚Äô limited accesses at compile-time with the usage of <a href=\"c2.borrowing.html\">References and Borrowing</a>. And it does automatic compile-time memory management by checking the <a href=\"c3.lifetimes.html\">Lifetimes</a>.</p>\n</blockquote>\n<h2 id=\"Influences\"><a href=\"#Influences\" class=\"headerlink\" title=\"Influences\"></a>Influences</h2><p>Its design elements came from a wide range of sources.</p>\n<ul>\n<li>Abstract Machine Model: <strong>C</strong></li>\n<li>Data types: <strong>C, SML, OCaml, Lisp, Limbo</strong></li>\n<li>Optional Bindings: <strong>Swift</strong></li>\n<li>Hygienic Macros: <strong>Scheme</strong></li>\n<li>Functional Programming: <strong>Haskell, OCaml, F#</strong></li>\n<li>Attributes: <strong>ECMA</strong>-335</li>\n<li>Memory Model and Memory Management: <strong>C++, ML Kit, Cyclone</strong></li>\n<li>Type Classes: <strong>Haskell</strong></li>\n<li>Crate: Assembly in the <strong>ECMA</strong>-335 CLI model</li>\n<li>Channels and Concurrency: <strong>Newsqueak, Alef, Limbo</strong></li>\n<li>Message passing and Thread failure: <strong>Erlang</strong></li>\n</ul>\n<p>and etc.</p>\n<p>Rust <strong>doesn‚Äôt use an automated garbage collection</strong> system(GC) by default.</p>\n<p>Rust compiler observes the code <strong>at compile-time</strong> and helps to <a href=\"https://doc.rust-lang.org/error-index.html\" target=\"_blank\" rel=\"noopener\"><strong>prevent many types of errors</strong></a> that are possible to write in C, C++ like programming languages.</p>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<h2 id=\"History-of-Rust\"><a href=\"#History-of-Rust\" class=\"headerlink\" title=\"History of Rust\"></a>History of Rust</h2><p>Rust was initially designed and developed by Mozilla employee <strong>Graydon Hoare</strong> as a personal project. Mozilla began sponsoring the project in 2009 and announced it in 2010. But the first stable release, Rust 1.0 was released on May 15, 2015.</p>\n<h2 id=\"Initial-Goals\"><a href=\"#Initial-Goals\" class=\"headerlink\" title=\"Initial Goals\"></a>Initial Goals</h2><p>The goal of Rust is to be a good programming language for creating highly concurrent, safe and performant systems.</p>\n<blockquote>\n<p>‚ÄúRust is a systems programming language focused on three goals: safety, speed, and concurrency.‚Äù<br>__ Rust Documentation</p>\n</blockquote>\n<p>Rust is very young and very modern language. It is a <strong>compiled programming language</strong> and it uses <a href=\"https://en.wikipedia.org/wiki/LLVM\" target=\"_blank\" rel=\"noopener\">LLVM</a> on the backend. Also, Rust is a <strong>multi-paradigm programming language</strong>, which supports imperative procedural, concurrent actor, object-oriented and pure functional styles. It also supports generic programming and metaprogramming, in both static and dynamic styles.</p>\n<blockquote>\n<p>üîé One of Rust‚Äôs most unique and compelling features is <a href=\"c1.ownership.html\">Ownership</a>, which is used to achieve memory safety. Rust creates memory pointers optimistically, checks memory pointers‚Äô limited accesses at compile-time with the usage of <a href=\"c2.borrowing.html\">References and Borrowing</a>. And it does automatic compile-time memory management by checking the <a href=\"c3.lifetimes.html\">Lifetimes</a>.</p>\n</blockquote>\n<h2 id=\"Influences\"><a href=\"#Influences\" class=\"headerlink\" title=\"Influences\"></a>Influences</h2><p>Its design elements came from a wide range of sources.</p>\n<ul>\n<li>Abstract Machine Model: <strong>C</strong></li>\n<li>Data types: <strong>C, SML, OCaml, Lisp, Limbo</strong></li>\n<li>Optional Bindings: <strong>Swift</strong></li>\n<li>Hygienic Macros: <strong>Scheme</strong></li>\n<li>Functional Programming: <strong>Haskell, OCaml, F#</strong></li>\n<li>Attributes: <strong>ECMA</strong>-335</li>\n<li>Memory Model and Memory Management: <strong>C++, ML Kit, Cyclone</strong></li>\n<li>Type Classes: <strong>Haskell</strong></li>\n<li>Crate: Assembly in the <strong>ECMA</strong>-335 CLI model</li>\n<li>Channels and Concurrency: <strong>Newsqueak, Alef, Limbo</strong></li>\n<li>Message passing and Thread failure: <strong>Erlang</strong></li>\n</ul>\n<p>and etc.</p>\n<p>Rust <strong>doesn‚Äôt use an automated garbage collection</strong> system(GC) by default.</p>\n<p>Rust compiler observes the code <strong>at compile-time</strong> and helps to <a href=\"https://doc.rust-lang.org/error-index.html\" target=\"_blank\" rel=\"noopener\"><strong>prevent many types of errors</strong></a> that are possible to write in C, C++ like programming languages.</p>\n"},{"title":"Control Flows","_content":"\n# if - else if - else\n\n```rust\n// Simplest Example\nlet team_size = 7;\nif team_size < 5 {\n    println!(\"Small\");\n} else if team_size < 10 {\n    println!(\"Medium\");\n} else {\n    println!(\"Large\");\n}\n\n// partially refactored code\nlet team_size = 7;\nlet team_size_in_text;\nif team_size < 5 {\n    team_size_in_text = \"Small\";\n} else if team_size < 10 {\n    team_size_in_text = \"Medium\";\n} else {\n    team_size_in_text = \"Large\";\n}\nprintln!(\"Current team size : {}\", team_size_in_text);\n\n//optimistic code\nlet team_size = 7;\nlet team_size_in_text = if team_size < 5 {\n    \"Small\" //‚≠êÔ∏èno ;\n} else if team_size < 10 {\n    \"Medium\"\n} else {\n    \"Large\"\n};\nprintln!(\"Current team size : {}\", team_size_in_text);\n\n\nlet is_below_eighteen = if team_size < 18 { true } else { false };\n```\n\n‚≠êÔ∏è **Return data type should be the same on each block when using this as an expression.**\n\n\n# match\n\n```rust\nlet tshirt_width = 20;\nlet tshirt_size = match tshirt_width {\n    16 => \"S\", // check 16\n    17 | 18 => \"M\", // check 17 and 18\n    19 ... 21 => \"L\", // check from 19 to 21 (19,20,21)\n    22 => \"XL\",\n    _ => \"Not Available\",\n};\nprintln!(\"{}\", tshirt_size); // L\n\n\nlet is_allowed = false;\nlet list_type = match is_allowed {\n    true => \"Full\",\n    false => \"Restricted\"\n    // no default/ _ condition can be skipped\n    // Because data type of is_allowed is boolean and all possibilities checked on conditions\n};\nprintln!(\"{}\", list_type); // Restricted\n\n\nlet marks_paper_a: u8 = 25;\nlet marks_paper_b: u8 = 30;\nlet output = match (marks_paper_a, marks_paper_b) {\n    (50, 50) => \"Full marks for both papers\",\n    (50, _) => \"Full marks for paper A\",\n    (_, 50) => \"Full marks for paper B\",\n    (x, y) if x > 25 && y > 25 => \"Good\",\n    (_, _) => \"Work hard\"\n};\nprintln!(\"{}\", output); // Work hard\n```\n\n\n# while\n\n```rust\nlet mut a = 1;\nwhile a <= 10 {\n\tprintln!(\"Current value : {}\", a);\n\ta += 1; //no ++ or -- on Rust\n}\n\n// Usage of break and continue\nlet mut b = 0;\nwhile b < 5 {\n\tif b == 0 {\n\t\tprintln!(\"Skip value : {}\", b);\n\t\tb += 1;\n\t\tcontinue;\n\t} else if b == 2 {\n\t\tprintln!(\"Break At : {}\", b);\n\t\tbreak;\n\t}\n\tprintln!(\"Current value : {}\", b);\n\tb += 1;\n}\n\n// Outer break\nlet mut c1 = 1;\n'outer_while: while c1 < 6 { //set label outer_while\n\tlet mut c2 = 1;\n\t'inner_while: while c2 < 6 {\n\t\tprintln!(\"Current Value : [{}][{}]\", c1, c2);\n\t\tif c1 == 2 && c2 == 2 { break 'outer_while; } //kill outer_while\n\t\tc2 += 1;\n\t}\n\tc1 += 1;\n}\n```\n\n\n# loop\n\n```rust\nloop {\n\tprintln!(\"Loop forever!\");\n}\n\n// Usage of break and continue\nlet mut a = 0;\nloop {\n\tif a == 0 {\n\t\tprintln!(\"Skip Value : {}\", a);\n\t\ta += 1;\n\t\tcontinue;\n\t} else if a == 2 {\n\t\tprintln!(\"Break At : {}\", a);\n\t\tbreak;\n\t}\n\tprintln!(\"Current Value : {}\", a);\n\ta += 1;\n}\n\n// Outer break\nlet mut b1 = 1;\n'outer_loop: loop { //set label outer_loop\n  let mut b2 = 1;\n  'inner_loop: loop {\n    println!(\"Current Value : [{}][{}]\", b1, b2);\n    if b1 == 2 && b2 == 2 {\n        break 'outer_loop; // kill outer_loop\n    } else if b2 == 5 {\n    \tbreak;\n    }\n    b2 += 1;\n  }\n  b1 += 1;\n}\n```\n\n\n# for\n\n```rust\nfor a in 0..10 { //(a = o; a <10; a++) // 0 to 10(exclusive)\n  println!(\"Current value : {}\", a);\n}\n\n// Usage of break and continue\nfor b in 0..6 {\n  if b == 0 {\n    println!(\"Skip Value : {}\", b);\n    continue;\n  } else if b == 2 {\n    println!(\"Break At : {}\", b);\n    break;\n  }\n  println!(\"Current value : {}\", b);\n}\n\n// Outer break\n'outer_for: for c1 in 1..6 { //set label outer_for\n  'inner_for: for c2 in 1..6 {\n    println!(\"Current Value : [{}][{}]\", c1, c2);\n    if c1 == 2 && c2 == 2 { break 'outer_for; } //kill outer_for\n  }\n}\n\n\n// Working with arrays/vectors\nlet group : [&str; 4] = [\"Mark\", \"Larry\", \"Bill\", \"Steve\"];\n\nfor n in 0..group.len() { //group.len() = 4 -> 0..4 üëé check group.len()on each iteration\n  println!(\"Current Person : {}\", group[n]);\n}\n\nfor person in group.iter() { //üëç group.iter() turn the array into a simple iterator\n  println!(\"Current Person : {}\", person);\n}\n```\n","source":"docs/a10.control_flows.md","raw":"title: Control Flows\n---\n\n# if - else if - else\n\n```rust\n// Simplest Example\nlet team_size = 7;\nif team_size < 5 {\n    println!(\"Small\");\n} else if team_size < 10 {\n    println!(\"Medium\");\n} else {\n    println!(\"Large\");\n}\n\n// partially refactored code\nlet team_size = 7;\nlet team_size_in_text;\nif team_size < 5 {\n    team_size_in_text = \"Small\";\n} else if team_size < 10 {\n    team_size_in_text = \"Medium\";\n} else {\n    team_size_in_text = \"Large\";\n}\nprintln!(\"Current team size : {}\", team_size_in_text);\n\n//optimistic code\nlet team_size = 7;\nlet team_size_in_text = if team_size < 5 {\n    \"Small\" //‚≠êÔ∏èno ;\n} else if team_size < 10 {\n    \"Medium\"\n} else {\n    \"Large\"\n};\nprintln!(\"Current team size : {}\", team_size_in_text);\n\n\nlet is_below_eighteen = if team_size < 18 { true } else { false };\n```\n\n‚≠êÔ∏è **Return data type should be the same on each block when using this as an expression.**\n\n\n# match\n\n```rust\nlet tshirt_width = 20;\nlet tshirt_size = match tshirt_width {\n    16 => \"S\", // check 16\n    17 | 18 => \"M\", // check 17 and 18\n    19 ... 21 => \"L\", // check from 19 to 21 (19,20,21)\n    22 => \"XL\",\n    _ => \"Not Available\",\n};\nprintln!(\"{}\", tshirt_size); // L\n\n\nlet is_allowed = false;\nlet list_type = match is_allowed {\n    true => \"Full\",\n    false => \"Restricted\"\n    // no default/ _ condition can be skipped\n    // Because data type of is_allowed is boolean and all possibilities checked on conditions\n};\nprintln!(\"{}\", list_type); // Restricted\n\n\nlet marks_paper_a: u8 = 25;\nlet marks_paper_b: u8 = 30;\nlet output = match (marks_paper_a, marks_paper_b) {\n    (50, 50) => \"Full marks for both papers\",\n    (50, _) => \"Full marks for paper A\",\n    (_, 50) => \"Full marks for paper B\",\n    (x, y) if x > 25 && y > 25 => \"Good\",\n    (_, _) => \"Work hard\"\n};\nprintln!(\"{}\", output); // Work hard\n```\n\n\n# while\n\n```rust\nlet mut a = 1;\nwhile a <= 10 {\n\tprintln!(\"Current value : {}\", a);\n\ta += 1; //no ++ or -- on Rust\n}\n\n// Usage of break and continue\nlet mut b = 0;\nwhile b < 5 {\n\tif b == 0 {\n\t\tprintln!(\"Skip value : {}\", b);\n\t\tb += 1;\n\t\tcontinue;\n\t} else if b == 2 {\n\t\tprintln!(\"Break At : {}\", b);\n\t\tbreak;\n\t}\n\tprintln!(\"Current value : {}\", b);\n\tb += 1;\n}\n\n// Outer break\nlet mut c1 = 1;\n'outer_while: while c1 < 6 { //set label outer_while\n\tlet mut c2 = 1;\n\t'inner_while: while c2 < 6 {\n\t\tprintln!(\"Current Value : [{}][{}]\", c1, c2);\n\t\tif c1 == 2 && c2 == 2 { break 'outer_while; } //kill outer_while\n\t\tc2 += 1;\n\t}\n\tc1 += 1;\n}\n```\n\n\n# loop\n\n```rust\nloop {\n\tprintln!(\"Loop forever!\");\n}\n\n// Usage of break and continue\nlet mut a = 0;\nloop {\n\tif a == 0 {\n\t\tprintln!(\"Skip Value : {}\", a);\n\t\ta += 1;\n\t\tcontinue;\n\t} else if a == 2 {\n\t\tprintln!(\"Break At : {}\", a);\n\t\tbreak;\n\t}\n\tprintln!(\"Current Value : {}\", a);\n\ta += 1;\n}\n\n// Outer break\nlet mut b1 = 1;\n'outer_loop: loop { //set label outer_loop\n  let mut b2 = 1;\n  'inner_loop: loop {\n    println!(\"Current Value : [{}][{}]\", b1, b2);\n    if b1 == 2 && b2 == 2 {\n        break 'outer_loop; // kill outer_loop\n    } else if b2 == 5 {\n    \tbreak;\n    }\n    b2 += 1;\n  }\n  b1 += 1;\n}\n```\n\n\n# for\n\n```rust\nfor a in 0..10 { //(a = o; a <10; a++) // 0 to 10(exclusive)\n  println!(\"Current value : {}\", a);\n}\n\n// Usage of break and continue\nfor b in 0..6 {\n  if b == 0 {\n    println!(\"Skip Value : {}\", b);\n    continue;\n  } else if b == 2 {\n    println!(\"Break At : {}\", b);\n    break;\n  }\n  println!(\"Current value : {}\", b);\n}\n\n// Outer break\n'outer_for: for c1 in 1..6 { //set label outer_for\n  'inner_for: for c2 in 1..6 {\n    println!(\"Current Value : [{}][{}]\", c1, c2);\n    if c1 == 2 && c2 == 2 { break 'outer_for; } //kill outer_for\n  }\n}\n\n\n// Working with arrays/vectors\nlet group : [&str; 4] = [\"Mark\", \"Larry\", \"Bill\", \"Steve\"];\n\nfor n in 0..group.len() { //group.len() = 4 -> 0..4 üëé check group.len()on each iteration\n  println!(\"Current Person : {}\", group[n]);\n}\n\nfor person in group.iter() { //üëç group.iter() turn the array into a simple iterator\n  println!(\"Current Person : {}\", person);\n}\n```\n","date":"2019-03-19T14:50:39.949Z","updated":"2019-03-19T14:50:39.949Z","path":"docs/a10.control_flows.html","comments":1,"layout":"page","_id":"cjtfwbiz60002dwgponcwthsj","content":"<h1 id=\"if-else-if-else\"><a href=\"#if-else-if-else\" class=\"headerlink\" title=\"if - else if - else\"></a>if - else if - else</h1><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Simplest Example\nlet team_size = 7;\nif team_size &lt; 5 {\n    println!(&quot;Small&quot;);\n} else if team_size &lt; 10 {\n    println!(&quot;Medium&quot;);\n} else {\n    println!(&quot;Large&quot;);\n}\n\n// partially refactored code\nlet team_size = 7;\nlet team_size_in_text;\nif team_size &lt; 5 {\n    team_size_in_text = &quot;Small&quot;;\n} else if team_size &lt; 10 {\n    team_size_in_text = &quot;Medium&quot;;\n} else {\n    team_size_in_text = &quot;Large&quot;;\n}\nprintln!(&quot;Current team size : {}&quot;, team_size_in_text);\n\n//optimistic code\nlet team_size = 7;\nlet team_size_in_text = if team_size &lt; 5 {\n    &quot;Small&quot; //‚≠êÔ∏èno ;\n} else if team_size &lt; 10 {\n    &quot;Medium&quot;\n} else {\n    &quot;Large&quot;\n};\nprintln!(&quot;Current team size : {}&quot;, team_size_in_text);\n\n\nlet is_below_eighteen = if team_size &lt; 18 { true } else { false };\n</code></pre>\n<p>‚≠êÔ∏è <strong>Return data type should be the same on each block when using this as an expression.</strong></p>\n<h1 id=\"match\"><a href=\"#match\" class=\"headerlink\" title=\"match\"></a>match</h1><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let tshirt_width = 20;\nlet tshirt_size = match tshirt_width {\n    16 =&gt; &quot;S&quot;, // check 16\n    17 | 18 =&gt; &quot;M&quot;, // check 17 and 18\n    19 ... 21 =&gt; &quot;L&quot;, // check from 19 to 21 (19,20,21)\n    22 =&gt; &quot;XL&quot;,\n    _ =&gt; &quot;Not Available&quot;,\n};\nprintln!(&quot;{}&quot;, tshirt_size); // L\n\n\nlet is_allowed = false;\nlet list_type = match is_allowed {\n    true =&gt; &quot;Full&quot;,\n    false =&gt; &quot;Restricted&quot;\n    // no default/ _ condition can be skipped\n    // Because data type of is_allowed is boolean and all possibilities checked on conditions\n};\nprintln!(&quot;{}&quot;, list_type); // Restricted\n\n\nlet marks_paper_a: u8 = 25;\nlet marks_paper_b: u8 = 30;\nlet output = match (marks_paper_a, marks_paper_b) {\n    (50, 50) =&gt; &quot;Full marks for both papers&quot;,\n    (50, _) =&gt; &quot;Full marks for paper A&quot;,\n    (_, 50) =&gt; &quot;Full marks for paper B&quot;,\n    (x, y) if x &gt; 25 &amp;&amp; y &gt; 25 =&gt; &quot;Good&quot;,\n    (_, _) =&gt; &quot;Work hard&quot;\n};\nprintln!(&quot;{}&quot;, output); // Work hard\n</code></pre>\n<h1 id=\"while\"><a href=\"#while\" class=\"headerlink\" title=\"while\"></a>while</h1><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let mut a = 1;\nwhile a &lt;= 10 {\n    println!(&quot;Current value : {}&quot;, a);\n    a += 1; //no ++ or -- on Rust\n}\n\n// Usage of break and continue\nlet mut b = 0;\nwhile b &lt; 5 {\n    if b == 0 {\n        println!(&quot;Skip value : {}&quot;, b);\n        b += 1;\n        continue;\n    } else if b == 2 {\n        println!(&quot;Break At : {}&quot;, b);\n        break;\n    }\n    println!(&quot;Current value : {}&quot;, b);\n    b += 1;\n}\n\n// Outer break\nlet mut c1 = 1;\n&#39;outer_while: while c1 &lt; 6 { //set label outer_while\n    let mut c2 = 1;\n    &#39;inner_while: while c2 &lt; 6 {\n        println!(&quot;Current Value : [{}][{}]&quot;, c1, c2);\n        if c1 == 2 &amp;&amp; c2 == 2 { break &#39;outer_while; } //kill outer_while\n        c2 += 1;\n    }\n    c1 += 1;\n}\n</code></pre>\n<h1 id=\"loop\"><a href=\"#loop\" class=\"headerlink\" title=\"loop\"></a>loop</h1><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">loop {\n    println!(&quot;Loop forever!&quot;);\n}\n\n// Usage of break and continue\nlet mut a = 0;\nloop {\n    if a == 0 {\n        println!(&quot;Skip Value : {}&quot;, a);\n        a += 1;\n        continue;\n    } else if a == 2 {\n        println!(&quot;Break At : {}&quot;, a);\n        break;\n    }\n    println!(&quot;Current Value : {}&quot;, a);\n    a += 1;\n}\n\n// Outer break\nlet mut b1 = 1;\n&#39;outer_loop: loop { //set label outer_loop\n  let mut b2 = 1;\n  &#39;inner_loop: loop {\n    println!(&quot;Current Value : [{}][{}]&quot;, b1, b2);\n    if b1 == 2 &amp;&amp; b2 == 2 {\n        break &#39;outer_loop; // kill outer_loop\n    } else if b2 == 5 {\n        break;\n    }\n    b2 += 1;\n  }\n  b1 += 1;\n}\n</code></pre>\n<h1 id=\"for\"><a href=\"#for\" class=\"headerlink\" title=\"for\"></a>for</h1><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">for a in 0..10 { //(a = o; a &lt;10; a++) // 0 to 10(exclusive)\n  println!(&quot;Current value : {}&quot;, a);\n}\n\n// Usage of break and continue\nfor b in 0..6 {\n  if b == 0 {\n    println!(&quot;Skip Value : {}&quot;, b);\n    continue;\n  } else if b == 2 {\n    println!(&quot;Break At : {}&quot;, b);\n    break;\n  }\n  println!(&quot;Current value : {}&quot;, b);\n}\n\n// Outer break\n&#39;outer_for: for c1 in 1..6 { //set label outer_for\n  &#39;inner_for: for c2 in 1..6 {\n    println!(&quot;Current Value : [{}][{}]&quot;, c1, c2);\n    if c1 == 2 &amp;&amp; c2 == 2 { break &#39;outer_for; } //kill outer_for\n  }\n}\n\n\n// Working with arrays/vectors\nlet group : [&amp;str; 4] = [&quot;Mark&quot;, &quot;Larry&quot;, &quot;Bill&quot;, &quot;Steve&quot;];\n\nfor n in 0..group.len() { //group.len() = 4 -&gt; 0..4 üëé check group.len()on each iteration\n  println!(&quot;Current Person : {}&quot;, group[n]);\n}\n\nfor person in group.iter() { //üëç group.iter() turn the array into a simple iterator\n  println!(&quot;Current Person : {}&quot;, person);\n}\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<h1 id=\"if-else-if-else\"><a href=\"#if-else-if-else\" class=\"headerlink\" title=\"if - else if - else\"></a>if - else if - else</h1><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Simplest Example\nlet team_size = 7;\nif team_size &lt; 5 {\n    println!(&quot;Small&quot;);\n} else if team_size &lt; 10 {\n    println!(&quot;Medium&quot;);\n} else {\n    println!(&quot;Large&quot;);\n}\n\n// partially refactored code\nlet team_size = 7;\nlet team_size_in_text;\nif team_size &lt; 5 {\n    team_size_in_text = &quot;Small&quot;;\n} else if team_size &lt; 10 {\n    team_size_in_text = &quot;Medium&quot;;\n} else {\n    team_size_in_text = &quot;Large&quot;;\n}\nprintln!(&quot;Current team size : {}&quot;, team_size_in_text);\n\n//optimistic code\nlet team_size = 7;\nlet team_size_in_text = if team_size &lt; 5 {\n    &quot;Small&quot; //‚≠êÔ∏èno ;\n} else if team_size &lt; 10 {\n    &quot;Medium&quot;\n} else {\n    &quot;Large&quot;\n};\nprintln!(&quot;Current team size : {}&quot;, team_size_in_text);\n\n\nlet is_below_eighteen = if team_size &lt; 18 { true } else { false };\n</code></pre>\n<p>‚≠êÔ∏è <strong>Return data type should be the same on each block when using this as an expression.</strong></p>\n<h1 id=\"match\"><a href=\"#match\" class=\"headerlink\" title=\"match\"></a>match</h1><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let tshirt_width = 20;\nlet tshirt_size = match tshirt_width {\n    16 =&gt; &quot;S&quot;, // check 16\n    17 | 18 =&gt; &quot;M&quot;, // check 17 and 18\n    19 ... 21 =&gt; &quot;L&quot;, // check from 19 to 21 (19,20,21)\n    22 =&gt; &quot;XL&quot;,\n    _ =&gt; &quot;Not Available&quot;,\n};\nprintln!(&quot;{}&quot;, tshirt_size); // L\n\n\nlet is_allowed = false;\nlet list_type = match is_allowed {\n    true =&gt; &quot;Full&quot;,\n    false =&gt; &quot;Restricted&quot;\n    // no default/ _ condition can be skipped\n    // Because data type of is_allowed is boolean and all possibilities checked on conditions\n};\nprintln!(&quot;{}&quot;, list_type); // Restricted\n\n\nlet marks_paper_a: u8 = 25;\nlet marks_paper_b: u8 = 30;\nlet output = match (marks_paper_a, marks_paper_b) {\n    (50, 50) =&gt; &quot;Full marks for both papers&quot;,\n    (50, _) =&gt; &quot;Full marks for paper A&quot;,\n    (_, 50) =&gt; &quot;Full marks for paper B&quot;,\n    (x, y) if x &gt; 25 &amp;&amp; y &gt; 25 =&gt; &quot;Good&quot;,\n    (_, _) =&gt; &quot;Work hard&quot;\n};\nprintln!(&quot;{}&quot;, output); // Work hard\n</code></pre>\n<h1 id=\"while\"><a href=\"#while\" class=\"headerlink\" title=\"while\"></a>while</h1><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let mut a = 1;\nwhile a &lt;= 10 {\n    println!(&quot;Current value : {}&quot;, a);\n    a += 1; //no ++ or -- on Rust\n}\n\n// Usage of break and continue\nlet mut b = 0;\nwhile b &lt; 5 {\n    if b == 0 {\n        println!(&quot;Skip value : {}&quot;, b);\n        b += 1;\n        continue;\n    } else if b == 2 {\n        println!(&quot;Break At : {}&quot;, b);\n        break;\n    }\n    println!(&quot;Current value : {}&quot;, b);\n    b += 1;\n}\n\n// Outer break\nlet mut c1 = 1;\n&#39;outer_while: while c1 &lt; 6 { //set label outer_while\n    let mut c2 = 1;\n    &#39;inner_while: while c2 &lt; 6 {\n        println!(&quot;Current Value : [{}][{}]&quot;, c1, c2);\n        if c1 == 2 &amp;&amp; c2 == 2 { break &#39;outer_while; } //kill outer_while\n        c2 += 1;\n    }\n    c1 += 1;\n}\n</code></pre>\n<h1 id=\"loop\"><a href=\"#loop\" class=\"headerlink\" title=\"loop\"></a>loop</h1><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">loop {\n    println!(&quot;Loop forever!&quot;);\n}\n\n// Usage of break and continue\nlet mut a = 0;\nloop {\n    if a == 0 {\n        println!(&quot;Skip Value : {}&quot;, a);\n        a += 1;\n        continue;\n    } else if a == 2 {\n        println!(&quot;Break At : {}&quot;, a);\n        break;\n    }\n    println!(&quot;Current Value : {}&quot;, a);\n    a += 1;\n}\n\n// Outer break\nlet mut b1 = 1;\n&#39;outer_loop: loop { //set label outer_loop\n  let mut b2 = 1;\n  &#39;inner_loop: loop {\n    println!(&quot;Current Value : [{}][{}]&quot;, b1, b2);\n    if b1 == 2 &amp;&amp; b2 == 2 {\n        break &#39;outer_loop; // kill outer_loop\n    } else if b2 == 5 {\n        break;\n    }\n    b2 += 1;\n  }\n  b1 += 1;\n}\n</code></pre>\n<h1 id=\"for\"><a href=\"#for\" class=\"headerlink\" title=\"for\"></a>for</h1><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">for a in 0..10 { //(a = o; a &lt;10; a++) // 0 to 10(exclusive)\n  println!(&quot;Current value : {}&quot;, a);\n}\n\n// Usage of break and continue\nfor b in 0..6 {\n  if b == 0 {\n    println!(&quot;Skip Value : {}&quot;, b);\n    continue;\n  } else if b == 2 {\n    println!(&quot;Break At : {}&quot;, b);\n    break;\n  }\n  println!(&quot;Current value : {}&quot;, b);\n}\n\n// Outer break\n&#39;outer_for: for c1 in 1..6 { //set label outer_for\n  &#39;inner_for: for c2 in 1..6 {\n    println!(&quot;Current Value : [{}][{}]&quot;, c1, c2);\n    if c1 == 2 &amp;&amp; c2 == 2 { break &#39;outer_for; } //kill outer_for\n  }\n}\n\n\n// Working with arrays/vectors\nlet group : [&amp;str; 4] = [&quot;Mark&quot;, &quot;Larry&quot;, &quot;Bill&quot;, &quot;Steve&quot;];\n\nfor n in 0..group.len() { //group.len() = 4 -&gt; 0..4 üëé check group.len()on each iteration\n  println!(&quot;Current Person : {}&quot;, group[n]);\n}\n\nfor person in group.iter() { //üëç group.iter() turn the array into a simple iterator\n  println!(&quot;Current Person : {}&quot;, person);\n}\n</code></pre>\n"},{"title":"Installation","_content":"\n## Rustup\nThere are many ways to install Rust on your system. For the moment the official way to install Rust is using [Rustup](https://rustup.rs/).\n\n[üìñ](https://github.com/rust-lang-nursery/rustup.rs) Rustup installs The Rust Programming Language from the official release channels, enabling you to easily switch between **stable, beta, and nightly** compilers and keep them updated. It makes **cross-compiling** simpler with binary builds of the standard library for common platforms.\n\n[üìñ](https://github.com/rust-lang-nursery/rustup.rs#installation) Rustup installs **`rustc`, `cargo`, `rustup`** and other standard tools to Cargo's `bin` directory. On Unix it is located at `$HOME/.cargo/bin` and on Windows at `%USERPROFILE%\\.cargo\\bin`. This is the same directory that `cargo install` will install Rust programs and Cargo plugins.\n\nüí° More information can be found on the [Github page of Rustup project](https://github.com/rust-lang-nursery/rustup.rs).\n\n### For Mac and Linux Users\n```bash\ncurl https://sh.rustup.rs -sSf | sh\n```\n\n### For Windows Users\nDownload **`rustup-init.exe`** from [www.rustup.rs](https://rustup.rs/) and run.\n\n> ‚≠ê If you are on **Microsoft Windows**, you have to install **[Visual C++ Build Tools](https://visualstudio.microsoft.com/visual-cpp-build-tools/)** 2015 or higher, which requires an additional 3‚Äì4 GBs.\n\nAfter installing Rust you can check the current version by typing **`rustc --version`** or **`rustc -V`** on your terminal to verify the success of the installation.\n","source":"docs/a2.installation.md","raw":"title: Installation\n---\n\n## Rustup\nThere are many ways to install Rust on your system. For the moment the official way to install Rust is using [Rustup](https://rustup.rs/).\n\n[üìñ](https://github.com/rust-lang-nursery/rustup.rs) Rustup installs The Rust Programming Language from the official release channels, enabling you to easily switch between **stable, beta, and nightly** compilers and keep them updated. It makes **cross-compiling** simpler with binary builds of the standard library for common platforms.\n\n[üìñ](https://github.com/rust-lang-nursery/rustup.rs#installation) Rustup installs **`rustc`, `cargo`, `rustup`** and other standard tools to Cargo's `bin` directory. On Unix it is located at `$HOME/.cargo/bin` and on Windows at `%USERPROFILE%\\.cargo\\bin`. This is the same directory that `cargo install` will install Rust programs and Cargo plugins.\n\nüí° More information can be found on the [Github page of Rustup project](https://github.com/rust-lang-nursery/rustup.rs).\n\n### For Mac and Linux Users\n```bash\ncurl https://sh.rustup.rs -sSf | sh\n```\n\n### For Windows Users\nDownload **`rustup-init.exe`** from [www.rustup.rs](https://rustup.rs/) and run.\n\n> ‚≠ê If you are on **Microsoft Windows**, you have to install **[Visual C++ Build Tools](https://visualstudio.microsoft.com/visual-cpp-build-tools/)** 2015 or higher, which requires an additional 3‚Äì4 GBs.\n\nAfter installing Rust you can check the current version by typing **`rustc --version`** or **`rustc -V`** on your terminal to verify the success of the installation.\n","date":"2019-03-19T14:50:39.949Z","updated":"2019-03-19T14:50:39.949Z","path":"docs/a2.installation.html","comments":1,"layout":"page","_id":"cjtfwbiz70003dwgpwyg7coni","content":"<h2 id=\"Rustup\"><a href=\"#Rustup\" class=\"headerlink\" title=\"Rustup\"></a>Rustup</h2><p>There are many ways to install Rust on your system. For the moment the official way to install Rust is using <a href=\"https://rustup.rs/\" target=\"_blank\" rel=\"noopener\">Rustup</a>.</p>\n<p><a href=\"https://github.com/rust-lang-nursery/rustup.rs\" target=\"_blank\" rel=\"noopener\">üìñ</a> Rustup installs The Rust Programming Language from the official release channels, enabling you to easily switch between <strong>stable, beta, and nightly</strong> compilers and keep them updated. It makes <strong>cross-compiling</strong> simpler with binary builds of the standard library for common platforms.</p>\n<p><a href=\"https://github.com/rust-lang-nursery/rustup.rs#installation\" target=\"_blank\" rel=\"noopener\">üìñ</a> Rustup installs <strong><code>rustc</code>, <code>cargo</code>, <code>rustup</code></strong> and other standard tools to Cargo‚Äôs <code>bin</code> directory. On Unix it is located at <code>$HOME/.cargo/bin</code> and on Windows at <code>%USERPROFILE%\\.cargo\\bin</code>. This is the same directory that <code>cargo install</code> will install Rust programs and Cargo plugins.</p>\n<p>üí° More information can be found on the <a href=\"https://github.com/rust-lang-nursery/rustup.rs\" target=\"_blank\" rel=\"noopener\">Github page of Rustup project</a>.</p>\n<h3 id=\"For-Mac-and-Linux-Users\"><a href=\"#For-Mac-and-Linux-Users\" class=\"headerlink\" title=\"For Mac and Linux Users\"></a>For Mac and Linux Users</h3><p></p><p class=\"code-caption\" data-lang=\"bash\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"bash\">curl https://sh.rustup.rs -sSf | sh\n</code></pre>\n<h3 id=\"For-Windows-Users\"><a href=\"#For-Windows-Users\" class=\"headerlink\" title=\"For Windows Users\"></a>For Windows Users</h3><p>Download <strong><code>rustup-init.exe</code></strong> from <a href=\"https://rustup.rs/\" target=\"_blank\" rel=\"noopener\">www.rustup.rs</a> and run.</p>\n<blockquote>\n<p>‚≠ê If you are on <strong>Microsoft Windows</strong>, you have to install <strong><a href=\"https://visualstudio.microsoft.com/visual-cpp-build-tools/\" target=\"_blank\" rel=\"noopener\">Visual C++ Build Tools</a></strong> 2015 or higher, which requires an additional 3‚Äì4 GBs.</p>\n</blockquote>\n<p>After installing Rust you can check the current version by typing <strong><code>rustc --version</code></strong> or <strong><code>rustc -V</code></strong> on your terminal to verify the success of the installation.</p>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<h2 id=\"Rustup\"><a href=\"#Rustup\" class=\"headerlink\" title=\"Rustup\"></a>Rustup</h2><p>There are many ways to install Rust on your system. For the moment the official way to install Rust is using <a href=\"https://rustup.rs/\" target=\"_blank\" rel=\"noopener\">Rustup</a>.</p>\n<p><a href=\"https://github.com/rust-lang-nursery/rustup.rs\" target=\"_blank\" rel=\"noopener\">üìñ</a> Rustup installs The Rust Programming Language from the official release channels, enabling you to easily switch between <strong>stable, beta, and nightly</strong> compilers and keep them updated. It makes <strong>cross-compiling</strong> simpler with binary builds of the standard library for common platforms.</p>\n<p><a href=\"https://github.com/rust-lang-nursery/rustup.rs#installation\" target=\"_blank\" rel=\"noopener\">üìñ</a> Rustup installs <strong><code>rustc</code>, <code>cargo</code>, <code>rustup</code></strong> and other standard tools to Cargo‚Äôs <code>bin</code> directory. On Unix it is located at <code>$HOME/.cargo/bin</code> and on Windows at <code>%USERPROFILE%\\.cargo\\bin</code>. This is the same directory that <code>cargo install</code> will install Rust programs and Cargo plugins.</p>\n<p>üí° More information can be found on the <a href=\"https://github.com/rust-lang-nursery/rustup.rs\" target=\"_blank\" rel=\"noopener\">Github page of Rustup project</a>.</p>\n<h3 id=\"For-Mac-and-Linux-Users\"><a href=\"#For-Mac-and-Linux-Users\" class=\"headerlink\" title=\"For Mac and Linux Users\"></a>For Mac and Linux Users</h3><p></p><p class=\"code-caption\" data-lang=\"bash\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"bash\">curl https://sh.rustup.rs -sSf | sh\n</code></pre>\n<h3 id=\"For-Windows-Users\"><a href=\"#For-Windows-Users\" class=\"headerlink\" title=\"For Windows Users\"></a>For Windows Users</h3><p>Download <strong><code>rustup-init.exe</code></strong> from <a href=\"https://rustup.rs/\" target=\"_blank\" rel=\"noopener\">www.rustup.rs</a> and run.</p>\n<blockquote>\n<p>‚≠ê If you are on <strong>Microsoft Windows</strong>, you have to install <strong><a href=\"https://visualstudio.microsoft.com/visual-cpp-build-tools/\" target=\"_blank\" rel=\"noopener\">Visual C++ Build Tools</a></strong> 2015 or higher, which requires an additional 3‚Äì4 GBs.</p>\n</blockquote>\n<p>After installing Rust you can check the current version by typing <strong><code>rustc --version</code></strong> or <strong><code>rustc -V</code></strong> on your terminal to verify the success of the installation.</p>\n"},{"title":"Comments and Documenting the code","_content":"\n## Comments\n\n```rust\n// Line comments\n/* Block comments */\n```\n\nNested block comments are supported.\n\nüí° **By convention, try to avoid block comments. Use line comments instead.**\n\n## Doc Comments\n\n```rust\n/// Line comments; document the next item\n/** Block comments; document the next item */\n\n//! Line comments; document the enclosing item\n/*! Block comments; document the enclosing item !*/\n```\n\nDoc comments support Markdown notations. Using `cargo doc`, the HTML documentation can be generated from these doc comments. Let‚Äôs see the difference between the two sets of doc comments.\n\n```rust\n/// This module contains tests\nmod test {\n    // ...\n}\n\n\nmod test {\n    //! This module contains tests\n\n    // ...\n}\n```\n\nAs you can see both uses to document the same module. The first comment has been added before the module while the second one has been added inside the module.\n\nüí° **Only use //! to write crate and module-level documentation, nothing else. When using `mod` blocks, use /// outside of the block.**\n\n## Doc Attributes\n\nWe can also use **doc attributes** for documenting the code.\n\n> üîé An [attribute](https://doc.rust-lang.org/reference.html#attributes) is a general, free-form **metadatum** that is interpreted according to the name, convention, language and compiler version. Any item declaration may have an attribute applied to it.\n\nHere, for instance, each comment is equivalent to relevant data attributes.\n\n```rust\n/// Foo\n#[doc=\"Foo\"]\n\n//! Foo\n#![doc=\"Foo\"]\n```\n","source":"docs/a5.comments_and_documenting_the_code.md","raw":"title: Comments and Documenting the code\n---\n\n## Comments\n\n```rust\n// Line comments\n/* Block comments */\n```\n\nNested block comments are supported.\n\nüí° **By convention, try to avoid block comments. Use line comments instead.**\n\n## Doc Comments\n\n```rust\n/// Line comments; document the next item\n/** Block comments; document the next item */\n\n//! Line comments; document the enclosing item\n/*! Block comments; document the enclosing item !*/\n```\n\nDoc comments support Markdown notations. Using `cargo doc`, the HTML documentation can be generated from these doc comments. Let‚Äôs see the difference between the two sets of doc comments.\n\n```rust\n/// This module contains tests\nmod test {\n    // ...\n}\n\n\nmod test {\n    //! This module contains tests\n\n    // ...\n}\n```\n\nAs you can see both uses to document the same module. The first comment has been added before the module while the second one has been added inside the module.\n\nüí° **Only use //! to write crate and module-level documentation, nothing else. When using `mod` blocks, use /// outside of the block.**\n\n## Doc Attributes\n\nWe can also use **doc attributes** for documenting the code.\n\n> üîé An [attribute](https://doc.rust-lang.org/reference.html#attributes) is a general, free-form **metadatum** that is interpreted according to the name, convention, language and compiler version. Any item declaration may have an attribute applied to it.\n\nHere, for instance, each comment is equivalent to relevant data attributes.\n\n```rust\n/// Foo\n#[doc=\"Foo\"]\n\n//! Foo\n#![doc=\"Foo\"]\n```\n","date":"2019-03-19T14:50:39.950Z","updated":"2019-03-19T14:50:39.950Z","path":"docs/a5.comments_and_documenting_the_code.html","comments":1,"layout":"page","_id":"cjtfwbiz80004dwgpp7d2yyz3","content":"<h2 id=\"Comments\"><a href=\"#Comments\" class=\"headerlink\" title=\"Comments\"></a>Comments</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Line comments\n/* Block comments */\n</code></pre>\n<p>Nested block comments are supported.</p>\n<p>üí° <strong>By convention, try to avoid block comments. Use line comments instead.</strong></p>\n<h2 id=\"Doc-Comments\"><a href=\"#Doc-Comments\" class=\"headerlink\" title=\"Doc Comments\"></a>Doc Comments</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">/// Line comments; document the next item\n/** Block comments; document the next item */\n\n//! Line comments; document the enclosing item\n/*! Block comments; document the enclosing item !*/\n</code></pre>\n<p>Doc comments support Markdown notations. Using <code>cargo doc</code>, the HTML documentation can be generated from these doc comments. Let‚Äôs see the difference between the two sets of doc comments.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">/// This module contains tests\nmod test {\n    // ...\n}\n\n\nmod test {\n    //! This module contains tests\n\n    // ...\n}\n</code></pre>\n<p>As you can see both uses to document the same module. The first comment has been added before the module while the second one has been added inside the module.</p>\n<p>üí° <strong>Only use //! to write crate and module-level documentation, nothing else. When using <code>mod</code> blocks, use /// outside of the block.</strong></p>\n<h2 id=\"Doc-Attributes\"><a href=\"#Doc-Attributes\" class=\"headerlink\" title=\"Doc Attributes\"></a>Doc Attributes</h2><p>We can also use <strong>doc attributes</strong> for documenting the code.</p>\n<blockquote>\n<p>üîé An <a href=\"https://doc.rust-lang.org/reference.html#attributes\" target=\"_blank\" rel=\"noopener\">attribute</a> is a general, free-form <strong>metadatum</strong> that is interpreted according to the name, convention, language and compiler version. Any item declaration may have an attribute applied to it.</p>\n</blockquote>\n<p>Here, for instance, each comment is equivalent to relevant data attributes.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">/// Foo\n#[doc=&quot;Foo&quot;]\n\n//! Foo\n#![doc=&quot;Foo&quot;]\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<h2 id=\"Comments\"><a href=\"#Comments\" class=\"headerlink\" title=\"Comments\"></a>Comments</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Line comments\n/* Block comments */\n</code></pre>\n<p>Nested block comments are supported.</p>\n<p>üí° <strong>By convention, try to avoid block comments. Use line comments instead.</strong></p>\n<h2 id=\"Doc-Comments\"><a href=\"#Doc-Comments\" class=\"headerlink\" title=\"Doc Comments\"></a>Doc Comments</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">/// Line comments; document the next item\n/** Block comments; document the next item */\n\n//! Line comments; document the enclosing item\n/*! Block comments; document the enclosing item !*/\n</code></pre>\n<p>Doc comments support Markdown notations. Using <code>cargo doc</code>, the HTML documentation can be generated from these doc comments. Let‚Äôs see the difference between the two sets of doc comments.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">/// This module contains tests\nmod test {\n    // ...\n}\n\n\nmod test {\n    //! This module contains tests\n\n    // ...\n}\n</code></pre>\n<p>As you can see both uses to document the same module. The first comment has been added before the module while the second one has been added inside the module.</p>\n<p>üí° <strong>Only use //! to write crate and module-level documentation, nothing else. When using <code>mod</code> blocks, use /// outside of the block.</strong></p>\n<h2 id=\"Doc-Attributes\"><a href=\"#Doc-Attributes\" class=\"headerlink\" title=\"Doc Attributes\"></a>Doc Attributes</h2><p>We can also use <strong>doc attributes</strong> for documenting the code.</p>\n<blockquote>\n<p>üîé An <a href=\"https://doc.rust-lang.org/reference.html#attributes\" target=\"_blank\" rel=\"noopener\">attribute</a> is a general, free-form <strong>metadatum</strong> that is interpreted according to the name, convention, language and compiler version. Any item declaration may have an attribute applied to it.</p>\n</blockquote>\n<p>Here, for instance, each comment is equivalent to relevant data attributes.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">/// Foo\n#[doc=&quot;Foo&quot;]\n\n//! Foo\n#![doc=&quot;Foo&quot;]\n</code></pre>\n"},{"title":"Cargo, Crates and Basic Project Structure","_content":"\n## Cargo\n\nCargo is Rust‚Äôs built-in package manager and the build system. It can be used to,\n\n- Create a new project: `cargo new`\n- Build the project: `cargo build`\n- Run the project: `cargo run`  \n- Update project dependencies: `cargo update`\n- Run tests: `cargo test`  \n- Generate the project documentation via [rustdoc](https://doc.rust-lang.org/stable/rustdoc/): `cargo doc`\n- Analyze the project to see it has any errors, without building it: `cargo check`\n\nIn addition, there are `cargo` commands to publish the project as a crate/ package to **Rust's official crate registry, [crates.io](https://crates.io/)**.\n\n> üí° We need to get an API token from [crates.io](https://crates.io/) to publish a crate to it. The API token can be found in the [Account Settings page](https://crates.io/me), after login to that site. We will discuss more about this under [code organization with crates](https://learning-rust.github.io/docs/d4.crates.html#c-Using-crates-io).\n\n- Log in to [crates.io](https://crates.io/) with the API token: `cargo login`\n- Make the local crate uploadable to [crates.io](https://crates.io/): `cargo package`\n- Upload the crate to [crates.io](https://crates.io/): `cargo publish`\n\n## Crate\n\nA crate is a package, which can be shared via [crates.io](https://crates.io/). A crate can produce an executable or a library. In other words, it can be a **binary** crate or a **library** crate.\n\n01. `cargo new crate_name --bin` or `cargo new crate_name`: Produces an executable\n02. `cargo new crate_name --lib`: Produces a library\n\nThe first one generates,\n\n```\n‚îú‚îÄ‚îÄ Cargo.toml\n‚îî‚îÄ‚îÄ src\n    ‚îî‚îÄ‚îÄ main.rs\n```\n\nand the second one generates,\n\n```\n‚îú‚îÄ‚îÄ Cargo.toml\n‚îî‚îÄ‚îÄ src\n    ‚îî‚îÄ‚îÄ lib.rs\n```\n\n* **Cargo.toml**\\(capital c\\) is the configuration file which contains all of the metadata that Cargo needs to compile your project.\n* **src** folder is the place to store the source code.\n* Each crate has an implicit crate root/ entry point. **main.rs** is the crate root for a binary crate and **lib.rs** is the crate root for a library crate.\n\n> üí° When we build a binary crate via `cargo build` or `cargo run`, the executable file will be stored in **target/debug/** folder. But when building it via `cargo build --release` for a release it will be stored in **target/release/** folder.\n\n## Project Structure\n\nThis is how [Cargo Docs describes](https://doc.rust-lang.org/cargo/guide/project-layout.html) about the recommended project layout,\n\n```\n.\n‚îú‚îÄ‚îÄ Cargo.lock\n‚îú‚îÄ‚îÄ Cargo.toml\n‚îú‚îÄ‚îÄ benches\n‚îÇ   ‚îî‚îÄ‚îÄ large-input.rs\n‚îú‚îÄ‚îÄ examples\n‚îÇ   ‚îî‚îÄ‚îÄ simple.rs\n‚îú‚îÄ‚îÄ src\n‚îÇ   ‚îú‚îÄ‚îÄ bin\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ another_executable.rs\n‚îÇ   ‚îú‚îÄ‚îÄ lib.rs\n‚îÇ   ‚îî‚îÄ‚îÄ main.rs\n‚îî‚îÄ‚îÄ tests\n    ‚îî‚îÄ‚îÄ some-integration-tests.rs\n```\n\n- The source code goes in the `src` directory.  \n- The default library file is `src/lib.rs`.  \n- The default executable file is `src/main.rs`.  \n- Other executables can be placed in `src/bin/*.rs`.  \n- Integration tests go in the `tests` directory \\(unit tests go in each file they're testing\\).  \n- Examples go in the `examples` directory.  \n- Benchmarks go in the `benches` directory.\n","source":"docs/a4.cargo,crates_and_basic_project_structure.md","raw":"title: Cargo, Crates and Basic Project Structure\n---\n\n## Cargo\n\nCargo is Rust‚Äôs built-in package manager and the build system. It can be used to,\n\n- Create a new project: `cargo new`\n- Build the project: `cargo build`\n- Run the project: `cargo run`  \n- Update project dependencies: `cargo update`\n- Run tests: `cargo test`  \n- Generate the project documentation via [rustdoc](https://doc.rust-lang.org/stable/rustdoc/): `cargo doc`\n- Analyze the project to see it has any errors, without building it: `cargo check`\n\nIn addition, there are `cargo` commands to publish the project as a crate/ package to **Rust's official crate registry, [crates.io](https://crates.io/)**.\n\n> üí° We need to get an API token from [crates.io](https://crates.io/) to publish a crate to it. The API token can be found in the [Account Settings page](https://crates.io/me), after login to that site. We will discuss more about this under [code organization with crates](https://learning-rust.github.io/docs/d4.crates.html#c-Using-crates-io).\n\n- Log in to [crates.io](https://crates.io/) with the API token: `cargo login`\n- Make the local crate uploadable to [crates.io](https://crates.io/): `cargo package`\n- Upload the crate to [crates.io](https://crates.io/): `cargo publish`\n\n## Crate\n\nA crate is a package, which can be shared via [crates.io](https://crates.io/). A crate can produce an executable or a library. In other words, it can be a **binary** crate or a **library** crate.\n\n01. `cargo new crate_name --bin` or `cargo new crate_name`: Produces an executable\n02. `cargo new crate_name --lib`: Produces a library\n\nThe first one generates,\n\n```\n‚îú‚îÄ‚îÄ Cargo.toml\n‚îî‚îÄ‚îÄ src\n    ‚îî‚îÄ‚îÄ main.rs\n```\n\nand the second one generates,\n\n```\n‚îú‚îÄ‚îÄ Cargo.toml\n‚îî‚îÄ‚îÄ src\n    ‚îî‚îÄ‚îÄ lib.rs\n```\n\n* **Cargo.toml**\\(capital c\\) is the configuration file which contains all of the metadata that Cargo needs to compile your project.\n* **src** folder is the place to store the source code.\n* Each crate has an implicit crate root/ entry point. **main.rs** is the crate root for a binary crate and **lib.rs** is the crate root for a library crate.\n\n> üí° When we build a binary crate via `cargo build` or `cargo run`, the executable file will be stored in **target/debug/** folder. But when building it via `cargo build --release` for a release it will be stored in **target/release/** folder.\n\n## Project Structure\n\nThis is how [Cargo Docs describes](https://doc.rust-lang.org/cargo/guide/project-layout.html) about the recommended project layout,\n\n```\n.\n‚îú‚îÄ‚îÄ Cargo.lock\n‚îú‚îÄ‚îÄ Cargo.toml\n‚îú‚îÄ‚îÄ benches\n‚îÇ   ‚îî‚îÄ‚îÄ large-input.rs\n‚îú‚îÄ‚îÄ examples\n‚îÇ   ‚îî‚îÄ‚îÄ simple.rs\n‚îú‚îÄ‚îÄ src\n‚îÇ   ‚îú‚îÄ‚îÄ bin\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ another_executable.rs\n‚îÇ   ‚îú‚îÄ‚îÄ lib.rs\n‚îÇ   ‚îî‚îÄ‚îÄ main.rs\n‚îî‚îÄ‚îÄ tests\n    ‚îî‚îÄ‚îÄ some-integration-tests.rs\n```\n\n- The source code goes in the `src` directory.  \n- The default library file is `src/lib.rs`.  \n- The default executable file is `src/main.rs`.  \n- Other executables can be placed in `src/bin/*.rs`.  \n- Integration tests go in the `tests` directory \\(unit tests go in each file they're testing\\).  \n- Examples go in the `examples` directory.  \n- Benchmarks go in the `benches` directory.\n","date":"2019-03-19T14:50:39.949Z","updated":"2019-03-19T14:50:39.949Z","path":"docs/a4.cargo,crates_and_basic_project_structure.html","comments":1,"layout":"page","_id":"cjtfwbiz90005dwgpm88ehmlx","content":"<h2 id=\"Cargo\"><a href=\"#Cargo\" class=\"headerlink\" title=\"Cargo\"></a>Cargo</h2><p>Cargo is Rust‚Äôs built-in package manager and the build system. It can be used to,</p>\n<ul>\n<li>Create a new project: <code>cargo new</code></li>\n<li>Build the project: <code>cargo build</code></li>\n<li>Run the project: <code>cargo run</code>  </li>\n<li>Update project dependencies: <code>cargo update</code></li>\n<li>Run tests: <code>cargo test</code>  </li>\n<li>Generate the project documentation via <a href=\"https://doc.rust-lang.org/stable/rustdoc/\" target=\"_blank\" rel=\"noopener\">rustdoc</a>: <code>cargo doc</code></li>\n<li>Analyze the project to see it has any errors, without building it: <code>cargo check</code></li>\n</ul>\n<p>In addition, there are <code>cargo</code> commands to publish the project as a crate/ package to <strong>Rust‚Äôs official crate registry, <a href=\"https://crates.io/\" target=\"_blank\" rel=\"noopener\">crates.io</a></strong>.</p>\n<blockquote>\n<p>üí° We need to get an API token from <a href=\"https://crates.io/\" target=\"_blank\" rel=\"noopener\">crates.io</a> to publish a crate to it. The API token can be found in the <a href=\"https://crates.io/me\" target=\"_blank\" rel=\"noopener\">Account Settings page</a>, after login to that site. We will discuss more about this under <a href=\"https://learning-rust.github.io/docs/d4.crates.html#c-Using-crates-io\">code organization with crates</a>.</p>\n</blockquote>\n<ul>\n<li>Log in to <a href=\"https://crates.io/\" target=\"_blank\" rel=\"noopener\">crates.io</a> with the API token: <code>cargo login</code></li>\n<li>Make the local crate uploadable to <a href=\"https://crates.io/\" target=\"_blank\" rel=\"noopener\">crates.io</a>: <code>cargo package</code></li>\n<li>Upload the crate to <a href=\"https://crates.io/\" target=\"_blank\" rel=\"noopener\">crates.io</a>: <code>cargo publish</code></li>\n</ul>\n<h2 id=\"Crate\"><a href=\"#Crate\" class=\"headerlink\" title=\"Crate\"></a>Crate</h2><p>A crate is a package, which can be shared via <a href=\"https://crates.io/\" target=\"_blank\" rel=\"noopener\">crates.io</a>. A crate can produce an executable or a library. In other words, it can be a <strong>binary</strong> crate or a <strong>library</strong> crate.</p>\n<ol>\n<li><code>cargo new crate_name --bin</code> or <code>cargo new crate_name</code>: Produces an executable</li>\n<li><code>cargo new crate_name --lib</code>: Produces a library</li>\n</ol>\n<p>The first one generates,</p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code>‚îú‚îÄ‚îÄ Cargo.toml\n‚îî‚îÄ‚îÄ src\n    ‚îî‚îÄ‚îÄ main.rs\n</code></pre><p>and the second one generates,</p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code>‚îú‚îÄ‚îÄ Cargo.toml\n‚îî‚îÄ‚îÄ src\n    ‚îî‚îÄ‚îÄ lib.rs\n</code></pre><ul>\n<li><strong>Cargo.toml</strong>(capital c) is the configuration file which contains all of the metadata that Cargo needs to compile your project.</li>\n<li><strong>src</strong> folder is the place to store the source code.</li>\n<li>Each crate has an implicit crate root/ entry point. <strong>main.rs</strong> is the crate root for a binary crate and <strong>lib.rs</strong> is the crate root for a library crate.</li>\n</ul>\n<blockquote>\n<p>üí° When we build a binary crate via <code>cargo build</code> or <code>cargo run</code>, the executable file will be stored in <strong>target/debug/</strong> folder. But when building it via <code>cargo build --release</code> for a release it will be stored in <strong>target/release/</strong> folder.</p>\n</blockquote>\n<h2 id=\"Project-Structure\"><a href=\"#Project-Structure\" class=\"headerlink\" title=\"Project Structure\"></a>Project Structure</h2><p>This is how <a href=\"https://doc.rust-lang.org/cargo/guide/project-layout.html\" target=\"_blank\" rel=\"noopener\">Cargo Docs describes</a> about the recommended project layout,</p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code>.\n‚îú‚îÄ‚îÄ Cargo.lock\n‚îú‚îÄ‚îÄ Cargo.toml\n‚îú‚îÄ‚îÄ benches\n‚îÇ   ‚îî‚îÄ‚îÄ large-input.rs\n‚îú‚îÄ‚îÄ examples\n‚îÇ   ‚îî‚îÄ‚îÄ simple.rs\n‚îú‚îÄ‚îÄ src\n‚îÇ   ‚îú‚îÄ‚îÄ bin\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ another_executable.rs\n‚îÇ   ‚îú‚îÄ‚îÄ lib.rs\n‚îÇ   ‚îî‚îÄ‚îÄ main.rs\n‚îî‚îÄ‚îÄ tests\n    ‚îî‚îÄ‚îÄ some-integration-tests.rs\n</code></pre><ul>\n<li>The source code goes in the <code>src</code> directory.  </li>\n<li>The default library file is <code>src/lib.rs</code>.  </li>\n<li>The default executable file is <code>src/main.rs</code>.  </li>\n<li>Other executables can be placed in <code>src/bin/*.rs</code>.  </li>\n<li>Integration tests go in the <code>tests</code> directory (unit tests go in each file they‚Äôre testing).  </li>\n<li>Examples go in the <code>examples</code> directory.  </li>\n<li>Benchmarks go in the <code>benches</code> directory.</li>\n</ul>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<h2 id=\"Cargo\"><a href=\"#Cargo\" class=\"headerlink\" title=\"Cargo\"></a>Cargo</h2><p>Cargo is Rust‚Äôs built-in package manager and the build system. It can be used to,</p>\n<ul>\n<li>Create a new project: <code>cargo new</code></li>\n<li>Build the project: <code>cargo build</code></li>\n<li>Run the project: <code>cargo run</code>  </li>\n<li>Update project dependencies: <code>cargo update</code></li>\n<li>Run tests: <code>cargo test</code>  </li>\n<li>Generate the project documentation via <a href=\"https://doc.rust-lang.org/stable/rustdoc/\" target=\"_blank\" rel=\"noopener\">rustdoc</a>: <code>cargo doc</code></li>\n<li>Analyze the project to see it has any errors, without building it: <code>cargo check</code></li>\n</ul>\n<p>In addition, there are <code>cargo</code> commands to publish the project as a crate/ package to <strong>Rust‚Äôs official crate registry, <a href=\"https://crates.io/\" target=\"_blank\" rel=\"noopener\">crates.io</a></strong>.</p>\n<blockquote>\n<p>üí° We need to get an API token from <a href=\"https://crates.io/\" target=\"_blank\" rel=\"noopener\">crates.io</a> to publish a crate to it. The API token can be found in the <a href=\"https://crates.io/me\" target=\"_blank\" rel=\"noopener\">Account Settings page</a>, after login to that site. We will discuss more about this under <a href=\"https://learning-rust.github.io/docs/d4.crates.html#c-Using-crates-io\">code organization with crates</a>.</p>\n</blockquote>\n<ul>\n<li>Log in to <a href=\"https://crates.io/\" target=\"_blank\" rel=\"noopener\">crates.io</a> with the API token: <code>cargo login</code></li>\n<li>Make the local crate uploadable to <a href=\"https://crates.io/\" target=\"_blank\" rel=\"noopener\">crates.io</a>: <code>cargo package</code></li>\n<li>Upload the crate to <a href=\"https://crates.io/\" target=\"_blank\" rel=\"noopener\">crates.io</a>: <code>cargo publish</code></li>\n</ul>\n<h2 id=\"Crate\"><a href=\"#Crate\" class=\"headerlink\" title=\"Crate\"></a>Crate</h2><p>A crate is a package, which can be shared via <a href=\"https://crates.io/\" target=\"_blank\" rel=\"noopener\">crates.io</a>. A crate can produce an executable or a library. In other words, it can be a <strong>binary</strong> crate or a <strong>library</strong> crate.</p>\n<ol>\n<li><code>cargo new crate_name --bin</code> or <code>cargo new crate_name</code>: Produces an executable</li>\n<li><code>cargo new crate_name --lib</code>: Produces a library</li>\n</ol>\n<p>The first one generates,</p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code>‚îú‚îÄ‚îÄ Cargo.toml\n‚îî‚îÄ‚îÄ src\n    ‚îî‚îÄ‚îÄ main.rs\n</code></pre><p>and the second one generates,</p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code>‚îú‚îÄ‚îÄ Cargo.toml\n‚îî‚îÄ‚îÄ src\n    ‚îî‚îÄ‚îÄ lib.rs\n</code></pre><ul>\n<li><strong>Cargo.toml</strong>(capital c) is the configuration file which contains all of the metadata that Cargo needs to compile your project.</li>\n<li><strong>src</strong> folder is the place to store the source code.</li>\n<li>Each crate has an implicit crate root/ entry point. <strong>main.rs</strong> is the crate root for a binary crate and <strong>lib.rs</strong> is the crate root for a library crate.</li>\n</ul>\n<blockquote>\n<p>üí° When we build a binary crate via <code>cargo build</code> or <code>cargo run</code>, the executable file will be stored in <strong>target/debug/</strong> folder. But when building it via <code>cargo build --release</code> for a release it will be stored in <strong>target/release/</strong> folder.</p>\n</blockquote>\n<h2 id=\"Project-Structure\"><a href=\"#Project-Structure\" class=\"headerlink\" title=\"Project Structure\"></a>Project Structure</h2><p>This is how <a href=\"https://doc.rust-lang.org/cargo/guide/project-layout.html\" target=\"_blank\" rel=\"noopener\">Cargo Docs describes</a> about the recommended project layout,</p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code>.\n‚îú‚îÄ‚îÄ Cargo.lock\n‚îú‚îÄ‚îÄ Cargo.toml\n‚îú‚îÄ‚îÄ benches\n‚îÇ   ‚îî‚îÄ‚îÄ large-input.rs\n‚îú‚îÄ‚îÄ examples\n‚îÇ   ‚îî‚îÄ‚îÄ simple.rs\n‚îú‚îÄ‚îÄ src\n‚îÇ   ‚îú‚îÄ‚îÄ bin\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ another_executable.rs\n‚îÇ   ‚îú‚îÄ‚îÄ lib.rs\n‚îÇ   ‚îî‚îÄ‚îÄ main.rs\n‚îî‚îÄ‚îÄ tests\n    ‚îî‚îÄ‚îÄ some-integration-tests.rs\n</code></pre><ul>\n<li>The source code goes in the <code>src</code> directory.  </li>\n<li>The default library file is <code>src/lib.rs</code>.  </li>\n<li>The default executable file is <code>src/main.rs</code>.  </li>\n<li>Other executables can be placed in <code>src/bin/*.rs</code>.  </li>\n<li>Integration tests go in the <code>tests</code> directory (unit tests go in each file they‚Äôre testing).  </li>\n<li>Examples go in the <code>examples</code> directory.  </li>\n<li>Benchmarks go in the <code>benches</code> directory.</li>\n</ul>\n"},{"title":"Variable bindings, Constants & Statics","_content":"\n‚≠êÔ∏è In Rust variables are **immutable by default**, so we call them **Variable bindings**. To make them mutable, the `mut` keyword is used.\n\n‚≠êÔ∏è Rust is a **statically typed** language; it checks data types at compile-time. But it **doesn‚Äôt require you to actually type it when declaring variable bindings**. In that case, the compiler checks the usage and sets a better data type for it. But for **constants and statics, you must annotate the type**. Types come after a colon(:)\n\n* ### Variable bindings\n\n```rust\nlet a = true;\nlet b: bool = true;\n\nlet (x, y) = (1, 2);\n\nlet mut z = 5;\nz = 6;\n```\n\n* ### Constants\n\n```rust\nconst N: i32 = 5;\n```\n\n* ### Statics\n\n```rust\nstatic N: i32 = 5;\n```\n\nThe **let** keyword is used in binding expressions. We can bind a name to a value or a function. Also, because the left-hand side of a let expression is a ‚Äòpattern‚Äô, you can bind multiple names to a set of values or function values.\n\nThe **const** keyword is used to define constants. It lives for the entire lifetime of a program but has no fixed address in the memory. The **static** keyword is used to define a ‚Äòglobal variable‚Äô type facility. There is only one instance for each value, and it‚Äôs at a **fixed location in memory**.\n\nüí° **Always use const**, instead of static. It‚Äôs pretty rare that you actually want a memory location associated with your constant, and using a const allows for optimizations like constant propagation not only in your crate but also in downstream crates.\n\nüí° Usually, statics are placed at the top of the code file, outside the functions.\n","source":"docs/a6.variable_bindings,constants_and_statics.md","raw":"title: Variable bindings, Constants & Statics\n---\n\n‚≠êÔ∏è In Rust variables are **immutable by default**, so we call them **Variable bindings**. To make them mutable, the `mut` keyword is used.\n\n‚≠êÔ∏è Rust is a **statically typed** language; it checks data types at compile-time. But it **doesn‚Äôt require you to actually type it when declaring variable bindings**. In that case, the compiler checks the usage and sets a better data type for it. But for **constants and statics, you must annotate the type**. Types come after a colon(:)\n\n* ### Variable bindings\n\n```rust\nlet a = true;\nlet b: bool = true;\n\nlet (x, y) = (1, 2);\n\nlet mut z = 5;\nz = 6;\n```\n\n* ### Constants\n\n```rust\nconst N: i32 = 5;\n```\n\n* ### Statics\n\n```rust\nstatic N: i32 = 5;\n```\n\nThe **let** keyword is used in binding expressions. We can bind a name to a value or a function. Also, because the left-hand side of a let expression is a ‚Äòpattern‚Äô, you can bind multiple names to a set of values or function values.\n\nThe **const** keyword is used to define constants. It lives for the entire lifetime of a program but has no fixed address in the memory. The **static** keyword is used to define a ‚Äòglobal variable‚Äô type facility. There is only one instance for each value, and it‚Äôs at a **fixed location in memory**.\n\nüí° **Always use const**, instead of static. It‚Äôs pretty rare that you actually want a memory location associated with your constant, and using a const allows for optimizations like constant propagation not only in your crate but also in downstream crates.\n\nüí° Usually, statics are placed at the top of the code file, outside the functions.\n","date":"2019-03-19T14:50:39.950Z","updated":"2019-03-19T14:50:39.950Z","path":"docs/a6.variable_bindings,constants_and_statics.html","comments":1,"layout":"page","_id":"cjtfwbiz90006dwgpglb0p1id","content":"<p>‚≠êÔ∏è In Rust variables are <strong>immutable by default</strong>, so we call them <strong>Variable bindings</strong>. To make them mutable, the <code>mut</code> keyword is used.</p>\n<p>‚≠êÔ∏è Rust is a <strong>statically typed</strong> language; it checks data types at compile-time. But it <strong>doesn‚Äôt require you to actually type it when declaring variable bindings</strong>. In that case, the compiler checks the usage and sets a better data type for it. But for <strong>constants and statics, you must annotate the type</strong>. Types come after a colon(:)</p>\n<ul>\n<li><h3 id=\"Variable-bindings\"><a href=\"#Variable-bindings\" class=\"headerlink\" title=\"Variable bindings\"></a>Variable bindings</h3></li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = true;\nlet b: bool = true;\n\nlet (x, y) = (1, 2);\n\nlet mut z = 5;\nz = 6;\n</code></pre>\n<ul>\n<li><h3 id=\"Constants\"><a href=\"#Constants\" class=\"headerlink\" title=\"Constants\"></a>Constants</h3></li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">const N: i32 = 5;\n</code></pre>\n<ul>\n<li><h3 id=\"Statics\"><a href=\"#Statics\" class=\"headerlink\" title=\"Statics\"></a>Statics</h3></li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">static N: i32 = 5;\n</code></pre>\n<p>The <strong>let</strong> keyword is used in binding expressions. We can bind a name to a value or a function. Also, because the left-hand side of a let expression is a ‚Äòpattern‚Äô, you can bind multiple names to a set of values or function values.</p>\n<p>The <strong>const</strong> keyword is used to define constants. It lives for the entire lifetime of a program but has no fixed address in the memory. The <strong>static</strong> keyword is used to define a ‚Äòglobal variable‚Äô type facility. There is only one instance for each value, and it‚Äôs at a <strong>fixed location in memory</strong>.</p>\n<p>üí° <strong>Always use const</strong>, instead of static. It‚Äôs pretty rare that you actually want a memory location associated with your constant, and using a const allows for optimizations like constant propagation not only in your crate but also in downstream crates.</p>\n<p>üí° Usually, statics are placed at the top of the code file, outside the functions.</p>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<p>‚≠êÔ∏è In Rust variables are <strong>immutable by default</strong>, so we call them <strong>Variable bindings</strong>. To make them mutable, the <code>mut</code> keyword is used.</p>\n<p>‚≠êÔ∏è Rust is a <strong>statically typed</strong> language; it checks data types at compile-time. But it <strong>doesn‚Äôt require you to actually type it when declaring variable bindings</strong>. In that case, the compiler checks the usage and sets a better data type for it. But for <strong>constants and statics, you must annotate the type</strong>. Types come after a colon(:)</p>\n<ul>\n<li><h3 id=\"Variable-bindings\"><a href=\"#Variable-bindings\" class=\"headerlink\" title=\"Variable bindings\"></a>Variable bindings</h3></li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = true;\nlet b: bool = true;\n\nlet (x, y) = (1, 2);\n\nlet mut z = 5;\nz = 6;\n</code></pre>\n<ul>\n<li><h3 id=\"Constants\"><a href=\"#Constants\" class=\"headerlink\" title=\"Constants\"></a>Constants</h3></li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">const N: i32 = 5;\n</code></pre>\n<ul>\n<li><h3 id=\"Statics\"><a href=\"#Statics\" class=\"headerlink\" title=\"Statics\"></a>Statics</h3></li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">static N: i32 = 5;\n</code></pre>\n<p>The <strong>let</strong> keyword is used in binding expressions. We can bind a name to a value or a function. Also, because the left-hand side of a let expression is a ‚Äòpattern‚Äô, you can bind multiple names to a set of values or function values.</p>\n<p>The <strong>const</strong> keyword is used to define constants. It lives for the entire lifetime of a program but has no fixed address in the memory. The <strong>static</strong> keyword is used to define a ‚Äòglobal variable‚Äô type facility. There is only one instance for each value, and it‚Äôs at a <strong>fixed location in memory</strong>.</p>\n<p>üí° <strong>Always use const</strong>, instead of static. It‚Äôs pretty rare that you actually want a memory location associated with your constant, and using a const allows for optimizations like constant propagation not only in your crate but also in downstream crates.</p>\n<p>üí° Usually, statics are placed at the top of the code file, outside the functions.</p>\n"},{"title":"Functions","_content":"\n## Named functions\n\n* Named functions are declared with the keyword **`fn`**\n* When using **arguments**, you **must declare data types**.\n* By default, functions **return empty tuple/ `()`**. If you want to return a value, the **return type must be specified** after **`->`**\n\n### i. Hello world\n\n```rust\nfn main() {\n    println!(\"Hello, world!\");\n}\n```\n\n### ii. Passing arguments\n\n```rust\nfn print_sum(a: i8, b: i8) {\n    println!(\"sum is: {}\", a + b);\n}\n```\n\n### iii. Returning values\n\n```rust\n// 01. Without the return keyword. Only last expression returns.\nfn plus_one(a: i32) -> i32 {\n    a + 1\n    // There is no ending ; in the above line. It means this is an expression which equals to `return a+1;`\n}\n\n// 02. With the return keyword.\nfn plus_two(a: i32) -> i32 {\n    return a + 2; // Returns a+2. But, this's a bad practice.\n    // Should use only on conditional returns, except in the last expression\n}\n```\n\n### iv. Function pointers, Usage as a Data Type\n\n```rust\n// 01. Without type declarations\nlet b = plus_one;\nlet c = b(5); //6\n\n// 02. With type declarations\nlet b: fn(i32) -> i32 = plus_one;\nlet c = b(5); //6\n```\n\n\n## Closures\n\n* Also known as **anonymous functions** or **lambda functions**.\n* The **data types of arguments and returns are optional**.\n\nExample with a named function, before using closures.\n```rust\nfn main() {\n  let x = 2;\n  println!(\"{}\", get_square_value(x));\n}\n\nfn get_square_value(x: i32) -> i32 {\n    x * x\n}\n```\n\n### i. With optional type declarations of input and return types\n```rust\nfn main() {\n    let x = 2;\n    let square = |x: i32| -> i32 { // Input parameters are passed inside | | and expression body is wrapped within { }\n        x * x \n    };\n    println!(\"{}\", square(x));\n}\n```\n\n### ii. Without type declarations of input and return types\n```rust\nfn main() {\n    let x = 2;\n    let square = |x| x * x; // { } are optional for single-lined closures\n    println!(\"{}\", square(x));\n}\n```\n","source":"docs/a7.functions.md","raw":"title: Functions\n---\n\n## Named functions\n\n* Named functions are declared with the keyword **`fn`**\n* When using **arguments**, you **must declare data types**.\n* By default, functions **return empty tuple/ `()`**. If you want to return a value, the **return type must be specified** after **`->`**\n\n### i. Hello world\n\n```rust\nfn main() {\n    println!(\"Hello, world!\");\n}\n```\n\n### ii. Passing arguments\n\n```rust\nfn print_sum(a: i8, b: i8) {\n    println!(\"sum is: {}\", a + b);\n}\n```\n\n### iii. Returning values\n\n```rust\n// 01. Without the return keyword. Only last expression returns.\nfn plus_one(a: i32) -> i32 {\n    a + 1\n    // There is no ending ; in the above line. It means this is an expression which equals to `return a+1;`\n}\n\n// 02. With the return keyword.\nfn plus_two(a: i32) -> i32 {\n    return a + 2; // Returns a+2. But, this's a bad practice.\n    // Should use only on conditional returns, except in the last expression\n}\n```\n\n### iv. Function pointers, Usage as a Data Type\n\n```rust\n// 01. Without type declarations\nlet b = plus_one;\nlet c = b(5); //6\n\n// 02. With type declarations\nlet b: fn(i32) -> i32 = plus_one;\nlet c = b(5); //6\n```\n\n\n## Closures\n\n* Also known as **anonymous functions** or **lambda functions**.\n* The **data types of arguments and returns are optional**.\n\nExample with a named function, before using closures.\n```rust\nfn main() {\n  let x = 2;\n  println!(\"{}\", get_square_value(x));\n}\n\nfn get_square_value(x: i32) -> i32 {\n    x * x\n}\n```\n\n### i. With optional type declarations of input and return types\n```rust\nfn main() {\n    let x = 2;\n    let square = |x: i32| -> i32 { // Input parameters are passed inside | | and expression body is wrapped within { }\n        x * x \n    };\n    println!(\"{}\", square(x));\n}\n```\n\n### ii. Without type declarations of input and return types\n```rust\nfn main() {\n    let x = 2;\n    let square = |x| x * x; // { } are optional for single-lined closures\n    println!(\"{}\", square(x));\n}\n```\n","date":"2019-03-19T14:50:39.950Z","updated":"2019-03-19T14:50:39.950Z","path":"docs/a7.functions.html","comments":1,"layout":"page","_id":"cjtfwbiza0007dwgp3fs8luyf","content":"<h2 id=\"Named-functions\"><a href=\"#Named-functions\" class=\"headerlink\" title=\"Named functions\"></a>Named functions</h2><ul>\n<li>Named functions are declared with the keyword <strong><code>fn</code></strong></li>\n<li>When using <strong>arguments</strong>, you <strong>must declare data types</strong>.</li>\n<li>By default, functions <strong>return empty tuple/ <code>()</code></strong>. If you want to return a value, the <strong>return type must be specified</strong> after <strong><code>-&gt;</code></strong></li>\n</ul>\n<h3 id=\"i-Hello-world\"><a href=\"#i-Hello-world\" class=\"headerlink\" title=\"i. Hello world\"></a>i. Hello world</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<h3 id=\"ii-Passing-arguments\"><a href=\"#ii-Passing-arguments\" class=\"headerlink\" title=\"ii. Passing arguments\"></a>ii. Passing arguments</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn print_sum(a: i8, b: i8) {\n    println!(&quot;sum is: {}&quot;, a + b);\n}\n</code></pre>\n<h3 id=\"iii-Returning-values\"><a href=\"#iii-Returning-values\" class=\"headerlink\" title=\"iii. Returning values\"></a>iii. Returning values</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// 01. Without the return keyword. Only last expression returns.\nfn plus_one(a: i32) -&gt; i32 {\n    a + 1\n    // There is no ending ; in the above line. It means this is an expression which equals to `return a+1;`\n}\n\n// 02. With the return keyword.\nfn plus_two(a: i32) -&gt; i32 {\n    return a + 2; // Returns a+2. But, this&#39;s a bad practice.\n    // Should use only on conditional returns, except in the last expression\n}\n</code></pre>\n<h3 id=\"iv-Function-pointers-Usage-as-a-Data-Type\"><a href=\"#iv-Function-pointers-Usage-as-a-Data-Type\" class=\"headerlink\" title=\"iv. Function pointers, Usage as a Data Type\"></a>iv. Function pointers, Usage as a Data Type</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// 01. Without type declarations\nlet b = plus_one;\nlet c = b(5); //6\n\n// 02. With type declarations\nlet b: fn(i32) -&gt; i32 = plus_one;\nlet c = b(5); //6\n</code></pre>\n<h2 id=\"Closures\"><a href=\"#Closures\" class=\"headerlink\" title=\"Closures\"></a>Closures</h2><ul>\n<li>Also known as <strong>anonymous functions</strong> or <strong>lambda functions</strong>.</li>\n<li>The <strong>data types of arguments and returns are optional</strong>.</li>\n</ul>\n<p>Example with a named function, before using closures.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n  let x = 2;\n  println!(&quot;{}&quot;, get_square_value(x));\n}\n\nfn get_square_value(x: i32) -&gt; i32 {\n    x * x\n}\n</code></pre>\n<h3 id=\"i-With-optional-type-declarations-of-input-and-return-types\"><a href=\"#i-With-optional-type-declarations-of-input-and-return-types\" class=\"headerlink\" title=\"i. With optional type declarations of input and return types\"></a>i. With optional type declarations of input and return types</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let x = 2;\n    let square = |x: i32| -&gt; i32 { // Input parameters are passed inside | | and expression body is wrapped within { }\n        x * x \n    };\n    println!(&quot;{}&quot;, square(x));\n}\n</code></pre>\n<h3 id=\"ii-Without-type-declarations-of-input-and-return-types\"><a href=\"#ii-Without-type-declarations-of-input-and-return-types\" class=\"headerlink\" title=\"ii. Without type declarations of input and return types\"></a>ii. Without type declarations of input and return types</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let x = 2;\n    let square = |x| x * x; // { } are optional for single-lined closures\n    println!(&quot;{}&quot;, square(x));\n}\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<h2 id=\"Named-functions\"><a href=\"#Named-functions\" class=\"headerlink\" title=\"Named functions\"></a>Named functions</h2><ul>\n<li>Named functions are declared with the keyword <strong><code>fn</code></strong></li>\n<li>When using <strong>arguments</strong>, you <strong>must declare data types</strong>.</li>\n<li>By default, functions <strong>return empty tuple/ <code>()</code></strong>. If you want to return a value, the <strong>return type must be specified</strong> after <strong><code>-&gt;</code></strong></li>\n</ul>\n<h3 id=\"i-Hello-world\"><a href=\"#i-Hello-world\" class=\"headerlink\" title=\"i. Hello world\"></a>i. Hello world</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<h3 id=\"ii-Passing-arguments\"><a href=\"#ii-Passing-arguments\" class=\"headerlink\" title=\"ii. Passing arguments\"></a>ii. Passing arguments</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn print_sum(a: i8, b: i8) {\n    println!(&quot;sum is: {}&quot;, a + b);\n}\n</code></pre>\n<h3 id=\"iii-Returning-values\"><a href=\"#iii-Returning-values\" class=\"headerlink\" title=\"iii. Returning values\"></a>iii. Returning values</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// 01. Without the return keyword. Only last expression returns.\nfn plus_one(a: i32) -&gt; i32 {\n    a + 1\n    // There is no ending ; in the above line. It means this is an expression which equals to `return a+1;`\n}\n\n// 02. With the return keyword.\nfn plus_two(a: i32) -&gt; i32 {\n    return a + 2; // Returns a+2. But, this&#39;s a bad practice.\n    // Should use only on conditional returns, except in the last expression\n}\n</code></pre>\n<h3 id=\"iv-Function-pointers-Usage-as-a-Data-Type\"><a href=\"#iv-Function-pointers-Usage-as-a-Data-Type\" class=\"headerlink\" title=\"iv. Function pointers, Usage as a Data Type\"></a>iv. Function pointers, Usage as a Data Type</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// 01. Without type declarations\nlet b = plus_one;\nlet c = b(5); //6\n\n// 02. With type declarations\nlet b: fn(i32) -&gt; i32 = plus_one;\nlet c = b(5); //6\n</code></pre>\n<h2 id=\"Closures\"><a href=\"#Closures\" class=\"headerlink\" title=\"Closures\"></a>Closures</h2><ul>\n<li>Also known as <strong>anonymous functions</strong> or <strong>lambda functions</strong>.</li>\n<li>The <strong>data types of arguments and returns are optional</strong>.</li>\n</ul>\n<p>Example with a named function, before using closures.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n  let x = 2;\n  println!(&quot;{}&quot;, get_square_value(x));\n}\n\nfn get_square_value(x: i32) -&gt; i32 {\n    x * x\n}\n</code></pre>\n<h3 id=\"i-With-optional-type-declarations-of-input-and-return-types\"><a href=\"#i-With-optional-type-declarations-of-input-and-return-types\" class=\"headerlink\" title=\"i. With optional type declarations of input and return types\"></a>i. With optional type declarations of input and return types</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let x = 2;\n    let square = |x: i32| -&gt; i32 { // Input parameters are passed inside | | and expression body is wrapped within { }\n        x * x \n    };\n    println!(&quot;{}&quot;, square(x));\n}\n</code></pre>\n<h3 id=\"ii-Without-type-declarations-of-input-and-return-types\"><a href=\"#ii-Without-type-declarations-of-input-and-return-types\" class=\"headerlink\" title=\"ii. Without type declarations of input and return types\"></a>ii. Without type declarations of input and return types</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let x = 2;\n    let square = |x| x * x; // { } are optional for single-lined closures\n    println!(&quot;{}&quot;, square(x));\n}\n</code></pre>\n"},{"title":"Hello World","_content":"\n## Hello, World!\n```rust\nfn main() {\n    println!(\"Hello, world!\");\n}\n```\n\n`fn` means function. The `main` function is the beginning of every Rust program.  \n`println!` prints text to the console and its *!* indicates that it‚Äôs a [macro](https://doc.rust-lang.org/book/first-edition/macros.html) rather than a function.\n\n> üí° Rust files should have .rs file extension and if you‚Äôre using more than one word for the file name, follow the [snake_case](https://en.wikipedia.org/wiki/Snake_case).\n\n- Save the above code in `file.rs` , but it can be any name with `.rs` extension.\n- Compile it with `rustc file.rs`\n- Execute it with `./file` on Linux and Mac or `file.exe` on Windows\n\n## Rust Playground\n\n[Rust Playground](https://play.rust-lang.org/) is a web interface for running Rust code.\n\n[![Rust Playground](images/rust_playground.png)](https://play.rust-lang.org/)\n\n## Usages of println!\n\nüíØ These are the other usages of the `println!` macro,\n\n```rust\nfn main() {\n    println!(\"{}, {}!\", \"Hello\", \"world\"); // Hello, world!\n    println!(\"{0}, {1}!\", \"Hello\", \"world\"); // Hello, world!\n    println!(\"{greeting}, {name}!\", greeting=\"Hello\", name=\"world\"); // Hello, world!\n\n    println!(\"{:?}\", [1,2,3]); // [1, 2, 3]\n    println!(\"{:#?}\", [1,2,3]);\n    /*\n        [\n            1,\n            2,\n            3\n        ]\n    */\n\n    // üîé The format! macro is used to store the formatted string.\n    let x = format!(\"{}, {}!\", \"Hello\", \"world\");\n    println!(\"{}\", x); // Hello, world!\n}\n```\n","source":"docs/a3.hello_world.md","raw":"title: Hello World\n---\n\n## Hello, World!\n```rust\nfn main() {\n    println!(\"Hello, world!\");\n}\n```\n\n`fn` means function. The `main` function is the beginning of every Rust program.  \n`println!` prints text to the console and its *!* indicates that it‚Äôs a [macro](https://doc.rust-lang.org/book/first-edition/macros.html) rather than a function.\n\n> üí° Rust files should have .rs file extension and if you‚Äôre using more than one word for the file name, follow the [snake_case](https://en.wikipedia.org/wiki/Snake_case).\n\n- Save the above code in `file.rs` , but it can be any name with `.rs` extension.\n- Compile it with `rustc file.rs`\n- Execute it with `./file` on Linux and Mac or `file.exe` on Windows\n\n## Rust Playground\n\n[Rust Playground](https://play.rust-lang.org/) is a web interface for running Rust code.\n\n[![Rust Playground](images/rust_playground.png)](https://play.rust-lang.org/)\n\n## Usages of println!\n\nüíØ These are the other usages of the `println!` macro,\n\n```rust\nfn main() {\n    println!(\"{}, {}!\", \"Hello\", \"world\"); // Hello, world!\n    println!(\"{0}, {1}!\", \"Hello\", \"world\"); // Hello, world!\n    println!(\"{greeting}, {name}!\", greeting=\"Hello\", name=\"world\"); // Hello, world!\n\n    println!(\"{:?}\", [1,2,3]); // [1, 2, 3]\n    println!(\"{:#?}\", [1,2,3]);\n    /*\n        [\n            1,\n            2,\n            3\n        ]\n    */\n\n    // üîé The format! macro is used to store the formatted string.\n    let x = format!(\"{}, {}!\", \"Hello\", \"world\");\n    println!(\"{}\", x); // Hello, world!\n}\n```\n","date":"2019-01-19T16:53:20.790Z","updated":"2019-01-19T16:53:20.790Z","path":"docs/a3.hello_world.html","comments":1,"layout":"page","_id":"cjtfwbizb0008dwgp884ysaqk","content":"<h2 id=\"Hello-World\"><a href=\"#Hello-World\" class=\"headerlink\" title=\"Hello, World!\"></a>Hello, World!</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<p><code>fn</code> means function. The <code>main</code> function is the beginning of every Rust program.<br><code>println!</code> prints text to the console and its <em>!</em> indicates that it‚Äôs a <a href=\"https://doc.rust-lang.org/book/first-edition/macros.html\" target=\"_blank\" rel=\"noopener\">macro</a> rather than a function.</p>\n<blockquote>\n<p>üí° Rust files should have .rs file extension and if you‚Äôre using more than one word for the file name, follow the <a href=\"https://en.wikipedia.org/wiki/Snake_case\" target=\"_blank\" rel=\"noopener\">snake_case</a>.</p>\n</blockquote>\n<ul>\n<li>Save the above code in <code>file.rs</code> , but it can be any name with <code>.rs</code> extension.</li>\n<li>Compile it with <code>rustc file.rs</code></li>\n<li>Execute it with <code>./file</code> on Linux and Mac or <code>file.exe</code> on Windows</li>\n</ul>\n<h2 id=\"Rust-Playground\"><a href=\"#Rust-Playground\" class=\"headerlink\" title=\"Rust Playground\"></a>Rust Playground</h2><p><a href=\"https://play.rust-lang.org/\" target=\"_blank\" rel=\"noopener\">Rust Playground</a> is a web interface for running Rust code.</p>\n<p><a href=\"https://play.rust-lang.org/\" target=\"_blank\" rel=\"noopener\"><img src=\"images/rust_playground.png\" alt=\"Rust Playground\"></a></p>\n<h2 id=\"Usages-of-println\"><a href=\"#Usages-of-println\" class=\"headerlink\" title=\"Usages of println!\"></a>Usages of println!</h2><p>üíØ These are the other usages of the <code>println!</code> macro,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    println!(&quot;{}, {}!&quot;, &quot;Hello&quot;, &quot;world&quot;); // Hello, world!\n    println!(&quot;{0}, {1}!&quot;, &quot;Hello&quot;, &quot;world&quot;); // Hello, world!\n    println!(&quot;{greeting}, {name}!&quot;, greeting=&quot;Hello&quot;, name=&quot;world&quot;); // Hello, world!\n\n    println!(&quot;{:?}&quot;, [1,2,3]); // [1, 2, 3]\n    println!(&quot;{:#?}&quot;, [1,2,3]);\n    /*\n        [\n            1,\n            2,\n            3\n        ]\n    */\n\n    // üîé The format! macro is used to store the formatted string.\n    let x = format!(&quot;{}, {}!&quot;, &quot;Hello&quot;, &quot;world&quot;);\n    println!(&quot;{}&quot;, x); // Hello, world!\n}\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<h2 id=\"Hello-World\"><a href=\"#Hello-World\" class=\"headerlink\" title=\"Hello, World!\"></a>Hello, World!</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<p><code>fn</code> means function. The <code>main</code> function is the beginning of every Rust program.<br><code>println!</code> prints text to the console and its <em>!</em> indicates that it‚Äôs a <a href=\"https://doc.rust-lang.org/book/first-edition/macros.html\" target=\"_blank\" rel=\"noopener\">macro</a> rather than a function.</p>\n<blockquote>\n<p>üí° Rust files should have .rs file extension and if you‚Äôre using more than one word for the file name, follow the <a href=\"https://en.wikipedia.org/wiki/Snake_case\" target=\"_blank\" rel=\"noopener\">snake_case</a>.</p>\n</blockquote>\n<ul>\n<li>Save the above code in <code>file.rs</code> , but it can be any name with <code>.rs</code> extension.</li>\n<li>Compile it with <code>rustc file.rs</code></li>\n<li>Execute it with <code>./file</code> on Linux and Mac or <code>file.exe</code> on Windows</li>\n</ul>\n<h2 id=\"Rust-Playground\"><a href=\"#Rust-Playground\" class=\"headerlink\" title=\"Rust Playground\"></a>Rust Playground</h2><p><a href=\"https://play.rust-lang.org/\" target=\"_blank\" rel=\"noopener\">Rust Playground</a> is a web interface for running Rust code.</p>\n<p><a href=\"https://play.rust-lang.org/\" target=\"_blank\" rel=\"noopener\"><img src=\"images/rust_playground.png\" alt=\"Rust Playground\"></a></p>\n<h2 id=\"Usages-of-println\"><a href=\"#Usages-of-println\" class=\"headerlink\" title=\"Usages of println!\"></a>Usages of println!</h2><p>üíØ These are the other usages of the <code>println!</code> macro,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    println!(&quot;{}, {}!&quot;, &quot;Hello&quot;, &quot;world&quot;); // Hello, world!\n    println!(&quot;{0}, {1}!&quot;, &quot;Hello&quot;, &quot;world&quot;); // Hello, world!\n    println!(&quot;{greeting}, {name}!&quot;, greeting=&quot;Hello&quot;, name=&quot;world&quot;); // Hello, world!\n\n    println!(&quot;{:?}&quot;, [1,2,3]); // [1, 2, 3]\n    println!(&quot;{:#?}&quot;, [1,2,3]);\n    /*\n        [\n            1,\n            2,\n            3\n        ]\n    */\n\n    // üîé The format! macro is used to store the formatted string.\n    let x = format!(&quot;{}, {}!&quot;, &quot;Hello&quot;, &quot;world&quot;);\n    println!(&quot;{}&quot;, x); // Hello, world!\n}\n</code></pre>\n"},{"title":"Primitive Data Types","_content":"\n- ## bool\ntrue or false\n\n```rust\nlet x = true;\nlet y: bool = false;\n\n// ‚≠êÔ∏è no TRUE, FALSE, 1, 0\n```\n\n\n- ## char\nA single Unicode scalar value\n\n```rust\nlet x = 'x';\nlet y = 'üòé';\n\n// ‚≠êÔ∏è no \"x\", only single quotes\n```\nBecause of Unicode support, char is not a single byte, but four.\n\n- ## i8, i16, i32, i64, i128\n8, 16, 32, 64 and 128 bit fixed sized signed(+/-) integer types\n\n| DATA TYPE | MIN                                      | MAX                                     |\n| --------- | ---------------------------------------- | --------------------------------------- |\n| i8        | -128                                     | 127                                     |\n| i16       | -32768                                   | 32767                                   |\n| i32       | -2147483648                              | 2147483647                              |\n| i64       | -9223372036854775808                     | 9223372036854775807                     |\n| i128      | -170141183460469231731687303715884105728 | 170141183460469231731687303715884105727 |\n\nüí° The min and max values are based on the following equation; **from -(2‚Åø‚Åª¬π) to 2‚Åø‚Åª¬π-1**. You can use **min_value()** and **max_value()** functions to find min and max of each integer type. ex.`i8::min_value();`\n\n\n- ## u8, u16, u32, u64, u128\n8, 16, 32, 64 and 128 bit fixed sized unsigned(0/+) integer types\n\n| DATA TYPE | MIN | MAX                                     |\n| --------- | --- | --------------------------------------- |\n| u8        | 0   | 255                                     |\n| u16       | 0   | 65535                                   |\n| u32       | 0   | 4294967295                              |\n| u64       | 0   | 18446744073709551615                    |\n| u128      | 0   | 340282366920938463463374607431768211455 |\n\nüí° The min and max values are based on the following equation; **from 0 to 2‚Åø-1**. Same way you can use **min_value()** and **max_value()** functions to find min and max of each integer type. ex.`u8::max_value();`\n\n\n- ## isize, usize\nPointer sized signed and unsigned integer types\n\nThe actual bit size depends on the computer architecture you are compiling your program for. By default, the sizes are equal to 32 bit on 32-bit platforms and 64 bit on 64-bit platforms.\n\n> üîé Search more about [cross-compiling](https://github.com/rust-lang/rustup.rs#cross-compilation) and [Supported Tiers](https://forge.rust-lang.org/platform-support.html) of Rust programs.\n\n\n- ## f32, f64\n32 and 64 bit sized floating point numbers(numbers with decimal points)\n\nRust follows IEEE Standard for Binary Floating-Point Arithmetic. The `f32` type is similar to float(**Single precision**) in other languages, while `f64` is similar to double(**Double precision**) in other languages.\n\nüí° Should avoid using this unless you need to reduce memory consumption badly or if you are doing low-level optimization, when targeted hardware does not support for double-precision or when single-precision is faster than double-precision on it.\n\n\n- ## arrays\nFixed size list of elements of same data type\n\n```rust\nlet a = [1, 2, 3]; // a[0] = 1, a[1] = 2, a[2] = 3\nlet mut b = [1, 2, 3];\n\nlet c: [i32; 0] = []; //[Type; NO of elements] -> [] /empty array\nlet d: [i32; 3] = [1, 2, 3];\n\nlet e = [\"my value\"; 3]; //[\"my value\", \"my value\", \"my value\"];\n\nprintln!(\"{:?}\", a); //[1, 2, 3]\nprintln!(\"{:#?}\", a);\n//  [\n//      1,\n//      2,\n//      3\n//  ]\n```\n\n‚≠êÔ∏è Arrays are **immutable** by default and **even with `mut`, its element count cannot be changed**.\n\n> üîé If you are looking for a dynamic/growable array, you can use **Vec**. Vectors can contain any type of elements but all elements must be in the same data type.\n\n\n- ## tuples\nFixed size ordered list of elements of different(or same) data types\n\n```rust\nlet a = (1, 1.5, true, 'a', \"Hello, world!\");\n// a.0 = 1, a.1 = 1.5, a.2 = true, a.3 = 'a', a.4 = \"Hello, world!\"\n\nlet b: (i32, f64) = (1, 1.5);\n\nlet (c, d) = b; // c = 1, d = 1.5\nlet (e, _, _, _, f) = a; //e = 1, f = \"Hello, world!\", _ indicates not interested of that item\n\nlet g = (0,); //single-element tuple\n\nlet h = (b, (2, 4), 5); //((1, 1.5), (2, 4), 5)\n\nprintln!(\"{:?}\", a); //(1, 1.5, true, 'a', \"Hello, world!\")\n```\n\n‚≠êÔ∏è Tuples are also **immutable** by default and **even with `mut`, its element count cannot be changed. Also, if you want to change an element‚Äôs value, the new value should have the same data type of previous value**.\n\n\n- ## slice\nDynamically-sized reference to another data structure\n\nThink you want to get/pass a part of an array or any other data structure. Instead of copy it to another array (or same data structure), Rust allows creating a view/reference to access only that part of data. And it can be mutable or not.\n\n```rust\nlet a: [i32; 4] = [1, 2, 3, 4];//Parent Array\n\nlet b: &[i32] = &a; //Slicing whole array\nlet c = &a[0..4]; // From 0th position to 4th(excluding)\nlet d = &a[..]; //Slicing whole array\n\nlet e = &a[1..3]; //[2, 3]\nlet f = &a[1..]; //[2, 3, 4]\nlet g = &a[..3]; //[1, 2, 3]\n```\n\n\n- ## str\nUnsized UTF-8 sequence of Unicode string slices\n\n```rust\nlet a = \"Hello, world.\"; //a: &'static str\nlet b: &str = \"„Åì„Çì„Å´„Å°„ÅØ, ‰∏ñÁïå!\";\n```\n\n‚≠êÔ∏è It's an **immutable/statically allocated slice** holding an **unknown sized sequence of UTF-8** code points stored in somewhere in memory. **&str** is used to borrow and assign the whole array to the given variable binding.\n\n> üîé A [String](https://doc.rust-lang.org/std/string/struct.String.html) is a **heap**-allocated string. This string is growable and is also guaranteed to be UTF-8. They are commonly created by converting from a string slice using the **to_string()** or **String::from()** methods. ex: `‚ÄúHello‚Äù.to_string();`  `String::from(\"Hello\");`\n\nüí° In general, you should use **String** when you need **ownership**, and **`&str`** when you just need to **borrow a string**.\n\n\n- ## functions\nAs we discussed on functions section, `b` is a function pointer, to `plus_one()` in the below code.\n\n```rust\nfn plus_one(a: i32) -> i32 {\n    a + 1\n}\n\nlet b: fn(i32) -> i32 = plus_one;\nlet c = b(5); //6\n```\n","source":"docs/a8.primitive_data_types.md","raw":"title: Primitive Data Types\n---\n\n- ## bool\ntrue or false\n\n```rust\nlet x = true;\nlet y: bool = false;\n\n// ‚≠êÔ∏è no TRUE, FALSE, 1, 0\n```\n\n\n- ## char\nA single Unicode scalar value\n\n```rust\nlet x = 'x';\nlet y = 'üòé';\n\n// ‚≠êÔ∏è no \"x\", only single quotes\n```\nBecause of Unicode support, char is not a single byte, but four.\n\n- ## i8, i16, i32, i64, i128\n8, 16, 32, 64 and 128 bit fixed sized signed(+/-) integer types\n\n| DATA TYPE | MIN                                      | MAX                                     |\n| --------- | ---------------------------------------- | --------------------------------------- |\n| i8        | -128                                     | 127                                     |\n| i16       | -32768                                   | 32767                                   |\n| i32       | -2147483648                              | 2147483647                              |\n| i64       | -9223372036854775808                     | 9223372036854775807                     |\n| i128      | -170141183460469231731687303715884105728 | 170141183460469231731687303715884105727 |\n\nüí° The min and max values are based on the following equation; **from -(2‚Åø‚Åª¬π) to 2‚Åø‚Åª¬π-1**. You can use **min_value()** and **max_value()** functions to find min and max of each integer type. ex.`i8::min_value();`\n\n\n- ## u8, u16, u32, u64, u128\n8, 16, 32, 64 and 128 bit fixed sized unsigned(0/+) integer types\n\n| DATA TYPE | MIN | MAX                                     |\n| --------- | --- | --------------------------------------- |\n| u8        | 0   | 255                                     |\n| u16       | 0   | 65535                                   |\n| u32       | 0   | 4294967295                              |\n| u64       | 0   | 18446744073709551615                    |\n| u128      | 0   | 340282366920938463463374607431768211455 |\n\nüí° The min and max values are based on the following equation; **from 0 to 2‚Åø-1**. Same way you can use **min_value()** and **max_value()** functions to find min and max of each integer type. ex.`u8::max_value();`\n\n\n- ## isize, usize\nPointer sized signed and unsigned integer types\n\nThe actual bit size depends on the computer architecture you are compiling your program for. By default, the sizes are equal to 32 bit on 32-bit platforms and 64 bit on 64-bit platforms.\n\n> üîé Search more about [cross-compiling](https://github.com/rust-lang/rustup.rs#cross-compilation) and [Supported Tiers](https://forge.rust-lang.org/platform-support.html) of Rust programs.\n\n\n- ## f32, f64\n32 and 64 bit sized floating point numbers(numbers with decimal points)\n\nRust follows IEEE Standard for Binary Floating-Point Arithmetic. The `f32` type is similar to float(**Single precision**) in other languages, while `f64` is similar to double(**Double precision**) in other languages.\n\nüí° Should avoid using this unless you need to reduce memory consumption badly or if you are doing low-level optimization, when targeted hardware does not support for double-precision or when single-precision is faster than double-precision on it.\n\n\n- ## arrays\nFixed size list of elements of same data type\n\n```rust\nlet a = [1, 2, 3]; // a[0] = 1, a[1] = 2, a[2] = 3\nlet mut b = [1, 2, 3];\n\nlet c: [i32; 0] = []; //[Type; NO of elements] -> [] /empty array\nlet d: [i32; 3] = [1, 2, 3];\n\nlet e = [\"my value\"; 3]; //[\"my value\", \"my value\", \"my value\"];\n\nprintln!(\"{:?}\", a); //[1, 2, 3]\nprintln!(\"{:#?}\", a);\n//  [\n//      1,\n//      2,\n//      3\n//  ]\n```\n\n‚≠êÔ∏è Arrays are **immutable** by default and **even with `mut`, its element count cannot be changed**.\n\n> üîé If you are looking for a dynamic/growable array, you can use **Vec**. Vectors can contain any type of elements but all elements must be in the same data type.\n\n\n- ## tuples\nFixed size ordered list of elements of different(or same) data types\n\n```rust\nlet a = (1, 1.5, true, 'a', \"Hello, world!\");\n// a.0 = 1, a.1 = 1.5, a.2 = true, a.3 = 'a', a.4 = \"Hello, world!\"\n\nlet b: (i32, f64) = (1, 1.5);\n\nlet (c, d) = b; // c = 1, d = 1.5\nlet (e, _, _, _, f) = a; //e = 1, f = \"Hello, world!\", _ indicates not interested of that item\n\nlet g = (0,); //single-element tuple\n\nlet h = (b, (2, 4), 5); //((1, 1.5), (2, 4), 5)\n\nprintln!(\"{:?}\", a); //(1, 1.5, true, 'a', \"Hello, world!\")\n```\n\n‚≠êÔ∏è Tuples are also **immutable** by default and **even with `mut`, its element count cannot be changed. Also, if you want to change an element‚Äôs value, the new value should have the same data type of previous value**.\n\n\n- ## slice\nDynamically-sized reference to another data structure\n\nThink you want to get/pass a part of an array or any other data structure. Instead of copy it to another array (or same data structure), Rust allows creating a view/reference to access only that part of data. And it can be mutable or not.\n\n```rust\nlet a: [i32; 4] = [1, 2, 3, 4];//Parent Array\n\nlet b: &[i32] = &a; //Slicing whole array\nlet c = &a[0..4]; // From 0th position to 4th(excluding)\nlet d = &a[..]; //Slicing whole array\n\nlet e = &a[1..3]; //[2, 3]\nlet f = &a[1..]; //[2, 3, 4]\nlet g = &a[..3]; //[1, 2, 3]\n```\n\n\n- ## str\nUnsized UTF-8 sequence of Unicode string slices\n\n```rust\nlet a = \"Hello, world.\"; //a: &'static str\nlet b: &str = \"„Åì„Çì„Å´„Å°„ÅØ, ‰∏ñÁïå!\";\n```\n\n‚≠êÔ∏è It's an **immutable/statically allocated slice** holding an **unknown sized sequence of UTF-8** code points stored in somewhere in memory. **&str** is used to borrow and assign the whole array to the given variable binding.\n\n> üîé A [String](https://doc.rust-lang.org/std/string/struct.String.html) is a **heap**-allocated string. This string is growable and is also guaranteed to be UTF-8. They are commonly created by converting from a string slice using the **to_string()** or **String::from()** methods. ex: `‚ÄúHello‚Äù.to_string();`  `String::from(\"Hello\");`\n\nüí° In general, you should use **String** when you need **ownership**, and **`&str`** when you just need to **borrow a string**.\n\n\n- ## functions\nAs we discussed on functions section, `b` is a function pointer, to `plus_one()` in the below code.\n\n```rust\nfn plus_one(a: i32) -> i32 {\n    a + 1\n}\n\nlet b: fn(i32) -> i32 = plus_one;\nlet c = b(5); //6\n```\n","date":"2019-03-19T14:50:39.951Z","updated":"2019-03-19T14:50:39.951Z","path":"docs/a8.primitive_data_types.html","comments":1,"layout":"page","_id":"cjtfwbizb0009dwgpbgni4si1","content":"<ul>\n<li><h2 id=\"bool\"><a href=\"#bool\" class=\"headerlink\" title=\"bool\"></a>bool</h2>true or false</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let x = true;\nlet y: bool = false;\n\n// ‚≠êÔ∏è no TRUE, FALSE, 1, 0\n</code></pre>\n<ul>\n<li><h2 id=\"char\"><a href=\"#char\" class=\"headerlink\" title=\"char\"></a>char</h2>A single Unicode scalar value</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let x = &#39;x&#39;;\nlet y = &#39;üòé&#39;;\n\n// ‚≠êÔ∏è no &quot;x&quot;, only single quotes\n</code></pre>\n<p>Because of Unicode support, char is not a single byte, but four.</p>\n<ul>\n<li><h2 id=\"i8-i16-i32-i64-i128\"><a href=\"#i8-i16-i32-i64-i128\" class=\"headerlink\" title=\"i8, i16, i32, i64, i128\"></a>i8, i16, i32, i64, i128</h2>8, 16, 32, 64 and 128 bit fixed sized signed(+/-) integer types</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>DATA TYPE</th>\n<th>MIN</th>\n<th>MAX</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>i8</td>\n<td>-128</td>\n<td>127</td>\n</tr>\n<tr>\n<td>i16</td>\n<td>-32768</td>\n<td>32767</td>\n</tr>\n<tr>\n<td>i32</td>\n<td>-2147483648</td>\n<td>2147483647</td>\n</tr>\n<tr>\n<td>i64</td>\n<td>-9223372036854775808</td>\n<td>9223372036854775807</td>\n</tr>\n<tr>\n<td>i128</td>\n<td>-170141183460469231731687303715884105728</td>\n<td>170141183460469231731687303715884105727</td>\n</tr>\n</tbody>\n</table>\n<p>üí° The min and max values are based on the following equation; <strong>from -(2‚Åø‚Åª¬π) to 2‚Åø‚Åª¬π-1</strong>. You can use <strong>min_value()</strong> and <strong>max_value()</strong> functions to find min and max of each integer type. ex.<code>i8::min_value();</code></p>\n<ul>\n<li><h2 id=\"u8-u16-u32-u64-u128\"><a href=\"#u8-u16-u32-u64-u128\" class=\"headerlink\" title=\"u8, u16, u32, u64, u128\"></a>u8, u16, u32, u64, u128</h2>8, 16, 32, 64 and 128 bit fixed sized unsigned(0/+) integer types</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>DATA TYPE</th>\n<th>MIN</th>\n<th>MAX</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>u8</td>\n<td>0</td>\n<td>255</td>\n</tr>\n<tr>\n<td>u16</td>\n<td>0</td>\n<td>65535</td>\n</tr>\n<tr>\n<td>u32</td>\n<td>0</td>\n<td>4294967295</td>\n</tr>\n<tr>\n<td>u64</td>\n<td>0</td>\n<td>18446744073709551615</td>\n</tr>\n<tr>\n<td>u128</td>\n<td>0</td>\n<td>340282366920938463463374607431768211455</td>\n</tr>\n</tbody>\n</table>\n<p>üí° The min and max values are based on the following equation; <strong>from 0 to 2‚Åø-1</strong>. Same way you can use <strong>min_value()</strong> and <strong>max_value()</strong> functions to find min and max of each integer type. ex.<code>u8::max_value();</code></p>\n<ul>\n<li><h2 id=\"isize-usize\"><a href=\"#isize-usize\" class=\"headerlink\" title=\"isize, usize\"></a>isize, usize</h2>Pointer sized signed and unsigned integer types</li>\n</ul>\n<p>The actual bit size depends on the computer architecture you are compiling your program for. By default, the sizes are equal to 32 bit on 32-bit platforms and 64 bit on 64-bit platforms.</p>\n<blockquote>\n<p>üîé Search more about <a href=\"https://github.com/rust-lang/rustup.rs#cross-compilation\" target=\"_blank\" rel=\"noopener\">cross-compiling</a> and <a href=\"https://forge.rust-lang.org/platform-support.html\" target=\"_blank\" rel=\"noopener\">Supported Tiers</a> of Rust programs.</p>\n</blockquote>\n<ul>\n<li><h2 id=\"f32-f64\"><a href=\"#f32-f64\" class=\"headerlink\" title=\"f32, f64\"></a>f32, f64</h2>32 and 64 bit sized floating point numbers(numbers with decimal points)</li>\n</ul>\n<p>Rust follows IEEE Standard for Binary Floating-Point Arithmetic. The <code>f32</code> type is similar to float(<strong>Single precision</strong>) in other languages, while <code>f64</code> is similar to double(<strong>Double precision</strong>) in other languages.</p>\n<p>üí° Should avoid using this unless you need to reduce memory consumption badly or if you are doing low-level optimization, when targeted hardware does not support for double-precision or when single-precision is faster than double-precision on it.</p>\n<ul>\n<li><h2 id=\"arrays\"><a href=\"#arrays\" class=\"headerlink\" title=\"arrays\"></a>arrays</h2>Fixed size list of elements of same data type</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = [1, 2, 3]; // a[0] = 1, a[1] = 2, a[2] = 3\nlet mut b = [1, 2, 3];\n\nlet c: [i32; 0] = []; //[Type; NO of elements] -&gt; [] /empty array\nlet d: [i32; 3] = [1, 2, 3];\n\nlet e = [&quot;my value&quot;; 3]; //[&quot;my value&quot;, &quot;my value&quot;, &quot;my value&quot;];\n\nprintln!(&quot;{:?}&quot;, a); //[1, 2, 3]\nprintln!(&quot;{:#?}&quot;, a);\n//  [\n//      1,\n//      2,\n//      3\n//  ]\n</code></pre>\n<p>‚≠êÔ∏è Arrays are <strong>immutable</strong> by default and <strong>even with <code>mut</code>, its element count cannot be changed</strong>.</p>\n<blockquote>\n<p>üîé If you are looking for a dynamic/growable array, you can use <strong>Vec</strong>. Vectors can contain any type of elements but all elements must be in the same data type.</p>\n</blockquote>\n<ul>\n<li><h2 id=\"tuples\"><a href=\"#tuples\" class=\"headerlink\" title=\"tuples\"></a>tuples</h2>Fixed size ordered list of elements of different(or same) data types</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = (1, 1.5, true, &#39;a&#39;, &quot;Hello, world!&quot;);\n// a.0 = 1, a.1 = 1.5, a.2 = true, a.3 = &#39;a&#39;, a.4 = &quot;Hello, world!&quot;\n\nlet b: (i32, f64) = (1, 1.5);\n\nlet (c, d) = b; // c = 1, d = 1.5\nlet (e, _, _, _, f) = a; //e = 1, f = &quot;Hello, world!&quot;, _ indicates not interested of that item\n\nlet g = (0,); //single-element tuple\n\nlet h = (b, (2, 4), 5); //((1, 1.5), (2, 4), 5)\n\nprintln!(&quot;{:?}&quot;, a); //(1, 1.5, true, &#39;a&#39;, &quot;Hello, world!&quot;)\n</code></pre>\n<p>‚≠êÔ∏è Tuples are also <strong>immutable</strong> by default and <strong>even with <code>mut</code>, its element count cannot be changed. Also, if you want to change an element‚Äôs value, the new value should have the same data type of previous value</strong>.</p>\n<ul>\n<li><h2 id=\"slice\"><a href=\"#slice\" class=\"headerlink\" title=\"slice\"></a>slice</h2>Dynamically-sized reference to another data structure</li>\n</ul>\n<p>Think you want to get/pass a part of an array or any other data structure. Instead of copy it to another array (or same data structure), Rust allows creating a view/reference to access only that part of data. And it can be mutable or not.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a: [i32; 4] = [1, 2, 3, 4];//Parent Array\n\nlet b: &amp;[i32] = &amp;a; //Slicing whole array\nlet c = &amp;a[0..4]; // From 0th position to 4th(excluding)\nlet d = &amp;a[..]; //Slicing whole array\n\nlet e = &amp;a[1..3]; //[2, 3]\nlet f = &amp;a[1..]; //[2, 3, 4]\nlet g = &amp;a[..3]; //[1, 2, 3]\n</code></pre>\n<ul>\n<li><h2 id=\"str\"><a href=\"#str\" class=\"headerlink\" title=\"str\"></a>str</h2>Unsized UTF-8 sequence of Unicode string slices</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = &quot;Hello, world.&quot;; //a: &amp;&#39;static str\nlet b: &amp;str = &quot;„Åì„Çì„Å´„Å°„ÅØ, ‰∏ñÁïå!&quot;;\n</code></pre>\n<p>‚≠êÔ∏è It‚Äôs an <strong>immutable/statically allocated slice</strong> holding an <strong>unknown sized sequence of UTF-8</strong> code points stored in somewhere in memory. <strong>&amp;str</strong> is used to borrow and assign the whole array to the given variable binding.</p>\n<blockquote>\n<p>üîé A <a href=\"https://doc.rust-lang.org/std/string/struct.String.html\" target=\"_blank\" rel=\"noopener\">String</a> is a <strong>heap</strong>-allocated string. This string is growable and is also guaranteed to be UTF-8. They are commonly created by converting from a string slice using the <strong>to_string()</strong> or <strong>String::from()</strong> methods. ex: <code>‚ÄúHello‚Äù.to_string();</code>  <code>String::from(&quot;Hello&quot;);</code></p>\n</blockquote>\n<p>üí° In general, you should use <strong>String</strong> when you need <strong>ownership</strong>, and <strong><code>&amp;str</code></strong> when you just need to <strong>borrow a string</strong>.</p>\n<ul>\n<li><h2 id=\"functions\"><a href=\"#functions\" class=\"headerlink\" title=\"functions\"></a>functions</h2>As we discussed on functions section, <code>b</code> is a function pointer, to <code>plus_one()</code> in the below code.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn plus_one(a: i32) -&gt; i32 {\n    a + 1\n}\n\nlet b: fn(i32) -&gt; i32 = plus_one;\nlet c = b(5); //6\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<ul>\n<li><h2 id=\"bool\"><a href=\"#bool\" class=\"headerlink\" title=\"bool\"></a>bool</h2>true or false</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let x = true;\nlet y: bool = false;\n\n// ‚≠êÔ∏è no TRUE, FALSE, 1, 0\n</code></pre>\n<ul>\n<li><h2 id=\"char\"><a href=\"#char\" class=\"headerlink\" title=\"char\"></a>char</h2>A single Unicode scalar value</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let x = &#39;x&#39;;\nlet y = &#39;üòé&#39;;\n\n// ‚≠êÔ∏è no &quot;x&quot;, only single quotes\n</code></pre>\n<p>Because of Unicode support, char is not a single byte, but four.</p>\n<ul>\n<li><h2 id=\"i8-i16-i32-i64-i128\"><a href=\"#i8-i16-i32-i64-i128\" class=\"headerlink\" title=\"i8, i16, i32, i64, i128\"></a>i8, i16, i32, i64, i128</h2>8, 16, 32, 64 and 128 bit fixed sized signed(+/-) integer types</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>DATA TYPE</th>\n<th>MIN</th>\n<th>MAX</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>i8</td>\n<td>-128</td>\n<td>127</td>\n</tr>\n<tr>\n<td>i16</td>\n<td>-32768</td>\n<td>32767</td>\n</tr>\n<tr>\n<td>i32</td>\n<td>-2147483648</td>\n<td>2147483647</td>\n</tr>\n<tr>\n<td>i64</td>\n<td>-9223372036854775808</td>\n<td>9223372036854775807</td>\n</tr>\n<tr>\n<td>i128</td>\n<td>-170141183460469231731687303715884105728</td>\n<td>170141183460469231731687303715884105727</td>\n</tr>\n</tbody>\n</table>\n<p>üí° The min and max values are based on the following equation; <strong>from -(2‚Åø‚Åª¬π) to 2‚Åø‚Åª¬π-1</strong>. You can use <strong>min_value()</strong> and <strong>max_value()</strong> functions to find min and max of each integer type. ex.<code>i8::min_value();</code></p>\n<ul>\n<li><h2 id=\"u8-u16-u32-u64-u128\"><a href=\"#u8-u16-u32-u64-u128\" class=\"headerlink\" title=\"u8, u16, u32, u64, u128\"></a>u8, u16, u32, u64, u128</h2>8, 16, 32, 64 and 128 bit fixed sized unsigned(0/+) integer types</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>DATA TYPE</th>\n<th>MIN</th>\n<th>MAX</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>u8</td>\n<td>0</td>\n<td>255</td>\n</tr>\n<tr>\n<td>u16</td>\n<td>0</td>\n<td>65535</td>\n</tr>\n<tr>\n<td>u32</td>\n<td>0</td>\n<td>4294967295</td>\n</tr>\n<tr>\n<td>u64</td>\n<td>0</td>\n<td>18446744073709551615</td>\n</tr>\n<tr>\n<td>u128</td>\n<td>0</td>\n<td>340282366920938463463374607431768211455</td>\n</tr>\n</tbody>\n</table>\n<p>üí° The min and max values are based on the following equation; <strong>from 0 to 2‚Åø-1</strong>. Same way you can use <strong>min_value()</strong> and <strong>max_value()</strong> functions to find min and max of each integer type. ex.<code>u8::max_value();</code></p>\n<ul>\n<li><h2 id=\"isize-usize\"><a href=\"#isize-usize\" class=\"headerlink\" title=\"isize, usize\"></a>isize, usize</h2>Pointer sized signed and unsigned integer types</li>\n</ul>\n<p>The actual bit size depends on the computer architecture you are compiling your program for. By default, the sizes are equal to 32 bit on 32-bit platforms and 64 bit on 64-bit platforms.</p>\n<blockquote>\n<p>üîé Search more about <a href=\"https://github.com/rust-lang/rustup.rs#cross-compilation\" target=\"_blank\" rel=\"noopener\">cross-compiling</a> and <a href=\"https://forge.rust-lang.org/platform-support.html\" target=\"_blank\" rel=\"noopener\">Supported Tiers</a> of Rust programs.</p>\n</blockquote>\n<ul>\n<li><h2 id=\"f32-f64\"><a href=\"#f32-f64\" class=\"headerlink\" title=\"f32, f64\"></a>f32, f64</h2>32 and 64 bit sized floating point numbers(numbers with decimal points)</li>\n</ul>\n<p>Rust follows IEEE Standard for Binary Floating-Point Arithmetic. The <code>f32</code> type is similar to float(<strong>Single precision</strong>) in other languages, while <code>f64</code> is similar to double(<strong>Double precision</strong>) in other languages.</p>\n<p>üí° Should avoid using this unless you need to reduce memory consumption badly or if you are doing low-level optimization, when targeted hardware does not support for double-precision or when single-precision is faster than double-precision on it.</p>\n<ul>\n<li><h2 id=\"arrays\"><a href=\"#arrays\" class=\"headerlink\" title=\"arrays\"></a>arrays</h2>Fixed size list of elements of same data type</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = [1, 2, 3]; // a[0] = 1, a[1] = 2, a[2] = 3\nlet mut b = [1, 2, 3];\n\nlet c: [i32; 0] = []; //[Type; NO of elements] -&gt; [] /empty array\nlet d: [i32; 3] = [1, 2, 3];\n\nlet e = [&quot;my value&quot;; 3]; //[&quot;my value&quot;, &quot;my value&quot;, &quot;my value&quot;];\n\nprintln!(&quot;{:?}&quot;, a); //[1, 2, 3]\nprintln!(&quot;{:#?}&quot;, a);\n//  [\n//      1,\n//      2,\n//      3\n//  ]\n</code></pre>\n<p>‚≠êÔ∏è Arrays are <strong>immutable</strong> by default and <strong>even with <code>mut</code>, its element count cannot be changed</strong>.</p>\n<blockquote>\n<p>üîé If you are looking for a dynamic/growable array, you can use <strong>Vec</strong>. Vectors can contain any type of elements but all elements must be in the same data type.</p>\n</blockquote>\n<ul>\n<li><h2 id=\"tuples\"><a href=\"#tuples\" class=\"headerlink\" title=\"tuples\"></a>tuples</h2>Fixed size ordered list of elements of different(or same) data types</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = (1, 1.5, true, &#39;a&#39;, &quot;Hello, world!&quot;);\n// a.0 = 1, a.1 = 1.5, a.2 = true, a.3 = &#39;a&#39;, a.4 = &quot;Hello, world!&quot;\n\nlet b: (i32, f64) = (1, 1.5);\n\nlet (c, d) = b; // c = 1, d = 1.5\nlet (e, _, _, _, f) = a; //e = 1, f = &quot;Hello, world!&quot;, _ indicates not interested of that item\n\nlet g = (0,); //single-element tuple\n\nlet h = (b, (2, 4), 5); //((1, 1.5), (2, 4), 5)\n\nprintln!(&quot;{:?}&quot;, a); //(1, 1.5, true, &#39;a&#39;, &quot;Hello, world!&quot;)\n</code></pre>\n<p>‚≠êÔ∏è Tuples are also <strong>immutable</strong> by default and <strong>even with <code>mut</code>, its element count cannot be changed. Also, if you want to change an element‚Äôs value, the new value should have the same data type of previous value</strong>.</p>\n<ul>\n<li><h2 id=\"slice\"><a href=\"#slice\" class=\"headerlink\" title=\"slice\"></a>slice</h2>Dynamically-sized reference to another data structure</li>\n</ul>\n<p>Think you want to get/pass a part of an array or any other data structure. Instead of copy it to another array (or same data structure), Rust allows creating a view/reference to access only that part of data. And it can be mutable or not.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a: [i32; 4] = [1, 2, 3, 4];//Parent Array\n\nlet b: &amp;[i32] = &amp;a; //Slicing whole array\nlet c = &amp;a[0..4]; // From 0th position to 4th(excluding)\nlet d = &amp;a[..]; //Slicing whole array\n\nlet e = &amp;a[1..3]; //[2, 3]\nlet f = &amp;a[1..]; //[2, 3, 4]\nlet g = &amp;a[..3]; //[1, 2, 3]\n</code></pre>\n<ul>\n<li><h2 id=\"str\"><a href=\"#str\" class=\"headerlink\" title=\"str\"></a>str</h2>Unsized UTF-8 sequence of Unicode string slices</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = &quot;Hello, world.&quot;; //a: &amp;&#39;static str\nlet b: &amp;str = &quot;„Åì„Çì„Å´„Å°„ÅØ, ‰∏ñÁïå!&quot;;\n</code></pre>\n<p>‚≠êÔ∏è It‚Äôs an <strong>immutable/statically allocated slice</strong> holding an <strong>unknown sized sequence of UTF-8</strong> code points stored in somewhere in memory. <strong>&amp;str</strong> is used to borrow and assign the whole array to the given variable binding.</p>\n<blockquote>\n<p>üîé A <a href=\"https://doc.rust-lang.org/std/string/struct.String.html\" target=\"_blank\" rel=\"noopener\">String</a> is a <strong>heap</strong>-allocated string. This string is growable and is also guaranteed to be UTF-8. They are commonly created by converting from a string slice using the <strong>to_string()</strong> or <strong>String::from()</strong> methods. ex: <code>‚ÄúHello‚Äù.to_string();</code>  <code>String::from(&quot;Hello&quot;);</code></p>\n</blockquote>\n<p>üí° In general, you should use <strong>String</strong> when you need <strong>ownership</strong>, and <strong><code>&amp;str</code></strong> when you just need to <strong>borrow a string</strong>.</p>\n<ul>\n<li><h2 id=\"functions\"><a href=\"#functions\" class=\"headerlink\" title=\"functions\"></a>functions</h2>As we discussed on functions section, <code>b</code> is a function pointer, to <code>plus_one()</code> in the below code.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn plus_one(a: i32) -&gt; i32 {\n    a + 1\n}\n\nlet b: fn(i32) -&gt; i32 = plus_one;\nlet c = b(5); //6\n</code></pre>\n"},{"title":"Operators","_content":"\n- ## Arithmetic Operators\n** + - * / %**\n\n```rust\nlet a = 5;\nlet b = a + 1; //6\nlet c = a - 1; //4\nlet d = a * 2; //10\nlet e = a / 2; // ‚≠êÔ∏è 2 not 2.5\nlet f = a % 2; //1\n\nlet g = 5.0 / 2.0; //2.5\n```\n\n> üí° Also **+** is used for **array and string concatenation**.\n\n\n- ## Comparison Operators\n== != < > <= >=\n\n```rust\nlet a = 1;\nlet b = 2;\n\nlet c = a == b; //false\nlet d = a != b; //true\nlet e = a < b; //true\nlet f = a > b; //false\nlet g = a <= a; //true\nlet h = a >= a; //true\n\n// üîé\nlet i = true > false; //true\nlet j = 'a' > 'A'; //true\n```\n\n\n- ## Logical Operators\n! && ||\n\n```rust\nlet a = true;\nlet b = false;\n\nlet c = !a; //false\nlet d = a && b; //false\nlet e = a || b; //true\n```\n\n> üîé On integer types,`!` inverts the individual bits in the two‚Äôs complement representation of the value.\n\n```rust\nlet a = !-2; //1\nlet b = !-1; //0\nlet c = !0; //-1\nlet d = !1; //-2\n```\n\n\n- ## Bitwise Operators\n& | ^ << >>\n\n```rust\nlet a = 1;\nlet b = 2;\n\nlet c = a & b;  //0  (01 && 10 -> 00)\nlet d = a | b;  //3  (01 || 10 -> 11)\nlet e = a ^ b;  //3  (01 != 10 -> 11)\nlet f = a << b; //4  (Add b number of 0s to the end of a -> '01'+'00' -> 100)\nlet g = a >> b; //0  (Remove b number of bits from the end of a -> oÃ∂1Ã∂ -> 0)\n```\n\n\n- ## Assignment and Compound Assignment Operators\n\nThe = operator is used to assign a name to a value or a function. Compound Assignment Operators are created by composing one of + - * / % & | ^ << >> operators with = operator.\n\n```rust\nlet mut a = 2;\n\na += 5; //2 + 5 = 7\na -= 2; //7 - 2 = 5\na *= 5; //5 * 5 = 25\na /= 2; //25 / 2 = 12 not 12.5\na %= 5; //12 % 5 = 2\n\na &= 2; //10 && 10 -> 10 -> 2\na |= 5; //010 || 101 -> 111 -> 7\na ^= 2; //111 != 010 -> 101 -> 5\na <<= 1; //'101'+'0' -> 1010 -> 10\na >>= 2; //101Ã∂0Ã∂ -> 10 -> 2\n```\n\n\n- ## Type Casting Operator\nas\n\n```rust\nlet a = 15;\nlet b = (a as f64) / 2.0; //7.5\n```\n\n\n- ## Borrowing and Dereference Operators\n& &mut *\n\nThe **& or &mut** operators are used for **borrowing** and ***** operator for **Dereferencing**.\n\n> üîé For more information, refer to [Ownership](c1.ownership.html), [Borrowing](c2.borrowing.html) & [Lifetimes](c3.lifetimes.html) sections.\n","source":"docs/a9.operators.md","raw":"title: Operators\n---\n\n- ## Arithmetic Operators\n** + - * / %**\n\n```rust\nlet a = 5;\nlet b = a + 1; //6\nlet c = a - 1; //4\nlet d = a * 2; //10\nlet e = a / 2; // ‚≠êÔ∏è 2 not 2.5\nlet f = a % 2; //1\n\nlet g = 5.0 / 2.0; //2.5\n```\n\n> üí° Also **+** is used for **array and string concatenation**.\n\n\n- ## Comparison Operators\n== != < > <= >=\n\n```rust\nlet a = 1;\nlet b = 2;\n\nlet c = a == b; //false\nlet d = a != b; //true\nlet e = a < b; //true\nlet f = a > b; //false\nlet g = a <= a; //true\nlet h = a >= a; //true\n\n// üîé\nlet i = true > false; //true\nlet j = 'a' > 'A'; //true\n```\n\n\n- ## Logical Operators\n! && ||\n\n```rust\nlet a = true;\nlet b = false;\n\nlet c = !a; //false\nlet d = a && b; //false\nlet e = a || b; //true\n```\n\n> üîé On integer types,`!` inverts the individual bits in the two‚Äôs complement representation of the value.\n\n```rust\nlet a = !-2; //1\nlet b = !-1; //0\nlet c = !0; //-1\nlet d = !1; //-2\n```\n\n\n- ## Bitwise Operators\n& | ^ << >>\n\n```rust\nlet a = 1;\nlet b = 2;\n\nlet c = a & b;  //0  (01 && 10 -> 00)\nlet d = a | b;  //3  (01 || 10 -> 11)\nlet e = a ^ b;  //3  (01 != 10 -> 11)\nlet f = a << b; //4  (Add b number of 0s to the end of a -> '01'+'00' -> 100)\nlet g = a >> b; //0  (Remove b number of bits from the end of a -> oÃ∂1Ã∂ -> 0)\n```\n\n\n- ## Assignment and Compound Assignment Operators\n\nThe = operator is used to assign a name to a value or a function. Compound Assignment Operators are created by composing one of + - * / % & | ^ << >> operators with = operator.\n\n```rust\nlet mut a = 2;\n\na += 5; //2 + 5 = 7\na -= 2; //7 - 2 = 5\na *= 5; //5 * 5 = 25\na /= 2; //25 / 2 = 12 not 12.5\na %= 5; //12 % 5 = 2\n\na &= 2; //10 && 10 -> 10 -> 2\na |= 5; //010 || 101 -> 111 -> 7\na ^= 2; //111 != 010 -> 101 -> 5\na <<= 1; //'101'+'0' -> 1010 -> 10\na >>= 2; //101Ã∂0Ã∂ -> 10 -> 2\n```\n\n\n- ## Type Casting Operator\nas\n\n```rust\nlet a = 15;\nlet b = (a as f64) / 2.0; //7.5\n```\n\n\n- ## Borrowing and Dereference Operators\n& &mut *\n\nThe **& or &mut** operators are used for **borrowing** and ***** operator for **Dereferencing**.\n\n> üîé For more information, refer to [Ownership](c1.ownership.html), [Borrowing](c2.borrowing.html) & [Lifetimes](c3.lifetimes.html) sections.\n","date":"2019-03-19T14:50:39.951Z","updated":"2019-03-19T14:50:39.951Z","path":"docs/a9.operators.html","comments":1,"layout":"page","_id":"cjtfwbizc000adwgppf617jvp","content":"<ul>\n<li><h2 id=\"Arithmetic-Operators\"><a href=\"#Arithmetic-Operators\" class=\"headerlink\" title=\"Arithmetic Operators\"></a>Arithmetic Operators</h2><strong> + - * / %</strong></li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = 5;\nlet b = a + 1; //6\nlet c = a - 1; //4\nlet d = a * 2; //10\nlet e = a / 2; // ‚≠êÔ∏è 2 not 2.5\nlet f = a % 2; //1\n\nlet g = 5.0 / 2.0; //2.5\n</code></pre>\n<blockquote>\n<p>üí° Also <strong>+</strong> is used for <strong>array and string concatenation</strong>.</p>\n</blockquote>\n<ul>\n<li><h2 id=\"Comparison-Operators\"><a href=\"#Comparison-Operators\" class=\"headerlink\" title=\"Comparison Operators\"></a>Comparison Operators</h2>== != &lt; &gt; &lt;= &gt;=</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = 1;\nlet b = 2;\n\nlet c = a == b; //false\nlet d = a != b; //true\nlet e = a &lt; b; //true\nlet f = a &gt; b; //false\nlet g = a &lt;= a; //true\nlet h = a &gt;= a; //true\n\n// üîé\nlet i = true &gt; false; //true\nlet j = &#39;a&#39; &gt; &#39;A&#39;; //true\n</code></pre>\n<ul>\n<li><h2 id=\"Logical-Operators\"><a href=\"#Logical-Operators\" class=\"headerlink\" title=\"Logical Operators\"></a>Logical Operators</h2>! &amp;&amp; ||</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = true;\nlet b = false;\n\nlet c = !a; //false\nlet d = a &amp;&amp; b; //false\nlet e = a || b; //true\n</code></pre>\n<blockquote>\n<p>üîé On integer types,<code>!</code> inverts the individual bits in the two‚Äôs complement representation of the value.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = !-2; //1\nlet b = !-1; //0\nlet c = !0; //-1\nlet d = !1; //-2\n</code></pre>\n<ul>\n<li><h2 id=\"Bitwise-Operators\"><a href=\"#Bitwise-Operators\" class=\"headerlink\" title=\"Bitwise Operators\"></a>Bitwise Operators</h2>&amp; | ^ &lt;&lt; &gt;&gt;</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = 1;\nlet b = 2;\n\nlet c = a &amp; b;  //0  (01 &amp;&amp; 10 -&gt; 00)\nlet d = a | b;  //3  (01 || 10 -&gt; 11)\nlet e = a ^ b;  //3  (01 != 10 -&gt; 11)\nlet f = a &lt;&lt; b; //4  (Add b number of 0s to the end of a -&gt; &#39;01&#39;+&#39;00&#39; -&gt; 100)\nlet g = a &gt;&gt; b; //0  (Remove b number of bits from the end of a -&gt; oÃ∂1Ã∂ -&gt; 0)\n</code></pre>\n<ul>\n<li><h2 id=\"Assignment-and-Compound-Assignment-Operators\"><a href=\"#Assignment-and-Compound-Assignment-Operators\" class=\"headerlink\" title=\"Assignment and Compound Assignment Operators\"></a>Assignment and Compound Assignment Operators</h2></li>\n</ul>\n<p>The = operator is used to assign a name to a value or a function. Compound Assignment Operators are created by composing one of + - * / % &amp; | ^ &lt;&lt; &gt;&gt; operators with = operator.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let mut a = 2;\n\na += 5; //2 + 5 = 7\na -= 2; //7 - 2 = 5\na *= 5; //5 * 5 = 25\na /= 2; //25 / 2 = 12 not 12.5\na %= 5; //12 % 5 = 2\n\na &amp;= 2; //10 &amp;&amp; 10 -&gt; 10 -&gt; 2\na |= 5; //010 || 101 -&gt; 111 -&gt; 7\na ^= 2; //111 != 010 -&gt; 101 -&gt; 5\na &lt;&lt;= 1; //&#39;101&#39;+&#39;0&#39; -&gt; 1010 -&gt; 10\na &gt;&gt;= 2; //101Ã∂0Ã∂ -&gt; 10 -&gt; 2\n</code></pre>\n<ul>\n<li><h2 id=\"Type-Casting-Operator\"><a href=\"#Type-Casting-Operator\" class=\"headerlink\" title=\"Type Casting Operator\"></a>Type Casting Operator</h2>as</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = 15;\nlet b = (a as f64) / 2.0; //7.5\n</code></pre>\n<ul>\n<li><h2 id=\"Borrowing-and-Dereference-Operators\"><a href=\"#Borrowing-and-Dereference-Operators\" class=\"headerlink\" title=\"Borrowing and Dereference Operators\"></a>Borrowing and Dereference Operators</h2>&amp; &amp;mut *</li>\n</ul>\n<p>The <strong>&amp; or &amp;mut</strong> operators are used for <strong>borrowing</strong> and <strong>*</strong> operator for <strong>Dereferencing</strong>.</p>\n<blockquote>\n<p>üîé For more information, refer to <a href=\"c1.ownership.html\">Ownership</a>, <a href=\"c2.borrowing.html\">Borrowing</a> &amp; <a href=\"c3.lifetimes.html\">Lifetimes</a> sections.</p>\n</blockquote>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<ul>\n<li><h2 id=\"Arithmetic-Operators\"><a href=\"#Arithmetic-Operators\" class=\"headerlink\" title=\"Arithmetic Operators\"></a>Arithmetic Operators</h2><strong> + - * / %</strong></li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = 5;\nlet b = a + 1; //6\nlet c = a - 1; //4\nlet d = a * 2; //10\nlet e = a / 2; // ‚≠êÔ∏è 2 not 2.5\nlet f = a % 2; //1\n\nlet g = 5.0 / 2.0; //2.5\n</code></pre>\n<blockquote>\n<p>üí° Also <strong>+</strong> is used for <strong>array and string concatenation</strong>.</p>\n</blockquote>\n<ul>\n<li><h2 id=\"Comparison-Operators\"><a href=\"#Comparison-Operators\" class=\"headerlink\" title=\"Comparison Operators\"></a>Comparison Operators</h2>== != &lt; &gt; &lt;= &gt;=</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = 1;\nlet b = 2;\n\nlet c = a == b; //false\nlet d = a != b; //true\nlet e = a &lt; b; //true\nlet f = a &gt; b; //false\nlet g = a &lt;= a; //true\nlet h = a &gt;= a; //true\n\n// üîé\nlet i = true &gt; false; //true\nlet j = &#39;a&#39; &gt; &#39;A&#39;; //true\n</code></pre>\n<ul>\n<li><h2 id=\"Logical-Operators\"><a href=\"#Logical-Operators\" class=\"headerlink\" title=\"Logical Operators\"></a>Logical Operators</h2>! &amp;&amp; ||</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = true;\nlet b = false;\n\nlet c = !a; //false\nlet d = a &amp;&amp; b; //false\nlet e = a || b; //true\n</code></pre>\n<blockquote>\n<p>üîé On integer types,<code>!</code> inverts the individual bits in the two‚Äôs complement representation of the value.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = !-2; //1\nlet b = !-1; //0\nlet c = !0; //-1\nlet d = !1; //-2\n</code></pre>\n<ul>\n<li><h2 id=\"Bitwise-Operators\"><a href=\"#Bitwise-Operators\" class=\"headerlink\" title=\"Bitwise Operators\"></a>Bitwise Operators</h2>&amp; | ^ &lt;&lt; &gt;&gt;</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = 1;\nlet b = 2;\n\nlet c = a &amp; b;  //0  (01 &amp;&amp; 10 -&gt; 00)\nlet d = a | b;  //3  (01 || 10 -&gt; 11)\nlet e = a ^ b;  //3  (01 != 10 -&gt; 11)\nlet f = a &lt;&lt; b; //4  (Add b number of 0s to the end of a -&gt; &#39;01&#39;+&#39;00&#39; -&gt; 100)\nlet g = a &gt;&gt; b; //0  (Remove b number of bits from the end of a -&gt; oÃ∂1Ã∂ -&gt; 0)\n</code></pre>\n<ul>\n<li><h2 id=\"Assignment-and-Compound-Assignment-Operators\"><a href=\"#Assignment-and-Compound-Assignment-Operators\" class=\"headerlink\" title=\"Assignment and Compound Assignment Operators\"></a>Assignment and Compound Assignment Operators</h2></li>\n</ul>\n<p>The = operator is used to assign a name to a value or a function. Compound Assignment Operators are created by composing one of + - * / % &amp; | ^ &lt;&lt; &gt;&gt; operators with = operator.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let mut a = 2;\n\na += 5; //2 + 5 = 7\na -= 2; //7 - 2 = 5\na *= 5; //5 * 5 = 25\na /= 2; //25 / 2 = 12 not 12.5\na %= 5; //12 % 5 = 2\n\na &amp;= 2; //10 &amp;&amp; 10 -&gt; 10 -&gt; 2\na |= 5; //010 || 101 -&gt; 111 -&gt; 7\na ^= 2; //111 != 010 -&gt; 101 -&gt; 5\na &lt;&lt;= 1; //&#39;101&#39;+&#39;0&#39; -&gt; 1010 -&gt; 10\na &gt;&gt;= 2; //101Ã∂0Ã∂ -&gt; 10 -&gt; 2\n</code></pre>\n<ul>\n<li><h2 id=\"Type-Casting-Operator\"><a href=\"#Type-Casting-Operator\" class=\"headerlink\" title=\"Type Casting Operator\"></a>Type Casting Operator</h2>as</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = 15;\nlet b = (a as f64) / 2.0; //7.5\n</code></pre>\n<ul>\n<li><h2 id=\"Borrowing-and-Dereference-Operators\"><a href=\"#Borrowing-and-Dereference-Operators\" class=\"headerlink\" title=\"Borrowing and Dereference Operators\"></a>Borrowing and Dereference Operators</h2>&amp; &amp;mut *</li>\n</ul>\n<p>The <strong>&amp; or &amp;mut</strong> operators are used for <strong>borrowing</strong> and <strong>*</strong> operator for <strong>Dereferencing</strong>.</p>\n<blockquote>\n<p>üîé For more information, refer to <a href=\"c1.ownership.html\">Ownership</a>, <a href=\"c2.borrowing.html\">Borrowing</a> &amp; <a href=\"c3.lifetimes.html\">Lifetimes</a> sections.</p>\n</blockquote>\n"},{"title":"Vectors","_content":"\nIf you remember, the array is a fixed-size list of elements, of the same data type. Even with mut, its element count cannot be changed. A vector is kind of **a re-sizable array** but **all elements must be in the same type**.\n\n‚≠êÔ∏è It‚Äôs a generic type, written as **`Vec<T>`**¬†. T can have any type, ex. The type of a Vec of i32s is `Vec<i32>`. Also, Vectors always allocate their data in a dynamically allocated heap.\n\n### Create empty vector\n\n```rust\nlet mut a = Vec::new(); //1.With new() keyword\nlet mut b = vec![]; //2.Using the vec! macro\n```\n\n### Create with data types\n\n```rust\nlet mut a2: Vec<i32> = Vec::new();\nlet mut b2: Vec<i32> = vec![];\nlet mut b3 = vec![1i32, 2, 3];//Sufixing 1st value with data type\n\nlet mut b4 = vec![1, 2, 3];\nlet mut b5: Vec<i32> = vec![1, 2, 3];\nlet mut b6  = vec![1i32, 2, 3];\nlet mut b7 = vec![0; 10]; //Ten zeroes\n```\n\n### Access and change data\n\n```rust\n//Accessing and changing existing data\nlet mut c = vec![5, 4, 3, 2, 1];\nc[0] = 1;\nc[1] = 2;\n//c[6] = 2; Cannot assign values this way, index out of bounds\nprintln!(\"{:?}\", c); //[1, 2, 3, 2, 1]\n\n//push and pop\nlet mut d: Vec<i32> = Vec::new();\nd.push(1); //[1] : Add an element to the end\nd.push(2); //[1, 2]\nd.pop(); //[1] : : Remove an element from the end\n\n\n// üîé Capacity and reallocation\nlet mut e: Vec<i32> = Vec::with_capacity(10);\nprintln!(\"Length: {}, Capacity : {}\", e.len(), e.capacity()); //Length: 0, Capacity : 10\n\n// These are all done without reallocating...\nfor i in 0..10 {\n    e.push(i);\n}\n// ...but this may make the vector reallocate\ne.push(11);\n```\n\n‚≠êÔ∏è Mainly a vector represent 3 things,\n- A **pointer** to the data\n- **No of elements** currently have(**length**)\n- **Capacity** (Amount of space allocated for any future elements). \n\nIf the length of a vector exceeds its capacity, its capacity will be increased automatically. But its elements will be reallocated(which can be slow). So always use Vec::**with_capacity** whenever it‚Äôs possible.\n\n> üí° The **String** data type is a UTF-8 encoded vector. But you can not index into a String because of encoding.\n\n\nüíØ Vectors can be used with iterators in three ways,\n\n```rust\nlet mut v = vec![1, 2, 3, 4, 5];\n\nfor i in &v {\n    println!(\"A reference to {}\", i);\n}\n\nfor i in &mut v {\n    println!(\"A mutable reference to {}\", i);\n}\n\nfor i in v {\n    println!(\"Take ownership of the vector and its element {}\", i);\n}\n```\n","source":"docs/b1.vectors.md","raw":"title: Vectors\n---\n\nIf you remember, the array is a fixed-size list of elements, of the same data type. Even with mut, its element count cannot be changed. A vector is kind of **a re-sizable array** but **all elements must be in the same type**.\n\n‚≠êÔ∏è It‚Äôs a generic type, written as **`Vec<T>`**¬†. T can have any type, ex. The type of a Vec of i32s is `Vec<i32>`. Also, Vectors always allocate their data in a dynamically allocated heap.\n\n### Create empty vector\n\n```rust\nlet mut a = Vec::new(); //1.With new() keyword\nlet mut b = vec![]; //2.Using the vec! macro\n```\n\n### Create with data types\n\n```rust\nlet mut a2: Vec<i32> = Vec::new();\nlet mut b2: Vec<i32> = vec![];\nlet mut b3 = vec![1i32, 2, 3];//Sufixing 1st value with data type\n\nlet mut b4 = vec![1, 2, 3];\nlet mut b5: Vec<i32> = vec![1, 2, 3];\nlet mut b6  = vec![1i32, 2, 3];\nlet mut b7 = vec![0; 10]; //Ten zeroes\n```\n\n### Access and change data\n\n```rust\n//Accessing and changing existing data\nlet mut c = vec![5, 4, 3, 2, 1];\nc[0] = 1;\nc[1] = 2;\n//c[6] = 2; Cannot assign values this way, index out of bounds\nprintln!(\"{:?}\", c); //[1, 2, 3, 2, 1]\n\n//push and pop\nlet mut d: Vec<i32> = Vec::new();\nd.push(1); //[1] : Add an element to the end\nd.push(2); //[1, 2]\nd.pop(); //[1] : : Remove an element from the end\n\n\n// üîé Capacity and reallocation\nlet mut e: Vec<i32> = Vec::with_capacity(10);\nprintln!(\"Length: {}, Capacity : {}\", e.len(), e.capacity()); //Length: 0, Capacity : 10\n\n// These are all done without reallocating...\nfor i in 0..10 {\n    e.push(i);\n}\n// ...but this may make the vector reallocate\ne.push(11);\n```\n\n‚≠êÔ∏è Mainly a vector represent 3 things,\n- A **pointer** to the data\n- **No of elements** currently have(**length**)\n- **Capacity** (Amount of space allocated for any future elements). \n\nIf the length of a vector exceeds its capacity, its capacity will be increased automatically. But its elements will be reallocated(which can be slow). So always use Vec::**with_capacity** whenever it‚Äôs possible.\n\n> üí° The **String** data type is a UTF-8 encoded vector. But you can not index into a String because of encoding.\n\n\nüíØ Vectors can be used with iterators in three ways,\n\n```rust\nlet mut v = vec![1, 2, 3, 4, 5];\n\nfor i in &v {\n    println!(\"A reference to {}\", i);\n}\n\nfor i in &mut v {\n    println!(\"A mutable reference to {}\", i);\n}\n\nfor i in v {\n    println!(\"Take ownership of the vector and its element {}\", i);\n}\n```\n","date":"2019-03-19T14:50:39.951Z","updated":"2019-03-19T14:50:39.951Z","path":"docs/b1.vectors.html","comments":1,"layout":"page","_id":"cjtfwbizd000bdwgpouecj1ye","content":"<p>If you remember, the array is a fixed-size list of elements, of the same data type. Even with mut, its element count cannot be changed. A vector is kind of <strong>a re-sizable array</strong> but <strong>all elements must be in the same type</strong>.</p>\n<p>‚≠êÔ∏è It‚Äôs a generic type, written as <strong><code>Vec&lt;T&gt;</code></strong> . T can have any type, ex. The type of a Vec of i32s is <code>Vec&lt;i32&gt;</code>. Also, Vectors always allocate their data in a dynamically allocated heap.</p>\n<h3 id=\"Create-empty-vector\"><a href=\"#Create-empty-vector\" class=\"headerlink\" title=\"Create empty vector\"></a>Create empty vector</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let mut a = Vec::new(); //1.With new() keyword\nlet mut b = vec![]; //2.Using the vec! macro\n</code></pre>\n<h3 id=\"Create-with-data-types\"><a href=\"#Create-with-data-types\" class=\"headerlink\" title=\"Create with data types\"></a>Create with data types</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let mut a2: Vec&lt;i32&gt; = Vec::new();\nlet mut b2: Vec&lt;i32&gt; = vec![];\nlet mut b3 = vec![1i32, 2, 3];//Sufixing 1st value with data type\n\nlet mut b4 = vec![1, 2, 3];\nlet mut b5: Vec&lt;i32&gt; = vec![1, 2, 3];\nlet mut b6  = vec![1i32, 2, 3];\nlet mut b7 = vec![0; 10]; //Ten zeroes\n</code></pre>\n<h3 id=\"Access-and-change-data\"><a href=\"#Access-and-change-data\" class=\"headerlink\" title=\"Access and change data\"></a>Access and change data</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">//Accessing and changing existing data\nlet mut c = vec![5, 4, 3, 2, 1];\nc[0] = 1;\nc[1] = 2;\n//c[6] = 2; Cannot assign values this way, index out of bounds\nprintln!(&quot;{:?}&quot;, c); //[1, 2, 3, 2, 1]\n\n//push and pop\nlet mut d: Vec&lt;i32&gt; = Vec::new();\nd.push(1); //[1] : Add an element to the end\nd.push(2); //[1, 2]\nd.pop(); //[1] : : Remove an element from the end\n\n\n// üîé Capacity and reallocation\nlet mut e: Vec&lt;i32&gt; = Vec::with_capacity(10);\nprintln!(&quot;Length: {}, Capacity : {}&quot;, e.len(), e.capacity()); //Length: 0, Capacity : 10\n\n// These are all done without reallocating...\nfor i in 0..10 {\n    e.push(i);\n}\n// ...but this may make the vector reallocate\ne.push(11);\n</code></pre>\n<p>‚≠êÔ∏è Mainly a vector represent 3 things,</p>\n<ul>\n<li>A <strong>pointer</strong> to the data</li>\n<li><strong>No of elements</strong> currently have(<strong>length</strong>)</li>\n<li><strong>Capacity</strong> (Amount of space allocated for any future elements). </li>\n</ul>\n<p>If the length of a vector exceeds its capacity, its capacity will be increased automatically. But its elements will be reallocated(which can be slow). So always use Vec::<strong>with_capacity</strong> whenever it‚Äôs possible.</p>\n<blockquote>\n<p>üí° The <strong>String</strong> data type is a UTF-8 encoded vector. But you can not index into a String because of encoding.</p>\n</blockquote>\n<p>üíØ Vectors can be used with iterators in three ways,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let mut v = vec![1, 2, 3, 4, 5];\n\nfor i in &amp;v {\n    println!(&quot;A reference to {}&quot;, i);\n}\n\nfor i in &amp;mut v {\n    println!(&quot;A mutable reference to {}&quot;, i);\n}\n\nfor i in v {\n    println!(&quot;Take ownership of the vector and its element {}&quot;, i);\n}\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<p>If you remember, the array is a fixed-size list of elements, of the same data type. Even with mut, its element count cannot be changed. A vector is kind of <strong>a re-sizable array</strong> but <strong>all elements must be in the same type</strong>.</p>\n<p>‚≠êÔ∏è It‚Äôs a generic type, written as <strong><code>Vec&lt;T&gt;</code></strong> . T can have any type, ex. The type of a Vec of i32s is <code>Vec&lt;i32&gt;</code>. Also, Vectors always allocate their data in a dynamically allocated heap.</p>\n<h3 id=\"Create-empty-vector\"><a href=\"#Create-empty-vector\" class=\"headerlink\" title=\"Create empty vector\"></a>Create empty vector</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let mut a = Vec::new(); //1.With new() keyword\nlet mut b = vec![]; //2.Using the vec! macro\n</code></pre>\n<h3 id=\"Create-with-data-types\"><a href=\"#Create-with-data-types\" class=\"headerlink\" title=\"Create with data types\"></a>Create with data types</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let mut a2: Vec&lt;i32&gt; = Vec::new();\nlet mut b2: Vec&lt;i32&gt; = vec![];\nlet mut b3 = vec![1i32, 2, 3];//Sufixing 1st value with data type\n\nlet mut b4 = vec![1, 2, 3];\nlet mut b5: Vec&lt;i32&gt; = vec![1, 2, 3];\nlet mut b6  = vec![1i32, 2, 3];\nlet mut b7 = vec![0; 10]; //Ten zeroes\n</code></pre>\n<h3 id=\"Access-and-change-data\"><a href=\"#Access-and-change-data\" class=\"headerlink\" title=\"Access and change data\"></a>Access and change data</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">//Accessing and changing existing data\nlet mut c = vec![5, 4, 3, 2, 1];\nc[0] = 1;\nc[1] = 2;\n//c[6] = 2; Cannot assign values this way, index out of bounds\nprintln!(&quot;{:?}&quot;, c); //[1, 2, 3, 2, 1]\n\n//push and pop\nlet mut d: Vec&lt;i32&gt; = Vec::new();\nd.push(1); //[1] : Add an element to the end\nd.push(2); //[1, 2]\nd.pop(); //[1] : : Remove an element from the end\n\n\n// üîé Capacity and reallocation\nlet mut e: Vec&lt;i32&gt; = Vec::with_capacity(10);\nprintln!(&quot;Length: {}, Capacity : {}&quot;, e.len(), e.capacity()); //Length: 0, Capacity : 10\n\n// These are all done without reallocating...\nfor i in 0..10 {\n    e.push(i);\n}\n// ...but this may make the vector reallocate\ne.push(11);\n</code></pre>\n<p>‚≠êÔ∏è Mainly a vector represent 3 things,</p>\n<ul>\n<li>A <strong>pointer</strong> to the data</li>\n<li><strong>No of elements</strong> currently have(<strong>length</strong>)</li>\n<li><strong>Capacity</strong> (Amount of space allocated for any future elements). </li>\n</ul>\n<p>If the length of a vector exceeds its capacity, its capacity will be increased automatically. But its elements will be reallocated(which can be slow). So always use Vec::<strong>with_capacity</strong> whenever it‚Äôs possible.</p>\n<blockquote>\n<p>üí° The <strong>String</strong> data type is a UTF-8 encoded vector. But you can not index into a String because of encoding.</p>\n</blockquote>\n<p>üíØ Vectors can be used with iterators in three ways,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let mut v = vec![1, 2, 3, 4, 5];\n\nfor i in &amp;v {\n    println!(&quot;A reference to {}&quot;, i);\n}\n\nfor i in &amp;mut v {\n    println!(&quot;A mutable reference to {}&quot;, i);\n}\n\nfor i in v {\n    println!(&quot;Take ownership of the vector and its element {}&quot;, i);\n}\n</code></pre>\n"},{"title":"Structs","_content":"\n‚≠êÔ∏è Structs are used to **encapsulate related properties** into one unified data type.\n\nüí° By convention, the name of the struct starts with a capital letter and follows **CamelCase**.\n\nThere are 3 variants of structs,  \n1. **C-like structs**\n  * One or more comma-separated name:value pairs\n  * Brace-enclosed list\n  * Similar to classes \\(without its methods\\) in OOP languages\n  * Because fields have names, we can access them through dot notation\n\n2. **Tuple structs**\n  * One or more comma-separated values\n  * A parenthesized list like tuples\n  * Looks like a named tuples\n\n3. **Unit structs**\n  * A struct with no members at all\n  * It defines a new type but it resembles an empty tuple, \\(\\)\n  * Rarely in use, useful with generics\n\n‚≠êÔ∏è When regarding OOP in Rust, attributes and methods are placed separately on **structs** and **traits**. Structs contain only attributes, traits contain only methods. They are getting connected via **impls**.\n\n>üí°More complex examples can be found on [impls & traits](b5.impls_and_traits.html), [lifetimes](c3.lifetimes.html) and [modules](d3.modules.html) sections.\n\n## C-like structs\n\n```rust\n// Struct Declaration\nstruct Color {\n    red: u8,\n    green: u8,\n    blue: u8\n}\n\nfn main() {\n  // Creating an instance\n  let black = Color {red: 0, green: 0, blue: 0};\n\n  // Accessing its fields using dot notation\n  println!(\"Black = rgb({}, {}, {})\", black.red, black.green, black.blue); //Black = rgb(0, 0, 0)\n\n  // Structs are immutable by default, use `mut` to make it mutable but doesn't support field level mutability\n  let mut link_color = Color {red: 0,green: 0,blue: 255};\n  link_color.blue = 238;\n  println!(\"Link Color = rgb({}, {}, {})\", link_color.red, link_color.green, link_color.blue); //Link Color = rgb(0, 0, 238)\n\n  // Copy elements from another instance\n  let blue = Color {blue: 255, .. link_color};\n  println!(\"Blue = rgb({}, {}, {})\", blue.red, blue.green, blue.blue); //Blue = rgb(0, 0, 255)\n\n  // Destructure the instance using a `let` binding, this will not destruct blue instance\n  let Color {red: r, green: g, blue: b} = blue;\n  println!(\"Blue = rgb({}, {}, {})\", r, g, b); //Blue = rgb(0, 0, 255)\n\n  // Creating an instance via functions & accessing its fields\n  let midnightblue = get_midnightblue_color();\n  println!(\"Midnight Blue = rgb({}, {}, {})\", midnightblue.red, midnightblue.green, midnightblue.blue); //Midnight Blue = rgb(25, 25, 112)\n\n  // Destructure the instance using a `let` binding\n  let Color {red: r, green: g, blue: b} = get_midnightblue_color();\n  println!(\"Midnight Blue = rgb({}, {}, {})\", r, g, b); //Midnight Blue = rgb(25, 25, 112)\n}\n\nfn get_midnightblue_color() -> Color {\n    Color {red: 25, green: 25, blue: 112}\n}\n```\n\n## Tuple structs\n\n‚≠êÔ∏è When a tuple struct has only one element, we call it **newtype pattern**. Because it helps to create a new type.\n\n```rust\nstruct Color(u8, u8, u8);\nstruct Kilometers(i32);\n\nfn main() {\n  // Creating an instance\n  let black = Color(0, 0, 0);\n\n  // Destructure the instance using a `let` binding, this will not destruct black instance\n  let Color(r, g, b) = black;\n  println!(\"Black = rgb({}, {}, {})\", r, g, b); //black = rgb(0, 0, 0);\n\n  // Newtype pattern\n  let distance = Kilometers(20);\n  // Destructure the instance using a `let` binding\n  let Kilometers(distance_in_km) = distance;\n  println!(\"The distance: {} km\", distance_in_km); //The distance: 20 km\n}\n```\n\n## Unit structs\n\nThis is rarely useful on its own. But in combination with other features, it can become useful.\n\n> [üìñ](https://doc.rust-lang.org/book/first-edition/structs.html) ex: A library may ask you to create a structure that implements a certain trait to handle events. If you don‚Äôt have any data you need to store in the structure, you can create a unit-like struct.\n\n```rust\nstruct Electron;\n\nfn main() {\n  let x = Electron;\n}\n```\n","source":"docs/b2.structs.md","raw":"title: Structs\n---\n\n‚≠êÔ∏è Structs are used to **encapsulate related properties** into one unified data type.\n\nüí° By convention, the name of the struct starts with a capital letter and follows **CamelCase**.\n\nThere are 3 variants of structs,  \n1. **C-like structs**\n  * One or more comma-separated name:value pairs\n  * Brace-enclosed list\n  * Similar to classes \\(without its methods\\) in OOP languages\n  * Because fields have names, we can access them through dot notation\n\n2. **Tuple structs**\n  * One or more comma-separated values\n  * A parenthesized list like tuples\n  * Looks like a named tuples\n\n3. **Unit structs**\n  * A struct with no members at all\n  * It defines a new type but it resembles an empty tuple, \\(\\)\n  * Rarely in use, useful with generics\n\n‚≠êÔ∏è When regarding OOP in Rust, attributes and methods are placed separately on **structs** and **traits**. Structs contain only attributes, traits contain only methods. They are getting connected via **impls**.\n\n>üí°More complex examples can be found on [impls & traits](b5.impls_and_traits.html), [lifetimes](c3.lifetimes.html) and [modules](d3.modules.html) sections.\n\n## C-like structs\n\n```rust\n// Struct Declaration\nstruct Color {\n    red: u8,\n    green: u8,\n    blue: u8\n}\n\nfn main() {\n  // Creating an instance\n  let black = Color {red: 0, green: 0, blue: 0};\n\n  // Accessing its fields using dot notation\n  println!(\"Black = rgb({}, {}, {})\", black.red, black.green, black.blue); //Black = rgb(0, 0, 0)\n\n  // Structs are immutable by default, use `mut` to make it mutable but doesn't support field level mutability\n  let mut link_color = Color {red: 0,green: 0,blue: 255};\n  link_color.blue = 238;\n  println!(\"Link Color = rgb({}, {}, {})\", link_color.red, link_color.green, link_color.blue); //Link Color = rgb(0, 0, 238)\n\n  // Copy elements from another instance\n  let blue = Color {blue: 255, .. link_color};\n  println!(\"Blue = rgb({}, {}, {})\", blue.red, blue.green, blue.blue); //Blue = rgb(0, 0, 255)\n\n  // Destructure the instance using a `let` binding, this will not destruct blue instance\n  let Color {red: r, green: g, blue: b} = blue;\n  println!(\"Blue = rgb({}, {}, {})\", r, g, b); //Blue = rgb(0, 0, 255)\n\n  // Creating an instance via functions & accessing its fields\n  let midnightblue = get_midnightblue_color();\n  println!(\"Midnight Blue = rgb({}, {}, {})\", midnightblue.red, midnightblue.green, midnightblue.blue); //Midnight Blue = rgb(25, 25, 112)\n\n  // Destructure the instance using a `let` binding\n  let Color {red: r, green: g, blue: b} = get_midnightblue_color();\n  println!(\"Midnight Blue = rgb({}, {}, {})\", r, g, b); //Midnight Blue = rgb(25, 25, 112)\n}\n\nfn get_midnightblue_color() -> Color {\n    Color {red: 25, green: 25, blue: 112}\n}\n```\n\n## Tuple structs\n\n‚≠êÔ∏è When a tuple struct has only one element, we call it **newtype pattern**. Because it helps to create a new type.\n\n```rust\nstruct Color(u8, u8, u8);\nstruct Kilometers(i32);\n\nfn main() {\n  // Creating an instance\n  let black = Color(0, 0, 0);\n\n  // Destructure the instance using a `let` binding, this will not destruct black instance\n  let Color(r, g, b) = black;\n  println!(\"Black = rgb({}, {}, {})\", r, g, b); //black = rgb(0, 0, 0);\n\n  // Newtype pattern\n  let distance = Kilometers(20);\n  // Destructure the instance using a `let` binding\n  let Kilometers(distance_in_km) = distance;\n  println!(\"The distance: {} km\", distance_in_km); //The distance: 20 km\n}\n```\n\n## Unit structs\n\nThis is rarely useful on its own. But in combination with other features, it can become useful.\n\n> [üìñ](https://doc.rust-lang.org/book/first-edition/structs.html) ex: A library may ask you to create a structure that implements a certain trait to handle events. If you don‚Äôt have any data you need to store in the structure, you can create a unit-like struct.\n\n```rust\nstruct Electron;\n\nfn main() {\n  let x = Electron;\n}\n```\n","date":"2019-03-19T14:50:39.952Z","updated":"2019-03-19T14:50:39.952Z","path":"docs/b2.structs.html","comments":1,"layout":"page","_id":"cjtfwbizf000cdwgpzeihnjcl","content":"<p>‚≠êÔ∏è Structs are used to <strong>encapsulate related properties</strong> into one unified data type.</p>\n<p>üí° By convention, the name of the struct starts with a capital letter and follows <strong>CamelCase</strong>.</p>\n<p>There are 3 variants of structs,  </p>\n<ol>\n<li><p><strong>C-like structs</strong></p>\n<ul>\n<li>One or more comma-separated name:value pairs</li>\n<li>Brace-enclosed list</li>\n<li>Similar to classes (without its methods) in OOP languages</li>\n<li>Because fields have names, we can access them through dot notation</li>\n</ul>\n</li>\n<li><p><strong>Tuple structs</strong></p>\n<ul>\n<li>One or more comma-separated values</li>\n<li>A parenthesized list like tuples</li>\n<li>Looks like a named tuples</li>\n</ul>\n</li>\n<li><p><strong>Unit structs</strong></p>\n<ul>\n<li>A struct with no members at all</li>\n<li>It defines a new type but it resembles an empty tuple, ()</li>\n<li>Rarely in use, useful with generics</li>\n</ul>\n</li>\n</ol>\n<p>‚≠êÔ∏è When regarding OOP in Rust, attributes and methods are placed separately on <strong>structs</strong> and <strong>traits</strong>. Structs contain only attributes, traits contain only methods. They are getting connected via <strong>impls</strong>.</p>\n<blockquote>\n<p>üí°More complex examples can be found on <a href=\"b5.impls_and_traits.html\">impls &amp; traits</a>, <a href=\"c3.lifetimes.html\">lifetimes</a> and <a href=\"d3.modules.html\">modules</a> sections.</p>\n</blockquote>\n<h2 id=\"C-like-structs\"><a href=\"#C-like-structs\" class=\"headerlink\" title=\"C-like structs\"></a>C-like structs</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Struct Declaration\nstruct Color {\n    red: u8,\n    green: u8,\n    blue: u8\n}\n\nfn main() {\n  // Creating an instance\n  let black = Color {red: 0, green: 0, blue: 0};\n\n  // Accessing its fields using dot notation\n  println!(&quot;Black = rgb({}, {}, {})&quot;, black.red, black.green, black.blue); //Black = rgb(0, 0, 0)\n\n  // Structs are immutable by default, use `mut` to make it mutable but doesn&#39;t support field level mutability\n  let mut link_color = Color {red: 0,green: 0,blue: 255};\n  link_color.blue = 238;\n  println!(&quot;Link Color = rgb({}, {}, {})&quot;, link_color.red, link_color.green, link_color.blue); //Link Color = rgb(0, 0, 238)\n\n  // Copy elements from another instance\n  let blue = Color {blue: 255, .. link_color};\n  println!(&quot;Blue = rgb({}, {}, {})&quot;, blue.red, blue.green, blue.blue); //Blue = rgb(0, 0, 255)\n\n  // Destructure the instance using a `let` binding, this will not destruct blue instance\n  let Color {red: r, green: g, blue: b} = blue;\n  println!(&quot;Blue = rgb({}, {}, {})&quot;, r, g, b); //Blue = rgb(0, 0, 255)\n\n  // Creating an instance via functions &amp; accessing its fields\n  let midnightblue = get_midnightblue_color();\n  println!(&quot;Midnight Blue = rgb({}, {}, {})&quot;, midnightblue.red, midnightblue.green, midnightblue.blue); //Midnight Blue = rgb(25, 25, 112)\n\n  // Destructure the instance using a `let` binding\n  let Color {red: r, green: g, blue: b} = get_midnightblue_color();\n  println!(&quot;Midnight Blue = rgb({}, {}, {})&quot;, r, g, b); //Midnight Blue = rgb(25, 25, 112)\n}\n\nfn get_midnightblue_color() -&gt; Color {\n    Color {red: 25, green: 25, blue: 112}\n}\n</code></pre>\n<h2 id=\"Tuple-structs\"><a href=\"#Tuple-structs\" class=\"headerlink\" title=\"Tuple structs\"></a>Tuple structs</h2><p>‚≠êÔ∏è When a tuple struct has only one element, we call it <strong>newtype pattern</strong>. Because it helps to create a new type.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Color(u8, u8, u8);\nstruct Kilometers(i32);\n\nfn main() {\n  // Creating an instance\n  let black = Color(0, 0, 0);\n\n  // Destructure the instance using a `let` binding, this will not destruct black instance\n  let Color(r, g, b) = black;\n  println!(&quot;Black = rgb({}, {}, {})&quot;, r, g, b); //black = rgb(0, 0, 0);\n\n  // Newtype pattern\n  let distance = Kilometers(20);\n  // Destructure the instance using a `let` binding\n  let Kilometers(distance_in_km) = distance;\n  println!(&quot;The distance: {} km&quot;, distance_in_km); //The distance: 20 km\n}\n</code></pre>\n<h2 id=\"Unit-structs\"><a href=\"#Unit-structs\" class=\"headerlink\" title=\"Unit structs\"></a>Unit structs</h2><p>This is rarely useful on its own. But in combination with other features, it can become useful.</p>\n<blockquote>\n<p><a href=\"https://doc.rust-lang.org/book/first-edition/structs.html\" target=\"_blank\" rel=\"noopener\">üìñ</a> ex: A library may ask you to create a structure that implements a certain trait to handle events. If you don‚Äôt have any data you need to store in the structure, you can create a unit-like struct.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Electron;\n\nfn main() {\n  let x = Electron;\n}\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<p>‚≠êÔ∏è Structs are used to <strong>encapsulate related properties</strong> into one unified data type.</p>\n<p>üí° By convention, the name of the struct starts with a capital letter and follows <strong>CamelCase</strong>.</p>\n<p>There are 3 variants of structs,  </p>\n<ol>\n<li><p><strong>C-like structs</strong></p>\n<ul>\n<li>One or more comma-separated name:value pairs</li>\n<li>Brace-enclosed list</li>\n<li>Similar to classes (without its methods) in OOP languages</li>\n<li>Because fields have names, we can access them through dot notation</li>\n</ul>\n</li>\n<li><p><strong>Tuple structs</strong></p>\n<ul>\n<li>One or more comma-separated values</li>\n<li>A parenthesized list like tuples</li>\n<li>Looks like a named tuples</li>\n</ul>\n</li>\n<li><p><strong>Unit structs</strong></p>\n<ul>\n<li>A struct with no members at all</li>\n<li>It defines a new type but it resembles an empty tuple, ()</li>\n<li>Rarely in use, useful with generics</li>\n</ul>\n</li>\n</ol>\n<p>‚≠êÔ∏è When regarding OOP in Rust, attributes and methods are placed separately on <strong>structs</strong> and <strong>traits</strong>. Structs contain only attributes, traits contain only methods. They are getting connected via <strong>impls</strong>.</p>\n<blockquote>\n<p>üí°More complex examples can be found on <a href=\"b5.impls_and_traits.html\">impls &amp; traits</a>, <a href=\"c3.lifetimes.html\">lifetimes</a> and <a href=\"d3.modules.html\">modules</a> sections.</p>\n</blockquote>\n<h2 id=\"C-like-structs\"><a href=\"#C-like-structs\" class=\"headerlink\" title=\"C-like structs\"></a>C-like structs</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Struct Declaration\nstruct Color {\n    red: u8,\n    green: u8,\n    blue: u8\n}\n\nfn main() {\n  // Creating an instance\n  let black = Color {red: 0, green: 0, blue: 0};\n\n  // Accessing its fields using dot notation\n  println!(&quot;Black = rgb({}, {}, {})&quot;, black.red, black.green, black.blue); //Black = rgb(0, 0, 0)\n\n  // Structs are immutable by default, use `mut` to make it mutable but doesn&#39;t support field level mutability\n  let mut link_color = Color {red: 0,green: 0,blue: 255};\n  link_color.blue = 238;\n  println!(&quot;Link Color = rgb({}, {}, {})&quot;, link_color.red, link_color.green, link_color.blue); //Link Color = rgb(0, 0, 238)\n\n  // Copy elements from another instance\n  let blue = Color {blue: 255, .. link_color};\n  println!(&quot;Blue = rgb({}, {}, {})&quot;, blue.red, blue.green, blue.blue); //Blue = rgb(0, 0, 255)\n\n  // Destructure the instance using a `let` binding, this will not destruct blue instance\n  let Color {red: r, green: g, blue: b} = blue;\n  println!(&quot;Blue = rgb({}, {}, {})&quot;, r, g, b); //Blue = rgb(0, 0, 255)\n\n  // Creating an instance via functions &amp; accessing its fields\n  let midnightblue = get_midnightblue_color();\n  println!(&quot;Midnight Blue = rgb({}, {}, {})&quot;, midnightblue.red, midnightblue.green, midnightblue.blue); //Midnight Blue = rgb(25, 25, 112)\n\n  // Destructure the instance using a `let` binding\n  let Color {red: r, green: g, blue: b} = get_midnightblue_color();\n  println!(&quot;Midnight Blue = rgb({}, {}, {})&quot;, r, g, b); //Midnight Blue = rgb(25, 25, 112)\n}\n\nfn get_midnightblue_color() -&gt; Color {\n    Color {red: 25, green: 25, blue: 112}\n}\n</code></pre>\n<h2 id=\"Tuple-structs\"><a href=\"#Tuple-structs\" class=\"headerlink\" title=\"Tuple structs\"></a>Tuple structs</h2><p>‚≠êÔ∏è When a tuple struct has only one element, we call it <strong>newtype pattern</strong>. Because it helps to create a new type.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Color(u8, u8, u8);\nstruct Kilometers(i32);\n\nfn main() {\n  // Creating an instance\n  let black = Color(0, 0, 0);\n\n  // Destructure the instance using a `let` binding, this will not destruct black instance\n  let Color(r, g, b) = black;\n  println!(&quot;Black = rgb({}, {}, {})&quot;, r, g, b); //black = rgb(0, 0, 0);\n\n  // Newtype pattern\n  let distance = Kilometers(20);\n  // Destructure the instance using a `let` binding\n  let Kilometers(distance_in_km) = distance;\n  println!(&quot;The distance: {} km&quot;, distance_in_km); //The distance: 20 km\n}\n</code></pre>\n<h2 id=\"Unit-structs\"><a href=\"#Unit-structs\" class=\"headerlink\" title=\"Unit structs\"></a>Unit structs</h2><p>This is rarely useful on its own. But in combination with other features, it can become useful.</p>\n<blockquote>\n<p><a href=\"https://doc.rust-lang.org/book/first-edition/structs.html\" target=\"_blank\" rel=\"noopener\">üìñ</a> ex: A library may ask you to create a structure that implements a certain trait to handle events. If you don‚Äôt have any data you need to store in the structure, you can create a unit-like struct.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Electron;\n\nfn main() {\n  let x = Electron;\n}\n</code></pre>\n"},{"title":"Enums","_content":"\n‚≠êÔ∏è An **enum** is a single type. It contains **variants**, which are possible values of the enum at a given time. For example,\n\n```rust\nenum Day {\n    Sunday,\n    Monday,\n    Tuesday,\n    Wednesday,\n    Thursday,\n    Friday,\n    Saturday\n}\n\n// The `Day` is the enum\n// Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday are the variants\n```\n\n‚≠êÔ∏è Variants can be accessed through¬†:: notation, ex. Day::Sunday\n\n‚≠êÔ∏è Each enum **variant** can have,\n* No data (unit variant)\n* Unnamed ordered data (tuple variant)\n* Named data (struct variant)\n\n\n```rust\nenum FlashMessage {\n  Success, // A unit variant\n  Warning{ category: i32, message: String }, // A struct variant\n  Error(String) // A tuple variant\n}\n\nfn main() {\n  let mut form_status = FlashMessage::Success;\n  print_flash_message(form_status);\n\n  form_status = FlashMessage::Warning {category: 2, message: String::from(\"Field X is required\")};\n  print_flash_message(form_status);\n\n  form_status = FlashMessage::Error(String::from(\"Connection Error\"));\n  print_flash_message(form_status);\n}\n\nfn print_flash_message(m : FlashMessage) {\n  // Pattern matching with enum\n  match m {\n    FlashMessage::Success =>\n      println!(\"Form Submitted correctly\"),\n    FlashMessage::Warning {category, message} => // Destructure, should use same field names\n      println!(\"Warning : {} - {}\", category, message),\n    FlashMessage::Error(msg) =>\n      println!(\"Error : {}\", msg)\n  }\n}\n```\n","source":"docs/b3.enums.md","raw":"title: Enums\n---\n\n‚≠êÔ∏è An **enum** is a single type. It contains **variants**, which are possible values of the enum at a given time. For example,\n\n```rust\nenum Day {\n    Sunday,\n    Monday,\n    Tuesday,\n    Wednesday,\n    Thursday,\n    Friday,\n    Saturday\n}\n\n// The `Day` is the enum\n// Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday are the variants\n```\n\n‚≠êÔ∏è Variants can be accessed through¬†:: notation, ex. Day::Sunday\n\n‚≠êÔ∏è Each enum **variant** can have,\n* No data (unit variant)\n* Unnamed ordered data (tuple variant)\n* Named data (struct variant)\n\n\n```rust\nenum FlashMessage {\n  Success, // A unit variant\n  Warning{ category: i32, message: String }, // A struct variant\n  Error(String) // A tuple variant\n}\n\nfn main() {\n  let mut form_status = FlashMessage::Success;\n  print_flash_message(form_status);\n\n  form_status = FlashMessage::Warning {category: 2, message: String::from(\"Field X is required\")};\n  print_flash_message(form_status);\n\n  form_status = FlashMessage::Error(String::from(\"Connection Error\"));\n  print_flash_message(form_status);\n}\n\nfn print_flash_message(m : FlashMessage) {\n  // Pattern matching with enum\n  match m {\n    FlashMessage::Success =>\n      println!(\"Form Submitted correctly\"),\n    FlashMessage::Warning {category, message} => // Destructure, should use same field names\n      println!(\"Warning : {} - {}\", category, message),\n    FlashMessage::Error(msg) =>\n      println!(\"Error : {}\", msg)\n  }\n}\n```\n","date":"2019-03-19T14:50:39.952Z","updated":"2019-03-19T14:50:39.952Z","path":"docs/b3.enums.html","comments":1,"layout":"page","_id":"cjtfwbizf000ddwgplrmr0p7e","content":"<p>‚≠êÔ∏è An <strong>enum</strong> is a single type. It contains <strong>variants</strong>, which are possible values of the enum at a given time. For example,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">enum Day {\n    Sunday,\n    Monday,\n    Tuesday,\n    Wednesday,\n    Thursday,\n    Friday,\n    Saturday\n}\n\n// The `Day` is the enum\n// Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday are the variants\n</code></pre>\n<p>‚≠êÔ∏è Variants can be accessed through :: notation, ex. Day::Sunday</p>\n<p>‚≠êÔ∏è Each enum <strong>variant</strong> can have,</p>\n<ul>\n<li>No data (unit variant)</li>\n<li>Unnamed ordered data (tuple variant)</li>\n<li>Named data (struct variant)</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">enum FlashMessage {\n  Success, // A unit variant\n  Warning{ category: i32, message: String }, // A struct variant\n  Error(String) // A tuple variant\n}\n\nfn main() {\n  let mut form_status = FlashMessage::Success;\n  print_flash_message(form_status);\n\n  form_status = FlashMessage::Warning {category: 2, message: String::from(&quot;Field X is required&quot;)};\n  print_flash_message(form_status);\n\n  form_status = FlashMessage::Error(String::from(&quot;Connection Error&quot;));\n  print_flash_message(form_status);\n}\n\nfn print_flash_message(m : FlashMessage) {\n  // Pattern matching with enum\n  match m {\n    FlashMessage::Success =&gt;\n      println!(&quot;Form Submitted correctly&quot;),\n    FlashMessage::Warning {category, message} =&gt; // Destructure, should use same field names\n      println!(&quot;Warning : {} - {}&quot;, category, message),\n    FlashMessage::Error(msg) =&gt;\n      println!(&quot;Error : {}&quot;, msg)\n  }\n}\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<p>‚≠êÔ∏è An <strong>enum</strong> is a single type. It contains <strong>variants</strong>, which are possible values of the enum at a given time. For example,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">enum Day {\n    Sunday,\n    Monday,\n    Tuesday,\n    Wednesday,\n    Thursday,\n    Friday,\n    Saturday\n}\n\n// The `Day` is the enum\n// Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday are the variants\n</code></pre>\n<p>‚≠êÔ∏è Variants can be accessed through :: notation, ex. Day::Sunday</p>\n<p>‚≠êÔ∏è Each enum <strong>variant</strong> can have,</p>\n<ul>\n<li>No data (unit variant)</li>\n<li>Unnamed ordered data (tuple variant)</li>\n<li>Named data (struct variant)</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">enum FlashMessage {\n  Success, // A unit variant\n  Warning{ category: i32, message: String }, // A struct variant\n  Error(String) // A tuple variant\n}\n\nfn main() {\n  let mut form_status = FlashMessage::Success;\n  print_flash_message(form_status);\n\n  form_status = FlashMessage::Warning {category: 2, message: String::from(&quot;Field X is required&quot;)};\n  print_flash_message(form_status);\n\n  form_status = FlashMessage::Error(String::from(&quot;Connection Error&quot;));\n  print_flash_message(form_status);\n}\n\nfn print_flash_message(m : FlashMessage) {\n  // Pattern matching with enum\n  match m {\n    FlashMessage::Success =&gt;\n      println!(&quot;Form Submitted correctly&quot;),\n    FlashMessage::Warning {category, message} =&gt; // Destructure, should use same field names\n      println!(&quot;Warning : {} - {}&quot;, category, message),\n    FlashMessage::Error(msg) =&gt;\n      println!(&quot;Error : {}&quot;, msg)\n  }\n}\n</code></pre>\n"},{"title":"Generics","_content":"\n> [üìñ](https://doc.rust-lang.org/beta/book/first-edition/generics.html) Sometimes, when writing a function or data type, we may want it to work for multiple types of arguments. In Rust, we can do this with generics.\n\nüí≠ The concept is, instead of declaring a specific data type we use an uppercase letter(or CamelCase identifier). ex, **instead of x¬†: u8** we use **x¬†: T**¬†. but we have to inform to the compiler that T is a generic type(can be any type) by adding `<T>` at first.\n\n### Generalizing functions\n\n```rust\nfn takes_anything<T>(x: T) { // x has type T, T is a generic type\n}\n\nfn takes_two_of_the_same_things<T>(x: T, y: T) { // Both x and y has the same type\n}\n\nfn takes_two_things<T, U>(x: T, y: U) { // Multiple types\n}\n```\n\n### Generalizing structs\n\n```rust\nstruct Point<T> {\n  x: T,\n  y: T,\n}\n\nfn main() {\n  let point_a = Point { x: 0, y: 0 }; // T is a int type\n  let point_b = Point { x: 0.0, y: 0.0 }; // T is a float type\n}\n\n// üîé When adding an implementation for a generic struct, the type parameters should be declared after the impl as well\n//   impl<T> Point<T> {\n```\n\n### Generalizing enums\n\n```rust\nenum Option<T> {\n    Some(T),\n    None,\n}\n\nenum Result<T, E> {\n    Ok(T),\n    Err(E),\n}\n```\n\n> ‚≠êÔ∏è Above [Option](https://doc.rust-lang.org/std/option/index.html) and [Result](https://doc.rust-lang.org/std/result/index.html) types are kind of special generic types which are already defined in Rust‚Äôs standard library.¬†\n  * An **optional value** can have either **Some** value or no value/ **None**.\n  * A **result** can represent either success/ **Ok** or failure/ **Err**\n\n #### Usages of Option\n \n```rust\n// 01 - - - - - - - - - - - - - - - - - - - - - -\nfn get_id_by_username(username: &str) -> Option<usize> {\n    // if username can be found in the system, set userId\n        return Some(userId);\n    // else\n        None\n}\n\n// üí≠ So, on the above function, instead of setting return type as usize\n//   set return type as Option<usize>\n// Instead of return userId, return Some(userId)\n//   else None (üí°remember? last return statement no need return keyword and ending ;)\n\n// 02 - - - - - - - - - - - - - - - - - - - - - -\nstruct Task {\n    title: String,\n    assignee: Option<Person>,\n}\n\n// üí≠ Instead of assignee: Person, we use Option<Person>\n// because the task has not been assigned to a specific person\n\n// - - - - - - - - - - - - - - - - - - - - - - -\n// When using Option types as return types on functions\n// we can use pattern matching to catch the relevant return type(Some/None) when calling them\n\nfn main() {\n    let username = \"anonymous\";\n    match get_id_by_username(username) {\n        None => println!(\"User not found\"),\n        Some(i) => println!(\"User Id: {}\", i)\n    }\n}\n```\n\n #### Usages of Result\n \n> [üìñ](https://doc.rust-lang.org/book/first-edition/error-handling.html) The Option type is a way to use Rust‚Äôs type system to express the possibility of absence. Result expresses the possibility of error.\n\n```rust\n// - - - - - - - - - - - - - - - - - - - - - -\nfn get_word_count_from_file(file_name: &str) -> Result<u32, &str> {\n  // if the file is not found on the system, return error\n    return Err(\"File can not be found!\")\n  // else, count and return the word count\n    // let mut word_count: u32; ....\n    Ok(word_count)\n}\n\n// üí≠ On the above function,\n// instead panic(break) the app, when the file can not be found; return Err(something)\n// or when it could get the relevant data; return Ok(data)\n\n\n// - - - - - - - - - - - - - - - - - - - - - - -\n// We can use pattern matching to catch the relevant return type(Ok/Err) when calling it\n\nfn main() {\n    let mut file_name = \"file_a\";\n    match get_word_count_from_file(file_name) {\n        Ok(i) => println!(\"Word Count: {}\", i),\n        Err(e) => println!(\"Error: {}\", e)\n    }\n}\n```\n\n\n> üîé Many useful methods have been implemented around Option and Result types. More information can be found on [std::option::Option](https://doc.rust-lang.org/std/option/enum.Option.html) and [std::result::Result](https://doc.rust-lang.org/std/result/enum.Result.html) pages on Rust doc.\n\n‚≠êÔ∏è Also **more practical examples** of options & results can be found on [Error Handling](https://doc.rust-lang.org/book/first-edition/error-handling.html) section in  Rust doc.\n","source":"docs/b4.generics.md","raw":"title: Generics\n---\n\n> [üìñ](https://doc.rust-lang.org/beta/book/first-edition/generics.html) Sometimes, when writing a function or data type, we may want it to work for multiple types of arguments. In Rust, we can do this with generics.\n\nüí≠ The concept is, instead of declaring a specific data type we use an uppercase letter(or CamelCase identifier). ex, **instead of x¬†: u8** we use **x¬†: T**¬†. but we have to inform to the compiler that T is a generic type(can be any type) by adding `<T>` at first.\n\n### Generalizing functions\n\n```rust\nfn takes_anything<T>(x: T) { // x has type T, T is a generic type\n}\n\nfn takes_two_of_the_same_things<T>(x: T, y: T) { // Both x and y has the same type\n}\n\nfn takes_two_things<T, U>(x: T, y: U) { // Multiple types\n}\n```\n\n### Generalizing structs\n\n```rust\nstruct Point<T> {\n  x: T,\n  y: T,\n}\n\nfn main() {\n  let point_a = Point { x: 0, y: 0 }; // T is a int type\n  let point_b = Point { x: 0.0, y: 0.0 }; // T is a float type\n}\n\n// üîé When adding an implementation for a generic struct, the type parameters should be declared after the impl as well\n//   impl<T> Point<T> {\n```\n\n### Generalizing enums\n\n```rust\nenum Option<T> {\n    Some(T),\n    None,\n}\n\nenum Result<T, E> {\n    Ok(T),\n    Err(E),\n}\n```\n\n> ‚≠êÔ∏è Above [Option](https://doc.rust-lang.org/std/option/index.html) and [Result](https://doc.rust-lang.org/std/result/index.html) types are kind of special generic types which are already defined in Rust‚Äôs standard library.¬†\n  * An **optional value** can have either **Some** value or no value/ **None**.\n  * A **result** can represent either success/ **Ok** or failure/ **Err**\n\n #### Usages of Option\n \n```rust\n// 01 - - - - - - - - - - - - - - - - - - - - - -\nfn get_id_by_username(username: &str) -> Option<usize> {\n    // if username can be found in the system, set userId\n        return Some(userId);\n    // else\n        None\n}\n\n// üí≠ So, on the above function, instead of setting return type as usize\n//   set return type as Option<usize>\n// Instead of return userId, return Some(userId)\n//   else None (üí°remember? last return statement no need return keyword and ending ;)\n\n// 02 - - - - - - - - - - - - - - - - - - - - - -\nstruct Task {\n    title: String,\n    assignee: Option<Person>,\n}\n\n// üí≠ Instead of assignee: Person, we use Option<Person>\n// because the task has not been assigned to a specific person\n\n// - - - - - - - - - - - - - - - - - - - - - - -\n// When using Option types as return types on functions\n// we can use pattern matching to catch the relevant return type(Some/None) when calling them\n\nfn main() {\n    let username = \"anonymous\";\n    match get_id_by_username(username) {\n        None => println!(\"User not found\"),\n        Some(i) => println!(\"User Id: {}\", i)\n    }\n}\n```\n\n #### Usages of Result\n \n> [üìñ](https://doc.rust-lang.org/book/first-edition/error-handling.html) The Option type is a way to use Rust‚Äôs type system to express the possibility of absence. Result expresses the possibility of error.\n\n```rust\n// - - - - - - - - - - - - - - - - - - - - - -\nfn get_word_count_from_file(file_name: &str) -> Result<u32, &str> {\n  // if the file is not found on the system, return error\n    return Err(\"File can not be found!\")\n  // else, count and return the word count\n    // let mut word_count: u32; ....\n    Ok(word_count)\n}\n\n// üí≠ On the above function,\n// instead panic(break) the app, when the file can not be found; return Err(something)\n// or when it could get the relevant data; return Ok(data)\n\n\n// - - - - - - - - - - - - - - - - - - - - - - -\n// We can use pattern matching to catch the relevant return type(Ok/Err) when calling it\n\nfn main() {\n    let mut file_name = \"file_a\";\n    match get_word_count_from_file(file_name) {\n        Ok(i) => println!(\"Word Count: {}\", i),\n        Err(e) => println!(\"Error: {}\", e)\n    }\n}\n```\n\n\n> üîé Many useful methods have been implemented around Option and Result types. More information can be found on [std::option::Option](https://doc.rust-lang.org/std/option/enum.Option.html) and [std::result::Result](https://doc.rust-lang.org/std/result/enum.Result.html) pages on Rust doc.\n\n‚≠êÔ∏è Also **more practical examples** of options & results can be found on [Error Handling](https://doc.rust-lang.org/book/first-edition/error-handling.html) section in  Rust doc.\n","date":"2019-03-19T14:50:39.952Z","updated":"2019-03-19T14:50:39.952Z","path":"docs/b4.generics.html","comments":1,"layout":"page","_id":"cjtfwbizg000edwgpmix13yle","content":"<blockquote>\n<p><a href=\"https://doc.rust-lang.org/beta/book/first-edition/generics.html\" target=\"_blank\" rel=\"noopener\">üìñ</a> Sometimes, when writing a function or data type, we may want it to work for multiple types of arguments. In Rust, we can do this with generics.</p>\n</blockquote>\n<p>üí≠ The concept is, instead of declaring a specific data type we use an uppercase letter(or CamelCase identifier). ex, <strong>instead of x : u8</strong> we use <strong>x : T</strong> . but we have to inform to the compiler that T is a generic type(can be any type) by adding <code>&lt;T&gt;</code> at first.</p>\n<h3 id=\"Generalizing-functions\"><a href=\"#Generalizing-functions\" class=\"headerlink\" title=\"Generalizing functions\"></a>Generalizing functions</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn takes_anything&lt;T&gt;(x: T) { // x has type T, T is a generic type\n}\n\nfn takes_two_of_the_same_things&lt;T&gt;(x: T, y: T) { // Both x and y has the same type\n}\n\nfn takes_two_things&lt;T, U&gt;(x: T, y: U) { // Multiple types\n}\n</code></pre>\n<h3 id=\"Generalizing-structs\"><a href=\"#Generalizing-structs\" class=\"headerlink\" title=\"Generalizing structs\"></a>Generalizing structs</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Point&lt;T&gt; {\n  x: T,\n  y: T,\n}\n\nfn main() {\n  let point_a = Point { x: 0, y: 0 }; // T is a int type\n  let point_b = Point { x: 0.0, y: 0.0 }; // T is a float type\n}\n\n// üîé When adding an implementation for a generic struct, the type parameters should be declared after the impl as well\n//   impl&lt;T&gt; Point&lt;T&gt; {\n</code></pre>\n<h3 id=\"Generalizing-enums\"><a href=\"#Generalizing-enums\" class=\"headerlink\" title=\"Generalizing enums\"></a>Generalizing enums</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">enum Option&lt;T&gt; {\n    Some(T),\n    None,\n}\n\nenum Result&lt;T, E&gt; {\n    Ok(T),\n    Err(E),\n}\n</code></pre>\n<blockquote>\n<p>‚≠êÔ∏è Above <a href=\"https://doc.rust-lang.org/std/option/index.html\" target=\"_blank\" rel=\"noopener\">Option</a> and <a href=\"https://doc.rust-lang.org/std/result/index.html\" target=\"_blank\" rel=\"noopener\">Result</a> types are kind of special generic types which are already defined in Rust‚Äôs standard library. </p>\n<ul>\n<li>An <strong>optional value</strong> can have either <strong>Some</strong> value or no value/ <strong>None</strong>.</li>\n<li>A <strong>result</strong> can represent either success/ <strong>Ok</strong> or failure/ <strong>Err</strong></li>\n</ul>\n</blockquote>\n<h4 id=\"Usages-of-Option\"><a href=\"#Usages-of-Option\" class=\"headerlink\" title=\"Usages of Option\"></a>Usages of Option</h4><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// 01 - - - - - - - - - - - - - - - - - - - - - -\nfn get_id_by_username(username: &amp;str) -&gt; Option&lt;usize&gt; {\n    // if username can be found in the system, set userId\n        return Some(userId);\n    // else\n        None\n}\n\n// üí≠ So, on the above function, instead of setting return type as usize\n//   set return type as Option&lt;usize&gt;\n// Instead of return userId, return Some(userId)\n//   else None (üí°remember? last return statement no need return keyword and ending ;)\n\n// 02 - - - - - - - - - - - - - - - - - - - - - -\nstruct Task {\n    title: String,\n    assignee: Option&lt;Person&gt;,\n}\n\n// üí≠ Instead of assignee: Person, we use Option&lt;Person&gt;\n// because the task has not been assigned to a specific person\n\n// - - - - - - - - - - - - - - - - - - - - - - -\n// When using Option types as return types on functions\n// we can use pattern matching to catch the relevant return type(Some/None) when calling them\n\nfn main() {\n    let username = &quot;anonymous&quot;;\n    match get_id_by_username(username) {\n        None =&gt; println!(&quot;User not found&quot;),\n        Some(i) =&gt; println!(&quot;User Id: {}&quot;, i)\n    }\n}\n</code></pre>\n<h4 id=\"Usages-of-Result\"><a href=\"#Usages-of-Result\" class=\"headerlink\" title=\"Usages of Result\"></a>Usages of Result</h4><blockquote>\n<p><a href=\"https://doc.rust-lang.org/book/first-edition/error-handling.html\" target=\"_blank\" rel=\"noopener\">üìñ</a> The Option type is a way to use Rust‚Äôs type system to express the possibility of absence. Result expresses the possibility of error.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// - - - - - - - - - - - - - - - - - - - - - -\nfn get_word_count_from_file(file_name: &amp;str) -&gt; Result&lt;u32, &amp;str&gt; {\n  // if the file is not found on the system, return error\n    return Err(&quot;File can not be found!&quot;)\n  // else, count and return the word count\n    // let mut word_count: u32; ....\n    Ok(word_count)\n}\n\n// üí≠ On the above function,\n// instead panic(break) the app, when the file can not be found; return Err(something)\n// or when it could get the relevant data; return Ok(data)\n\n\n// - - - - - - - - - - - - - - - - - - - - - - -\n// We can use pattern matching to catch the relevant return type(Ok/Err) when calling it\n\nfn main() {\n    let mut file_name = &quot;file_a&quot;;\n    match get_word_count_from_file(file_name) {\n        Ok(i) =&gt; println!(&quot;Word Count: {}&quot;, i),\n        Err(e) =&gt; println!(&quot;Error: {}&quot;, e)\n    }\n}\n</code></pre>\n<blockquote>\n<p>üîé Many useful methods have been implemented around Option and Result types. More information can be found on <a href=\"https://doc.rust-lang.org/std/option/enum.Option.html\" target=\"_blank\" rel=\"noopener\">std::option::Option</a> and <a href=\"https://doc.rust-lang.org/std/result/enum.Result.html\" target=\"_blank\" rel=\"noopener\">std::result::Result</a> pages on Rust doc.</p>\n</blockquote>\n<p>‚≠êÔ∏è Also <strong>more practical examples</strong> of options &amp; results can be found on <a href=\"https://doc.rust-lang.org/book/first-edition/error-handling.html\" target=\"_blank\" rel=\"noopener\">Error Handling</a> section in  Rust doc.</p>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<blockquote>\n<p><a href=\"https://doc.rust-lang.org/beta/book/first-edition/generics.html\" target=\"_blank\" rel=\"noopener\">üìñ</a> Sometimes, when writing a function or data type, we may want it to work for multiple types of arguments. In Rust, we can do this with generics.</p>\n</blockquote>\n<p>üí≠ The concept is, instead of declaring a specific data type we use an uppercase letter(or CamelCase identifier). ex, <strong>instead of x : u8</strong> we use <strong>x : T</strong> . but we have to inform to the compiler that T is a generic type(can be any type) by adding <code>&lt;T&gt;</code> at first.</p>\n<h3 id=\"Generalizing-functions\"><a href=\"#Generalizing-functions\" class=\"headerlink\" title=\"Generalizing functions\"></a>Generalizing functions</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn takes_anything&lt;T&gt;(x: T) { // x has type T, T is a generic type\n}\n\nfn takes_two_of_the_same_things&lt;T&gt;(x: T, y: T) { // Both x and y has the same type\n}\n\nfn takes_two_things&lt;T, U&gt;(x: T, y: U) { // Multiple types\n}\n</code></pre>\n<h3 id=\"Generalizing-structs\"><a href=\"#Generalizing-structs\" class=\"headerlink\" title=\"Generalizing structs\"></a>Generalizing structs</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Point&lt;T&gt; {\n  x: T,\n  y: T,\n}\n\nfn main() {\n  let point_a = Point { x: 0, y: 0 }; // T is a int type\n  let point_b = Point { x: 0.0, y: 0.0 }; // T is a float type\n}\n\n// üîé When adding an implementation for a generic struct, the type parameters should be declared after the impl as well\n//   impl&lt;T&gt; Point&lt;T&gt; {\n</code></pre>\n<h3 id=\"Generalizing-enums\"><a href=\"#Generalizing-enums\" class=\"headerlink\" title=\"Generalizing enums\"></a>Generalizing enums</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">enum Option&lt;T&gt; {\n    Some(T),\n    None,\n}\n\nenum Result&lt;T, E&gt; {\n    Ok(T),\n    Err(E),\n}\n</code></pre>\n<blockquote>\n<p>‚≠êÔ∏è Above <a href=\"https://doc.rust-lang.org/std/option/index.html\" target=\"_blank\" rel=\"noopener\">Option</a> and <a href=\"https://doc.rust-lang.org/std/result/index.html\" target=\"_blank\" rel=\"noopener\">Result</a> types are kind of special generic types which are already defined in Rust‚Äôs standard library. </p>\n<ul>\n<li>An <strong>optional value</strong> can have either <strong>Some</strong> value or no value/ <strong>None</strong>.</li>\n<li>A <strong>result</strong> can represent either success/ <strong>Ok</strong> or failure/ <strong>Err</strong></li>\n</ul>\n</blockquote>\n<h4 id=\"Usages-of-Option\"><a href=\"#Usages-of-Option\" class=\"headerlink\" title=\"Usages of Option\"></a>Usages of Option</h4><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// 01 - - - - - - - - - - - - - - - - - - - - - -\nfn get_id_by_username(username: &amp;str) -&gt; Option&lt;usize&gt; {\n    // if username can be found in the system, set userId\n        return Some(userId);\n    // else\n        None\n}\n\n// üí≠ So, on the above function, instead of setting return type as usize\n//   set return type as Option&lt;usize&gt;\n// Instead of return userId, return Some(userId)\n//   else None (üí°remember? last return statement no need return keyword and ending ;)\n\n// 02 - - - - - - - - - - - - - - - - - - - - - -\nstruct Task {\n    title: String,\n    assignee: Option&lt;Person&gt;,\n}\n\n// üí≠ Instead of assignee: Person, we use Option&lt;Person&gt;\n// because the task has not been assigned to a specific person\n\n// - - - - - - - - - - - - - - - - - - - - - - -\n// When using Option types as return types on functions\n// we can use pattern matching to catch the relevant return type(Some/None) when calling them\n\nfn main() {\n    let username = &quot;anonymous&quot;;\n    match get_id_by_username(username) {\n        None =&gt; println!(&quot;User not found&quot;),\n        Some(i) =&gt; println!(&quot;User Id: {}&quot;, i)\n    }\n}\n</code></pre>\n<h4 id=\"Usages-of-Result\"><a href=\"#Usages-of-Result\" class=\"headerlink\" title=\"Usages of Result\"></a>Usages of Result</h4><blockquote>\n<p><a href=\"https://doc.rust-lang.org/book/first-edition/error-handling.html\" target=\"_blank\" rel=\"noopener\">üìñ</a> The Option type is a way to use Rust‚Äôs type system to express the possibility of absence. Result expresses the possibility of error.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// - - - - - - - - - - - - - - - - - - - - - -\nfn get_word_count_from_file(file_name: &amp;str) -&gt; Result&lt;u32, &amp;str&gt; {\n  // if the file is not found on the system, return error\n    return Err(&quot;File can not be found!&quot;)\n  // else, count and return the word count\n    // let mut word_count: u32; ....\n    Ok(word_count)\n}\n\n// üí≠ On the above function,\n// instead panic(break) the app, when the file can not be found; return Err(something)\n// or when it could get the relevant data; return Ok(data)\n\n\n// - - - - - - - - - - - - - - - - - - - - - - -\n// We can use pattern matching to catch the relevant return type(Ok/Err) when calling it\n\nfn main() {\n    let mut file_name = &quot;file_a&quot;;\n    match get_word_count_from_file(file_name) {\n        Ok(i) =&gt; println!(&quot;Word Count: {}&quot;, i),\n        Err(e) =&gt; println!(&quot;Error: {}&quot;, e)\n    }\n}\n</code></pre>\n<blockquote>\n<p>üîé Many useful methods have been implemented around Option and Result types. More information can be found on <a href=\"https://doc.rust-lang.org/std/option/enum.Option.html\" target=\"_blank\" rel=\"noopener\">std::option::Option</a> and <a href=\"https://doc.rust-lang.org/std/result/enum.Result.html\" target=\"_blank\" rel=\"noopener\">std::result::Result</a> pages on Rust doc.</p>\n</blockquote>\n<p>‚≠êÔ∏è Also <strong>more practical examples</strong> of options &amp; results can be found on <a href=\"https://doc.rust-lang.org/book/first-edition/error-handling.html\" target=\"_blank\" rel=\"noopener\">Error Handling</a> section in  Rust doc.</p>\n"},{"title":"Impls & Traits","_content":"\nüí° When we discussed about **C-like structs**, I mentioned that those are **similar to classes** in OOP languages **but without their methods**. **impls** are **used to define methods** for Rust structs and enums.\n\nüí° **Traits** are kind of **similar to interfaces** in OOP languages. They are used to define the functionality a type must provide. Multiple traits can be implemented for a single type.\n\n‚≠êÔ∏èÔ∏è But traits **can also include default implementations of methods**. Default methods can be overridden when implementing types.\n\n### Impls without traits\n\n```rust\nstruct Player {\n    first_name: String,\n    last_name: String,\n}\n\nimpl Player {\n    fn full_name(&self) -> String {\n        format!(\"{} {}\", self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_1 = Player {\n        first_name: \"Rafael\".to_string(),\n        last_name: \"Nadal\".to_string(),\n    };\n\n    println!(\"Player 01: {}\", player_1.full_name());\n}\n\n// ‚≠êÔ∏è Implementation must appear in the same crate as the self type\n\n// üí° And also in Rust, new traits can be implemented for existing types even for types like i8, f64 and etc.\n// Same way existing traits can be implemented for new types you are creating.\n// But we can not implement existing traits into existing types.\n```\n\n### Impls & traits, without default methods\n\n```rust\nstruct Player {\n    first_name: String,\n    last_name: String,\n}\n\ntrait FullName {\n    fn full_name(&self) -> String;\n}\n\nimpl FullName for Player {\n    fn full_name(&self) -> String {\n        format!(\"{} {}\", self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_2 = Player {\n        first_name: \"Roger\".to_string(),\n        last_name: \"Federer\".to_string(),\n    };\n\n    println!(\"Player 02: {}\", player_2.full_name());\n}\n\n// üîé Other than functions, traits can contain constants and types.\n```\n\n### Impls, traits & default methods\n\n```rust\ntrait Foo {\n    fn bar(&self);\n    fn baz(&self) { println!(\"We called baz.\"); }\n}\n```\n\n‚≠êÔ∏è As you can see methods take a **special first parameter**, the type itself. It can be **either self, &self, or &mut self**; self if it‚Äôs a value on the stack (taking ownership), &self if it‚Äôs a reference, and &mut self if it‚Äôs a mutable reference.\n\n### Impls with Associated functions\n\nSome other languages support **static methods**. At such times, we **call a function directly** through the class without creating an object. In Rust, we call them Associated Functions. we use¬†**::**  instead of¬†. when calling them from the struct.\nex. `Person::new(‚ÄúElon Musk Jr‚Äù);`\n\n\n```rust\nstruct Player {\n    first_name: String,\n    last_name: String,\n}\n\nimpl Player {\n    fn new(first_name: String, last_name: String) -> Player {\n        Player {\n            first_name : first_name,\n            last_name : last_name,\n        }\n    }\n\n    fn full_name(&self) -> String {\n        format!(\"{} {}\", self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_name = Player::new(\"Serena\".to_string(), \"Williams\".to_string()).full_name();\n    println!(\"Player: {}\", player_name);\n}\n\n// We have used :: notation for `new()` and . notation for `full_name()`\n\n// üîé Also in here, instead of using new() and full_name() separately as two expressions, \n// we can use Method Chaining. ex. `player.add_points(2).get_point_count();`\n```\n\n### Traits with generics\n\n```rust\ntrait From<T> {\n    fn from(T) -> Self;\n}\n    impl From<u8> for u16 {\n        //...\n    }\n    impl From<u8> for u32{\n        //...\n    }\n    \n// Should specify after the trait name like generic functions\n```\n\n### Traits inheritance\n\n```rust\ntrait Person {\n    fn full_name(&self) -> String;\n}\n\n    trait Employee : Person { // Employee inherits from person trait\n      fn job_title(&self) -> String;\n    }\n\n    trait ExpatEmployee : Employee + Expat { // ExpatEmployee inherits from Employee and Expat traits\n      fn additional_tax(&self) -> f64;\n    }\n```\n\n### Trait objects\n\nüîé While Rust favors static dispatch, it also supports dynamic dispatch through a mechanism called ‚Äòtrait objects.‚Äô\n\n> [üÖÜ](https://en.wikipedia.org/wiki/Dynamic_dispatch) **Dynamic dispatch** is the process of selecting which implementation of a polymorphic operation (method or function) to call at run time.\n\n\n```rust\ntrait GetSound {\n    fn get_sound(&self) -> String;\n}\n\nstruct Cat {\n    sound: String,\n}\n    impl GetSound for Cat {\n        fn get_sound(&self) -> String {\n            self.sound.clone()\n        }\n    }\n\nstruct Bell {\n    sound: String,\n}\n    impl GetSound for Bell {\n        fn get_sound(&self) -> String {\n            self.sound.clone()\n        }\n    }\n\n\nfn make_sound<T: GetSound>(t: &T) {\n    println!(\"{}!\", t.get_sound())\n}\n\nfn main() {\n    let kitty = Cat { sound: \"Meow\".to_string() };\n    let the_bell = Bell { sound: \"Ding Dong\".to_string() };\n\n    make_sound(&kitty); // Meow!\n    make_sound(&the_bell); // Ding Dong!\n}\n```\n","source":"docs/b5.impls_and_traits.md","raw":"title: Impls & Traits\n---\n\nüí° When we discussed about **C-like structs**, I mentioned that those are **similar to classes** in OOP languages **but without their methods**. **impls** are **used to define methods** for Rust structs and enums.\n\nüí° **Traits** are kind of **similar to interfaces** in OOP languages. They are used to define the functionality a type must provide. Multiple traits can be implemented for a single type.\n\n‚≠êÔ∏èÔ∏è But traits **can also include default implementations of methods**. Default methods can be overridden when implementing types.\n\n### Impls without traits\n\n```rust\nstruct Player {\n    first_name: String,\n    last_name: String,\n}\n\nimpl Player {\n    fn full_name(&self) -> String {\n        format!(\"{} {}\", self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_1 = Player {\n        first_name: \"Rafael\".to_string(),\n        last_name: \"Nadal\".to_string(),\n    };\n\n    println!(\"Player 01: {}\", player_1.full_name());\n}\n\n// ‚≠êÔ∏è Implementation must appear in the same crate as the self type\n\n// üí° And also in Rust, new traits can be implemented for existing types even for types like i8, f64 and etc.\n// Same way existing traits can be implemented for new types you are creating.\n// But we can not implement existing traits into existing types.\n```\n\n### Impls & traits, without default methods\n\n```rust\nstruct Player {\n    first_name: String,\n    last_name: String,\n}\n\ntrait FullName {\n    fn full_name(&self) -> String;\n}\n\nimpl FullName for Player {\n    fn full_name(&self) -> String {\n        format!(\"{} {}\", self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_2 = Player {\n        first_name: \"Roger\".to_string(),\n        last_name: \"Federer\".to_string(),\n    };\n\n    println!(\"Player 02: {}\", player_2.full_name());\n}\n\n// üîé Other than functions, traits can contain constants and types.\n```\n\n### Impls, traits & default methods\n\n```rust\ntrait Foo {\n    fn bar(&self);\n    fn baz(&self) { println!(\"We called baz.\"); }\n}\n```\n\n‚≠êÔ∏è As you can see methods take a **special first parameter**, the type itself. It can be **either self, &self, or &mut self**; self if it‚Äôs a value on the stack (taking ownership), &self if it‚Äôs a reference, and &mut self if it‚Äôs a mutable reference.\n\n### Impls with Associated functions\n\nSome other languages support **static methods**. At such times, we **call a function directly** through the class without creating an object. In Rust, we call them Associated Functions. we use¬†**::**  instead of¬†. when calling them from the struct.\nex. `Person::new(‚ÄúElon Musk Jr‚Äù);`\n\n\n```rust\nstruct Player {\n    first_name: String,\n    last_name: String,\n}\n\nimpl Player {\n    fn new(first_name: String, last_name: String) -> Player {\n        Player {\n            first_name : first_name,\n            last_name : last_name,\n        }\n    }\n\n    fn full_name(&self) -> String {\n        format!(\"{} {}\", self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_name = Player::new(\"Serena\".to_string(), \"Williams\".to_string()).full_name();\n    println!(\"Player: {}\", player_name);\n}\n\n// We have used :: notation for `new()` and . notation for `full_name()`\n\n// üîé Also in here, instead of using new() and full_name() separately as two expressions, \n// we can use Method Chaining. ex. `player.add_points(2).get_point_count();`\n```\n\n### Traits with generics\n\n```rust\ntrait From<T> {\n    fn from(T) -> Self;\n}\n    impl From<u8> for u16 {\n        //...\n    }\n    impl From<u8> for u32{\n        //...\n    }\n    \n// Should specify after the trait name like generic functions\n```\n\n### Traits inheritance\n\n```rust\ntrait Person {\n    fn full_name(&self) -> String;\n}\n\n    trait Employee : Person { // Employee inherits from person trait\n      fn job_title(&self) -> String;\n    }\n\n    trait ExpatEmployee : Employee + Expat { // ExpatEmployee inherits from Employee and Expat traits\n      fn additional_tax(&self) -> f64;\n    }\n```\n\n### Trait objects\n\nüîé While Rust favors static dispatch, it also supports dynamic dispatch through a mechanism called ‚Äòtrait objects.‚Äô\n\n> [üÖÜ](https://en.wikipedia.org/wiki/Dynamic_dispatch) **Dynamic dispatch** is the process of selecting which implementation of a polymorphic operation (method or function) to call at run time.\n\n\n```rust\ntrait GetSound {\n    fn get_sound(&self) -> String;\n}\n\nstruct Cat {\n    sound: String,\n}\n    impl GetSound for Cat {\n        fn get_sound(&self) -> String {\n            self.sound.clone()\n        }\n    }\n\nstruct Bell {\n    sound: String,\n}\n    impl GetSound for Bell {\n        fn get_sound(&self) -> String {\n            self.sound.clone()\n        }\n    }\n\n\nfn make_sound<T: GetSound>(t: &T) {\n    println!(\"{}!\", t.get_sound())\n}\n\nfn main() {\n    let kitty = Cat { sound: \"Meow\".to_string() };\n    let the_bell = Bell { sound: \"Ding Dong\".to_string() };\n\n    make_sound(&kitty); // Meow!\n    make_sound(&the_bell); // Ding Dong!\n}\n```\n","date":"2019-03-19T14:50:39.953Z","updated":"2019-03-19T14:50:39.953Z","path":"docs/b5.impls_and_traits.html","comments":1,"layout":"page","_id":"cjtfwbizg000fdwgp94t9h4ma","content":"<p>üí° When we discussed about <strong>C-like structs</strong>, I mentioned that those are <strong>similar to classes</strong> in OOP languages <strong>but without their methods</strong>. <strong>impls</strong> are <strong>used to define methods</strong> for Rust structs and enums.</p>\n<p>üí° <strong>Traits</strong> are kind of <strong>similar to interfaces</strong> in OOP languages. They are used to define the functionality a type must provide. Multiple traits can be implemented for a single type.</p>\n<p>‚≠êÔ∏èÔ∏è But traits <strong>can also include default implementations of methods</strong>. Default methods can be overridden when implementing types.</p>\n<h3 id=\"Impls-without-traits\"><a href=\"#Impls-without-traits\" class=\"headerlink\" title=\"Impls without traits\"></a>Impls without traits</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Player {\n    first_name: String,\n    last_name: String,\n}\n\nimpl Player {\n    fn full_name(&amp;self) -&gt; String {\n        format!(&quot;{} {}&quot;, self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_1 = Player {\n        first_name: &quot;Rafael&quot;.to_string(),\n        last_name: &quot;Nadal&quot;.to_string(),\n    };\n\n    println!(&quot;Player 01: {}&quot;, player_1.full_name());\n}\n\n// ‚≠êÔ∏è Implementation must appear in the same crate as the self type\n\n// üí° And also in Rust, new traits can be implemented for existing types even for types like i8, f64 and etc.\n// Same way existing traits can be implemented for new types you are creating.\n// But we can not implement existing traits into existing types.\n</code></pre>\n<h3 id=\"Impls-amp-traits-without-default-methods\"><a href=\"#Impls-amp-traits-without-default-methods\" class=\"headerlink\" title=\"Impls &amp; traits, without default methods\"></a>Impls &amp; traits, without default methods</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Player {\n    first_name: String,\n    last_name: String,\n}\n\ntrait FullName {\n    fn full_name(&amp;self) -&gt; String;\n}\n\nimpl FullName for Player {\n    fn full_name(&amp;self) -&gt; String {\n        format!(&quot;{} {}&quot;, self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_2 = Player {\n        first_name: &quot;Roger&quot;.to_string(),\n        last_name: &quot;Federer&quot;.to_string(),\n    };\n\n    println!(&quot;Player 02: {}&quot;, player_2.full_name());\n}\n\n// üîé Other than functions, traits can contain constants and types.\n</code></pre>\n<h3 id=\"Impls-traits-amp-default-methods\"><a href=\"#Impls-traits-amp-default-methods\" class=\"headerlink\" title=\"Impls, traits &amp; default methods\"></a>Impls, traits &amp; default methods</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">trait Foo {\n    fn bar(&amp;self);\n    fn baz(&amp;self) { println!(&quot;We called baz.&quot;); }\n}\n</code></pre>\n<p>‚≠êÔ∏è As you can see methods take a <strong>special first parameter</strong>, the type itself. It can be <strong>either self, &amp;self, or &amp;mut self</strong>; self if it‚Äôs a value on the stack (taking ownership), &amp;self if it‚Äôs a reference, and &amp;mut self if it‚Äôs a mutable reference.</p>\n<h3 id=\"Impls-with-Associated-functions\"><a href=\"#Impls-with-Associated-functions\" class=\"headerlink\" title=\"Impls with Associated functions\"></a>Impls with Associated functions</h3><p>Some other languages support <strong>static methods</strong>. At such times, we <strong>call a function directly</strong> through the class without creating an object. In Rust, we call them Associated Functions. we use <strong>::</strong>  instead of . when calling them from the struct.<br>ex. <code>Person::new(‚ÄúElon Musk Jr‚Äù);</code></p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Player {\n    first_name: String,\n    last_name: String,\n}\n\nimpl Player {\n    fn new(first_name: String, last_name: String) -&gt; Player {\n        Player {\n            first_name : first_name,\n            last_name : last_name,\n        }\n    }\n\n    fn full_name(&amp;self) -&gt; String {\n        format!(&quot;{} {}&quot;, self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_name = Player::new(&quot;Serena&quot;.to_string(), &quot;Williams&quot;.to_string()).full_name();\n    println!(&quot;Player: {}&quot;, player_name);\n}\n\n// We have used :: notation for `new()` and . notation for `full_name()`\n\n// üîé Also in here, instead of using new() and full_name() separately as two expressions, \n// we can use Method Chaining. ex. `player.add_points(2).get_point_count();`\n</code></pre>\n<h3 id=\"Traits-with-generics\"><a href=\"#Traits-with-generics\" class=\"headerlink\" title=\"Traits with generics\"></a>Traits with generics</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">trait From&lt;T&gt; {\n    fn from(T) -&gt; Self;\n}\n    impl From&lt;u8&gt; for u16 {\n        //...\n    }\n    impl From&lt;u8&gt; for u32{\n        //...\n    }\n\n// Should specify after the trait name like generic functions\n</code></pre>\n<h3 id=\"Traits-inheritance\"><a href=\"#Traits-inheritance\" class=\"headerlink\" title=\"Traits inheritance\"></a>Traits inheritance</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">trait Person {\n    fn full_name(&amp;self) -&gt; String;\n}\n\n    trait Employee : Person { // Employee inherits from person trait\n      fn job_title(&amp;self) -&gt; String;\n    }\n\n    trait ExpatEmployee : Employee + Expat { // ExpatEmployee inherits from Employee and Expat traits\n      fn additional_tax(&amp;self) -&gt; f64;\n    }\n</code></pre>\n<h3 id=\"Trait-objects\"><a href=\"#Trait-objects\" class=\"headerlink\" title=\"Trait objects\"></a>Trait objects</h3><p>üîé While Rust favors static dispatch, it also supports dynamic dispatch through a mechanism called ‚Äòtrait objects.‚Äô</p>\n<blockquote>\n<p><a href=\"https://en.wikipedia.org/wiki/Dynamic_dispatch\" target=\"_blank\" rel=\"noopener\">üÖÜ</a> <strong>Dynamic dispatch</strong> is the process of selecting which implementation of a polymorphic operation (method or function) to call at run time.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">trait GetSound {\n    fn get_sound(&amp;self) -&gt; String;\n}\n\nstruct Cat {\n    sound: String,\n}\n    impl GetSound for Cat {\n        fn get_sound(&amp;self) -&gt; String {\n            self.sound.clone()\n        }\n    }\n\nstruct Bell {\n    sound: String,\n}\n    impl GetSound for Bell {\n        fn get_sound(&amp;self) -&gt; String {\n            self.sound.clone()\n        }\n    }\n\n\nfn make_sound&lt;T: GetSound&gt;(t: &amp;T) {\n    println!(&quot;{}!&quot;, t.get_sound())\n}\n\nfn main() {\n    let kitty = Cat { sound: &quot;Meow&quot;.to_string() };\n    let the_bell = Bell { sound: &quot;Ding Dong&quot;.to_string() };\n\n    make_sound(&amp;kitty); // Meow!\n    make_sound(&amp;the_bell); // Ding Dong!\n}\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<p>üí° When we discussed about <strong>C-like structs</strong>, I mentioned that those are <strong>similar to classes</strong> in OOP languages <strong>but without their methods</strong>. <strong>impls</strong> are <strong>used to define methods</strong> for Rust structs and enums.</p>\n<p>üí° <strong>Traits</strong> are kind of <strong>similar to interfaces</strong> in OOP languages. They are used to define the functionality a type must provide. Multiple traits can be implemented for a single type.</p>\n<p>‚≠êÔ∏èÔ∏è But traits <strong>can also include default implementations of methods</strong>. Default methods can be overridden when implementing types.</p>\n<h3 id=\"Impls-without-traits\"><a href=\"#Impls-without-traits\" class=\"headerlink\" title=\"Impls without traits\"></a>Impls without traits</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Player {\n    first_name: String,\n    last_name: String,\n}\n\nimpl Player {\n    fn full_name(&amp;self) -&gt; String {\n        format!(&quot;{} {}&quot;, self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_1 = Player {\n        first_name: &quot;Rafael&quot;.to_string(),\n        last_name: &quot;Nadal&quot;.to_string(),\n    };\n\n    println!(&quot;Player 01: {}&quot;, player_1.full_name());\n}\n\n// ‚≠êÔ∏è Implementation must appear in the same crate as the self type\n\n// üí° And also in Rust, new traits can be implemented for existing types even for types like i8, f64 and etc.\n// Same way existing traits can be implemented for new types you are creating.\n// But we can not implement existing traits into existing types.\n</code></pre>\n<h3 id=\"Impls-amp-traits-without-default-methods\"><a href=\"#Impls-amp-traits-without-default-methods\" class=\"headerlink\" title=\"Impls &amp; traits, without default methods\"></a>Impls &amp; traits, without default methods</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Player {\n    first_name: String,\n    last_name: String,\n}\n\ntrait FullName {\n    fn full_name(&amp;self) -&gt; String;\n}\n\nimpl FullName for Player {\n    fn full_name(&amp;self) -&gt; String {\n        format!(&quot;{} {}&quot;, self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_2 = Player {\n        first_name: &quot;Roger&quot;.to_string(),\n        last_name: &quot;Federer&quot;.to_string(),\n    };\n\n    println!(&quot;Player 02: {}&quot;, player_2.full_name());\n}\n\n// üîé Other than functions, traits can contain constants and types.\n</code></pre>\n<h3 id=\"Impls-traits-amp-default-methods\"><a href=\"#Impls-traits-amp-default-methods\" class=\"headerlink\" title=\"Impls, traits &amp; default methods\"></a>Impls, traits &amp; default methods</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">trait Foo {\n    fn bar(&amp;self);\n    fn baz(&amp;self) { println!(&quot;We called baz.&quot;); }\n}\n</code></pre>\n<p>‚≠êÔ∏è As you can see methods take a <strong>special first parameter</strong>, the type itself. It can be <strong>either self, &amp;self, or &amp;mut self</strong>; self if it‚Äôs a value on the stack (taking ownership), &amp;self if it‚Äôs a reference, and &amp;mut self if it‚Äôs a mutable reference.</p>\n<h3 id=\"Impls-with-Associated-functions\"><a href=\"#Impls-with-Associated-functions\" class=\"headerlink\" title=\"Impls with Associated functions\"></a>Impls with Associated functions</h3><p>Some other languages support <strong>static methods</strong>. At such times, we <strong>call a function directly</strong> through the class without creating an object. In Rust, we call them Associated Functions. we use <strong>::</strong>  instead of . when calling them from the struct.<br>ex. <code>Person::new(‚ÄúElon Musk Jr‚Äù);</code></p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Player {\n    first_name: String,\n    last_name: String,\n}\n\nimpl Player {\n    fn new(first_name: String, last_name: String) -&gt; Player {\n        Player {\n            first_name : first_name,\n            last_name : last_name,\n        }\n    }\n\n    fn full_name(&amp;self) -&gt; String {\n        format!(&quot;{} {}&quot;, self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_name = Player::new(&quot;Serena&quot;.to_string(), &quot;Williams&quot;.to_string()).full_name();\n    println!(&quot;Player: {}&quot;, player_name);\n}\n\n// We have used :: notation for `new()` and . notation for `full_name()`\n\n// üîé Also in here, instead of using new() and full_name() separately as two expressions, \n// we can use Method Chaining. ex. `player.add_points(2).get_point_count();`\n</code></pre>\n<h3 id=\"Traits-with-generics\"><a href=\"#Traits-with-generics\" class=\"headerlink\" title=\"Traits with generics\"></a>Traits with generics</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">trait From&lt;T&gt; {\n    fn from(T) -&gt; Self;\n}\n    impl From&lt;u8&gt; for u16 {\n        //...\n    }\n    impl From&lt;u8&gt; for u32{\n        //...\n    }\n\n// Should specify after the trait name like generic functions\n</code></pre>\n<h3 id=\"Traits-inheritance\"><a href=\"#Traits-inheritance\" class=\"headerlink\" title=\"Traits inheritance\"></a>Traits inheritance</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">trait Person {\n    fn full_name(&amp;self) -&gt; String;\n}\n\n    trait Employee : Person { // Employee inherits from person trait\n      fn job_title(&amp;self) -&gt; String;\n    }\n\n    trait ExpatEmployee : Employee + Expat { // ExpatEmployee inherits from Employee and Expat traits\n      fn additional_tax(&amp;self) -&gt; f64;\n    }\n</code></pre>\n<h3 id=\"Trait-objects\"><a href=\"#Trait-objects\" class=\"headerlink\" title=\"Trait objects\"></a>Trait objects</h3><p>üîé While Rust favors static dispatch, it also supports dynamic dispatch through a mechanism called ‚Äòtrait objects.‚Äô</p>\n<blockquote>\n<p><a href=\"https://en.wikipedia.org/wiki/Dynamic_dispatch\" target=\"_blank\" rel=\"noopener\">üÖÜ</a> <strong>Dynamic dispatch</strong> is the process of selecting which implementation of a polymorphic operation (method or function) to call at run time.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">trait GetSound {\n    fn get_sound(&amp;self) -&gt; String;\n}\n\nstruct Cat {\n    sound: String,\n}\n    impl GetSound for Cat {\n        fn get_sound(&amp;self) -&gt; String {\n            self.sound.clone()\n        }\n    }\n\nstruct Bell {\n    sound: String,\n}\n    impl GetSound for Bell {\n        fn get_sound(&amp;self) -&gt; String {\n            self.sound.clone()\n        }\n    }\n\n\nfn make_sound&lt;T: GetSound&gt;(t: &amp;T) {\n    println!(&quot;{}!&quot;, t.get_sound())\n}\n\nfn main() {\n    let kitty = Cat { sound: &quot;Meow&quot;.to_string() };\n    let the_bell = Bell { sound: &quot;Ding Dong&quot;.to_string() };\n\n    make_sound(&amp;kitty); // Meow!\n    make_sound(&amp;the_bell); // Ding Dong!\n}\n</code></pre>\n"},{"title":"Ownership","_content":"\n```rust\nfn main() {\n    let a = [1, 2, 3];\n    let b = a;\n    println!(\"{:?} {:?}\", a, b); // [1, 2, 3] [1, 2, 3]\n}\n\nfn main() {\n    let a = vec![1, 2, 3];\n    let b = a;\n    println!(\"{:?} {:?}\", a, b); // Error; use of moved value: `a`\n}\n```\n\nIn the above examples, we are just trying to **assign the value of `a` to `b`** . Almost the same code in both code blocks, but having **two different data types**. And the second one gives an error. This is because of the **Ownership**.\n\n\n## What is ownership?\n\n‚≠êÔ∏è Variable bindings have **ownership** of what they‚Äôre bound to. A piece of data can only have **one owner at a time**. When a binding goes out of scope, Rust will free the bound resources. This is how Rust achieves **memory safety**.\n\n> [Ownership \\(noun\\)](https://github.com/nikomatsakis/rust-tutorials-keynote/blob/master/Ownership%20and%20Borrowing.pdf)  \n> The act, state, or right of possessing something.\n\n## Copy types & move types\n‚≠êÔ∏è **When assigning** a variable binding to another variable binding **or when passing it to a function**\\(Without referencing\\), if its data type is a\n\n1. **Copy Type**\n   * Bound resources are **made a copy and assign** or pass it to the function.\n   * The ownership state of the original bindings is set to **‚Äúcopied‚Äù state**.\n   * **Mostly Primitive types**\n   \n2. **Move type**\n   * Bound resources are **moved** to the new variable binding and we **can not access the original variable binding** anymore.\n   * The ownership state of the original bindings is set to **‚Äúmoved‚Äù state**.\n   * **Non-primitive types**\n\n> üîé The functionality of a type is handled by the traits which have been implemented to it. By default, variable bindings have ‚Äòmove semantics.‚Äô However, if a type implements [**`core::marker::Copy trait`**](https://doc.rust-lang.org/core/marker/trait.Copy.html) , it has a 'copy semantics'.\n\n\nüí° **So in the above second example, ownership of the Vec object moves to `b` and `a` doesn‚Äôt have any ownership to access the resource.**\n","source":"docs/c1.ownership.md","raw":"title: Ownership\n---\n\n```rust\nfn main() {\n    let a = [1, 2, 3];\n    let b = a;\n    println!(\"{:?} {:?}\", a, b); // [1, 2, 3] [1, 2, 3]\n}\n\nfn main() {\n    let a = vec![1, 2, 3];\n    let b = a;\n    println!(\"{:?} {:?}\", a, b); // Error; use of moved value: `a`\n}\n```\n\nIn the above examples, we are just trying to **assign the value of `a` to `b`** . Almost the same code in both code blocks, but having **two different data types**. And the second one gives an error. This is because of the **Ownership**.\n\n\n## What is ownership?\n\n‚≠êÔ∏è Variable bindings have **ownership** of what they‚Äôre bound to. A piece of data can only have **one owner at a time**. When a binding goes out of scope, Rust will free the bound resources. This is how Rust achieves **memory safety**.\n\n> [Ownership \\(noun\\)](https://github.com/nikomatsakis/rust-tutorials-keynote/blob/master/Ownership%20and%20Borrowing.pdf)  \n> The act, state, or right of possessing something.\n\n## Copy types & move types\n‚≠êÔ∏è **When assigning** a variable binding to another variable binding **or when passing it to a function**\\(Without referencing\\), if its data type is a\n\n1. **Copy Type**\n   * Bound resources are **made a copy and assign** or pass it to the function.\n   * The ownership state of the original bindings is set to **‚Äúcopied‚Äù state**.\n   * **Mostly Primitive types**\n   \n2. **Move type**\n   * Bound resources are **moved** to the new variable binding and we **can not access the original variable binding** anymore.\n   * The ownership state of the original bindings is set to **‚Äúmoved‚Äù state**.\n   * **Non-primitive types**\n\n> üîé The functionality of a type is handled by the traits which have been implemented to it. By default, variable bindings have ‚Äòmove semantics.‚Äô However, if a type implements [**`core::marker::Copy trait`**](https://doc.rust-lang.org/core/marker/trait.Copy.html) , it has a 'copy semantics'.\n\n\nüí° **So in the above second example, ownership of the Vec object moves to `b` and `a` doesn‚Äôt have any ownership to access the resource.**\n","date":"2019-03-19T14:50:39.953Z","updated":"2019-03-19T14:50:39.953Z","path":"docs/c1.ownership.html","comments":1,"layout":"page","_id":"cjtfwbizh000gdwgp7hdhtev9","content":"<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let a = [1, 2, 3];\n    let b = a;\n    println!(&quot;{:?} {:?}&quot;, a, b); // [1, 2, 3] [1, 2, 3]\n}\n\nfn main() {\n    let a = vec![1, 2, 3];\n    let b = a;\n    println!(&quot;{:?} {:?}&quot;, a, b); // Error; use of moved value: `a`\n}\n</code></pre>\n<p>In the above examples, we are just trying to <strong>assign the value of <code>a</code> to <code>b</code></strong> . Almost the same code in both code blocks, but having <strong>two different data types</strong>. And the second one gives an error. This is because of the <strong>Ownership</strong>.</p>\n<h2 id=\"What-is-ownership\"><a href=\"#What-is-ownership\" class=\"headerlink\" title=\"What is ownership?\"></a>What is ownership?</h2><p>‚≠êÔ∏è Variable bindings have <strong>ownership</strong> of what they‚Äôre bound to. A piece of data can only have <strong>one owner at a time</strong>. When a binding goes out of scope, Rust will free the bound resources. This is how Rust achieves <strong>memory safety</strong>.</p>\n<blockquote>\n<p><a href=\"https://github.com/nikomatsakis/rust-tutorials-keynote/blob/master/Ownership%20and%20Borrowing.pdf\" target=\"_blank\" rel=\"noopener\">Ownership (noun)</a><br>The act, state, or right of possessing something.</p>\n</blockquote>\n<h2 id=\"Copy-types-amp-move-types\"><a href=\"#Copy-types-amp-move-types\" class=\"headerlink\" title=\"Copy types &amp; move types\"></a>Copy types &amp; move types</h2><p>‚≠êÔ∏è <strong>When assigning</strong> a variable binding to another variable binding <strong>or when passing it to a function</strong>(Without referencing), if its data type is a</p>\n<ol>\n<li><p><strong>Copy Type</strong></p>\n<ul>\n<li>Bound resources are <strong>made a copy and assign</strong> or pass it to the function.</li>\n<li>The ownership state of the original bindings is set to <strong>‚Äúcopied‚Äù state</strong>.</li>\n<li><strong>Mostly Primitive types</strong></li>\n</ul>\n</li>\n<li><p><strong>Move type</strong></p>\n<ul>\n<li>Bound resources are <strong>moved</strong> to the new variable binding and we <strong>can not access the original variable binding</strong> anymore.</li>\n<li>The ownership state of the original bindings is set to <strong>‚Äúmoved‚Äù state</strong>.</li>\n<li><strong>Non-primitive types</strong></li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>üîé The functionality of a type is handled by the traits which have been implemented to it. By default, variable bindings have ‚Äòmove semantics.‚Äô However, if a type implements <a href=\"https://doc.rust-lang.org/core/marker/trait.Copy.html\" target=\"_blank\" rel=\"noopener\"><strong><code>core::marker::Copy trait</code></strong></a> , it has a ‚Äòcopy semantics‚Äô.</p>\n</blockquote>\n<p>üí° <strong>So in the above second example, ownership of the Vec object moves to <code>b</code> and <code>a</code> doesn‚Äôt have any ownership to access the resource.</strong></p>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let a = [1, 2, 3];\n    let b = a;\n    println!(&quot;{:?} {:?}&quot;, a, b); // [1, 2, 3] [1, 2, 3]\n}\n\nfn main() {\n    let a = vec![1, 2, 3];\n    let b = a;\n    println!(&quot;{:?} {:?}&quot;, a, b); // Error; use of moved value: `a`\n}\n</code></pre>\n<p>In the above examples, we are just trying to <strong>assign the value of <code>a</code> to <code>b</code></strong> . Almost the same code in both code blocks, but having <strong>two different data types</strong>. And the second one gives an error. This is because of the <strong>Ownership</strong>.</p>\n<h2 id=\"What-is-ownership\"><a href=\"#What-is-ownership\" class=\"headerlink\" title=\"What is ownership?\"></a>What is ownership?</h2><p>‚≠êÔ∏è Variable bindings have <strong>ownership</strong> of what they‚Äôre bound to. A piece of data can only have <strong>one owner at a time</strong>. When a binding goes out of scope, Rust will free the bound resources. This is how Rust achieves <strong>memory safety</strong>.</p>\n<blockquote>\n<p><a href=\"https://github.com/nikomatsakis/rust-tutorials-keynote/blob/master/Ownership%20and%20Borrowing.pdf\" target=\"_blank\" rel=\"noopener\">Ownership (noun)</a><br>The act, state, or right of possessing something.</p>\n</blockquote>\n<h2 id=\"Copy-types-amp-move-types\"><a href=\"#Copy-types-amp-move-types\" class=\"headerlink\" title=\"Copy types &amp; move types\"></a>Copy types &amp; move types</h2><p>‚≠êÔ∏è <strong>When assigning</strong> a variable binding to another variable binding <strong>or when passing it to a function</strong>(Without referencing), if its data type is a</p>\n<ol>\n<li><p><strong>Copy Type</strong></p>\n<ul>\n<li>Bound resources are <strong>made a copy and assign</strong> or pass it to the function.</li>\n<li>The ownership state of the original bindings is set to <strong>‚Äúcopied‚Äù state</strong>.</li>\n<li><strong>Mostly Primitive types</strong></li>\n</ul>\n</li>\n<li><p><strong>Move type</strong></p>\n<ul>\n<li>Bound resources are <strong>moved</strong> to the new variable binding and we <strong>can not access the original variable binding</strong> anymore.</li>\n<li>The ownership state of the original bindings is set to <strong>‚Äúmoved‚Äù state</strong>.</li>\n<li><strong>Non-primitive types</strong></li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>üîé The functionality of a type is handled by the traits which have been implemented to it. By default, variable bindings have ‚Äòmove semantics.‚Äô However, if a type implements <a href=\"https://doc.rust-lang.org/core/marker/trait.Copy.html\" target=\"_blank\" rel=\"noopener\"><strong><code>core::marker::Copy trait</code></strong></a> , it has a ‚Äòcopy semantics‚Äô.</p>\n</blockquote>\n<p>üí° <strong>So in the above second example, ownership of the Vec object moves to <code>b</code> and <code>a</code> doesn‚Äôt have any ownership to access the resource.</strong></p>\n"},{"title":"Borrowing","_content":"\nIn real life applications, most of the times we have to pass variable bindings to other functions or assign them to other variable bindings. In this case, we are **referencing** the original binding; **borrow** the data of it.\n\n## What is Borrowing?\n\n> [Borrow \\(verb\\)](https://github.com/nikomatsakis/rust-tutorials-keynote/blob/master/Ownership%20and%20Borrowing.pdf)  \n> To receive something with the promise of returning it.\n\n## Shared & Mutable borrowings\n\n‚≠êÔ∏è There are two types of Borrowing,\n\n1. **Shared Borrowing** `(&T)`\n\n   * A piece of data can be **borrowed by a single or multiple users**, but **data should not be altered**.\n\n2. **Mutable Borrowing** `(&mut T)`\n\n   * A piece of data can be **borrowed and altered by a single user**, but the data should not be accessible for any other users at that time.\n\n## Rules for borrowings\n\nThere are very important rules regarding borrowing,\n\n1. One piece of data can be borrowed **either** as a shared borrow **or** as a mutable borrow **at a given time. But not both at the same time**.\n\n2. Borrowing **applies for both copy types and move types**.\n\n3. The concept of **Liveness** ‚Ü¥\n\n```rust\nfn main() {\n  let mut a = vec![1, 2, 3];\n  let b = &mut a;  //  &mut borrow of `a` starts here\n                   //  ‚Åù\n  // some code     //  ‚Åù\n  // some code     //  ‚Åù\n}                  //  &mut borrow of `a` ends here\n\n\nfn main() {\n  let mut a = vec![1, 2, 3];\n  let b = &mut a;  //  &mut borrow of `a` starts here\n  // some code\n\n  println!(\"{:?}\", a); // trying to access `a` as a shared borrow, so giving an error\n}                  //  &mut borrow of `a` ends here\n\n\nfn main() {\n  let mut a = vec![1, 2, 3];\n  {\n    let b = &mut a;  //  &mut borrow of `a` starts here\n    // any other code\n  }                  //  &mut borrow of `a` ends here\n\n  println!(\"{:?}\", a); // allow borrowing `a` as a shared borrow\n}\n```\n\nüí° Let‚Äôs see how to use shared and mutable borrowings in examples.\n\n### Examples for Shared Borrowing\n\n```rust\nfn main() {\n    let a = [1, 2, 3];\n    let b = &a;\n    println!(\"{:?} {}\", a, b[0]); // [1, 2, 3] 1\n}\n\n\nfn main() {\n    let a = vec![1, 2, 3];\n    let b = get_first_element(&a);\n\n    println!(\"{:?} {}\", a, b); // [1, 2, 3] 1\n}\n\nfn get_first_element(a: &Vec<i32>) -> i32 {\n    a[0]\n}\n```\n\n### Examples for Mutable Borrowing\n\n```rust\nfn main() {\n    let mut a = [1, 2, 3];\n    let b = &mut a;\n    b[0] = 4;\n    println!(\"{:?}\", b); // [4, 2, 3]\n}\n\n\nfn main() {\n    let mut a = [1, 2, 3];\n    {\n        let b = &mut a;\n        b[0] = 4;\n    }\n\n    println!(\"{:?}\", a); // [4, 2, 3]\n}\n\n\nfn main() {\n    let mut a = vec![1, 2, 3];\n    let b = change_and_get_first_element(&mut a);\n\n    println!(\"{:?} {}\", a, b); // [4, 2, 3] 4\n}\n\nfn change_and_get_first_element(a: &mut Vec<i32>) -> i32 {\n    a[0] = 4;\n    a[0]\n}\n```\n","source":"docs/c2.borrowing.md","raw":"title: Borrowing\n---\n\nIn real life applications, most of the times we have to pass variable bindings to other functions or assign them to other variable bindings. In this case, we are **referencing** the original binding; **borrow** the data of it.\n\n## What is Borrowing?\n\n> [Borrow \\(verb\\)](https://github.com/nikomatsakis/rust-tutorials-keynote/blob/master/Ownership%20and%20Borrowing.pdf)  \n> To receive something with the promise of returning it.\n\n## Shared & Mutable borrowings\n\n‚≠êÔ∏è There are two types of Borrowing,\n\n1. **Shared Borrowing** `(&T)`\n\n   * A piece of data can be **borrowed by a single or multiple users**, but **data should not be altered**.\n\n2. **Mutable Borrowing** `(&mut T)`\n\n   * A piece of data can be **borrowed and altered by a single user**, but the data should not be accessible for any other users at that time.\n\n## Rules for borrowings\n\nThere are very important rules regarding borrowing,\n\n1. One piece of data can be borrowed **either** as a shared borrow **or** as a mutable borrow **at a given time. But not both at the same time**.\n\n2. Borrowing **applies for both copy types and move types**.\n\n3. The concept of **Liveness** ‚Ü¥\n\n```rust\nfn main() {\n  let mut a = vec![1, 2, 3];\n  let b = &mut a;  //  &mut borrow of `a` starts here\n                   //  ‚Åù\n  // some code     //  ‚Åù\n  // some code     //  ‚Åù\n}                  //  &mut borrow of `a` ends here\n\n\nfn main() {\n  let mut a = vec![1, 2, 3];\n  let b = &mut a;  //  &mut borrow of `a` starts here\n  // some code\n\n  println!(\"{:?}\", a); // trying to access `a` as a shared borrow, so giving an error\n}                  //  &mut borrow of `a` ends here\n\n\nfn main() {\n  let mut a = vec![1, 2, 3];\n  {\n    let b = &mut a;  //  &mut borrow of `a` starts here\n    // any other code\n  }                  //  &mut borrow of `a` ends here\n\n  println!(\"{:?}\", a); // allow borrowing `a` as a shared borrow\n}\n```\n\nüí° Let‚Äôs see how to use shared and mutable borrowings in examples.\n\n### Examples for Shared Borrowing\n\n```rust\nfn main() {\n    let a = [1, 2, 3];\n    let b = &a;\n    println!(\"{:?} {}\", a, b[0]); // [1, 2, 3] 1\n}\n\n\nfn main() {\n    let a = vec![1, 2, 3];\n    let b = get_first_element(&a);\n\n    println!(\"{:?} {}\", a, b); // [1, 2, 3] 1\n}\n\nfn get_first_element(a: &Vec<i32>) -> i32 {\n    a[0]\n}\n```\n\n### Examples for Mutable Borrowing\n\n```rust\nfn main() {\n    let mut a = [1, 2, 3];\n    let b = &mut a;\n    b[0] = 4;\n    println!(\"{:?}\", b); // [4, 2, 3]\n}\n\n\nfn main() {\n    let mut a = [1, 2, 3];\n    {\n        let b = &mut a;\n        b[0] = 4;\n    }\n\n    println!(\"{:?}\", a); // [4, 2, 3]\n}\n\n\nfn main() {\n    let mut a = vec![1, 2, 3];\n    let b = change_and_get_first_element(&mut a);\n\n    println!(\"{:?} {}\", a, b); // [4, 2, 3] 4\n}\n\nfn change_and_get_first_element(a: &mut Vec<i32>) -> i32 {\n    a[0] = 4;\n    a[0]\n}\n```\n","date":"2019-03-19T14:50:39.953Z","updated":"2019-03-19T14:50:39.953Z","path":"docs/c2.borrowing.html","comments":1,"layout":"page","_id":"cjtfwbizh000hdwgp3yadp9r6","content":"<p>In real life applications, most of the times we have to pass variable bindings to other functions or assign them to other variable bindings. In this case, we are <strong>referencing</strong> the original binding; <strong>borrow</strong> the data of it.</p>\n<h2 id=\"What-is-Borrowing\"><a href=\"#What-is-Borrowing\" class=\"headerlink\" title=\"What is Borrowing?\"></a>What is Borrowing?</h2><blockquote>\n<p><a href=\"https://github.com/nikomatsakis/rust-tutorials-keynote/blob/master/Ownership%20and%20Borrowing.pdf\" target=\"_blank\" rel=\"noopener\">Borrow (verb)</a><br>To receive something with the promise of returning it.</p>\n</blockquote>\n<h2 id=\"Shared-amp-Mutable-borrowings\"><a href=\"#Shared-amp-Mutable-borrowings\" class=\"headerlink\" title=\"Shared &amp; Mutable borrowings\"></a>Shared &amp; Mutable borrowings</h2><p>‚≠êÔ∏è There are two types of Borrowing,</p>\n<ol>\n<li><p><strong>Shared Borrowing</strong> <code>(&amp;T)</code></p>\n<ul>\n<li>A piece of data can be <strong>borrowed by a single or multiple users</strong>, but <strong>data should not be altered</strong>.</li>\n</ul>\n</li>\n<li><p><strong>Mutable Borrowing</strong> <code>(&amp;mut T)</code></p>\n<ul>\n<li>A piece of data can be <strong>borrowed and altered by a single user</strong>, but the data should not be accessible for any other users at that time.</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"Rules-for-borrowings\"><a href=\"#Rules-for-borrowings\" class=\"headerlink\" title=\"Rules for borrowings\"></a>Rules for borrowings</h2><p>There are very important rules regarding borrowing,</p>\n<ol>\n<li><p>One piece of data can be borrowed <strong>either</strong> as a shared borrow <strong>or</strong> as a mutable borrow <strong>at a given time. But not both at the same time</strong>.</p>\n</li>\n<li><p>Borrowing <strong>applies for both copy types and move types</strong>.</p>\n</li>\n<li><p>The concept of <strong>Liveness</strong> ‚Ü¥</p>\n</li>\n</ol>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n  let mut a = vec![1, 2, 3];\n  let b = &amp;mut a;  //  &amp;mut borrow of `a` starts here\n                   //  ‚Åù\n  // some code     //  ‚Åù\n  // some code     //  ‚Åù\n}                  //  &amp;mut borrow of `a` ends here\n\n\nfn main() {\n  let mut a = vec![1, 2, 3];\n  let b = &amp;mut a;  //  &amp;mut borrow of `a` starts here\n  // some code\n\n  println!(&quot;{:?}&quot;, a); // trying to access `a` as a shared borrow, so giving an error\n}                  //  &amp;mut borrow of `a` ends here\n\n\nfn main() {\n  let mut a = vec![1, 2, 3];\n  {\n    let b = &amp;mut a;  //  &amp;mut borrow of `a` starts here\n    // any other code\n  }                  //  &amp;mut borrow of `a` ends here\n\n  println!(&quot;{:?}&quot;, a); // allow borrowing `a` as a shared borrow\n}\n</code></pre>\n<p>üí° Let‚Äôs see how to use shared and mutable borrowings in examples.</p>\n<h3 id=\"Examples-for-Shared-Borrowing\"><a href=\"#Examples-for-Shared-Borrowing\" class=\"headerlink\" title=\"Examples for Shared Borrowing\"></a>Examples for Shared Borrowing</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let a = [1, 2, 3];\n    let b = &amp;a;\n    println!(&quot;{:?} {}&quot;, a, b[0]); // [1, 2, 3] 1\n}\n\n\nfn main() {\n    let a = vec![1, 2, 3];\n    let b = get_first_element(&amp;a);\n\n    println!(&quot;{:?} {}&quot;, a, b); // [1, 2, 3] 1\n}\n\nfn get_first_element(a: &amp;Vec&lt;i32&gt;) -&gt; i32 {\n    a[0]\n}\n</code></pre>\n<h3 id=\"Examples-for-Mutable-Borrowing\"><a href=\"#Examples-for-Mutable-Borrowing\" class=\"headerlink\" title=\"Examples for Mutable Borrowing\"></a>Examples for Mutable Borrowing</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let mut a = [1, 2, 3];\n    let b = &amp;mut a;\n    b[0] = 4;\n    println!(&quot;{:?}&quot;, b); // [4, 2, 3]\n}\n\n\nfn main() {\n    let mut a = [1, 2, 3];\n    {\n        let b = &amp;mut a;\n        b[0] = 4;\n    }\n\n    println!(&quot;{:?}&quot;, a); // [4, 2, 3]\n}\n\n\nfn main() {\n    let mut a = vec![1, 2, 3];\n    let b = change_and_get_first_element(&amp;mut a);\n\n    println!(&quot;{:?} {}&quot;, a, b); // [4, 2, 3] 4\n}\n\nfn change_and_get_first_element(a: &amp;mut Vec&lt;i32&gt;) -&gt; i32 {\n    a[0] = 4;\n    a[0]\n}\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<p>In real life applications, most of the times we have to pass variable bindings to other functions or assign them to other variable bindings. In this case, we are <strong>referencing</strong> the original binding; <strong>borrow</strong> the data of it.</p>\n<h2 id=\"What-is-Borrowing\"><a href=\"#What-is-Borrowing\" class=\"headerlink\" title=\"What is Borrowing?\"></a>What is Borrowing?</h2><blockquote>\n<p><a href=\"https://github.com/nikomatsakis/rust-tutorials-keynote/blob/master/Ownership%20and%20Borrowing.pdf\" target=\"_blank\" rel=\"noopener\">Borrow (verb)</a><br>To receive something with the promise of returning it.</p>\n</blockquote>\n<h2 id=\"Shared-amp-Mutable-borrowings\"><a href=\"#Shared-amp-Mutable-borrowings\" class=\"headerlink\" title=\"Shared &amp; Mutable borrowings\"></a>Shared &amp; Mutable borrowings</h2><p>‚≠êÔ∏è There are two types of Borrowing,</p>\n<ol>\n<li><p><strong>Shared Borrowing</strong> <code>(&amp;T)</code></p>\n<ul>\n<li>A piece of data can be <strong>borrowed by a single or multiple users</strong>, but <strong>data should not be altered</strong>.</li>\n</ul>\n</li>\n<li><p><strong>Mutable Borrowing</strong> <code>(&amp;mut T)</code></p>\n<ul>\n<li>A piece of data can be <strong>borrowed and altered by a single user</strong>, but the data should not be accessible for any other users at that time.</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"Rules-for-borrowings\"><a href=\"#Rules-for-borrowings\" class=\"headerlink\" title=\"Rules for borrowings\"></a>Rules for borrowings</h2><p>There are very important rules regarding borrowing,</p>\n<ol>\n<li><p>One piece of data can be borrowed <strong>either</strong> as a shared borrow <strong>or</strong> as a mutable borrow <strong>at a given time. But not both at the same time</strong>.</p>\n</li>\n<li><p>Borrowing <strong>applies for both copy types and move types</strong>.</p>\n</li>\n<li><p>The concept of <strong>Liveness</strong> ‚Ü¥</p>\n</li>\n</ol>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n  let mut a = vec![1, 2, 3];\n  let b = &amp;mut a;  //  &amp;mut borrow of `a` starts here\n                   //  ‚Åù\n  // some code     //  ‚Åù\n  // some code     //  ‚Åù\n}                  //  &amp;mut borrow of `a` ends here\n\n\nfn main() {\n  let mut a = vec![1, 2, 3];\n  let b = &amp;mut a;  //  &amp;mut borrow of `a` starts here\n  // some code\n\n  println!(&quot;{:?}&quot;, a); // trying to access `a` as a shared borrow, so giving an error\n}                  //  &amp;mut borrow of `a` ends here\n\n\nfn main() {\n  let mut a = vec![1, 2, 3];\n  {\n    let b = &amp;mut a;  //  &amp;mut borrow of `a` starts here\n    // any other code\n  }                  //  &amp;mut borrow of `a` ends here\n\n  println!(&quot;{:?}&quot;, a); // allow borrowing `a` as a shared borrow\n}\n</code></pre>\n<p>üí° Let‚Äôs see how to use shared and mutable borrowings in examples.</p>\n<h3 id=\"Examples-for-Shared-Borrowing\"><a href=\"#Examples-for-Shared-Borrowing\" class=\"headerlink\" title=\"Examples for Shared Borrowing\"></a>Examples for Shared Borrowing</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let a = [1, 2, 3];\n    let b = &amp;a;\n    println!(&quot;{:?} {}&quot;, a, b[0]); // [1, 2, 3] 1\n}\n\n\nfn main() {\n    let a = vec![1, 2, 3];\n    let b = get_first_element(&amp;a);\n\n    println!(&quot;{:?} {}&quot;, a, b); // [1, 2, 3] 1\n}\n\nfn get_first_element(a: &amp;Vec&lt;i32&gt;) -&gt; i32 {\n    a[0]\n}\n</code></pre>\n<h3 id=\"Examples-for-Mutable-Borrowing\"><a href=\"#Examples-for-Mutable-Borrowing\" class=\"headerlink\" title=\"Examples for Mutable Borrowing\"></a>Examples for Mutable Borrowing</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let mut a = [1, 2, 3];\n    let b = &amp;mut a;\n    b[0] = 4;\n    println!(&quot;{:?}&quot;, b); // [4, 2, 3]\n}\n\n\nfn main() {\n    let mut a = [1, 2, 3];\n    {\n        let b = &amp;mut a;\n        b[0] = 4;\n    }\n\n    println!(&quot;{:?}&quot;, a); // [4, 2, 3]\n}\n\n\nfn main() {\n    let mut a = vec![1, 2, 3];\n    let b = change_and_get_first_element(&amp;mut a);\n\n    println!(&quot;{:?} {}&quot;, a, b); // [4, 2, 3] 4\n}\n\nfn change_and_get_first_element(a: &amp;mut Vec&lt;i32&gt;) -&gt; i32 {\n    a[0] = 4;\n    a[0]\n}\n</code></pre>\n"},{"title":"Code Organization","_content":"\nWhen a single code block is getting larger, it should be decomposed into smaller pieces and should be organized in a proper manner. Rust supports different levels of code organization.\n\n1. ### [Functions](d2.functions.html)\n\n2. ### [Modules](d3.modules.html)\n\n  Can be mapped to a,\n  \n  - **Inline module**\n  - **File** \n  - **Directory hierarchy**\n  \n3. ### [Crates](d4.crates.html)\n\n  Can be mapped to a, \n  - **lib.rs file on the same executable crate**\n  - **Dependency crate specified on Cargo.toml**\n    \n    Can be specified from,\n    \n    - **Path**\n    - **Git repository**\n    - **crates.io**\n    \n4. ### [Workspaces](d5.workspaces.html)\n\n  Helps to manage multiple crates as a single project.\n\n\nLet‚Äôs discuss one by one.\n\n> üí° To make examples more simpler, we use a simple function which prints `‚ÄúHello, world!‚Äù`. But regarding writing testable codes, always try to return the `String` from the function and print it when calling it, instead of printing the `String` inside the function.","source":"docs/d1.code_organization.md","raw":"title: Code Organization\n---\n\nWhen a single code block is getting larger, it should be decomposed into smaller pieces and should be organized in a proper manner. Rust supports different levels of code organization.\n\n1. ### [Functions](d2.functions.html)\n\n2. ### [Modules](d3.modules.html)\n\n  Can be mapped to a,\n  \n  - **Inline module**\n  - **File** \n  - **Directory hierarchy**\n  \n3. ### [Crates](d4.crates.html)\n\n  Can be mapped to a, \n  - **lib.rs file on the same executable crate**\n  - **Dependency crate specified on Cargo.toml**\n    \n    Can be specified from,\n    \n    - **Path**\n    - **Git repository**\n    - **crates.io**\n    \n4. ### [Workspaces](d5.workspaces.html)\n\n  Helps to manage multiple crates as a single project.\n\n\nLet‚Äôs discuss one by one.\n\n> üí° To make examples more simpler, we use a simple function which prints `‚ÄúHello, world!‚Äù`. But regarding writing testable codes, always try to return the `String` from the function and print it when calling it, instead of printing the `String` inside the function.","date":"2019-03-19T14:50:39.954Z","updated":"2019-03-19T14:50:39.954Z","path":"docs/d1.code_organization.html","comments":1,"layout":"page","_id":"cjtfwbizi000idwgpb01etu4x","content":"<p>When a single code block is getting larger, it should be decomposed into smaller pieces and should be organized in a proper manner. Rust supports different levels of code organization.</p>\n<ol>\n<li><h3 id=\"Functions\"><a href=\"#Functions\" class=\"headerlink\" title=\"Functions\"></a><a href=\"d2.functions.html\">Functions</a></h3></li>\n<li><h3 id=\"Modules\"><a href=\"#Modules\" class=\"headerlink\" title=\"Modules\"></a><a href=\"d3.modules.html\">Modules</a></h3><p>Can be mapped to a,</p>\n<ul>\n<li><strong>Inline module</strong></li>\n<li><strong>File</strong> </li>\n<li><strong>Directory hierarchy</strong></li>\n</ul>\n</li>\n<li><h3 id=\"Crates\"><a href=\"#Crates\" class=\"headerlink\" title=\"Crates\"></a><a href=\"d4.crates.html\">Crates</a></h3><p>Can be mapped to a, </p>\n<ul>\n<li><strong>lib.rs file on the same executable crate</strong></li>\n<li><p><strong>Dependency crate specified on Cargo.toml</strong></p>\n<p>Can be specified from,</p>\n<ul>\n<li><strong>Path</strong></li>\n<li><strong>Git repository</strong></li>\n<li><strong>crates.io</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><h3 id=\"Workspaces\"><a href=\"#Workspaces\" class=\"headerlink\" title=\"Workspaces\"></a><a href=\"d5.workspaces.html\">Workspaces</a></h3><p>Helps to manage multiple crates as a single project.</p>\n</li>\n</ol>\n<p>Let‚Äôs discuss one by one.</p>\n<blockquote>\n<p>üí° To make examples more simpler, we use a simple function which prints <code>‚ÄúHello, world!‚Äù</code>. But regarding writing testable codes, always try to return the <code>String</code> from the function and print it when calling it, instead of printing the <code>String</code> inside the function.</p>\n</blockquote>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<p>When a single code block is getting larger, it should be decomposed into smaller pieces and should be organized in a proper manner. Rust supports different levels of code organization.</p>\n<ol>\n<li><h3 id=\"Functions\"><a href=\"#Functions\" class=\"headerlink\" title=\"Functions\"></a><a href=\"d2.functions.html\">Functions</a></h3></li>\n<li><h3 id=\"Modules\"><a href=\"#Modules\" class=\"headerlink\" title=\"Modules\"></a><a href=\"d3.modules.html\">Modules</a></h3><p>Can be mapped to a,</p>\n<ul>\n<li><strong>Inline module</strong></li>\n<li><strong>File</strong> </li>\n<li><strong>Directory hierarchy</strong></li>\n</ul>\n</li>\n<li><h3 id=\"Crates\"><a href=\"#Crates\" class=\"headerlink\" title=\"Crates\"></a><a href=\"d4.crates.html\">Crates</a></h3><p>Can be mapped to a, </p>\n<ul>\n<li><strong>lib.rs file on the same executable crate</strong></li>\n<li><p><strong>Dependency crate specified on Cargo.toml</strong></p>\n<p>Can be specified from,</p>\n<ul>\n<li><strong>Path</strong></li>\n<li><strong>Git repository</strong></li>\n<li><strong>crates.io</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><h3 id=\"Workspaces\"><a href=\"#Workspaces\" class=\"headerlink\" title=\"Workspaces\"></a><a href=\"d5.workspaces.html\">Workspaces</a></h3><p>Helps to manage multiple crates as a single project.</p>\n</li>\n</ol>\n<p>Let‚Äôs discuss one by one.</p>\n<blockquote>\n<p>üí° To make examples more simpler, we use a simple function which prints <code>‚ÄúHello, world!‚Äù</code>. But regarding writing testable codes, always try to return the <code>String</code> from the function and print it when calling it, instead of printing the <code>String</code> inside the function.</p>\n</blockquote>\n"},{"title":"Functions","_content":"\nFunctions are the first line of organization in any program.\n\n```rust\nfn main() {\n  greet(); // Do one thing\n  ask_location(); // Do another thing\n}\n\nfn greet() {\n  println!(\"Hello!\");\n}\n\nfn ask_location() {\n  println!(\"Where are you from?\");\n}\n```\n\nWe can add unit tests in the same file.\n\n```rust\nfn main() {\n    greet();\n}\n\nfn greet() -> String {\n    \"Hello, world!\".to_string()\n}\n\n#[test] // Test attribute indicates this is a test function\nfn test_greet() {\n    assert_eq!(\"Hello, world!\", greet())\n}\n\n// üí° Always put test functions inside a tests module with #[cfg(test)] attribute. \n// cfg(test) module compiles only when running tests. We discuss more about this in the next section.\n```\n\n> üí≠ An [attribute](https://doc.rust-lang.org/reference/attributes.html) is a general, free-form **metadatum** that is interpreted according to name, convention, and language and compiler version.","source":"docs/d2.functions.md","raw":"title: Functions\n---\n\nFunctions are the first line of organization in any program.\n\n```rust\nfn main() {\n  greet(); // Do one thing\n  ask_location(); // Do another thing\n}\n\nfn greet() {\n  println!(\"Hello!\");\n}\n\nfn ask_location() {\n  println!(\"Where are you from?\");\n}\n```\n\nWe can add unit tests in the same file.\n\n```rust\nfn main() {\n    greet();\n}\n\nfn greet() -> String {\n    \"Hello, world!\".to_string()\n}\n\n#[test] // Test attribute indicates this is a test function\nfn test_greet() {\n    assert_eq!(\"Hello, world!\", greet())\n}\n\n// üí° Always put test functions inside a tests module with #[cfg(test)] attribute. \n// cfg(test) module compiles only when running tests. We discuss more about this in the next section.\n```\n\n> üí≠ An [attribute](https://doc.rust-lang.org/reference/attributes.html) is a general, free-form **metadatum** that is interpreted according to name, convention, and language and compiler version.","date":"2019-03-19T14:50:39.955Z","updated":"2019-03-19T14:50:39.955Z","path":"docs/d2.functions.html","comments":1,"layout":"page","_id":"cjtfwbizj000jdwgp4vmm10iw","content":"<p>Functions are the first line of organization in any program.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n  greet(); // Do one thing\n  ask_location(); // Do another thing\n}\n\nfn greet() {\n  println!(&quot;Hello!&quot;);\n}\n\nfn ask_location() {\n  println!(&quot;Where are you from?&quot;);\n}\n</code></pre>\n<p>We can add unit tests in the same file.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    greet();\n}\n\nfn greet() -&gt; String {\n    &quot;Hello, world!&quot;.to_string()\n}\n\n#[test] // Test attribute indicates this is a test function\nfn test_greet() {\n    assert_eq!(&quot;Hello, world!&quot;, greet())\n}\n\n// üí° Always put test functions inside a tests module with #[cfg(test)] attribute. \n// cfg(test) module compiles only when running tests. We discuss more about this in the next section.\n</code></pre>\n<blockquote>\n<p>üí≠ An <a href=\"https://doc.rust-lang.org/reference/attributes.html\" target=\"_blank\" rel=\"noopener\">attribute</a> is a general, free-form <strong>metadatum</strong> that is interpreted according to name, convention, and language and compiler version.</p>\n</blockquote>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<p>Functions are the first line of organization in any program.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n  greet(); // Do one thing\n  ask_location(); // Do another thing\n}\n\nfn greet() {\n  println!(&quot;Hello!&quot;);\n}\n\nfn ask_location() {\n  println!(&quot;Where are you from?&quot;);\n}\n</code></pre>\n<p>We can add unit tests in the same file.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    greet();\n}\n\nfn greet() -&gt; String {\n    &quot;Hello, world!&quot;.to_string()\n}\n\n#[test] // Test attribute indicates this is a test function\nfn test_greet() {\n    assert_eq!(&quot;Hello, world!&quot;, greet())\n}\n\n// üí° Always put test functions inside a tests module with #[cfg(test)] attribute. \n// cfg(test) module compiles only when running tests. We discuss more about this in the next section.\n</code></pre>\n<blockquote>\n<p>üí≠ An <a href=\"https://doc.rust-lang.org/reference/attributes.html\" target=\"_blank\" rel=\"noopener\">attribute</a> is a general, free-form <strong>metadatum</strong> that is interpreted according to name, convention, and language and compiler version.</p>\n</blockquote>\n"},{"title":"Modules","_content":"\n## 01. In the same file\n\nRelated code and data are grouped into a module and stored in the same file.\n\n```rust\nfn main() {\n   greetings::hello();\n}\n\nmod greetings {\n  // ‚≠êÔ∏è By default, everything inside a module is private\n  pub fn hello() { // ‚≠êÔ∏è So function has to be public to access from outside\n    println!(\"Hello, world!\");\n  }\n}\n```\n\nModules can also be nested.\n\n```rust\nfn main() { \n  phrases::greetings::hello();\n}\n\nmod phrases { \n  pub mod greetings { \n    pub fn hello() { \n      println!(\"Hello, world!\");\n    }\n  }\n}\n```\n\nPrivate functions can be called from the same module or from a child module.\n\n```rust\n// 01. Calling private functions of the same module\nfn main() {\n  phrases::greet();\n}\n\nmod phrases {\n  pub fn greet() {\n    hello(); // Or `self::hello();`\n  }\n  \n  fn hello() {\n    println!(\"Hello, world!\");\n  }\n}\n\n// 02. Calling private functions of the parent module\nfn main() {\n  phrases::greetings::hello();\n}\n\nmod phrases {\n  fn private_fn() {\n    println!(\"Hello, world!\");\n  }\n  \n  pub mod greetings {\n    pub fn hello() {\n      super::private_fn();\n    }\n  }\n}\n```\n\n> üí° The `self` keyword is used to refer the same module, while the `super` keyword is used to refer parent module. Also, the `super` keyword can be used to access root functions from inside a module.\n\n```rust\nfn main() {\n  greetings::hello();\n}\n\nfn hello() {\n  println!(\"Hello, world!\");\n}\n\nmod greetings {\n  pub fn hello() {\n    super::hello();\n  }\n}\n```\n\n> üîé When writing tests it‚Äôs a good practice to write tests inside a test module because they compile only when running tests.\n\n```rust\nfn greet() -> String {\n    \"Hello, world!\".to_string()\n}\n\n#[cfg(test)] // Only compiles when running tests\nmod tests {\n    use super::greet; // Import root greet function\n\n    #[test]\n    fn test_greet() {\n        assert_eq!(\"Hello, world!\", greet());\n    }\n}\n```\n\n## 02. In a different file, same directory\n\n```rust\n// ‚Ü≥ main.rs\nmod greetings; // Import greetings module\n\nfn main() {\n  greetings::hello();\n}\n\n// ‚Ü≥ greetings.rs\n// ‚≠êÔ∏è No need to wrap the code with a mod declaration. The file itself acts as a module.\npub fn hello() { // The function has to be public to access from outside\n  println!(\"Hello, world!\");\n}\n```\n\nIf we wrap file content with a `mod` declaration, it will act as a nested module.\n\n```rust\n// ‚Ü≥ main.rs\nmod phrases;\n\nfn main() {\n  phrases::greetings::hello();\n}\n\n// ‚Ü≥ phrases.rs\npub mod greetings { // ‚≠êÔ∏è The module has to be public to access from outside\n  pub fn hello() {\n    println!(\"Hello, world!\");\n  }\n}\n```\n\n## 03. In a different file, different directory\n\n`mod.rs` in the directory module root is the entry point to the directory module. All other files in that directory root, act as sub-modules of the directory module.\n\n```rust\n// ‚Ü≥ main.rs\nmod greetings;\n\nfn main() {\n  greetings::hello();\n}\n\n// ‚Ü≥ greetings/mod.rs\npub fn hello() { // ‚≠êÔ∏è The function has to be public to access from outside\n  println!(\"Hello, world!\");\n}\n```\n\nAgain, If we wrap file content with a `mod` declaration, it will act as a nested module.\n\n```rust\n// ‚Ü≥ main.rs\nmod phrases;\n\nfn main() {\n  phrases::greetings::hello();\n}\n\n// ‚Ü≥ phrases/mod.rs\npub mod greetings { // ‚≠êÔ∏è The module has to be public to access from outside\n  pub fn hello() {\n    println!(\"Hello, world!\");\n  }\n}\n```\n\nOther files in the directory module act as sub-modules for `mod.rs`.\n\n```rust\n// ‚Ü≥ main.rs\nmod phrases;\n\nfn main() {\n  phrases::hello()\n}\n\n// ‚Ü≥ phrases/mod.rs\nmod greetings;\n\npub fn hello() {\n  greetings::hello()\n}\n\n// ‚Ü≥ phrases/greetings.rs\npub fn hello() {\n  println!(\"Hello, world!\");\n}\n```\n\n‚≠êÔ∏è If you need to access an element of `phrases/greetings.rs` from outside the module, you have to import the `greetings` module as a public module.\n\n```rust\n// ‚Ü≥ main.rs\nmod phrases;\n\nfn main() {\n    phrases::greetings::hello();\n}\n\n// ‚Ü≥ phrases/mod.rs\npub mod greetings;  // ‚≠êÔ∏è `pub mod` instead `mod`\n\n// ‚Ü≥ phrases/greetings.rs\npub fn hello() {\n  println!(\"Hello, world!\");\n}\n```\n\n> üîé It‚Äôs unable to import child file modules of directory modules to `main.rs`, so you can‚Äôt use `mod phrases::greetings;` from `main.rs`. But there is a way to import `phrases::greetings::hello()` to `phrases` module by re-exporting `hello` to `phrases` module. So you can call it directly as `phrases::hello()`.\n\n```rust\n// ‚Ü≥ phrases/greetings.rs\npub fn hello() {\n  println!(\"Hello, world!\");\n}\n\n// ‚Ü≥ phrases/mod.rs\npub mod greetings;\n\npub use self::greetings::hello; // Re-export `greetings::hello` to phrases\n\n// ‚Ü≥ main.rs\nmod phrases;\n\nfn main() {\n    phrases::hello(); // You can call `hello()` directly from phrases\n}\n```\n\nThis allows you to present an external interface that **may not directly map** to your internal code organization. If still it is not clear, don‚Äôt worry; We discuss the usages of `use` on an upcoming section in this post.","source":"docs/d3.modules.md","raw":"title: Modules\n---\n\n## 01. In the same file\n\nRelated code and data are grouped into a module and stored in the same file.\n\n```rust\nfn main() {\n   greetings::hello();\n}\n\nmod greetings {\n  // ‚≠êÔ∏è By default, everything inside a module is private\n  pub fn hello() { // ‚≠êÔ∏è So function has to be public to access from outside\n    println!(\"Hello, world!\");\n  }\n}\n```\n\nModules can also be nested.\n\n```rust\nfn main() { \n  phrases::greetings::hello();\n}\n\nmod phrases { \n  pub mod greetings { \n    pub fn hello() { \n      println!(\"Hello, world!\");\n    }\n  }\n}\n```\n\nPrivate functions can be called from the same module or from a child module.\n\n```rust\n// 01. Calling private functions of the same module\nfn main() {\n  phrases::greet();\n}\n\nmod phrases {\n  pub fn greet() {\n    hello(); // Or `self::hello();`\n  }\n  \n  fn hello() {\n    println!(\"Hello, world!\");\n  }\n}\n\n// 02. Calling private functions of the parent module\nfn main() {\n  phrases::greetings::hello();\n}\n\nmod phrases {\n  fn private_fn() {\n    println!(\"Hello, world!\");\n  }\n  \n  pub mod greetings {\n    pub fn hello() {\n      super::private_fn();\n    }\n  }\n}\n```\n\n> üí° The `self` keyword is used to refer the same module, while the `super` keyword is used to refer parent module. Also, the `super` keyword can be used to access root functions from inside a module.\n\n```rust\nfn main() {\n  greetings::hello();\n}\n\nfn hello() {\n  println!(\"Hello, world!\");\n}\n\nmod greetings {\n  pub fn hello() {\n    super::hello();\n  }\n}\n```\n\n> üîé When writing tests it‚Äôs a good practice to write tests inside a test module because they compile only when running tests.\n\n```rust\nfn greet() -> String {\n    \"Hello, world!\".to_string()\n}\n\n#[cfg(test)] // Only compiles when running tests\nmod tests {\n    use super::greet; // Import root greet function\n\n    #[test]\n    fn test_greet() {\n        assert_eq!(\"Hello, world!\", greet());\n    }\n}\n```\n\n## 02. In a different file, same directory\n\n```rust\n// ‚Ü≥ main.rs\nmod greetings; // Import greetings module\n\nfn main() {\n  greetings::hello();\n}\n\n// ‚Ü≥ greetings.rs\n// ‚≠êÔ∏è No need to wrap the code with a mod declaration. The file itself acts as a module.\npub fn hello() { // The function has to be public to access from outside\n  println!(\"Hello, world!\");\n}\n```\n\nIf we wrap file content with a `mod` declaration, it will act as a nested module.\n\n```rust\n// ‚Ü≥ main.rs\nmod phrases;\n\nfn main() {\n  phrases::greetings::hello();\n}\n\n// ‚Ü≥ phrases.rs\npub mod greetings { // ‚≠êÔ∏è The module has to be public to access from outside\n  pub fn hello() {\n    println!(\"Hello, world!\");\n  }\n}\n```\n\n## 03. In a different file, different directory\n\n`mod.rs` in the directory module root is the entry point to the directory module. All other files in that directory root, act as sub-modules of the directory module.\n\n```rust\n// ‚Ü≥ main.rs\nmod greetings;\n\nfn main() {\n  greetings::hello();\n}\n\n// ‚Ü≥ greetings/mod.rs\npub fn hello() { // ‚≠êÔ∏è The function has to be public to access from outside\n  println!(\"Hello, world!\");\n}\n```\n\nAgain, If we wrap file content with a `mod` declaration, it will act as a nested module.\n\n```rust\n// ‚Ü≥ main.rs\nmod phrases;\n\nfn main() {\n  phrases::greetings::hello();\n}\n\n// ‚Ü≥ phrases/mod.rs\npub mod greetings { // ‚≠êÔ∏è The module has to be public to access from outside\n  pub fn hello() {\n    println!(\"Hello, world!\");\n  }\n}\n```\n\nOther files in the directory module act as sub-modules for `mod.rs`.\n\n```rust\n// ‚Ü≥ main.rs\nmod phrases;\n\nfn main() {\n  phrases::hello()\n}\n\n// ‚Ü≥ phrases/mod.rs\nmod greetings;\n\npub fn hello() {\n  greetings::hello()\n}\n\n// ‚Ü≥ phrases/greetings.rs\npub fn hello() {\n  println!(\"Hello, world!\");\n}\n```\n\n‚≠êÔ∏è If you need to access an element of `phrases/greetings.rs` from outside the module, you have to import the `greetings` module as a public module.\n\n```rust\n// ‚Ü≥ main.rs\nmod phrases;\n\nfn main() {\n    phrases::greetings::hello();\n}\n\n// ‚Ü≥ phrases/mod.rs\npub mod greetings;  // ‚≠êÔ∏è `pub mod` instead `mod`\n\n// ‚Ü≥ phrases/greetings.rs\npub fn hello() {\n  println!(\"Hello, world!\");\n}\n```\n\n> üîé It‚Äôs unable to import child file modules of directory modules to `main.rs`, so you can‚Äôt use `mod phrases::greetings;` from `main.rs`. But there is a way to import `phrases::greetings::hello()` to `phrases` module by re-exporting `hello` to `phrases` module. So you can call it directly as `phrases::hello()`.\n\n```rust\n// ‚Ü≥ phrases/greetings.rs\npub fn hello() {\n  println!(\"Hello, world!\");\n}\n\n// ‚Ü≥ phrases/mod.rs\npub mod greetings;\n\npub use self::greetings::hello; // Re-export `greetings::hello` to phrases\n\n// ‚Ü≥ main.rs\nmod phrases;\n\nfn main() {\n    phrases::hello(); // You can call `hello()` directly from phrases\n}\n```\n\nThis allows you to present an external interface that **may not directly map** to your internal code organization. If still it is not clear, don‚Äôt worry; We discuss the usages of `use` on an upcoming section in this post.","date":"2019-03-19T14:50:39.955Z","updated":"2019-03-19T14:50:39.955Z","path":"docs/d3.modules.html","comments":1,"layout":"page","_id":"cjtfwbizj000kdwgplfqu4o1n","content":"<h2 id=\"01-In-the-same-file\"><a href=\"#01-In-the-same-file\" class=\"headerlink\" title=\"01. In the same file\"></a>01. In the same file</h2><p>Related code and data are grouped into a module and stored in the same file.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n   greetings::hello();\n}\n\nmod greetings {\n  // ‚≠êÔ∏è By default, everything inside a module is private\n  pub fn hello() { // ‚≠êÔ∏è So function has to be public to access from outside\n    println!(&quot;Hello, world!&quot;);\n  }\n}\n</code></pre>\n<p>Modules can also be nested.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() { \n  phrases::greetings::hello();\n}\n\nmod phrases { \n  pub mod greetings { \n    pub fn hello() { \n      println!(&quot;Hello, world!&quot;);\n    }\n  }\n}\n</code></pre>\n<p>Private functions can be called from the same module or from a child module.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// 01. Calling private functions of the same module\nfn main() {\n  phrases::greet();\n}\n\nmod phrases {\n  pub fn greet() {\n    hello(); // Or `self::hello();`\n  }\n\n  fn hello() {\n    println!(&quot;Hello, world!&quot;);\n  }\n}\n\n// 02. Calling private functions of the parent module\nfn main() {\n  phrases::greetings::hello();\n}\n\nmod phrases {\n  fn private_fn() {\n    println!(&quot;Hello, world!&quot;);\n  }\n\n  pub mod greetings {\n    pub fn hello() {\n      super::private_fn();\n    }\n  }\n}\n</code></pre>\n<blockquote>\n<p>üí° The <code>self</code> keyword is used to refer the same module, while the <code>super</code> keyword is used to refer parent module. Also, the <code>super</code> keyword can be used to access root functions from inside a module.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n  greetings::hello();\n}\n\nfn hello() {\n  println!(&quot;Hello, world!&quot;);\n}\n\nmod greetings {\n  pub fn hello() {\n    super::hello();\n  }\n}\n</code></pre>\n<blockquote>\n<p>üîé When writing tests it‚Äôs a good practice to write tests inside a test module because they compile only when running tests.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn greet() -&gt; String {\n    &quot;Hello, world!&quot;.to_string()\n}\n\n#[cfg(test)] // Only compiles when running tests\nmod tests {\n    use super::greet; // Import root greet function\n\n    #[test]\n    fn test_greet() {\n        assert_eq!(&quot;Hello, world!&quot;, greet());\n    }\n}\n</code></pre>\n<h2 id=\"02-In-a-different-file-same-directory\"><a href=\"#02-In-a-different-file-same-directory\" class=\"headerlink\" title=\"02. In a different file, same directory\"></a>02. In a different file, same directory</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ‚Ü≥ main.rs\nmod greetings; // Import greetings module\n\nfn main() {\n  greetings::hello();\n}\n\n// ‚Ü≥ greetings.rs\n// ‚≠êÔ∏è No need to wrap the code with a mod declaration. The file itself acts as a module.\npub fn hello() { // The function has to be public to access from outside\n  println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<p>If we wrap file content with a <code>mod</code> declaration, it will act as a nested module.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ‚Ü≥ main.rs\nmod phrases;\n\nfn main() {\n  phrases::greetings::hello();\n}\n\n// ‚Ü≥ phrases.rs\npub mod greetings { // ‚≠êÔ∏è The module has to be public to access from outside\n  pub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n  }\n}\n</code></pre>\n<h2 id=\"03-In-a-different-file-different-directory\"><a href=\"#03-In-a-different-file-different-directory\" class=\"headerlink\" title=\"03. In a different file, different directory\"></a>03. In a different file, different directory</h2><p><code>mod.rs</code> in the directory module root is the entry point to the directory module. All other files in that directory root, act as sub-modules of the directory module.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ‚Ü≥ main.rs\nmod greetings;\n\nfn main() {\n  greetings::hello();\n}\n\n// ‚Ü≥ greetings/mod.rs\npub fn hello() { // ‚≠êÔ∏è The function has to be public to access from outside\n  println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<p>Again, If we wrap file content with a <code>mod</code> declaration, it will act as a nested module.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ‚Ü≥ main.rs\nmod phrases;\n\nfn main() {\n  phrases::greetings::hello();\n}\n\n// ‚Ü≥ phrases/mod.rs\npub mod greetings { // ‚≠êÔ∏è The module has to be public to access from outside\n  pub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n  }\n}\n</code></pre>\n<p>Other files in the directory module act as sub-modules for <code>mod.rs</code>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ‚Ü≥ main.rs\nmod phrases;\n\nfn main() {\n  phrases::hello()\n}\n\n// ‚Ü≥ phrases/mod.rs\nmod greetings;\n\npub fn hello() {\n  greetings::hello()\n}\n\n// ‚Ü≥ phrases/greetings.rs\npub fn hello() {\n  println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<p>‚≠êÔ∏è If you need to access an element of <code>phrases/greetings.rs</code> from outside the module, you have to import the <code>greetings</code> module as a public module.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ‚Ü≥ main.rs\nmod phrases;\n\nfn main() {\n    phrases::greetings::hello();\n}\n\n// ‚Ü≥ phrases/mod.rs\npub mod greetings;  // ‚≠êÔ∏è `pub mod` instead `mod`\n\n// ‚Ü≥ phrases/greetings.rs\npub fn hello() {\n  println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<blockquote>\n<p>üîé It‚Äôs unable to import child file modules of directory modules to <code>main.rs</code>, so you can‚Äôt use <code>mod phrases::greetings;</code> from <code>main.rs</code>. But there is a way to import <code>phrases::greetings::hello()</code> to <code>phrases</code> module by re-exporting <code>hello</code> to <code>phrases</code> module. So you can call it directly as <code>phrases::hello()</code>.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ‚Ü≥ phrases/greetings.rs\npub fn hello() {\n  println!(&quot;Hello, world!&quot;);\n}\n\n// ‚Ü≥ phrases/mod.rs\npub mod greetings;\n\npub use self::greetings::hello; // Re-export `greetings::hello` to phrases\n\n// ‚Ü≥ main.rs\nmod phrases;\n\nfn main() {\n    phrases::hello(); // You can call `hello()` directly from phrases\n}\n</code></pre>\n<p>This allows you to present an external interface that <strong>may not directly map</strong> to your internal code organization. If still it is not clear, don‚Äôt worry; We discuss the usages of <code>use</code> on an upcoming section in this post.</p>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<h2 id=\"01-In-the-same-file\"><a href=\"#01-In-the-same-file\" class=\"headerlink\" title=\"01. In the same file\"></a>01. In the same file</h2><p>Related code and data are grouped into a module and stored in the same file.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n   greetings::hello();\n}\n\nmod greetings {\n  // ‚≠êÔ∏è By default, everything inside a module is private\n  pub fn hello() { // ‚≠êÔ∏è So function has to be public to access from outside\n    println!(&quot;Hello, world!&quot;);\n  }\n}\n</code></pre>\n<p>Modules can also be nested.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() { \n  phrases::greetings::hello();\n}\n\nmod phrases { \n  pub mod greetings { \n    pub fn hello() { \n      println!(&quot;Hello, world!&quot;);\n    }\n  }\n}\n</code></pre>\n<p>Private functions can be called from the same module or from a child module.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// 01. Calling private functions of the same module\nfn main() {\n  phrases::greet();\n}\n\nmod phrases {\n  pub fn greet() {\n    hello(); // Or `self::hello();`\n  }\n\n  fn hello() {\n    println!(&quot;Hello, world!&quot;);\n  }\n}\n\n// 02. Calling private functions of the parent module\nfn main() {\n  phrases::greetings::hello();\n}\n\nmod phrases {\n  fn private_fn() {\n    println!(&quot;Hello, world!&quot;);\n  }\n\n  pub mod greetings {\n    pub fn hello() {\n      super::private_fn();\n    }\n  }\n}\n</code></pre>\n<blockquote>\n<p>üí° The <code>self</code> keyword is used to refer the same module, while the <code>super</code> keyword is used to refer parent module. Also, the <code>super</code> keyword can be used to access root functions from inside a module.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n  greetings::hello();\n}\n\nfn hello() {\n  println!(&quot;Hello, world!&quot;);\n}\n\nmod greetings {\n  pub fn hello() {\n    super::hello();\n  }\n}\n</code></pre>\n<blockquote>\n<p>üîé When writing tests it‚Äôs a good practice to write tests inside a test module because they compile only when running tests.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn greet() -&gt; String {\n    &quot;Hello, world!&quot;.to_string()\n}\n\n#[cfg(test)] // Only compiles when running tests\nmod tests {\n    use super::greet; // Import root greet function\n\n    #[test]\n    fn test_greet() {\n        assert_eq!(&quot;Hello, world!&quot;, greet());\n    }\n}\n</code></pre>\n<h2 id=\"02-In-a-different-file-same-directory\"><a href=\"#02-In-a-different-file-same-directory\" class=\"headerlink\" title=\"02. In a different file, same directory\"></a>02. In a different file, same directory</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ‚Ü≥ main.rs\nmod greetings; // Import greetings module\n\nfn main() {\n  greetings::hello();\n}\n\n// ‚Ü≥ greetings.rs\n// ‚≠êÔ∏è No need to wrap the code with a mod declaration. The file itself acts as a module.\npub fn hello() { // The function has to be public to access from outside\n  println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<p>If we wrap file content with a <code>mod</code> declaration, it will act as a nested module.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ‚Ü≥ main.rs\nmod phrases;\n\nfn main() {\n  phrases::greetings::hello();\n}\n\n// ‚Ü≥ phrases.rs\npub mod greetings { // ‚≠êÔ∏è The module has to be public to access from outside\n  pub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n  }\n}\n</code></pre>\n<h2 id=\"03-In-a-different-file-different-directory\"><a href=\"#03-In-a-different-file-different-directory\" class=\"headerlink\" title=\"03. In a different file, different directory\"></a>03. In a different file, different directory</h2><p><code>mod.rs</code> in the directory module root is the entry point to the directory module. All other files in that directory root, act as sub-modules of the directory module.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ‚Ü≥ main.rs\nmod greetings;\n\nfn main() {\n  greetings::hello();\n}\n\n// ‚Ü≥ greetings/mod.rs\npub fn hello() { // ‚≠êÔ∏è The function has to be public to access from outside\n  println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<p>Again, If we wrap file content with a <code>mod</code> declaration, it will act as a nested module.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ‚Ü≥ main.rs\nmod phrases;\n\nfn main() {\n  phrases::greetings::hello();\n}\n\n// ‚Ü≥ phrases/mod.rs\npub mod greetings { // ‚≠êÔ∏è The module has to be public to access from outside\n  pub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n  }\n}\n</code></pre>\n<p>Other files in the directory module act as sub-modules for <code>mod.rs</code>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ‚Ü≥ main.rs\nmod phrases;\n\nfn main() {\n  phrases::hello()\n}\n\n// ‚Ü≥ phrases/mod.rs\nmod greetings;\n\npub fn hello() {\n  greetings::hello()\n}\n\n// ‚Ü≥ phrases/greetings.rs\npub fn hello() {\n  println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<p>‚≠êÔ∏è If you need to access an element of <code>phrases/greetings.rs</code> from outside the module, you have to import the <code>greetings</code> module as a public module.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ‚Ü≥ main.rs\nmod phrases;\n\nfn main() {\n    phrases::greetings::hello();\n}\n\n// ‚Ü≥ phrases/mod.rs\npub mod greetings;  // ‚≠êÔ∏è `pub mod` instead `mod`\n\n// ‚Ü≥ phrases/greetings.rs\npub fn hello() {\n  println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<blockquote>\n<p>üîé It‚Äôs unable to import child file modules of directory modules to <code>main.rs</code>, so you can‚Äôt use <code>mod phrases::greetings;</code> from <code>main.rs</code>. But there is a way to import <code>phrases::greetings::hello()</code> to <code>phrases</code> module by re-exporting <code>hello</code> to <code>phrases</code> module. So you can call it directly as <code>phrases::hello()</code>.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ‚Ü≥ phrases/greetings.rs\npub fn hello() {\n  println!(&quot;Hello, world!&quot;);\n}\n\n// ‚Ü≥ phrases/mod.rs\npub mod greetings;\n\npub use self::greetings::hello; // Re-export `greetings::hello` to phrases\n\n// ‚Ü≥ main.rs\nmod phrases;\n\nfn main() {\n    phrases::hello(); // You can call `hello()` directly from phrases\n}\n</code></pre>\n<p>This allows you to present an external interface that <strong>may not directly map</strong> to your internal code organization. If still it is not clear, don‚Äôt worry; We discuss the usages of <code>use</code> on an upcoming section in this post.</p>\n"},{"title":"Use","_content":"\nLet's see the main usages of the `use` keyword.\n\n\n## 01. Bind a full path to a new name\n\nMainly `use` keyword is used to bind a full path of an element to a new name. So the user doesn‚Äôt want to repeat the full path each time.\n\n```rust\n// -- Initial code without the `use` keyword --\nmod phrases { \n  pub mod greetings { \n    pub fn hello() { \n      println!(\"Hello, world!\");\n    }\n  }\n}\n\nfn main() { \n  phrases::greetings::hello(); // Using full path\n}\n\n\n// -- Usage of the `use` keyword --\n// 01. Create an alias for module\nuse phrases::greetings;\nfn main() { \n  greetings::hello();\n}\n\n// 02. Create an alias for module elements\nuse phrases::greetings::hello;\nfn main() { \n  hello();\n}\n\n// 03. Customize names with the `as` keyword\nuse phrases::greetings::hello as greet;\nfn main() { \n  greet();\n}\n```\n\n\n## 02. Import elements to scope\n\nAnother common usage of `use` is importing elements to scope. Remember that, this is also a bit similar to creating an alias and using it instead of using the full path.\n\n```rust\nfn hello() -> String {\n  \"Hello, world!\".to_string()\n}\n\n#[cfg(test)]\nmod tests {\n  use super::hello; // Import the `hello()` function into the scope\n    \n  #[test]\n  fn test_hello() {\n    assert_eq!(\"Hello, world!\", hello()); // If not using the above `use` statement, we can run same via `super::hello()`\n  }\n}\n```\n\n> üí° By default, `use` declarations use absolute paths, starting from the crate root. But `self` and `super` declarations make that path relative to the current module.\n\nSame way the `use` keyword is used to import the elements of other crates including the `std`, Rust‚Äôs [Standard Library](https://github.com/rust-lang/rust/tree/master/src/libstd).\n\n```rust\n// -- 01. Importing elements --\nuse std::fs::File;\n\nfn main() {\n    File::create(\"empty.txt\").expect(\"Can not create the file!\");\n}\n\n\n// -- 02. Importing module and elements --\nstd::fs::{self, File} // `use std::fs; use std::fs::File;`\n\nfn main() {\n    fs::create_dir(\"some_dir\").expect(\"Can not create the directry!\");\n    File::create(\"some_dir/empty.txt\").expect(\"Can not create the file!\");\n}\n\n\n// -- 03. Importing multiple elements --\nuse std::fs::File;\nuse std::io::{BufReader, BufRead}; // `use std::io::BufReader; use std::io::BufRead;`\n\nfn main() {\n    let file = File::open(\"src/hello.txt\").expect(\"file not found\");\n    let buf_reader = BufReader::new(file);\n\n    for line in buf_reader.lines() {\n        println!(\"{}\", line.unwrap());\n    }\n}\n```\n\n> We **don‚Äôt need** to use `extern crate std;` when using the `std` library. We will discuss more about this under the Standard Library section.\n\nüí° `use` statements import only what we‚Äôve specified into the scope, instead of importing all elements of a module or crate. So it improves the efficiency of the program.\n\n\n## 03. Re-exporting\n\nAnother special case is `pub use`. When creating a module, you can export things from another module into your module. So after that, they can be accessed directly from your module. This is called **re-exporting**.\n\n```rust\n// ‚Ü≥ main.rs\nmod phrases;\n\nfn main() {\n    phrases::hello(); // Not directly map\n}\n\n// ‚Ü≥ phrases/mod.rs\npub mod greetings;\n\npub use self::greetings::hello; // Re-export `greetings::hello` to phrases\n\n// ‚Ü≥ phrases/greetings.rs\npub fn hello() {\n  println!(\"Hello, world!\");\n}\n```\n\nThis pattern is quite common in large libraries. It helps to hide the complexity of the internal module structure of the library from users. Because users don‚Äôt need to know/follow the whole directory map of the elements of the library while working with them.","source":"docs/d6.use.md","raw":"title: Use\n---\n\nLet's see the main usages of the `use` keyword.\n\n\n## 01. Bind a full path to a new name\n\nMainly `use` keyword is used to bind a full path of an element to a new name. So the user doesn‚Äôt want to repeat the full path each time.\n\n```rust\n// -- Initial code without the `use` keyword --\nmod phrases { \n  pub mod greetings { \n    pub fn hello() { \n      println!(\"Hello, world!\");\n    }\n  }\n}\n\nfn main() { \n  phrases::greetings::hello(); // Using full path\n}\n\n\n// -- Usage of the `use` keyword --\n// 01. Create an alias for module\nuse phrases::greetings;\nfn main() { \n  greetings::hello();\n}\n\n// 02. Create an alias for module elements\nuse phrases::greetings::hello;\nfn main() { \n  hello();\n}\n\n// 03. Customize names with the `as` keyword\nuse phrases::greetings::hello as greet;\nfn main() { \n  greet();\n}\n```\n\n\n## 02. Import elements to scope\n\nAnother common usage of `use` is importing elements to scope. Remember that, this is also a bit similar to creating an alias and using it instead of using the full path.\n\n```rust\nfn hello() -> String {\n  \"Hello, world!\".to_string()\n}\n\n#[cfg(test)]\nmod tests {\n  use super::hello; // Import the `hello()` function into the scope\n    \n  #[test]\n  fn test_hello() {\n    assert_eq!(\"Hello, world!\", hello()); // If not using the above `use` statement, we can run same via `super::hello()`\n  }\n}\n```\n\n> üí° By default, `use` declarations use absolute paths, starting from the crate root. But `self` and `super` declarations make that path relative to the current module.\n\nSame way the `use` keyword is used to import the elements of other crates including the `std`, Rust‚Äôs [Standard Library](https://github.com/rust-lang/rust/tree/master/src/libstd).\n\n```rust\n// -- 01. Importing elements --\nuse std::fs::File;\n\nfn main() {\n    File::create(\"empty.txt\").expect(\"Can not create the file!\");\n}\n\n\n// -- 02. Importing module and elements --\nstd::fs::{self, File} // `use std::fs; use std::fs::File;`\n\nfn main() {\n    fs::create_dir(\"some_dir\").expect(\"Can not create the directry!\");\n    File::create(\"some_dir/empty.txt\").expect(\"Can not create the file!\");\n}\n\n\n// -- 03. Importing multiple elements --\nuse std::fs::File;\nuse std::io::{BufReader, BufRead}; // `use std::io::BufReader; use std::io::BufRead;`\n\nfn main() {\n    let file = File::open(\"src/hello.txt\").expect(\"file not found\");\n    let buf_reader = BufReader::new(file);\n\n    for line in buf_reader.lines() {\n        println!(\"{}\", line.unwrap());\n    }\n}\n```\n\n> We **don‚Äôt need** to use `extern crate std;` when using the `std` library. We will discuss more about this under the Standard Library section.\n\nüí° `use` statements import only what we‚Äôve specified into the scope, instead of importing all elements of a module or crate. So it improves the efficiency of the program.\n\n\n## 03. Re-exporting\n\nAnother special case is `pub use`. When creating a module, you can export things from another module into your module. So after that, they can be accessed directly from your module. This is called **re-exporting**.\n\n```rust\n// ‚Ü≥ main.rs\nmod phrases;\n\nfn main() {\n    phrases::hello(); // Not directly map\n}\n\n// ‚Ü≥ phrases/mod.rs\npub mod greetings;\n\npub use self::greetings::hello; // Re-export `greetings::hello` to phrases\n\n// ‚Ü≥ phrases/greetings.rs\npub fn hello() {\n  println!(\"Hello, world!\");\n}\n```\n\nThis pattern is quite common in large libraries. It helps to hide the complexity of the internal module structure of the library from users. Because users don‚Äôt need to know/follow the whole directory map of the elements of the library while working with them.","date":"2019-03-19T14:50:39.957Z","updated":"2019-03-19T14:50:39.957Z","path":"docs/d6.use.html","comments":1,"layout":"page","_id":"cjtfwbizk000ldwgpknshiq1y","content":"<p>Let‚Äôs see the main usages of the <code>use</code> keyword.</p>\n<h2 id=\"01-Bind-a-full-path-to-a-new-name\"><a href=\"#01-Bind-a-full-path-to-a-new-name\" class=\"headerlink\" title=\"01. Bind a full path to a new name\"></a>01. Bind a full path to a new name</h2><p>Mainly <code>use</code> keyword is used to bind a full path of an element to a new name. So the user doesn‚Äôt want to repeat the full path each time.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// -- Initial code without the `use` keyword --\nmod phrases { \n  pub mod greetings { \n    pub fn hello() { \n      println!(&quot;Hello, world!&quot;);\n    }\n  }\n}\n\nfn main() { \n  phrases::greetings::hello(); // Using full path\n}\n\n\n// -- Usage of the `use` keyword --\n// 01. Create an alias for module\nuse phrases::greetings;\nfn main() { \n  greetings::hello();\n}\n\n// 02. Create an alias for module elements\nuse phrases::greetings::hello;\nfn main() { \n  hello();\n}\n\n// 03. Customize names with the `as` keyword\nuse phrases::greetings::hello as greet;\nfn main() { \n  greet();\n}\n</code></pre>\n<h2 id=\"02-Import-elements-to-scope\"><a href=\"#02-Import-elements-to-scope\" class=\"headerlink\" title=\"02. Import elements to scope\"></a>02. Import elements to scope</h2><p>Another common usage of <code>use</code> is importing elements to scope. Remember that, this is also a bit similar to creating an alias and using it instead of using the full path.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn hello() -&gt; String {\n  &quot;Hello, world!&quot;.to_string()\n}\n\n#[cfg(test)]\nmod tests {\n  use super::hello; // Import the `hello()` function into the scope\n\n  #[test]\n  fn test_hello() {\n    assert_eq!(&quot;Hello, world!&quot;, hello()); // If not using the above `use` statement, we can run same via `super::hello()`\n  }\n}\n</code></pre>\n<blockquote>\n<p>üí° By default, <code>use</code> declarations use absolute paths, starting from the crate root. But <code>self</code> and <code>super</code> declarations make that path relative to the current module.</p>\n</blockquote>\n<p>Same way the <code>use</code> keyword is used to import the elements of other crates including the <code>std</code>, Rust‚Äôs <a href=\"https://github.com/rust-lang/rust/tree/master/src/libstd\" target=\"_blank\" rel=\"noopener\">Standard Library</a>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// -- 01. Importing elements --\nuse std::fs::File;\n\nfn main() {\n    File::create(&quot;empty.txt&quot;).expect(&quot;Can not create the file!&quot;);\n}\n\n\n// -- 02. Importing module and elements --\nstd::fs::{self, File} // `use std::fs; use std::fs::File;`\n\nfn main() {\n    fs::create_dir(&quot;some_dir&quot;).expect(&quot;Can not create the directry!&quot;);\n    File::create(&quot;some_dir/empty.txt&quot;).expect(&quot;Can not create the file!&quot;);\n}\n\n\n// -- 03. Importing multiple elements --\nuse std::fs::File;\nuse std::io::{BufReader, BufRead}; // `use std::io::BufReader; use std::io::BufRead;`\n\nfn main() {\n    let file = File::open(&quot;src/hello.txt&quot;).expect(&quot;file not found&quot;);\n    let buf_reader = BufReader::new(file);\n\n    for line in buf_reader.lines() {\n        println!(&quot;{}&quot;, line.unwrap());\n    }\n}\n</code></pre>\n<blockquote>\n<p>We <strong>don‚Äôt need</strong> to use <code>extern crate std;</code> when using the <code>std</code> library. We will discuss more about this under the Standard Library section.</p>\n</blockquote>\n<p>üí° <code>use</code> statements import only what we‚Äôve specified into the scope, instead of importing all elements of a module or crate. So it improves the efficiency of the program.</p>\n<h2 id=\"03-Re-exporting\"><a href=\"#03-Re-exporting\" class=\"headerlink\" title=\"03. Re-exporting\"></a>03. Re-exporting</h2><p>Another special case is <code>pub use</code>. When creating a module, you can export things from another module into your module. So after that, they can be accessed directly from your module. This is called <strong>re-exporting</strong>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ‚Ü≥ main.rs\nmod phrases;\n\nfn main() {\n    phrases::hello(); // Not directly map\n}\n\n// ‚Ü≥ phrases/mod.rs\npub mod greetings;\n\npub use self::greetings::hello; // Re-export `greetings::hello` to phrases\n\n// ‚Ü≥ phrases/greetings.rs\npub fn hello() {\n  println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<p>This pattern is quite common in large libraries. It helps to hide the complexity of the internal module structure of the library from users. Because users don‚Äôt need to know/follow the whole directory map of the elements of the library while working with them.</p>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<p>Let‚Äôs see the main usages of the <code>use</code> keyword.</p>\n<h2 id=\"01-Bind-a-full-path-to-a-new-name\"><a href=\"#01-Bind-a-full-path-to-a-new-name\" class=\"headerlink\" title=\"01. Bind a full path to a new name\"></a>01. Bind a full path to a new name</h2><p>Mainly <code>use</code> keyword is used to bind a full path of an element to a new name. So the user doesn‚Äôt want to repeat the full path each time.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// -- Initial code without the `use` keyword --\nmod phrases { \n  pub mod greetings { \n    pub fn hello() { \n      println!(&quot;Hello, world!&quot;);\n    }\n  }\n}\n\nfn main() { \n  phrases::greetings::hello(); // Using full path\n}\n\n\n// -- Usage of the `use` keyword --\n// 01. Create an alias for module\nuse phrases::greetings;\nfn main() { \n  greetings::hello();\n}\n\n// 02. Create an alias for module elements\nuse phrases::greetings::hello;\nfn main() { \n  hello();\n}\n\n// 03. Customize names with the `as` keyword\nuse phrases::greetings::hello as greet;\nfn main() { \n  greet();\n}\n</code></pre>\n<h2 id=\"02-Import-elements-to-scope\"><a href=\"#02-Import-elements-to-scope\" class=\"headerlink\" title=\"02. Import elements to scope\"></a>02. Import elements to scope</h2><p>Another common usage of <code>use</code> is importing elements to scope. Remember that, this is also a bit similar to creating an alias and using it instead of using the full path.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn hello() -&gt; String {\n  &quot;Hello, world!&quot;.to_string()\n}\n\n#[cfg(test)]\nmod tests {\n  use super::hello; // Import the `hello()` function into the scope\n\n  #[test]\n  fn test_hello() {\n    assert_eq!(&quot;Hello, world!&quot;, hello()); // If not using the above `use` statement, we can run same via `super::hello()`\n  }\n}\n</code></pre>\n<blockquote>\n<p>üí° By default, <code>use</code> declarations use absolute paths, starting from the crate root. But <code>self</code> and <code>super</code> declarations make that path relative to the current module.</p>\n</blockquote>\n<p>Same way the <code>use</code> keyword is used to import the elements of other crates including the <code>std</code>, Rust‚Äôs <a href=\"https://github.com/rust-lang/rust/tree/master/src/libstd\" target=\"_blank\" rel=\"noopener\">Standard Library</a>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// -- 01. Importing elements --\nuse std::fs::File;\n\nfn main() {\n    File::create(&quot;empty.txt&quot;).expect(&quot;Can not create the file!&quot;);\n}\n\n\n// -- 02. Importing module and elements --\nstd::fs::{self, File} // `use std::fs; use std::fs::File;`\n\nfn main() {\n    fs::create_dir(&quot;some_dir&quot;).expect(&quot;Can not create the directry!&quot;);\n    File::create(&quot;some_dir/empty.txt&quot;).expect(&quot;Can not create the file!&quot;);\n}\n\n\n// -- 03. Importing multiple elements --\nuse std::fs::File;\nuse std::io::{BufReader, BufRead}; // `use std::io::BufReader; use std::io::BufRead;`\n\nfn main() {\n    let file = File::open(&quot;src/hello.txt&quot;).expect(&quot;file not found&quot;);\n    let buf_reader = BufReader::new(file);\n\n    for line in buf_reader.lines() {\n        println!(&quot;{}&quot;, line.unwrap());\n    }\n}\n</code></pre>\n<blockquote>\n<p>We <strong>don‚Äôt need</strong> to use <code>extern crate std;</code> when using the <code>std</code> library. We will discuss more about this under the Standard Library section.</p>\n</blockquote>\n<p>üí° <code>use</code> statements import only what we‚Äôve specified into the scope, instead of importing all elements of a module or crate. So it improves the efficiency of the program.</p>\n<h2 id=\"03-Re-exporting\"><a href=\"#03-Re-exporting\" class=\"headerlink\" title=\"03. Re-exporting\"></a>03. Re-exporting</h2><p>Another special case is <code>pub use</code>. When creating a module, you can export things from another module into your module. So after that, they can be accessed directly from your module. This is called <strong>re-exporting</strong>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ‚Ü≥ main.rs\nmod phrases;\n\nfn main() {\n    phrases::hello(); // Not directly map\n}\n\n// ‚Ü≥ phrases/mod.rs\npub mod greetings;\n\npub use self::greetings::hello; // Re-export `greetings::hello` to phrases\n\n// ‚Ü≥ phrases/greetings.rs\npub fn hello() {\n  println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<p>This pattern is quite common in large libraries. It helps to hide the complexity of the internal module structure of the library from users. Because users don‚Äôt need to know/follow the whole directory map of the elements of the library while working with them.</p>\n"},{"title":"Workspaces","_content":"\nWhen the code base is getting larger, you might need to work with **multiple crates on the same project**. Rust supports this via Workspaces. You can **analyze (`cargo check`), build, run tests or generate docs for all crates** at once by running `cargo` commands from the project root.\n\n‚≠êÔ∏è When working on multiple crates same time, there is a higher possibility of having shared dependencies on crates. To prevent downloading and compiling the same dependency multiple times, Rust uses a **shared build directory** under the project root, while running `cargo build` from the project root.\n\nLet's create a library crate with a simple hello world function and a binary crate which uses the library crate.\n\nAssume we run,\n```bash\nmkdir greetings\ntouch greetings/Cargo.toml\ncargo new greetings/lib --lib\ncargo new greetings/examples/hello\n```\n\nThat generates,\n```\ngreetings\n ‚îú‚îÄ‚îÄ Cargo.toml\n ‚îú‚îÄ‚îÄ examples\n ‚îÇ  ‚îî‚îÄ‚îÄ hello\n ‚îÇ     ‚îú‚îÄ‚îÄ Cargo.toml\n ‚îÇ     ‚îî‚îÄ‚îÄ src\n ‚îÇ        ‚îî‚îÄ‚îÄ main.rs\n ‚îî‚îÄ‚îÄ lib\n    ‚îú‚îÄ‚îÄ Cargo.toml\n    ‚îî‚îÄ‚îÄ src\n       ‚îî‚îÄ‚îÄ lib.rs\n```\n\nWe have to modify the following files,\n```rust\n// 01. greetings/Cargo.toml to mark as a workspace and to add members\n[workspace]\nmembers = [\n    \"lib\",\n    \"examples/hello\"\n]\n\n// 02.1 greetings/lib/Cargo.toml to change the package name to greetings\n[package]\nname = \"greetings\"\nversion = \"0.1.0\"\nauthors = [\"Dumindu Madunuwan\"]\n\n[dependencies]\n\n// 02.2 greetings/lib/src/lib.rs to add a simple hello world function\npub fn hello() {\n    println!(\"Hello, world!\");\n}\n\n// 03.1 greetings/examples/hello/Cargo.toml to add the `greetings` lib as a dependency\n[package]\nname = \"hello\"\nversion = \"0.1.0\"\nauthors = [\"Dumindu Madunuwan\"]\n\n[dependencies]\ngreetings = { path = \"../../lib\" }\n\n// 03.2 greetings/examples/hello/src/main.rs to import the `greetings` lib and call its hello world function\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n```\n\nüí° On Linux and Mac, you can run `cargo` commands on each carets without changing the working directory all the times via Subshells (A command list embedded between parentheses). For example, if you are in the `greetings` directory, even you run `(cd examples/hello && cargo run)` your working directory will be kept  as same in `greetings` folder.\n\n> üîé [rust-lang/rust source folder](https://github.com/rust-lang/rust/tree/master/src) is a good example for a workspace.","source":"docs/d5.workspaces.md","raw":"title: Workspaces\n---\n\nWhen the code base is getting larger, you might need to work with **multiple crates on the same project**. Rust supports this via Workspaces. You can **analyze (`cargo check`), build, run tests or generate docs for all crates** at once by running `cargo` commands from the project root.\n\n‚≠êÔ∏è When working on multiple crates same time, there is a higher possibility of having shared dependencies on crates. To prevent downloading and compiling the same dependency multiple times, Rust uses a **shared build directory** under the project root, while running `cargo build` from the project root.\n\nLet's create a library crate with a simple hello world function and a binary crate which uses the library crate.\n\nAssume we run,\n```bash\nmkdir greetings\ntouch greetings/Cargo.toml\ncargo new greetings/lib --lib\ncargo new greetings/examples/hello\n```\n\nThat generates,\n```\ngreetings\n ‚îú‚îÄ‚îÄ Cargo.toml\n ‚îú‚îÄ‚îÄ examples\n ‚îÇ  ‚îî‚îÄ‚îÄ hello\n ‚îÇ     ‚îú‚îÄ‚îÄ Cargo.toml\n ‚îÇ     ‚îî‚îÄ‚îÄ src\n ‚îÇ        ‚îî‚îÄ‚îÄ main.rs\n ‚îî‚îÄ‚îÄ lib\n    ‚îú‚îÄ‚îÄ Cargo.toml\n    ‚îî‚îÄ‚îÄ src\n       ‚îî‚îÄ‚îÄ lib.rs\n```\n\nWe have to modify the following files,\n```rust\n// 01. greetings/Cargo.toml to mark as a workspace and to add members\n[workspace]\nmembers = [\n    \"lib\",\n    \"examples/hello\"\n]\n\n// 02.1 greetings/lib/Cargo.toml to change the package name to greetings\n[package]\nname = \"greetings\"\nversion = \"0.1.0\"\nauthors = [\"Dumindu Madunuwan\"]\n\n[dependencies]\n\n// 02.2 greetings/lib/src/lib.rs to add a simple hello world function\npub fn hello() {\n    println!(\"Hello, world!\");\n}\n\n// 03.1 greetings/examples/hello/Cargo.toml to add the `greetings` lib as a dependency\n[package]\nname = \"hello\"\nversion = \"0.1.0\"\nauthors = [\"Dumindu Madunuwan\"]\n\n[dependencies]\ngreetings = { path = \"../../lib\" }\n\n// 03.2 greetings/examples/hello/src/main.rs to import the `greetings` lib and call its hello world function\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n```\n\nüí° On Linux and Mac, you can run `cargo` commands on each carets without changing the working directory all the times via Subshells (A command list embedded between parentheses). For example, if you are in the `greetings` directory, even you run `(cd examples/hello && cargo run)` your working directory will be kept  as same in `greetings` folder.\n\n> üîé [rust-lang/rust source folder](https://github.com/rust-lang/rust/tree/master/src) is a good example for a workspace.","date":"2019-03-19T14:50:39.956Z","updated":"2019-03-19T14:50:39.956Z","path":"docs/d5.workspaces.html","comments":1,"layout":"page","_id":"cjtfwbizk000mdwgpusva4dhe","content":"<p>When the code base is getting larger, you might need to work with <strong>multiple crates on the same project</strong>. Rust supports this via Workspaces. You can <strong>analyze (<code>cargo check</code>), build, run tests or generate docs for all crates</strong> at once by running <code>cargo</code> commands from the project root.</p>\n<p>‚≠êÔ∏è When working on multiple crates same time, there is a higher possibility of having shared dependencies on crates. To prevent downloading and compiling the same dependency multiple times, Rust uses a <strong>shared build directory</strong> under the project root, while running <code>cargo build</code> from the project root.</p>\n<p>Let‚Äôs create a library crate with a simple hello world function and a binary crate which uses the library crate.</p>\n<p>Assume we run,</p>\n<p></p><p class=\"code-caption\" data-lang=\"bash\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"bash\">mkdir greetings\ntouch greetings/Cargo.toml\ncargo new greetings/lib --lib\ncargo new greetings/examples/hello\n</code></pre>\n<p>That generates,</p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code>greetings\n ‚îú‚îÄ‚îÄ Cargo.toml\n ‚îú‚îÄ‚îÄ examples\n ‚îÇ  ‚îî‚îÄ‚îÄ hello\n ‚îÇ     ‚îú‚îÄ‚îÄ Cargo.toml\n ‚îÇ     ‚îî‚îÄ‚îÄ src\n ‚îÇ        ‚îî‚îÄ‚îÄ main.rs\n ‚îî‚îÄ‚îÄ lib\n    ‚îú‚îÄ‚îÄ Cargo.toml\n    ‚îî‚îÄ‚îÄ src\n       ‚îî‚îÄ‚îÄ lib.rs\n</code></pre><p>We have to modify the following files,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// 01. greetings/Cargo.toml to mark as a workspace and to add members\n[workspace]\nmembers = [\n    &quot;lib&quot;,\n    &quot;examples/hello&quot;\n]\n\n// 02.1 greetings/lib/Cargo.toml to change the package name to greetings\n[package]\nname = &quot;greetings&quot;\nversion = &quot;0.1.0&quot;\nauthors = [&quot;Dumindu Madunuwan&quot;]\n\n[dependencies]\n\n// 02.2 greetings/lib/src/lib.rs to add a simple hello world function\npub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n}\n\n// 03.1 greetings/examples/hello/Cargo.toml to add the `greetings` lib as a dependency\n[package]\nname = &quot;hello&quot;\nversion = &quot;0.1.0&quot;\nauthors = [&quot;Dumindu Madunuwan&quot;]\n\n[dependencies]\ngreetings = { path = &quot;../../lib&quot; }\n\n// 03.2 greetings/examples/hello/src/main.rs to import the `greetings` lib and call its hello world function\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n</code></pre>\n<p>üí° On Linux and Mac, you can run <code>cargo</code> commands on each carets without changing the working directory all the times via Subshells (A command list embedded between parentheses). For example, if you are in the <code>greetings</code> directory, even you run <code>(cd examples/hello &amp;&amp; cargo run)</code> your working directory will be kept  as same in <code>greetings</code> folder.</p>\n<blockquote>\n<p>üîé <a href=\"https://github.com/rust-lang/rust/tree/master/src\" target=\"_blank\" rel=\"noopener\">rust-lang/rust source folder</a> is a good example for a workspace.</p>\n</blockquote>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<p>When the code base is getting larger, you might need to work with <strong>multiple crates on the same project</strong>. Rust supports this via Workspaces. You can <strong>analyze (<code>cargo check</code>), build, run tests or generate docs for all crates</strong> at once by running <code>cargo</code> commands from the project root.</p>\n<p>‚≠êÔ∏è When working on multiple crates same time, there is a higher possibility of having shared dependencies on crates. To prevent downloading and compiling the same dependency multiple times, Rust uses a <strong>shared build directory</strong> under the project root, while running <code>cargo build</code> from the project root.</p>\n<p>Let‚Äôs create a library crate with a simple hello world function and a binary crate which uses the library crate.</p>\n<p>Assume we run,</p>\n<p></p><p class=\"code-caption\" data-lang=\"bash\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"bash\">mkdir greetings\ntouch greetings/Cargo.toml\ncargo new greetings/lib --lib\ncargo new greetings/examples/hello\n</code></pre>\n<p>That generates,</p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code>greetings\n ‚îú‚îÄ‚îÄ Cargo.toml\n ‚îú‚îÄ‚îÄ examples\n ‚îÇ  ‚îî‚îÄ‚îÄ hello\n ‚îÇ     ‚îú‚îÄ‚îÄ Cargo.toml\n ‚îÇ     ‚îî‚îÄ‚îÄ src\n ‚îÇ        ‚îî‚îÄ‚îÄ main.rs\n ‚îî‚îÄ‚îÄ lib\n    ‚îú‚îÄ‚îÄ Cargo.toml\n    ‚îî‚îÄ‚îÄ src\n       ‚îî‚îÄ‚îÄ lib.rs\n</code></pre><p>We have to modify the following files,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// 01. greetings/Cargo.toml to mark as a workspace and to add members\n[workspace]\nmembers = [\n    &quot;lib&quot;,\n    &quot;examples/hello&quot;\n]\n\n// 02.1 greetings/lib/Cargo.toml to change the package name to greetings\n[package]\nname = &quot;greetings&quot;\nversion = &quot;0.1.0&quot;\nauthors = [&quot;Dumindu Madunuwan&quot;]\n\n[dependencies]\n\n// 02.2 greetings/lib/src/lib.rs to add a simple hello world function\npub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n}\n\n// 03.1 greetings/examples/hello/Cargo.toml to add the `greetings` lib as a dependency\n[package]\nname = &quot;hello&quot;\nversion = &quot;0.1.0&quot;\nauthors = [&quot;Dumindu Madunuwan&quot;]\n\n[dependencies]\ngreetings = { path = &quot;../../lib&quot; }\n\n// 03.2 greetings/examples/hello/src/main.rs to import the `greetings` lib and call its hello world function\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n</code></pre>\n<p>üí° On Linux and Mac, you can run <code>cargo</code> commands on each carets without changing the working directory all the times via Subshells (A command list embedded between parentheses). For example, if you are in the <code>greetings</code> directory, even you run <code>(cd examples/hello &amp;&amp; cargo run)</code> your working directory will be kept  as same in <code>greetings</code> folder.</p>\n<blockquote>\n<p>üîé <a href=\"https://github.com/rust-lang/rust/tree/master/src\" target=\"_blank\" rel=\"noopener\">rust-lang/rust source folder</a> is a good example for a workspace.</p>\n</blockquote>\n"},{"title":"Panicking","_content":"\n## panic!()\n\n- In some cases, while an error happens we can not do anything to handle it, **if the error is something, which should not be happened**. In other words, if it‚Äôs an **unrecoverable error**.\n- Also **when we are not using a feature-rich debugger or proper logs**, sometimes we need to **debug the code by quitting the program from a specific line of code** by printing out a specific message or a value of a variable binding to understand the current flow of the program.\nFor above cases, we can use `panic!` macro.\n\n‚≠ê `panic!()` runs **thread based**. One thread can be panicked, while other threads are running.\n\n### 01. Quit from a specific line.\n```rust\nfn main() {\n    // some code\n\n    // if we need to debug in here\n    panic!();\n}\n\n// -------------- Compile-time error --------------\nthread 'main' panicked at 'explicit panic', src/main.rs:5:5\n```\n\n### 02. Quit with a custom error message.\n```rust\n#[allow(unused_mut)] // üí° A lint attribute used to suppress the warning; username variable does not need to be mutable\nfn main() {\n    let mut username = String::new();\n\n    // some code to get the name\n  \n    if username.is_empty() {\n        panic!(\"Username is empty!\");\n    }\n\n    println!(\"{}\", username);\n}\n\n// -------------- Compile-time error --------------\nthread 'main' panicked at 'Username is empty!', src/main.rs:8:9\n```\n\n### 03. Quit with the value of code elements.\n```rust\n#[derive(Debug)] // üí° A lint attribute which use to implement `std::fmt::Debug` to Color\nstruct Color {\n    r: u8,\n    g: u8,\n    b: u8,\n}\n\n#[allow(unreachable_code)] // üí° A lint attribute used to suppress the warning; unreachable statement\nfn main() {\n    let some_color: Color;\n    \n    // some code to get the color. ex\n    some_color = Color {r: 255, g: 255, b: 0};\n\n    // if we need to debug in here\n    panic!(\"{:?}\", some_color);\n\n    println!(\n        \"The color = rgb({},{},{})\",\n        some_color.r, some_color.g, some_color.b\n    );\n}\n\n// -------------- Compile-time error --------------\nthread 'main' panicked at 'Color { r: 255, g: 255, b: 0 }', src/main.rs:16:5\n```\n\nAs you can see in the above examples `panic!()` supports [`println!()` type style arguments](a3.hello_world.html#Usages-of-println). By default, it prints the **error message, file path and line & column numbers** where the error happens.\n\n## unimplemented!()\n\nüí° If your code is having **unfinished code sections**, there is a standardized macro as `unimplemented!()` to mark those routes. The program will be panicked with a **‚Äúnot yet implemented‚Äù** error message, if the program runs through those routes.\n\n```rust\n// error messages with panic!()\nthread 'main' panicked at 'explicit panic', src/main.rs:6:5\nthread 'main' panicked at 'Username is empty!', src/main.rs:9:9\nthread 'main' panicked at 'Color { r: 255, g: 255, b: 0 }', src/main.rs:17:5\n\n// error messages with unimplemented!()\nthread 'main' panicked at 'not yet implemented', src/main.rs:6:5\nthread 'main' panicked at 'not yet implemented: Username is empty!', src/main.rs:9:9\nthread 'main' panicked at 'not yet implemented: Color { r: 255, g: 255, b: 0 }', src/main.rs:17:5\n```\n\n## unreachable!()\n\nThis is the standard macro to mark **routes that the program should not enter**. The program will be panicked with a **‚Äú'internal error: entered unreachable code'‚Äù** error message, if the program entered those routes.\n\n```rust\nfn main() {\n    let level = 22;\n    let stage = match level {\n        1...5 => \"beginner\",\n        6...10 => \"intermediate\",\n        11...20 => \"expert\",\n        _ => unreachable!(),\n    };\n    \n    println!(\"{}\", stage);\n}\n\n\n// -------------- Compile-time error --------------\nthread 'main' panicked at 'internal error: entered unreachable code', src/main.rs:7:20\n```\n\nWe can set custom error messages for this as well.\n\n```rust\n// --- with a custom message ---\n_ => unreachable!(\"Custom message\"),\n// -------------- Compile-time error --------------\nthread 'main' panicked at 'internal error: entered unreachable code: Custom message', src/main.rs:7:20\n\n\n// --- with debug data ---\n_ => unreachable!(\"level is {}\", level),\n// -------------- Compile-time error --------------\nthread 'main' panicked at 'internal error: entered unreachable code: level is 22', src/main.rs:7:14\n```\n\n## assert!(), assert_eq!(), assert_ne!()\n\nThese are standard macros which usually use with test assertions.\n\n- `assert!()` ensures that a boolean expression is true. It panics if the expression is false.\n\n```rust\nfn main() {\n    let f = false;\n    \n    assert!(f)\n}\n\n\n// -------------- Compile-time error --------------\nthread 'main' panicked at 'assertion failed: f', src/main.rs:4:5\n```\n\n- `assert_eq!()` ensures that two expressions are equal. It panics if the expressions are not equal.\n\n```rust\nfn main() {\n    let a = 10;\n    let b = 20;\n    \n    assert_eq!(a, b);\n}\n\n\n// -------------- Compile-time error --------------\nthread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `10`,\n right: `20`', src/main.rs:5:5\n```\n\n- `assert_ne!()` ensures that two expressions are not equal. It panics if the expressions are equal.\n\n```rust\nfn main() {\n    let a = 10;\n    let b = 10;\n    \n    assert_ne!(a, b);\n}\n\n\n// -------------- Compile-time error --------------\nthread 'main' panicked at 'assertion failed: `(left != right)`\n  left: `10`,\n right: `10`', src/main.rs:5:5\n```\n\n> ‚≠ê Expressions which use with `assert_eq!()` and `assert_ne!()` should return same data type.\n\nWe can set custom error messages for these macros as well. For examples,\n\n1. With a custom message for `assert_eq!()`\n\n```rust\nfn main() {\n    let a = 10;\n    let b = 20;\n    \n    assert_eq!(a, b, \"a and b should be equal\");\n}\n\n\n// -------------- Compile-time error --------------\nthread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `10`,\n right: `20`: a and b should be equal', src/main.rs:5:5\n```\n\n2. `assert_eq!()` with debug data\n\n```rust\nfn main() {\n    let a = 10;\n    let b = 20;\n\n    let c = 40;\n    \n    assert_eq!(a+b, c, \"a = {} ; b = {}\", a, b);\n}\n\n// -------------- Compile-time error --------------\nthread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `30`,\n right: `40`: a = 10 ; b = 20', src/main.rs:7:5\n```\n\n## debug_assert!(), debug_assert_eq!(), debug_assert_ne!()\n\nüîé These are similar to above `assert` macros. But these statements are only enabled in non optimized builds by default. All these `debug_assert` macros will be omitted in release builds, unless we pass `-C debug-assertions` to the compiler.\n","source":"docs/e2.panicking.md","raw":"title: Panicking\n---\n\n## panic!()\n\n- In some cases, while an error happens we can not do anything to handle it, **if the error is something, which should not be happened**. In other words, if it‚Äôs an **unrecoverable error**.\n- Also **when we are not using a feature-rich debugger or proper logs**, sometimes we need to **debug the code by quitting the program from a specific line of code** by printing out a specific message or a value of a variable binding to understand the current flow of the program.\nFor above cases, we can use `panic!` macro.\n\n‚≠ê `panic!()` runs **thread based**. One thread can be panicked, while other threads are running.\n\n### 01. Quit from a specific line.\n```rust\nfn main() {\n    // some code\n\n    // if we need to debug in here\n    panic!();\n}\n\n// -------------- Compile-time error --------------\nthread 'main' panicked at 'explicit panic', src/main.rs:5:5\n```\n\n### 02. Quit with a custom error message.\n```rust\n#[allow(unused_mut)] // üí° A lint attribute used to suppress the warning; username variable does not need to be mutable\nfn main() {\n    let mut username = String::new();\n\n    // some code to get the name\n  \n    if username.is_empty() {\n        panic!(\"Username is empty!\");\n    }\n\n    println!(\"{}\", username);\n}\n\n// -------------- Compile-time error --------------\nthread 'main' panicked at 'Username is empty!', src/main.rs:8:9\n```\n\n### 03. Quit with the value of code elements.\n```rust\n#[derive(Debug)] // üí° A lint attribute which use to implement `std::fmt::Debug` to Color\nstruct Color {\n    r: u8,\n    g: u8,\n    b: u8,\n}\n\n#[allow(unreachable_code)] // üí° A lint attribute used to suppress the warning; unreachable statement\nfn main() {\n    let some_color: Color;\n    \n    // some code to get the color. ex\n    some_color = Color {r: 255, g: 255, b: 0};\n\n    // if we need to debug in here\n    panic!(\"{:?}\", some_color);\n\n    println!(\n        \"The color = rgb({},{},{})\",\n        some_color.r, some_color.g, some_color.b\n    );\n}\n\n// -------------- Compile-time error --------------\nthread 'main' panicked at 'Color { r: 255, g: 255, b: 0 }', src/main.rs:16:5\n```\n\nAs you can see in the above examples `panic!()` supports [`println!()` type style arguments](a3.hello_world.html#Usages-of-println). By default, it prints the **error message, file path and line & column numbers** where the error happens.\n\n## unimplemented!()\n\nüí° If your code is having **unfinished code sections**, there is a standardized macro as `unimplemented!()` to mark those routes. The program will be panicked with a **‚Äúnot yet implemented‚Äù** error message, if the program runs through those routes.\n\n```rust\n// error messages with panic!()\nthread 'main' panicked at 'explicit panic', src/main.rs:6:5\nthread 'main' panicked at 'Username is empty!', src/main.rs:9:9\nthread 'main' panicked at 'Color { r: 255, g: 255, b: 0 }', src/main.rs:17:5\n\n// error messages with unimplemented!()\nthread 'main' panicked at 'not yet implemented', src/main.rs:6:5\nthread 'main' panicked at 'not yet implemented: Username is empty!', src/main.rs:9:9\nthread 'main' panicked at 'not yet implemented: Color { r: 255, g: 255, b: 0 }', src/main.rs:17:5\n```\n\n## unreachable!()\n\nThis is the standard macro to mark **routes that the program should not enter**. The program will be panicked with a **‚Äú'internal error: entered unreachable code'‚Äù** error message, if the program entered those routes.\n\n```rust\nfn main() {\n    let level = 22;\n    let stage = match level {\n        1...5 => \"beginner\",\n        6...10 => \"intermediate\",\n        11...20 => \"expert\",\n        _ => unreachable!(),\n    };\n    \n    println!(\"{}\", stage);\n}\n\n\n// -------------- Compile-time error --------------\nthread 'main' panicked at 'internal error: entered unreachable code', src/main.rs:7:20\n```\n\nWe can set custom error messages for this as well.\n\n```rust\n// --- with a custom message ---\n_ => unreachable!(\"Custom message\"),\n// -------------- Compile-time error --------------\nthread 'main' panicked at 'internal error: entered unreachable code: Custom message', src/main.rs:7:20\n\n\n// --- with debug data ---\n_ => unreachable!(\"level is {}\", level),\n// -------------- Compile-time error --------------\nthread 'main' panicked at 'internal error: entered unreachable code: level is 22', src/main.rs:7:14\n```\n\n## assert!(), assert_eq!(), assert_ne!()\n\nThese are standard macros which usually use with test assertions.\n\n- `assert!()` ensures that a boolean expression is true. It panics if the expression is false.\n\n```rust\nfn main() {\n    let f = false;\n    \n    assert!(f)\n}\n\n\n// -------------- Compile-time error --------------\nthread 'main' panicked at 'assertion failed: f', src/main.rs:4:5\n```\n\n- `assert_eq!()` ensures that two expressions are equal. It panics if the expressions are not equal.\n\n```rust\nfn main() {\n    let a = 10;\n    let b = 20;\n    \n    assert_eq!(a, b);\n}\n\n\n// -------------- Compile-time error --------------\nthread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `10`,\n right: `20`', src/main.rs:5:5\n```\n\n- `assert_ne!()` ensures that two expressions are not equal. It panics if the expressions are equal.\n\n```rust\nfn main() {\n    let a = 10;\n    let b = 10;\n    \n    assert_ne!(a, b);\n}\n\n\n// -------------- Compile-time error --------------\nthread 'main' panicked at 'assertion failed: `(left != right)`\n  left: `10`,\n right: `10`', src/main.rs:5:5\n```\n\n> ‚≠ê Expressions which use with `assert_eq!()` and `assert_ne!()` should return same data type.\n\nWe can set custom error messages for these macros as well. For examples,\n\n1. With a custom message for `assert_eq!()`\n\n```rust\nfn main() {\n    let a = 10;\n    let b = 20;\n    \n    assert_eq!(a, b, \"a and b should be equal\");\n}\n\n\n// -------------- Compile-time error --------------\nthread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `10`,\n right: `20`: a and b should be equal', src/main.rs:5:5\n```\n\n2. `assert_eq!()` with debug data\n\n```rust\nfn main() {\n    let a = 10;\n    let b = 20;\n\n    let c = 40;\n    \n    assert_eq!(a+b, c, \"a = {} ; b = {}\", a, b);\n}\n\n// -------------- Compile-time error --------------\nthread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `30`,\n right: `40`: a = 10 ; b = 20', src/main.rs:7:5\n```\n\n## debug_assert!(), debug_assert_eq!(), debug_assert_ne!()\n\nüîé These are similar to above `assert` macros. But these statements are only enabled in non optimized builds by default. All these `debug_assert` macros will be omitted in release builds, unless we pass `-C debug-assertions` to the compiler.\n","date":"2019-03-19T14:50:39.959Z","updated":"2019-03-19T14:50:39.959Z","path":"docs/e2.panicking.html","comments":1,"layout":"page","_id":"cjtfwbizl000ndwgp9vztkoob","content":"<h2 id=\"panic\"><a href=\"#panic\" class=\"headerlink\" title=\"panic!()\"></a>panic!()</h2><ul>\n<li>In some cases, while an error happens we can not do anything to handle it, <strong>if the error is something, which should not be happened</strong>. In other words, if it‚Äôs an <strong>unrecoverable error</strong>.</li>\n<li>Also <strong>when we are not using a feature-rich debugger or proper logs</strong>, sometimes we need to <strong>debug the code by quitting the program from a specific line of code</strong> by printing out a specific message or a value of a variable binding to understand the current flow of the program.<br>For above cases, we can use <code>panic!</code> macro.</li>\n</ul>\n<p>‚≠ê <code>panic!()</code> runs <strong>thread based</strong>. One thread can be panicked, while other threads are running.</p>\n<h3 id=\"01-Quit-from-a-specific-line\"><a href=\"#01-Quit-from-a-specific-line\" class=\"headerlink\" title=\"01. Quit from a specific line.\"></a>01. Quit from a specific line.</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    // some code\n\n    // if we need to debug in here\n    panic!();\n}\n\n// -------------- Compile-time error --------------\nthread &#39;main&#39; panicked at &#39;explicit panic&#39;, src/main.rs:5:5\n</code></pre>\n<h3 id=\"02-Quit-with-a-custom-error-message\"><a href=\"#02-Quit-with-a-custom-error-message\" class=\"headerlink\" title=\"02. Quit with a custom error message.\"></a>02. Quit with a custom error message.</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">#[allow(unused_mut)] // üí° A lint attribute used to suppress the warning; username variable does not need to be mutable\nfn main() {\n    let mut username = String::new();\n\n    // some code to get the name\n\n    if username.is_empty() {\n        panic!(&quot;Username is empty!&quot;);\n    }\n\n    println!(&quot;{}&quot;, username);\n}\n\n// -------------- Compile-time error --------------\nthread &#39;main&#39; panicked at &#39;Username is empty!&#39;, src/main.rs:8:9\n</code></pre>\n<h3 id=\"03-Quit-with-the-value-of-code-elements\"><a href=\"#03-Quit-with-the-value-of-code-elements\" class=\"headerlink\" title=\"03. Quit with the value of code elements.\"></a>03. Quit with the value of code elements.</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">#[derive(Debug)] // üí° A lint attribute which use to implement `std::fmt::Debug` to Color\nstruct Color {\n    r: u8,\n    g: u8,\n    b: u8,\n}\n\n#[allow(unreachable_code)] // üí° A lint attribute used to suppress the warning; unreachable statement\nfn main() {\n    let some_color: Color;\n\n    // some code to get the color. ex\n    some_color = Color {r: 255, g: 255, b: 0};\n\n    // if we need to debug in here\n    panic!(&quot;{:?}&quot;, some_color);\n\n    println!(\n        &quot;The color = rgb({},{},{})&quot;,\n        some_color.r, some_color.g, some_color.b\n    );\n}\n\n// -------------- Compile-time error --------------\nthread &#39;main&#39; panicked at &#39;Color { r: 255, g: 255, b: 0 }&#39;, src/main.rs:16:5\n</code></pre>\n<p>As you can see in the above examples <code>panic!()</code> supports <a href=\"a3.hello_world.html#Usages-of-println\"><code>println!()</code> type style arguments</a>. By default, it prints the <strong>error message, file path and line &amp; column numbers</strong> where the error happens.</p>\n<h2 id=\"unimplemented\"><a href=\"#unimplemented\" class=\"headerlink\" title=\"unimplemented!()\"></a>unimplemented!()</h2><p>üí° If your code is having <strong>unfinished code sections</strong>, there is a standardized macro as <code>unimplemented!()</code> to mark those routes. The program will be panicked with a <strong>‚Äúnot yet implemented‚Äù</strong> error message, if the program runs through those routes.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// error messages with panic!()\nthread &#39;main&#39; panicked at &#39;explicit panic&#39;, src/main.rs:6:5\nthread &#39;main&#39; panicked at &#39;Username is empty!&#39;, src/main.rs:9:9\nthread &#39;main&#39; panicked at &#39;Color { r: 255, g: 255, b: 0 }&#39;, src/main.rs:17:5\n\n// error messages with unimplemented!()\nthread &#39;main&#39; panicked at &#39;not yet implemented&#39;, src/main.rs:6:5\nthread &#39;main&#39; panicked at &#39;not yet implemented: Username is empty!&#39;, src/main.rs:9:9\nthread &#39;main&#39; panicked at &#39;not yet implemented: Color { r: 255, g: 255, b: 0 }&#39;, src/main.rs:17:5\n</code></pre>\n<h2 id=\"unreachable\"><a href=\"#unreachable\" class=\"headerlink\" title=\"unreachable!()\"></a>unreachable!()</h2><p>This is the standard macro to mark <strong>routes that the program should not enter</strong>. The program will be panicked with a <strong>‚Äú‚Äôinternal error: entered unreachable code‚Äô‚Äù</strong> error message, if the program entered those routes.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let level = 22;\n    let stage = match level {\n        1...5 =&gt; &quot;beginner&quot;,\n        6...10 =&gt; &quot;intermediate&quot;,\n        11...20 =&gt; &quot;expert&quot;,\n        _ =&gt; unreachable!(),\n    };\n\n    println!(&quot;{}&quot;, stage);\n}\n\n\n// -------------- Compile-time error --------------\nthread &#39;main&#39; panicked at &#39;internal error: entered unreachable code&#39;, src/main.rs:7:20\n</code></pre>\n<p>We can set custom error messages for this as well.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// --- with a custom message ---\n_ =&gt; unreachable!(&quot;Custom message&quot;),\n// -------------- Compile-time error --------------\nthread &#39;main&#39; panicked at &#39;internal error: entered unreachable code: Custom message&#39;, src/main.rs:7:20\n\n\n// --- with debug data ---\n_ =&gt; unreachable!(&quot;level is {}&quot;, level),\n// -------------- Compile-time error --------------\nthread &#39;main&#39; panicked at &#39;internal error: entered unreachable code: level is 22&#39;, src/main.rs:7:14\n</code></pre>\n<h2 id=\"assert-assert-eq-assert-ne\"><a href=\"#assert-assert-eq-assert-ne\" class=\"headerlink\" title=\"assert!(), assert_eq!(), assert_ne!()\"></a>assert!(), assert_eq!(), assert_ne!()</h2><p>These are standard macros which usually use with test assertions.</p>\n<ul>\n<li><code>assert!()</code> ensures that a boolean expression is true. It panics if the expression is false.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let f = false;\n\n    assert!(f)\n}\n\n\n// -------------- Compile-time error --------------\nthread &#39;main&#39; panicked at &#39;assertion failed: f&#39;, src/main.rs:4:5\n</code></pre>\n<ul>\n<li><code>assert_eq!()</code> ensures that two expressions are equal. It panics if the expressions are not equal.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let a = 10;\n    let b = 20;\n\n    assert_eq!(a, b);\n}\n\n\n// -------------- Compile-time error --------------\nthread &#39;main&#39; panicked at &#39;assertion failed: `(left == right)`\n  left: `10`,\n right: `20`&#39;, src/main.rs:5:5\n</code></pre>\n<ul>\n<li><code>assert_ne!()</code> ensures that two expressions are not equal. It panics if the expressions are equal.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let a = 10;\n    let b = 10;\n\n    assert_ne!(a, b);\n}\n\n\n// -------------- Compile-time error --------------\nthread &#39;main&#39; panicked at &#39;assertion failed: `(left != right)`\n  left: `10`,\n right: `10`&#39;, src/main.rs:5:5\n</code></pre>\n<blockquote>\n<p>‚≠ê Expressions which use with <code>assert_eq!()</code> and <code>assert_ne!()</code> should return same data type.</p>\n</blockquote>\n<p>We can set custom error messages for these macros as well. For examples,</p>\n<ol>\n<li>With a custom message for <code>assert_eq!()</code></li>\n</ol>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let a = 10;\n    let b = 20;\n\n    assert_eq!(a, b, &quot;a and b should be equal&quot;);\n}\n\n\n// -------------- Compile-time error --------------\nthread &#39;main&#39; panicked at &#39;assertion failed: `(left == right)`\n  left: `10`,\n right: `20`: a and b should be equal&#39;, src/main.rs:5:5\n</code></pre>\n<ol start=\"2\">\n<li><code>assert_eq!()</code> with debug data</li>\n</ol>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let a = 10;\n    let b = 20;\n\n    let c = 40;\n\n    assert_eq!(a+b, c, &quot;a = {} ; b = {}&quot;, a, b);\n}\n\n// -------------- Compile-time error --------------\nthread &#39;main&#39; panicked at &#39;assertion failed: `(left == right)`\n  left: `30`,\n right: `40`: a = 10 ; b = 20&#39;, src/main.rs:7:5\n</code></pre>\n<h2 id=\"debug-assert-debug-assert-eq-debug-assert-ne\"><a href=\"#debug-assert-debug-assert-eq-debug-assert-ne\" class=\"headerlink\" title=\"debug_assert!(), debug_assert_eq!(), debug_assert_ne!()\"></a>debug_assert!(), debug_assert_eq!(), debug_assert_ne!()</h2><p>üîé These are similar to above <code>assert</code> macros. But these statements are only enabled in non optimized builds by default. All these <code>debug_assert</code> macros will be omitted in release builds, unless we pass <code>-C debug-assertions</code> to the compiler.</p>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<h2 id=\"panic\"><a href=\"#panic\" class=\"headerlink\" title=\"panic!()\"></a>panic!()</h2><ul>\n<li>In some cases, while an error happens we can not do anything to handle it, <strong>if the error is something, which should not be happened</strong>. In other words, if it‚Äôs an <strong>unrecoverable error</strong>.</li>\n<li>Also <strong>when we are not using a feature-rich debugger or proper logs</strong>, sometimes we need to <strong>debug the code by quitting the program from a specific line of code</strong> by printing out a specific message or a value of a variable binding to understand the current flow of the program.<br>For above cases, we can use <code>panic!</code> macro.</li>\n</ul>\n<p>‚≠ê <code>panic!()</code> runs <strong>thread based</strong>. One thread can be panicked, while other threads are running.</p>\n<h3 id=\"01-Quit-from-a-specific-line\"><a href=\"#01-Quit-from-a-specific-line\" class=\"headerlink\" title=\"01. Quit from a specific line.\"></a>01. Quit from a specific line.</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    // some code\n\n    // if we need to debug in here\n    panic!();\n}\n\n// -------------- Compile-time error --------------\nthread &#39;main&#39; panicked at &#39;explicit panic&#39;, src/main.rs:5:5\n</code></pre>\n<h3 id=\"02-Quit-with-a-custom-error-message\"><a href=\"#02-Quit-with-a-custom-error-message\" class=\"headerlink\" title=\"02. Quit with a custom error message.\"></a>02. Quit with a custom error message.</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">#[allow(unused_mut)] // üí° A lint attribute used to suppress the warning; username variable does not need to be mutable\nfn main() {\n    let mut username = String::new();\n\n    // some code to get the name\n\n    if username.is_empty() {\n        panic!(&quot;Username is empty!&quot;);\n    }\n\n    println!(&quot;{}&quot;, username);\n}\n\n// -------------- Compile-time error --------------\nthread &#39;main&#39; panicked at &#39;Username is empty!&#39;, src/main.rs:8:9\n</code></pre>\n<h3 id=\"03-Quit-with-the-value-of-code-elements\"><a href=\"#03-Quit-with-the-value-of-code-elements\" class=\"headerlink\" title=\"03. Quit with the value of code elements.\"></a>03. Quit with the value of code elements.</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">#[derive(Debug)] // üí° A lint attribute which use to implement `std::fmt::Debug` to Color\nstruct Color {\n    r: u8,\n    g: u8,\n    b: u8,\n}\n\n#[allow(unreachable_code)] // üí° A lint attribute used to suppress the warning; unreachable statement\nfn main() {\n    let some_color: Color;\n\n    // some code to get the color. ex\n    some_color = Color {r: 255, g: 255, b: 0};\n\n    // if we need to debug in here\n    panic!(&quot;{:?}&quot;, some_color);\n\n    println!(\n        &quot;The color = rgb({},{},{})&quot;,\n        some_color.r, some_color.g, some_color.b\n    );\n}\n\n// -------------- Compile-time error --------------\nthread &#39;main&#39; panicked at &#39;Color { r: 255, g: 255, b: 0 }&#39;, src/main.rs:16:5\n</code></pre>\n<p>As you can see in the above examples <code>panic!()</code> supports <a href=\"a3.hello_world.html#Usages-of-println\"><code>println!()</code> type style arguments</a>. By default, it prints the <strong>error message, file path and line &amp; column numbers</strong> where the error happens.</p>\n<h2 id=\"unimplemented\"><a href=\"#unimplemented\" class=\"headerlink\" title=\"unimplemented!()\"></a>unimplemented!()</h2><p>üí° If your code is having <strong>unfinished code sections</strong>, there is a standardized macro as <code>unimplemented!()</code> to mark those routes. The program will be panicked with a <strong>‚Äúnot yet implemented‚Äù</strong> error message, if the program runs through those routes.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// error messages with panic!()\nthread &#39;main&#39; panicked at &#39;explicit panic&#39;, src/main.rs:6:5\nthread &#39;main&#39; panicked at &#39;Username is empty!&#39;, src/main.rs:9:9\nthread &#39;main&#39; panicked at &#39;Color { r: 255, g: 255, b: 0 }&#39;, src/main.rs:17:5\n\n// error messages with unimplemented!()\nthread &#39;main&#39; panicked at &#39;not yet implemented&#39;, src/main.rs:6:5\nthread &#39;main&#39; panicked at &#39;not yet implemented: Username is empty!&#39;, src/main.rs:9:9\nthread &#39;main&#39; panicked at &#39;not yet implemented: Color { r: 255, g: 255, b: 0 }&#39;, src/main.rs:17:5\n</code></pre>\n<h2 id=\"unreachable\"><a href=\"#unreachable\" class=\"headerlink\" title=\"unreachable!()\"></a>unreachable!()</h2><p>This is the standard macro to mark <strong>routes that the program should not enter</strong>. The program will be panicked with a <strong>‚Äú‚Äôinternal error: entered unreachable code‚Äô‚Äù</strong> error message, if the program entered those routes.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let level = 22;\n    let stage = match level {\n        1...5 =&gt; &quot;beginner&quot;,\n        6...10 =&gt; &quot;intermediate&quot;,\n        11...20 =&gt; &quot;expert&quot;,\n        _ =&gt; unreachable!(),\n    };\n\n    println!(&quot;{}&quot;, stage);\n}\n\n\n// -------------- Compile-time error --------------\nthread &#39;main&#39; panicked at &#39;internal error: entered unreachable code&#39;, src/main.rs:7:20\n</code></pre>\n<p>We can set custom error messages for this as well.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// --- with a custom message ---\n_ =&gt; unreachable!(&quot;Custom message&quot;),\n// -------------- Compile-time error --------------\nthread &#39;main&#39; panicked at &#39;internal error: entered unreachable code: Custom message&#39;, src/main.rs:7:20\n\n\n// --- with debug data ---\n_ =&gt; unreachable!(&quot;level is {}&quot;, level),\n// -------------- Compile-time error --------------\nthread &#39;main&#39; panicked at &#39;internal error: entered unreachable code: level is 22&#39;, src/main.rs:7:14\n</code></pre>\n<h2 id=\"assert-assert-eq-assert-ne\"><a href=\"#assert-assert-eq-assert-ne\" class=\"headerlink\" title=\"assert!(), assert_eq!(), assert_ne!()\"></a>assert!(), assert_eq!(), assert_ne!()</h2><p>These are standard macros which usually use with test assertions.</p>\n<ul>\n<li><code>assert!()</code> ensures that a boolean expression is true. It panics if the expression is false.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let f = false;\n\n    assert!(f)\n}\n\n\n// -------------- Compile-time error --------------\nthread &#39;main&#39; panicked at &#39;assertion failed: f&#39;, src/main.rs:4:5\n</code></pre>\n<ul>\n<li><code>assert_eq!()</code> ensures that two expressions are equal. It panics if the expressions are not equal.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let a = 10;\n    let b = 20;\n\n    assert_eq!(a, b);\n}\n\n\n// -------------- Compile-time error --------------\nthread &#39;main&#39; panicked at &#39;assertion failed: `(left == right)`\n  left: `10`,\n right: `20`&#39;, src/main.rs:5:5\n</code></pre>\n<ul>\n<li><code>assert_ne!()</code> ensures that two expressions are not equal. It panics if the expressions are equal.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let a = 10;\n    let b = 10;\n\n    assert_ne!(a, b);\n}\n\n\n// -------------- Compile-time error --------------\nthread &#39;main&#39; panicked at &#39;assertion failed: `(left != right)`\n  left: `10`,\n right: `10`&#39;, src/main.rs:5:5\n</code></pre>\n<blockquote>\n<p>‚≠ê Expressions which use with <code>assert_eq!()</code> and <code>assert_ne!()</code> should return same data type.</p>\n</blockquote>\n<p>We can set custom error messages for these macros as well. For examples,</p>\n<ol>\n<li>With a custom message for <code>assert_eq!()</code></li>\n</ol>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let a = 10;\n    let b = 20;\n\n    assert_eq!(a, b, &quot;a and b should be equal&quot;);\n}\n\n\n// -------------- Compile-time error --------------\nthread &#39;main&#39; panicked at &#39;assertion failed: `(left == right)`\n  left: `10`,\n right: `20`: a and b should be equal&#39;, src/main.rs:5:5\n</code></pre>\n<ol start=\"2\">\n<li><code>assert_eq!()</code> with debug data</li>\n</ol>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let a = 10;\n    let b = 20;\n\n    let c = 40;\n\n    assert_eq!(a+b, c, &quot;a = {} ; b = {}&quot;, a, b);\n}\n\n// -------------- Compile-time error --------------\nthread &#39;main&#39; panicked at &#39;assertion failed: `(left == right)`\n  left: `30`,\n right: `40`: a = 10 ; b = 20&#39;, src/main.rs:7:5\n</code></pre>\n<h2 id=\"debug-assert-debug-assert-eq-debug-assert-ne\"><a href=\"#debug-assert-debug-assert-eq-debug-assert-ne\" class=\"headerlink\" title=\"debug_assert!(), debug_assert_eq!(), debug_assert_ne!()\"></a>debug_assert!(), debug_assert_eq!(), debug_assert_ne!()</h2><p>üîé These are similar to above <code>assert</code> macros. But these statements are only enabled in non optimized builds by default. All these <code>debug_assert</code> macros will be omitted in release builds, unless we pass <code>-C debug-assertions</code> to the compiler.</p>\n"},{"title":"Standard Library, Primitives and Preludes","_content":"\n‚≠êÔ∏è In Rust, language elements are implemented by not only **`std` library** crate but also **compiler** as well. Examples,\n- **[Primitives](https://doc.rust-lang.org/std/#primitives)**: Defined by the compiler and methods are implemented by `std` library directly on primitives.\n- **[Standard Macros](https://doc.rust-lang.org/std/#macros)**: Defined by both compiler and `std`\n\nThe **`std`** library has been divided into **[modules](https://doc.rust-lang.org/std/#modules)**, according to the main areas each covered.\n\n‚≠êÔ∏è While primitives are implemented by the **compiler**, the standard library implements the **most useful methods** directly on the primitive types. But some **rarely useful language elements** of some primitives are stored on relevant **`std` modules**. This is why you can see `char`, `str` and integer types on both [primitives](https://doc.rust-lang.org/std/#primitives) and [`std` modules](https://doc.rust-lang.org/std/#modules).\n\n\n## Primitives\n\n```rust\n// Primitives: Defined by the compiler and methods are directly implemented by std\nbool, char, slice, str\n\ni8, i16, i32, i64, i128, isize\nu8, u16, u32, u64, u128, usize\n\nf32, f64\n\narray, tuple\n\npointer, fn, reference\n```\n\n## Standard Macros\n\n```rust\n// Standard Macros also defined by both compiler and std\nprint, println, eprint, eprintln\nformat, format_args\nwrite, writeln\n\nconcat, concat_idents, stringify // concat_idents: nightly-only experimental API\n\ninclude, include_bytes, include_str\n\nassert, assert_eq, assert_ne\ndebug_assert, debug_assert_eq, debug_assert_ne\n\ntry, panic, compile_error, unreachable, unimplemented\n\nfile, line, column, module_path\nenv, option_env\ncfg\n\nselect, thread_local // select: nightly-only experimental API\n\nvec\n```\n\n## Std Modules\n\n```rust\n// std modules\nchar, str\n\ni8, i16, i32, i64, i128, isize\nu8, u16, u32 ,u64, u128, usize\nf32, f64\nnum\n\nvec, slice, hash, heap, collections // heap: nightly-only experimental API\n\nstring, ascii, fmt\n\ndefault\n\nmarker, clone, convert, cmp, iter\n\nops, ffi\n\noption, result, panic, error\n\nio\nfs, path\nmem, thread, sync\nprocess, env\nnet\ntime\nos\n\nptr, boxed, borrow, cell, any, rc\n\nprelude\n\nintrinsics // intrinsics: nightly-only experimental API\nraw // raw: nightly-only experimental API\n```\n\n> üîé When examining [Rust‚Äôs source code](https://github.com/rust-lang/rust), you can see that the [`src` directory](https://github.com/rust-lang/rust/tree/master/src) is a **workspace**. Even though it is having many library crates, by examining [root `Cargo.toml`](https://github.com/rust-lang/rust/blob/master/src/Cargo.toml) file you can easily identify that main crates are **[rustc](https://github.com/rust-lang/rust/tree/master/src/rustc)**(compiler) and **[libstd](https://github.com/rust-lang/rust/tree/master/src/libstd)** (std). In libstd/lib.rs std modules have been **re-exported** via `pub use` and the original location of most of the `std` modules is [`src/libcore`](https://github.com/rust-lang/rust/tree/master/src/libcore).\n\n**Few important `std` modules are,**\n- `std::io` - Core **I/O** functionality \n- `std::fs` - **Filesystem** specific functionality\n- `std::path` - **Cross-platform path** specific functionality\n- `std::env` - **Process‚Äôs environment** related functionality\n- `std::mem` - **Memory** related functionality\n- `std::net` - **TCP/UDP** communication\n- `std::os` - **OS** specific functionality\n- `std::thread` - Native **threads** specific functionality\n- `std::collections` - Core **Collection types**\n\n> üíØ Refer [Rust Standard Library Documentation](https://doc.rust-lang.org/std/) for more details.\n\n\n## Preludes\n\nEven though Rust `std` contains many modules, by default it doesn‚Äôt load each and everything of `std` library on every rust program. Instead, it loads only the **smallest list of things which require for almost every single Rust program**. These are called **[preludes](https://doc.rust-lang.org/std/prelude/)**. They import only,\n\n```rust\n// Reexported core operators\npub use marker::{Copy, Send, Sized, Sync};\npub use ops::{Drop, Fn, FnMut, FnOnce};\n\n// Reexported functions\npub use mem::drop;\n\n// Reexported types and traits\npub use boxed::Box;\npub use borrow::ToOwned;\npub use clone::Clone;\npub use cmp::{PartialEq, PartialOrd, Eq, Ord};\npub use convert::{AsRef, AsMut, Into, From};\npub use default::Default;\npub use iter::{Iterator, Extend, IntoIterator};\npub use iter::{DoubleEndedIterator, ExactSizeIterator};\npub use option::Option::{self, Some, None};\npub use result::Result::{self, Ok, Err};\npub use slice::SliceConcatExt;\npub use string::{String, ToString};\npub use vec::Vec;\n```\n\n> Preludes have been imported explicitly on [`libstd/lib.rs`](https://github.com/rust-lang/rust/blob/master/src/libstd/lib.rs#L353) and the whole list can be seen on [`libstd/prelude/v1.rs`](https://github.com/rust-lang/rust/blob/master/src/libstd/prelude/v1.rs).\n\n‚≠êÔ∏è So technically, Rust inserts,\n- `extern crate std;` : into the **crate root of every crate**\n- `use std::prelude::v1::*;` : into **every module**\n  So you don‚Äôt need to import these each time.\n\n\nThe concept of preludes is quite common on Rust libraries. Even some modules inside `std` crate (ex.[`std::io`](https://github.com/rust-lang/rust/blob/master/src/libstd/io/prelude.rs)) and many libraries (ex. [Diesel](https://github.com/diesel-rs/diesel/blob/master/diesel/src/lib.rs#L324)) are having their own `prelude` modules.\n\n‚≠êÔ∏è But **preludes** are used to **create a single place to import all important components** which are **required while using the library**. They **do not load automatically** unless you imported them manually. Only `std::prelude` imports automatically in every Rust programs.","source":"docs/d7.std_primitives_and_preludes.md","raw":"title: Standard Library, Primitives and Preludes\n---\n\n‚≠êÔ∏è In Rust, language elements are implemented by not only **`std` library** crate but also **compiler** as well. Examples,\n- **[Primitives](https://doc.rust-lang.org/std/#primitives)**: Defined by the compiler and methods are implemented by `std` library directly on primitives.\n- **[Standard Macros](https://doc.rust-lang.org/std/#macros)**: Defined by both compiler and `std`\n\nThe **`std`** library has been divided into **[modules](https://doc.rust-lang.org/std/#modules)**, according to the main areas each covered.\n\n‚≠êÔ∏è While primitives are implemented by the **compiler**, the standard library implements the **most useful methods** directly on the primitive types. But some **rarely useful language elements** of some primitives are stored on relevant **`std` modules**. This is why you can see `char`, `str` and integer types on both [primitives](https://doc.rust-lang.org/std/#primitives) and [`std` modules](https://doc.rust-lang.org/std/#modules).\n\n\n## Primitives\n\n```rust\n// Primitives: Defined by the compiler and methods are directly implemented by std\nbool, char, slice, str\n\ni8, i16, i32, i64, i128, isize\nu8, u16, u32, u64, u128, usize\n\nf32, f64\n\narray, tuple\n\npointer, fn, reference\n```\n\n## Standard Macros\n\n```rust\n// Standard Macros also defined by both compiler and std\nprint, println, eprint, eprintln\nformat, format_args\nwrite, writeln\n\nconcat, concat_idents, stringify // concat_idents: nightly-only experimental API\n\ninclude, include_bytes, include_str\n\nassert, assert_eq, assert_ne\ndebug_assert, debug_assert_eq, debug_assert_ne\n\ntry, panic, compile_error, unreachable, unimplemented\n\nfile, line, column, module_path\nenv, option_env\ncfg\n\nselect, thread_local // select: nightly-only experimental API\n\nvec\n```\n\n## Std Modules\n\n```rust\n// std modules\nchar, str\n\ni8, i16, i32, i64, i128, isize\nu8, u16, u32 ,u64, u128, usize\nf32, f64\nnum\n\nvec, slice, hash, heap, collections // heap: nightly-only experimental API\n\nstring, ascii, fmt\n\ndefault\n\nmarker, clone, convert, cmp, iter\n\nops, ffi\n\noption, result, panic, error\n\nio\nfs, path\nmem, thread, sync\nprocess, env\nnet\ntime\nos\n\nptr, boxed, borrow, cell, any, rc\n\nprelude\n\nintrinsics // intrinsics: nightly-only experimental API\nraw // raw: nightly-only experimental API\n```\n\n> üîé When examining [Rust‚Äôs source code](https://github.com/rust-lang/rust), you can see that the [`src` directory](https://github.com/rust-lang/rust/tree/master/src) is a **workspace**. Even though it is having many library crates, by examining [root `Cargo.toml`](https://github.com/rust-lang/rust/blob/master/src/Cargo.toml) file you can easily identify that main crates are **[rustc](https://github.com/rust-lang/rust/tree/master/src/rustc)**(compiler) and **[libstd](https://github.com/rust-lang/rust/tree/master/src/libstd)** (std). In libstd/lib.rs std modules have been **re-exported** via `pub use` and the original location of most of the `std` modules is [`src/libcore`](https://github.com/rust-lang/rust/tree/master/src/libcore).\n\n**Few important `std` modules are,**\n- `std::io` - Core **I/O** functionality \n- `std::fs` - **Filesystem** specific functionality\n- `std::path` - **Cross-platform path** specific functionality\n- `std::env` - **Process‚Äôs environment** related functionality\n- `std::mem` - **Memory** related functionality\n- `std::net` - **TCP/UDP** communication\n- `std::os` - **OS** specific functionality\n- `std::thread` - Native **threads** specific functionality\n- `std::collections` - Core **Collection types**\n\n> üíØ Refer [Rust Standard Library Documentation](https://doc.rust-lang.org/std/) for more details.\n\n\n## Preludes\n\nEven though Rust `std` contains many modules, by default it doesn‚Äôt load each and everything of `std` library on every rust program. Instead, it loads only the **smallest list of things which require for almost every single Rust program**. These are called **[preludes](https://doc.rust-lang.org/std/prelude/)**. They import only,\n\n```rust\n// Reexported core operators\npub use marker::{Copy, Send, Sized, Sync};\npub use ops::{Drop, Fn, FnMut, FnOnce};\n\n// Reexported functions\npub use mem::drop;\n\n// Reexported types and traits\npub use boxed::Box;\npub use borrow::ToOwned;\npub use clone::Clone;\npub use cmp::{PartialEq, PartialOrd, Eq, Ord};\npub use convert::{AsRef, AsMut, Into, From};\npub use default::Default;\npub use iter::{Iterator, Extend, IntoIterator};\npub use iter::{DoubleEndedIterator, ExactSizeIterator};\npub use option::Option::{self, Some, None};\npub use result::Result::{self, Ok, Err};\npub use slice::SliceConcatExt;\npub use string::{String, ToString};\npub use vec::Vec;\n```\n\n> Preludes have been imported explicitly on [`libstd/lib.rs`](https://github.com/rust-lang/rust/blob/master/src/libstd/lib.rs#L353) and the whole list can be seen on [`libstd/prelude/v1.rs`](https://github.com/rust-lang/rust/blob/master/src/libstd/prelude/v1.rs).\n\n‚≠êÔ∏è So technically, Rust inserts,\n- `extern crate std;` : into the **crate root of every crate**\n- `use std::prelude::v1::*;` : into **every module**\n  So you don‚Äôt need to import these each time.\n\n\nThe concept of preludes is quite common on Rust libraries. Even some modules inside `std` crate (ex.[`std::io`](https://github.com/rust-lang/rust/blob/master/src/libstd/io/prelude.rs)) and many libraries (ex. [Diesel](https://github.com/diesel-rs/diesel/blob/master/diesel/src/lib.rs#L324)) are having their own `prelude` modules.\n\n‚≠êÔ∏è But **preludes** are used to **create a single place to import all important components** which are **required while using the library**. They **do not load automatically** unless you imported them manually. Only `std::prelude` imports automatically in every Rust programs.","date":"2019-03-19T14:50:39.957Z","updated":"2019-03-19T14:50:39.957Z","path":"docs/d7.std_primitives_and_preludes.html","comments":1,"layout":"page","_id":"cjtfwbizl000odwgp5eudl57x","content":"<p>‚≠êÔ∏è In Rust, language elements are implemented by not only <strong><code>std</code> library</strong> crate but also <strong>compiler</strong> as well. Examples,</p>\n<ul>\n<li><strong><a href=\"https://doc.rust-lang.org/std/#primitives\" target=\"_blank\" rel=\"noopener\">Primitives</a></strong>: Defined by the compiler and methods are implemented by <code>std</code> library directly on primitives.</li>\n<li><strong><a href=\"https://doc.rust-lang.org/std/#macros\" target=\"_blank\" rel=\"noopener\">Standard Macros</a></strong>: Defined by both compiler and <code>std</code></li>\n</ul>\n<p>The <strong><code>std</code></strong> library has been divided into <strong><a href=\"https://doc.rust-lang.org/std/#modules\" target=\"_blank\" rel=\"noopener\">modules</a></strong>, according to the main areas each covered.</p>\n<p>‚≠êÔ∏è While primitives are implemented by the <strong>compiler</strong>, the standard library implements the <strong>most useful methods</strong> directly on the primitive types. But some <strong>rarely useful language elements</strong> of some primitives are stored on relevant <strong><code>std</code> modules</strong>. This is why you can see <code>char</code>, <code>str</code> and integer types on both <a href=\"https://doc.rust-lang.org/std/#primitives\" target=\"_blank\" rel=\"noopener\">primitives</a> and <a href=\"https://doc.rust-lang.org/std/#modules\" target=\"_blank\" rel=\"noopener\"><code>std</code> modules</a>.</p>\n<h2 id=\"Primitives\"><a href=\"#Primitives\" class=\"headerlink\" title=\"Primitives\"></a>Primitives</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Primitives: Defined by the compiler and methods are directly implemented by std\nbool, char, slice, str\n\ni8, i16, i32, i64, i128, isize\nu8, u16, u32, u64, u128, usize\n\nf32, f64\n\narray, tuple\n\npointer, fn, reference\n</code></pre>\n<h2 id=\"Standard-Macros\"><a href=\"#Standard-Macros\" class=\"headerlink\" title=\"Standard Macros\"></a>Standard Macros</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Standard Macros also defined by both compiler and std\nprint, println, eprint, eprintln\nformat, format_args\nwrite, writeln\n\nconcat, concat_idents, stringify // concat_idents: nightly-only experimental API\n\ninclude, include_bytes, include_str\n\nassert, assert_eq, assert_ne\ndebug_assert, debug_assert_eq, debug_assert_ne\n\ntry, panic, compile_error, unreachable, unimplemented\n\nfile, line, column, module_path\nenv, option_env\ncfg\n\nselect, thread_local // select: nightly-only experimental API\n\nvec\n</code></pre>\n<h2 id=\"Std-Modules\"><a href=\"#Std-Modules\" class=\"headerlink\" title=\"Std Modules\"></a>Std Modules</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// std modules\nchar, str\n\ni8, i16, i32, i64, i128, isize\nu8, u16, u32 ,u64, u128, usize\nf32, f64\nnum\n\nvec, slice, hash, heap, collections // heap: nightly-only experimental API\n\nstring, ascii, fmt\n\ndefault\n\nmarker, clone, convert, cmp, iter\n\nops, ffi\n\noption, result, panic, error\n\nio\nfs, path\nmem, thread, sync\nprocess, env\nnet\ntime\nos\n\nptr, boxed, borrow, cell, any, rc\n\nprelude\n\nintrinsics // intrinsics: nightly-only experimental API\nraw // raw: nightly-only experimental API\n</code></pre>\n<blockquote>\n<p>üîé When examining <a href=\"https://github.com/rust-lang/rust\" target=\"_blank\" rel=\"noopener\">Rust‚Äôs source code</a>, you can see that the <a href=\"https://github.com/rust-lang/rust/tree/master/src\" target=\"_blank\" rel=\"noopener\"><code>src</code> directory</a> is a <strong>workspace</strong>. Even though it is having many library crates, by examining <a href=\"https://github.com/rust-lang/rust/blob/master/src/Cargo.toml\" target=\"_blank\" rel=\"noopener\">root <code>Cargo.toml</code></a> file you can easily identify that main crates are <strong><a href=\"https://github.com/rust-lang/rust/tree/master/src/rustc\" target=\"_blank\" rel=\"noopener\">rustc</a></strong>(compiler) and <strong><a href=\"https://github.com/rust-lang/rust/tree/master/src/libstd\" target=\"_blank\" rel=\"noopener\">libstd</a></strong> (std). In libstd/lib.rs std modules have been <strong>re-exported</strong> via <code>pub use</code> and the original location of most of the <code>std</code> modules is <a href=\"https://github.com/rust-lang/rust/tree/master/src/libcore\" target=\"_blank\" rel=\"noopener\"><code>src/libcore</code></a>.</p>\n</blockquote>\n<p><strong>Few important <code>std</code> modules are,</strong></p>\n<ul>\n<li><code>std::io</code> - Core <strong>I/O</strong> functionality </li>\n<li><code>std::fs</code> - <strong>Filesystem</strong> specific functionality</li>\n<li><code>std::path</code> - <strong>Cross-platform path</strong> specific functionality</li>\n<li><code>std::env</code> - <strong>Process‚Äôs environment</strong> related functionality</li>\n<li><code>std::mem</code> - <strong>Memory</strong> related functionality</li>\n<li><code>std::net</code> - <strong>TCP/UDP</strong> communication</li>\n<li><code>std::os</code> - <strong>OS</strong> specific functionality</li>\n<li><code>std::thread</code> - Native <strong>threads</strong> specific functionality</li>\n<li><code>std::collections</code> - Core <strong>Collection types</strong></li>\n</ul>\n<blockquote>\n<p>üíØ Refer <a href=\"https://doc.rust-lang.org/std/\" target=\"_blank\" rel=\"noopener\">Rust Standard Library Documentation</a> for more details.</p>\n</blockquote>\n<h2 id=\"Preludes\"><a href=\"#Preludes\" class=\"headerlink\" title=\"Preludes\"></a>Preludes</h2><p>Even though Rust <code>std</code> contains many modules, by default it doesn‚Äôt load each and everything of <code>std</code> library on every rust program. Instead, it loads only the <strong>smallest list of things which require for almost every single Rust program</strong>. These are called <strong><a href=\"https://doc.rust-lang.org/std/prelude/\" target=\"_blank\" rel=\"noopener\">preludes</a></strong>. They import only,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Reexported core operators\npub use marker::{Copy, Send, Sized, Sync};\npub use ops::{Drop, Fn, FnMut, FnOnce};\n\n// Reexported functions\npub use mem::drop;\n\n// Reexported types and traits\npub use boxed::Box;\npub use borrow::ToOwned;\npub use clone::Clone;\npub use cmp::{PartialEq, PartialOrd, Eq, Ord};\npub use convert::{AsRef, AsMut, Into, From};\npub use default::Default;\npub use iter::{Iterator, Extend, IntoIterator};\npub use iter::{DoubleEndedIterator, ExactSizeIterator};\npub use option::Option::{self, Some, None};\npub use result::Result::{self, Ok, Err};\npub use slice::SliceConcatExt;\npub use string::{String, ToString};\npub use vec::Vec;\n</code></pre>\n<blockquote>\n<p>Preludes have been imported explicitly on <a href=\"https://github.com/rust-lang/rust/blob/master/src/libstd/lib.rs#L353\" target=\"_blank\" rel=\"noopener\"><code>libstd/lib.rs</code></a> and the whole list can be seen on <a href=\"https://github.com/rust-lang/rust/blob/master/src/libstd/prelude/v1.rs\" target=\"_blank\" rel=\"noopener\"><code>libstd/prelude/v1.rs</code></a>.</p>\n</blockquote>\n<p>‚≠êÔ∏è So technically, Rust inserts,</p>\n<ul>\n<li><code>extern crate std;</code> : into the <strong>crate root of every crate</strong></li>\n<li><code>use std::prelude::v1::*;</code> : into <strong>every module</strong><br>So you don‚Äôt need to import these each time.</li>\n</ul>\n<p>The concept of preludes is quite common on Rust libraries. Even some modules inside <code>std</code> crate (ex.<a href=\"https://github.com/rust-lang/rust/blob/master/src/libstd/io/prelude.rs\" target=\"_blank\" rel=\"noopener\"><code>std::io</code></a>) and many libraries (ex. <a href=\"https://github.com/diesel-rs/diesel/blob/master/diesel/src/lib.rs#L324\" target=\"_blank\" rel=\"noopener\">Diesel</a>) are having their own <code>prelude</code> modules.</p>\n<p>‚≠êÔ∏è But <strong>preludes</strong> are used to <strong>create a single place to import all important components</strong> which are <strong>required while using the library</strong>. They <strong>do not load automatically</strong> unless you imported them manually. Only <code>std::prelude</code> imports automatically in every Rust programs.</p>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<p>‚≠êÔ∏è In Rust, language elements are implemented by not only <strong><code>std</code> library</strong> crate but also <strong>compiler</strong> as well. Examples,</p>\n<ul>\n<li><strong><a href=\"https://doc.rust-lang.org/std/#primitives\" target=\"_blank\" rel=\"noopener\">Primitives</a></strong>: Defined by the compiler and methods are implemented by <code>std</code> library directly on primitives.</li>\n<li><strong><a href=\"https://doc.rust-lang.org/std/#macros\" target=\"_blank\" rel=\"noopener\">Standard Macros</a></strong>: Defined by both compiler and <code>std</code></li>\n</ul>\n<p>The <strong><code>std</code></strong> library has been divided into <strong><a href=\"https://doc.rust-lang.org/std/#modules\" target=\"_blank\" rel=\"noopener\">modules</a></strong>, according to the main areas each covered.</p>\n<p>‚≠êÔ∏è While primitives are implemented by the <strong>compiler</strong>, the standard library implements the <strong>most useful methods</strong> directly on the primitive types. But some <strong>rarely useful language elements</strong> of some primitives are stored on relevant <strong><code>std</code> modules</strong>. This is why you can see <code>char</code>, <code>str</code> and integer types on both <a href=\"https://doc.rust-lang.org/std/#primitives\" target=\"_blank\" rel=\"noopener\">primitives</a> and <a href=\"https://doc.rust-lang.org/std/#modules\" target=\"_blank\" rel=\"noopener\"><code>std</code> modules</a>.</p>\n<h2 id=\"Primitives\"><a href=\"#Primitives\" class=\"headerlink\" title=\"Primitives\"></a>Primitives</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Primitives: Defined by the compiler and methods are directly implemented by std\nbool, char, slice, str\n\ni8, i16, i32, i64, i128, isize\nu8, u16, u32, u64, u128, usize\n\nf32, f64\n\narray, tuple\n\npointer, fn, reference\n</code></pre>\n<h2 id=\"Standard-Macros\"><a href=\"#Standard-Macros\" class=\"headerlink\" title=\"Standard Macros\"></a>Standard Macros</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Standard Macros also defined by both compiler and std\nprint, println, eprint, eprintln\nformat, format_args\nwrite, writeln\n\nconcat, concat_idents, stringify // concat_idents: nightly-only experimental API\n\ninclude, include_bytes, include_str\n\nassert, assert_eq, assert_ne\ndebug_assert, debug_assert_eq, debug_assert_ne\n\ntry, panic, compile_error, unreachable, unimplemented\n\nfile, line, column, module_path\nenv, option_env\ncfg\n\nselect, thread_local // select: nightly-only experimental API\n\nvec\n</code></pre>\n<h2 id=\"Std-Modules\"><a href=\"#Std-Modules\" class=\"headerlink\" title=\"Std Modules\"></a>Std Modules</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// std modules\nchar, str\n\ni8, i16, i32, i64, i128, isize\nu8, u16, u32 ,u64, u128, usize\nf32, f64\nnum\n\nvec, slice, hash, heap, collections // heap: nightly-only experimental API\n\nstring, ascii, fmt\n\ndefault\n\nmarker, clone, convert, cmp, iter\n\nops, ffi\n\noption, result, panic, error\n\nio\nfs, path\nmem, thread, sync\nprocess, env\nnet\ntime\nos\n\nptr, boxed, borrow, cell, any, rc\n\nprelude\n\nintrinsics // intrinsics: nightly-only experimental API\nraw // raw: nightly-only experimental API\n</code></pre>\n<blockquote>\n<p>üîé When examining <a href=\"https://github.com/rust-lang/rust\" target=\"_blank\" rel=\"noopener\">Rust‚Äôs source code</a>, you can see that the <a href=\"https://github.com/rust-lang/rust/tree/master/src\" target=\"_blank\" rel=\"noopener\"><code>src</code> directory</a> is a <strong>workspace</strong>. Even though it is having many library crates, by examining <a href=\"https://github.com/rust-lang/rust/blob/master/src/Cargo.toml\" target=\"_blank\" rel=\"noopener\">root <code>Cargo.toml</code></a> file you can easily identify that main crates are <strong><a href=\"https://github.com/rust-lang/rust/tree/master/src/rustc\" target=\"_blank\" rel=\"noopener\">rustc</a></strong>(compiler) and <strong><a href=\"https://github.com/rust-lang/rust/tree/master/src/libstd\" target=\"_blank\" rel=\"noopener\">libstd</a></strong> (std). In libstd/lib.rs std modules have been <strong>re-exported</strong> via <code>pub use</code> and the original location of most of the <code>std</code> modules is <a href=\"https://github.com/rust-lang/rust/tree/master/src/libcore\" target=\"_blank\" rel=\"noopener\"><code>src/libcore</code></a>.</p>\n</blockquote>\n<p><strong>Few important <code>std</code> modules are,</strong></p>\n<ul>\n<li><code>std::io</code> - Core <strong>I/O</strong> functionality </li>\n<li><code>std::fs</code> - <strong>Filesystem</strong> specific functionality</li>\n<li><code>std::path</code> - <strong>Cross-platform path</strong> specific functionality</li>\n<li><code>std::env</code> - <strong>Process‚Äôs environment</strong> related functionality</li>\n<li><code>std::mem</code> - <strong>Memory</strong> related functionality</li>\n<li><code>std::net</code> - <strong>TCP/UDP</strong> communication</li>\n<li><code>std::os</code> - <strong>OS</strong> specific functionality</li>\n<li><code>std::thread</code> - Native <strong>threads</strong> specific functionality</li>\n<li><code>std::collections</code> - Core <strong>Collection types</strong></li>\n</ul>\n<blockquote>\n<p>üíØ Refer <a href=\"https://doc.rust-lang.org/std/\" target=\"_blank\" rel=\"noopener\">Rust Standard Library Documentation</a> for more details.</p>\n</blockquote>\n<h2 id=\"Preludes\"><a href=\"#Preludes\" class=\"headerlink\" title=\"Preludes\"></a>Preludes</h2><p>Even though Rust <code>std</code> contains many modules, by default it doesn‚Äôt load each and everything of <code>std</code> library on every rust program. Instead, it loads only the <strong>smallest list of things which require for almost every single Rust program</strong>. These are called <strong><a href=\"https://doc.rust-lang.org/std/prelude/\" target=\"_blank\" rel=\"noopener\">preludes</a></strong>. They import only,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Reexported core operators\npub use marker::{Copy, Send, Sized, Sync};\npub use ops::{Drop, Fn, FnMut, FnOnce};\n\n// Reexported functions\npub use mem::drop;\n\n// Reexported types and traits\npub use boxed::Box;\npub use borrow::ToOwned;\npub use clone::Clone;\npub use cmp::{PartialEq, PartialOrd, Eq, Ord};\npub use convert::{AsRef, AsMut, Into, From};\npub use default::Default;\npub use iter::{Iterator, Extend, IntoIterator};\npub use iter::{DoubleEndedIterator, ExactSizeIterator};\npub use option::Option::{self, Some, None};\npub use result::Result::{self, Ok, Err};\npub use slice::SliceConcatExt;\npub use string::{String, ToString};\npub use vec::Vec;\n</code></pre>\n<blockquote>\n<p>Preludes have been imported explicitly on <a href=\"https://github.com/rust-lang/rust/blob/master/src/libstd/lib.rs#L353\" target=\"_blank\" rel=\"noopener\"><code>libstd/lib.rs</code></a> and the whole list can be seen on <a href=\"https://github.com/rust-lang/rust/blob/master/src/libstd/prelude/v1.rs\" target=\"_blank\" rel=\"noopener\"><code>libstd/prelude/v1.rs</code></a>.</p>\n</blockquote>\n<p>‚≠êÔ∏è So technically, Rust inserts,</p>\n<ul>\n<li><code>extern crate std;</code> : into the <strong>crate root of every crate</strong></li>\n<li><code>use std::prelude::v1::*;</code> : into <strong>every module</strong><br>So you don‚Äôt need to import these each time.</li>\n</ul>\n<p>The concept of preludes is quite common on Rust libraries. Even some modules inside <code>std</code> crate (ex.<a href=\"https://github.com/rust-lang/rust/blob/master/src/libstd/io/prelude.rs\" target=\"_blank\" rel=\"noopener\"><code>std::io</code></a>) and many libraries (ex. <a href=\"https://github.com/diesel-rs/diesel/blob/master/diesel/src/lib.rs#L324\" target=\"_blank\" rel=\"noopener\">Diesel</a>) are having their own <code>prelude</code> modules.</p>\n<p>‚≠êÔ∏è But <strong>preludes</strong> are used to <strong>create a single place to import all important components</strong> which are <strong>required while using the library</strong>. They <strong>do not load automatically</strong> unless you imported them manually. Only <code>std::prelude</code> imports automatically in every Rust programs.</p>\n"},{"title":"Smart Compiler","_content":"\n## Why Compiler?\n\nThe Rust compiler does the most significant job to prevent errors in Rust programs. It **analyzes the code at compile-time** and issues warnings, if the code does not follow memory management rules or lifetime annotations correctly. \n\nFor example,\n```rust\n#[allow(unused_variables)] //üí° A lint attribute used to suppress the warning; unused variable: `b`\nfn main() {\n    let a = vec![1, 2, 3];\n    let b = a;\n\n    println!(\"{:?}\", a);\n}\n\n\n// ------ Compile-time error ------\nerror[E0382]: use of moved value: `a`\n --> src/main.rs:6:22\n  |\n3 |     let b = a;\n  |         - value moved here\n4 |\n5 |     println!(\"{:?}\", a);\n  |                      ^ value used here after move\n  |\n  = note: move occurs because `a` has type `std::vec::Vec<i32>`, which does not implement the `Copy` trait\n\nerror: aborting due to previous error\nFor more information about this error, try `rustc --explain E0382`.\n\n// ‚≠ê instead using #[allow(unused_variables)], consider using \"let _b = a;\" in line 4. \n// Also you can use \"let _ =\" to completely ignore return values\n```\n\n> üí≠ In the previous sections, we have discussed memory management concepts like [ownership](c1.ownership.html), [borrowing](c2.borrowing.html), [lifetimes](c3.lifetimes.md) and etc.\n\nRust compiler checks not only issues related with lifetimes or memory management and also common coding mistakes, like the following code.\n\n```rust\nstruct Color {\n    r: u8,\n    g: u8,\n    b: u8,\n}\n\nfn main() {\n    let yellow = Color {\n        r: 255,\n        g: 255,\n        d: 0,\n    };\n\n    println!(\"Yellow = rgb({},{},{})\", yellow.r, yellow.g, yellow.b);\n}\n\n\n// ------------ Compile-time error ------------\nerror[E0560]: struct `Color` has no field named `d`\n  --> src/main.rs:11:9\n   |\n11 |         d: 0,\n   |         ^ field does not exist - did you mean `b`?\n\nerror: aborting due to previous error\nFor more information about this error, try `rustc --explain E0560`.\n```\n\n## Explain Error Codes\n\nAbove error messages are very descriptive and we can easily see where is the error. But while we can not identify the issue via the error message, **`rustc --explain`** commands help us **to identify the error type and how to solve** it, by showing **simple code samples** which express the same problem and the solution we have to use. \n\nFor example, `rustc --explain E0571` shows the following output in the console.\n\n```rust\nA `break` statement with an argument appeared in a non-`loop` loop.\n\nExample of erroneous code:\nÔΩÄÔΩÄÔΩÄ\nlet result = while true {\n    if satisfied(i) {\n        break 2*i; // error: `break` with value from a `while` loop\n    }\n    i += 1;\n};\nÔΩÄÔΩÄÔΩÄ\n\nThe `break` statement can take an argument (which will be the value of the loop\nexpression if the `break` statement is executed) in `loop` loops, but not\n`for`, `while`, or `while let` loops.\n\nMake sure `break value;` statements only occur in `loop` loops:\nÔΩÄÔΩÄÔΩÄ\nlet result = loop { // ok!\n    if satisfied(i) {\n        break 2*i;\n    }\n    i += 1;\n};\nÔΩÄÔΩÄÔΩÄ\n```\n\nüí° Also you can read the same explanations via [Rust Compiler Error Index](https://medium.com/r/?url=https%3A%2F%2Fdoc.rust-lang.org%2Ferror-index.html). For example to check the explanation of `E0571` error, you can use https://doc.rust-lang.org/error-index.html#E0571.\n","source":"docs/e1.smart_compiler.md","raw":"title: Smart Compiler\n---\n\n## Why Compiler?\n\nThe Rust compiler does the most significant job to prevent errors in Rust programs. It **analyzes the code at compile-time** and issues warnings, if the code does not follow memory management rules or lifetime annotations correctly. \n\nFor example,\n```rust\n#[allow(unused_variables)] //üí° A lint attribute used to suppress the warning; unused variable: `b`\nfn main() {\n    let a = vec![1, 2, 3];\n    let b = a;\n\n    println!(\"{:?}\", a);\n}\n\n\n// ------ Compile-time error ------\nerror[E0382]: use of moved value: `a`\n --> src/main.rs:6:22\n  |\n3 |     let b = a;\n  |         - value moved here\n4 |\n5 |     println!(\"{:?}\", a);\n  |                      ^ value used here after move\n  |\n  = note: move occurs because `a` has type `std::vec::Vec<i32>`, which does not implement the `Copy` trait\n\nerror: aborting due to previous error\nFor more information about this error, try `rustc --explain E0382`.\n\n// ‚≠ê instead using #[allow(unused_variables)], consider using \"let _b = a;\" in line 4. \n// Also you can use \"let _ =\" to completely ignore return values\n```\n\n> üí≠ In the previous sections, we have discussed memory management concepts like [ownership](c1.ownership.html), [borrowing](c2.borrowing.html), [lifetimes](c3.lifetimes.md) and etc.\n\nRust compiler checks not only issues related with lifetimes or memory management and also common coding mistakes, like the following code.\n\n```rust\nstruct Color {\n    r: u8,\n    g: u8,\n    b: u8,\n}\n\nfn main() {\n    let yellow = Color {\n        r: 255,\n        g: 255,\n        d: 0,\n    };\n\n    println!(\"Yellow = rgb({},{},{})\", yellow.r, yellow.g, yellow.b);\n}\n\n\n// ------------ Compile-time error ------------\nerror[E0560]: struct `Color` has no field named `d`\n  --> src/main.rs:11:9\n   |\n11 |         d: 0,\n   |         ^ field does not exist - did you mean `b`?\n\nerror: aborting due to previous error\nFor more information about this error, try `rustc --explain E0560`.\n```\n\n## Explain Error Codes\n\nAbove error messages are very descriptive and we can easily see where is the error. But while we can not identify the issue via the error message, **`rustc --explain`** commands help us **to identify the error type and how to solve** it, by showing **simple code samples** which express the same problem and the solution we have to use. \n\nFor example, `rustc --explain E0571` shows the following output in the console.\n\n```rust\nA `break` statement with an argument appeared in a non-`loop` loop.\n\nExample of erroneous code:\nÔΩÄÔΩÄÔΩÄ\nlet result = while true {\n    if satisfied(i) {\n        break 2*i; // error: `break` with value from a `while` loop\n    }\n    i += 1;\n};\nÔΩÄÔΩÄÔΩÄ\n\nThe `break` statement can take an argument (which will be the value of the loop\nexpression if the `break` statement is executed) in `loop` loops, but not\n`for`, `while`, or `while let` loops.\n\nMake sure `break value;` statements only occur in `loop` loops:\nÔΩÄÔΩÄÔΩÄ\nlet result = loop { // ok!\n    if satisfied(i) {\n        break 2*i;\n    }\n    i += 1;\n};\nÔΩÄÔΩÄÔΩÄ\n```\n\nüí° Also you can read the same explanations via [Rust Compiler Error Index](https://medium.com/r/?url=https%3A%2F%2Fdoc.rust-lang.org%2Ferror-index.html). For example to check the explanation of `E0571` error, you can use https://doc.rust-lang.org/error-index.html#E0571.\n","date":"2019-03-19T14:50:39.958Z","updated":"2019-03-19T14:50:39.958Z","path":"docs/e1.smart_compiler.html","comments":1,"layout":"page","_id":"cjtfwbizl000pdwgpux401idd","content":"<h2 id=\"Why-Compiler\"><a href=\"#Why-Compiler\" class=\"headerlink\" title=\"Why Compiler?\"></a>Why Compiler?</h2><p>The Rust compiler does the most significant job to prevent errors in Rust programs. It <strong>analyzes the code at compile-time</strong> and issues warnings, if the code does not follow memory management rules or lifetime annotations correctly. </p>\n<p>For example,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">#[allow(unused_variables)] //üí° A lint attribute used to suppress the warning; unused variable: `b`\nfn main() {\n    let a = vec![1, 2, 3];\n    let b = a;\n\n    println!(&quot;{:?}&quot;, a);\n}\n\n\n// ------ Compile-time error ------\nerror[E0382]: use of moved value: `a`\n --&gt; src/main.rs:6:22\n  |\n3 |     let b = a;\n  |         - value moved here\n4 |\n5 |     println!(&quot;{:?}&quot;, a);\n  |                      ^ value used here after move\n  |\n  = note: move occurs because `a` has type `std::vec::Vec&lt;i32&gt;`, which does not implement the `Copy` trait\n\nerror: aborting due to previous error\nFor more information about this error, try `rustc --explain E0382`.\n\n// ‚≠ê instead using #[allow(unused_variables)], consider using &quot;let _b = a;&quot; in line 4. \n// Also you can use &quot;let _ =&quot; to completely ignore return values\n</code></pre>\n<blockquote>\n<p>üí≠ In the previous sections, we have discussed memory management concepts like <a href=\"c1.ownership.html\">ownership</a>, <a href=\"c2.borrowing.html\">borrowing</a>, <a href=\"c3.lifetimes.md\">lifetimes</a> and etc.</p>\n</blockquote>\n<p>Rust compiler checks not only issues related with lifetimes or memory management and also common coding mistakes, like the following code.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Color {\n    r: u8,\n    g: u8,\n    b: u8,\n}\n\nfn main() {\n    let yellow = Color {\n        r: 255,\n        g: 255,\n        d: 0,\n    };\n\n    println!(&quot;Yellow = rgb({},{},{})&quot;, yellow.r, yellow.g, yellow.b);\n}\n\n\n// ------------ Compile-time error ------------\nerror[E0560]: struct `Color` has no field named `d`\n  --&gt; src/main.rs:11:9\n   |\n11 |         d: 0,\n   |         ^ field does not exist - did you mean `b`?\n\nerror: aborting due to previous error\nFor more information about this error, try `rustc --explain E0560`.\n</code></pre>\n<h2 id=\"Explain-Error-Codes\"><a href=\"#Explain-Error-Codes\" class=\"headerlink\" title=\"Explain Error Codes\"></a>Explain Error Codes</h2><p>Above error messages are very descriptive and we can easily see where is the error. But while we can not identify the issue via the error message, <strong><code>rustc --explain</code></strong> commands help us <strong>to identify the error type and how to solve</strong> it, by showing <strong>simple code samples</strong> which express the same problem and the solution we have to use. </p>\n<p>For example, <code>rustc --explain E0571</code> shows the following output in the console.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">A `break` statement with an argument appeared in a non-`loop` loop.\n\nExample of erroneous code:\nÔΩÄÔΩÄÔΩÄ\nlet result = while true {\n    if satisfied(i) {\n        break 2*i; // error: `break` with value from a `while` loop\n    }\n    i += 1;\n};\nÔΩÄÔΩÄÔΩÄ\n\nThe `break` statement can take an argument (which will be the value of the loop\nexpression if the `break` statement is executed) in `loop` loops, but not\n`for`, `while`, or `while let` loops.\n\nMake sure `break value;` statements only occur in `loop` loops:\nÔΩÄÔΩÄÔΩÄ\nlet result = loop { // ok!\n    if satisfied(i) {\n        break 2*i;\n    }\n    i += 1;\n};\nÔΩÄÔΩÄÔΩÄ\n</code></pre>\n<p>üí° Also you can read the same explanations via <a href=\"https://medium.com/r/?url=https%3A%2F%2Fdoc.rust-lang.org%2Ferror-index.html\" target=\"_blank\" rel=\"noopener\">Rust Compiler Error Index</a>. For example to check the explanation of <code>E0571</code> error, you can use <a href=\"https://doc.rust-lang.org/error-index.html#E0571\" target=\"_blank\" rel=\"noopener\">https://doc.rust-lang.org/error-index.html#E0571</a>.</p>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<h2 id=\"Why-Compiler\"><a href=\"#Why-Compiler\" class=\"headerlink\" title=\"Why Compiler?\"></a>Why Compiler?</h2><p>The Rust compiler does the most significant job to prevent errors in Rust programs. It <strong>analyzes the code at compile-time</strong> and issues warnings, if the code does not follow memory management rules or lifetime annotations correctly. </p>\n<p>For example,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">#[allow(unused_variables)] //üí° A lint attribute used to suppress the warning; unused variable: `b`\nfn main() {\n    let a = vec![1, 2, 3];\n    let b = a;\n\n    println!(&quot;{:?}&quot;, a);\n}\n\n\n// ------ Compile-time error ------\nerror[E0382]: use of moved value: `a`\n --&gt; src/main.rs:6:22\n  |\n3 |     let b = a;\n  |         - value moved here\n4 |\n5 |     println!(&quot;{:?}&quot;, a);\n  |                      ^ value used here after move\n  |\n  = note: move occurs because `a` has type `std::vec::Vec&lt;i32&gt;`, which does not implement the `Copy` trait\n\nerror: aborting due to previous error\nFor more information about this error, try `rustc --explain E0382`.\n\n// ‚≠ê instead using #[allow(unused_variables)], consider using &quot;let _b = a;&quot; in line 4. \n// Also you can use &quot;let _ =&quot; to completely ignore return values\n</code></pre>\n<blockquote>\n<p>üí≠ In the previous sections, we have discussed memory management concepts like <a href=\"c1.ownership.html\">ownership</a>, <a href=\"c2.borrowing.html\">borrowing</a>, <a href=\"c3.lifetimes.md\">lifetimes</a> and etc.</p>\n</blockquote>\n<p>Rust compiler checks not only issues related with lifetimes or memory management and also common coding mistakes, like the following code.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Color {\n    r: u8,\n    g: u8,\n    b: u8,\n}\n\nfn main() {\n    let yellow = Color {\n        r: 255,\n        g: 255,\n        d: 0,\n    };\n\n    println!(&quot;Yellow = rgb({},{},{})&quot;, yellow.r, yellow.g, yellow.b);\n}\n\n\n// ------------ Compile-time error ------------\nerror[E0560]: struct `Color` has no field named `d`\n  --&gt; src/main.rs:11:9\n   |\n11 |         d: 0,\n   |         ^ field does not exist - did you mean `b`?\n\nerror: aborting due to previous error\nFor more information about this error, try `rustc --explain E0560`.\n</code></pre>\n<h2 id=\"Explain-Error-Codes\"><a href=\"#Explain-Error-Codes\" class=\"headerlink\" title=\"Explain Error Codes\"></a>Explain Error Codes</h2><p>Above error messages are very descriptive and we can easily see where is the error. But while we can not identify the issue via the error message, <strong><code>rustc --explain</code></strong> commands help us <strong>to identify the error type and how to solve</strong> it, by showing <strong>simple code samples</strong> which express the same problem and the solution we have to use. </p>\n<p>For example, <code>rustc --explain E0571</code> shows the following output in the console.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">A `break` statement with an argument appeared in a non-`loop` loop.\n\nExample of erroneous code:\nÔΩÄÔΩÄÔΩÄ\nlet result = while true {\n    if satisfied(i) {\n        break 2*i; // error: `break` with value from a `while` loop\n    }\n    i += 1;\n};\nÔΩÄÔΩÄÔΩÄ\n\nThe `break` statement can take an argument (which will be the value of the loop\nexpression if the `break` statement is executed) in `loop` loops, but not\n`for`, `while`, or `while let` loops.\n\nMake sure `break value;` statements only occur in `loop` loops:\nÔΩÄÔΩÄÔΩÄ\nlet result = loop { // ok!\n    if satisfied(i) {\n        break 2*i;\n    }\n    i += 1;\n};\nÔΩÄÔΩÄÔΩÄ\n</code></pre>\n<p>üí° Also you can read the same explanations via <a href=\"https://medium.com/r/?url=https%3A%2F%2Fdoc.rust-lang.org%2Ferror-index.html\" target=\"_blank\" rel=\"noopener\">Rust Compiler Error Index</a>. For example to check the explanation of <code>E0571</code> error, you can use <a href=\"https://doc.rust-lang.org/error-index.html#E0571\" target=\"_blank\" rel=\"noopener\">https://doc.rust-lang.org/error-index.html#E0571</a>.</p>\n"},{"title":"Unwrap and Expect","_content":"\n## unwrap()\n\n- If an `Option` type has **`Some`** value or a `Result` type has a **`Ok`** value, **the value inside them** passes to the next step.\n- If the `Option` type has **`None`** value or the `Result` type has **`Err`** value, **program panics**; If `Err`, panics with the error message.\n\nThe functionality is bit similar to the following codes, which are using `match` instead `unwrap()`.\n\nExample with `Option` and `match`, before using `unwrap()`\n\n```rust\nfn main() {\n    let x;\n    match get_an_optional_value() {\n        Some(v) => x = v, // if Some(\"abc\"), set x to \"abc\"\n        None => panic!(), // if None, panic without any message\n    }\n\n    println!(\"{}\", x); // \"abc\" ; if you change line 14 `false` to `true`\n}\n\nfn get_an_optional_value() -> Option<&'static str> {\n\n    //if the optional value is not empty\n    if false {\n        return Some(\"abc\");\n    }\n    \n    //else\n    None\n}\n\n\n// --------------- Compile-time error ---------------\nthread 'main' panicked at 'explicit panic', src/main.rs:5:17\n```\n\nExample with `Result` and `match`, before using `unwrap()`\n\n```rust\nfn main() {\n    let x;\n    match function_with_error() {\n        Ok(v) => x = v, // if Ok(255), set x to 255\n        Err(e) => panic!(e), // if Err(\"some message\"), panic with error message \"some message\"\n    }\n\n    println!(\"{}\", x); // 255 ; if you change line 13 `true` to `false`\n}\n\nfn function_with_error() -> Result<u64, String> {\n    //if error happens\n    if true {\n        return Err(\"some message\".to_string());\n    }\n\n    // else, return valid output\n    Ok(255)\n}\n\n\n// ---------- Compile-time error ----------\nthread 'main' panicked at 'some message', src/main.rs:5:19\n```\n\nSame codes in above `main` functions can be written with `unwrap()` using two lines.\n\n```rust\n// 01. unwrap error message for None\nfn main() {\n    let x = get_an_optional_value().unwrap();\n\n    println!(\"{}\", x);\n}\n\n// --------------- Compile-time error ---------------\nthread 'main' panicked at 'called `Option::unwrap()` on a `None` value', libcore/option.rs:345:21\n\n\n// 02. unwrap error message for Err\nfn main() {\n    let x = function_with_error().unwrap();\n\n    println!(\"{}\", x);\n}\n\n// --------------- Compile-time error ---------------\nthread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: \"some message\"', libcore/result.rs:945:5\n```\n\n‚≠ê But as you can see, when using `unwrap()` error messages are not showing the exact line numbers where the panic happens.\n\n\n## expect()\n\nSimilar to `unwrap()` but can set a custom message for the panics.\n\n```rust\n// 01. expect error message for None\nfn main() {\n    let n: Option<i8> = None;\n    \n    n.expect(\"empty value returned\");\n}\n\n// --------------- Compile-time error ---------------\nthread 'main' panicked at 'empty value returned', libcore/option.rs:989:5\n\n\n// 02. expect error message for Err\nfn main() {\n    let e: Result<i8, &str> = Err(\"some message\");\n\n    e.expect(\"expect error message\");\n}\n\n// --------------- Compile-time error ---------------\nthread 'main' panicked at 'expect error message: \"some message\"', libcore/result.rs:945:5\n```\n\n\n## unwrap_err() and expect_err() for Result types\nThe opposite case of `unwrap()` and `expect()`; Panics with `Ok` values, instead `Err`. Both print the value inside `Ok` on the error message.\n\nüí° Usually use with tests.\n\n```rust\n// 01. unwrap_err error message for Ok\nfn main() {\n    let o: Result<i8, &str> = Ok(8);\n\n    o.unwrap_err();\n}\n\n// ---------- Compile-time error ----------\nthread 'main' panicked at 'called `Result::unwrap_err()` on an `Ok` value: 8', libcore/result.rs:945:5\n\n\n// 02. expect_err error message for Ok\nfn main() {\n    let o: Result<i8, &str> = Ok(8);\n\n    o.expect_err(\"Should not get Ok value\");\n}\n\n// ---------- Compile-time error ----------\nthread 'main' panicked at 'Should not get Ok value: 8', libcore/result.rs:945:5\n```\n\n\n## unwrap_or(), unwrap_or_default() and unwrap_or_else() \n>üí° These are bit similar to `unwrap()`, If an `Option` type has `Some` value or a `Result` type has a `Ok` value, the value inside them passes to the next step. But when having `None` or `Err`, the functionalities are bit different.\n\n- `unwrap_or()`¬†: With `None` or `Err`, **the value you passes to `unwrap_or()`** is passing to the next step. But the data type of the value you passes  should match with the data type of the relevant `Some` or `Ok`.\n\n```rust\nfn main() {\n    let v1 = 8;\n    let v2 = 16;\n\n    let s_v1 = Some(8);\n    let n = None;\n\n    assert_eq!(s_v1.unwrap_or(v2), v1); // Some(v1) unwrap_or v2 = v1\n    assert_eq!(n.unwrap_or(v2), v2);    // None unwrap_or v2 = v2\n\n    let o_v1: Result<i8, &str> = Ok(8);\n    let e: Result<i8, &str> = Err(\"error\");\n\n    assert_eq!(o_v1.unwrap_or(v2), v1); // Ok(v1) unwrap_or v2 = v1\n    assert_eq!(e.unwrap_or(v2), v2);    // Err unwrap_or v2 = v2\n}\n```\n\n- `unwrap_or_default()`¬†:  With `None` or `Err`, **the default value of the data type of the relevant `Some` or `Ok`**, is passing to the next step.\n\n```rust\nfn main() {\n    let v = 8;\n    let v_default = 0;\n\n    let s_v: Option<i8> = Some(8);\n    let n: Option<i8> = None;\n\n    assert_eq!(s_v.unwrap_or_default(), v);       // Some(v) unwrap_or_default = v\n    assert_eq!(n.unwrap_or_default(), v_default); // None unwrap_or_default = default value of v\n\n    let o_v: Result<i8, &str> = Ok(8);\n    let e: Result<i8, &str> = Err(\"error\");\n\n    assert_eq!(o_v.unwrap_or_default(), v);       // Ok(v) unwrap_or_default = v\n    assert_eq!(e.unwrap_or_default(), v_default); // Err unwrap_or_default = default value of v\n}\n```\n\n- `unwrap_or_else()`¬†: Similar to `unwrap_or()`. The only difference is, instead of passing a value, you have to pass a **[closure](a7.functions.html#Closures)** which returns a value with the same data type of the relevant `Some` or `Ok`.\n\n```rust\nfn main() {\n    let v1 = 8;\n    let v2 = 16;\n\n    let s_v1 = Some(8);\n    let n = None;\n    let fn_v2_for_option = || 16;\n\n    assert_eq!(s_v1.unwrap_or_else(fn_v2_for_option), v1); // Some(v1) unwrap_or_else fn_v2 = v1\n    assert_eq!(n.unwrap_or_else(fn_v2_for_option), v2);    // None unwrap_or_else fn_v2 = v2\n\n    let o_v1: Result<i8, &str> = Ok(8);\n    let e: Result<i8, &str> = Err(\"error\");\n    let fn_v2_for_result = |_| 16;\n\n    assert_eq!(o_v1.unwrap_or_else(fn_v2_for_result), v1); // Ok(v1) unwrap_or_else fn_v2 = v1\n    assert_eq!(e.unwrap_or_else(fn_v2_for_result), v2);    // Err unwrap_or_else fn_v2 = v2\n}\n```\n","source":"docs/e4.unwrap_and_expect.md","raw":"title: Unwrap and Expect\n---\n\n## unwrap()\n\n- If an `Option` type has **`Some`** value or a `Result` type has a **`Ok`** value, **the value inside them** passes to the next step.\n- If the `Option` type has **`None`** value or the `Result` type has **`Err`** value, **program panics**; If `Err`, panics with the error message.\n\nThe functionality is bit similar to the following codes, which are using `match` instead `unwrap()`.\n\nExample with `Option` and `match`, before using `unwrap()`\n\n```rust\nfn main() {\n    let x;\n    match get_an_optional_value() {\n        Some(v) => x = v, // if Some(\"abc\"), set x to \"abc\"\n        None => panic!(), // if None, panic without any message\n    }\n\n    println!(\"{}\", x); // \"abc\" ; if you change line 14 `false` to `true`\n}\n\nfn get_an_optional_value() -> Option<&'static str> {\n\n    //if the optional value is not empty\n    if false {\n        return Some(\"abc\");\n    }\n    \n    //else\n    None\n}\n\n\n// --------------- Compile-time error ---------------\nthread 'main' panicked at 'explicit panic', src/main.rs:5:17\n```\n\nExample with `Result` and `match`, before using `unwrap()`\n\n```rust\nfn main() {\n    let x;\n    match function_with_error() {\n        Ok(v) => x = v, // if Ok(255), set x to 255\n        Err(e) => panic!(e), // if Err(\"some message\"), panic with error message \"some message\"\n    }\n\n    println!(\"{}\", x); // 255 ; if you change line 13 `true` to `false`\n}\n\nfn function_with_error() -> Result<u64, String> {\n    //if error happens\n    if true {\n        return Err(\"some message\".to_string());\n    }\n\n    // else, return valid output\n    Ok(255)\n}\n\n\n// ---------- Compile-time error ----------\nthread 'main' panicked at 'some message', src/main.rs:5:19\n```\n\nSame codes in above `main` functions can be written with `unwrap()` using two lines.\n\n```rust\n// 01. unwrap error message for None\nfn main() {\n    let x = get_an_optional_value().unwrap();\n\n    println!(\"{}\", x);\n}\n\n// --------------- Compile-time error ---------------\nthread 'main' panicked at 'called `Option::unwrap()` on a `None` value', libcore/option.rs:345:21\n\n\n// 02. unwrap error message for Err\nfn main() {\n    let x = function_with_error().unwrap();\n\n    println!(\"{}\", x);\n}\n\n// --------------- Compile-time error ---------------\nthread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: \"some message\"', libcore/result.rs:945:5\n```\n\n‚≠ê But as you can see, when using `unwrap()` error messages are not showing the exact line numbers where the panic happens.\n\n\n## expect()\n\nSimilar to `unwrap()` but can set a custom message for the panics.\n\n```rust\n// 01. expect error message for None\nfn main() {\n    let n: Option<i8> = None;\n    \n    n.expect(\"empty value returned\");\n}\n\n// --------------- Compile-time error ---------------\nthread 'main' panicked at 'empty value returned', libcore/option.rs:989:5\n\n\n// 02. expect error message for Err\nfn main() {\n    let e: Result<i8, &str> = Err(\"some message\");\n\n    e.expect(\"expect error message\");\n}\n\n// --------------- Compile-time error ---------------\nthread 'main' panicked at 'expect error message: \"some message\"', libcore/result.rs:945:5\n```\n\n\n## unwrap_err() and expect_err() for Result types\nThe opposite case of `unwrap()` and `expect()`; Panics with `Ok` values, instead `Err`. Both print the value inside `Ok` on the error message.\n\nüí° Usually use with tests.\n\n```rust\n// 01. unwrap_err error message for Ok\nfn main() {\n    let o: Result<i8, &str> = Ok(8);\n\n    o.unwrap_err();\n}\n\n// ---------- Compile-time error ----------\nthread 'main' panicked at 'called `Result::unwrap_err()` on an `Ok` value: 8', libcore/result.rs:945:5\n\n\n// 02. expect_err error message for Ok\nfn main() {\n    let o: Result<i8, &str> = Ok(8);\n\n    o.expect_err(\"Should not get Ok value\");\n}\n\n// ---------- Compile-time error ----------\nthread 'main' panicked at 'Should not get Ok value: 8', libcore/result.rs:945:5\n```\n\n\n## unwrap_or(), unwrap_or_default() and unwrap_or_else() \n>üí° These are bit similar to `unwrap()`, If an `Option` type has `Some` value or a `Result` type has a `Ok` value, the value inside them passes to the next step. But when having `None` or `Err`, the functionalities are bit different.\n\n- `unwrap_or()`¬†: With `None` or `Err`, **the value you passes to `unwrap_or()`** is passing to the next step. But the data type of the value you passes  should match with the data type of the relevant `Some` or `Ok`.\n\n```rust\nfn main() {\n    let v1 = 8;\n    let v2 = 16;\n\n    let s_v1 = Some(8);\n    let n = None;\n\n    assert_eq!(s_v1.unwrap_or(v2), v1); // Some(v1) unwrap_or v2 = v1\n    assert_eq!(n.unwrap_or(v2), v2);    // None unwrap_or v2 = v2\n\n    let o_v1: Result<i8, &str> = Ok(8);\n    let e: Result<i8, &str> = Err(\"error\");\n\n    assert_eq!(o_v1.unwrap_or(v2), v1); // Ok(v1) unwrap_or v2 = v1\n    assert_eq!(e.unwrap_or(v2), v2);    // Err unwrap_or v2 = v2\n}\n```\n\n- `unwrap_or_default()`¬†:  With `None` or `Err`, **the default value of the data type of the relevant `Some` or `Ok`**, is passing to the next step.\n\n```rust\nfn main() {\n    let v = 8;\n    let v_default = 0;\n\n    let s_v: Option<i8> = Some(8);\n    let n: Option<i8> = None;\n\n    assert_eq!(s_v.unwrap_or_default(), v);       // Some(v) unwrap_or_default = v\n    assert_eq!(n.unwrap_or_default(), v_default); // None unwrap_or_default = default value of v\n\n    let o_v: Result<i8, &str> = Ok(8);\n    let e: Result<i8, &str> = Err(\"error\");\n\n    assert_eq!(o_v.unwrap_or_default(), v);       // Ok(v) unwrap_or_default = v\n    assert_eq!(e.unwrap_or_default(), v_default); // Err unwrap_or_default = default value of v\n}\n```\n\n- `unwrap_or_else()`¬†: Similar to `unwrap_or()`. The only difference is, instead of passing a value, you have to pass a **[closure](a7.functions.html#Closures)** which returns a value with the same data type of the relevant `Some` or `Ok`.\n\n```rust\nfn main() {\n    let v1 = 8;\n    let v2 = 16;\n\n    let s_v1 = Some(8);\n    let n = None;\n    let fn_v2_for_option = || 16;\n\n    assert_eq!(s_v1.unwrap_or_else(fn_v2_for_option), v1); // Some(v1) unwrap_or_else fn_v2 = v1\n    assert_eq!(n.unwrap_or_else(fn_v2_for_option), v2);    // None unwrap_or_else fn_v2 = v2\n\n    let o_v1: Result<i8, &str> = Ok(8);\n    let e: Result<i8, &str> = Err(\"error\");\n    let fn_v2_for_result = |_| 16;\n\n    assert_eq!(o_v1.unwrap_or_else(fn_v2_for_result), v1); // Ok(v1) unwrap_or_else fn_v2 = v1\n    assert_eq!(e.unwrap_or_else(fn_v2_for_result), v2);    // Err unwrap_or_else fn_v2 = v2\n}\n```\n","date":"2019-03-19T14:50:39.960Z","updated":"2019-03-19T14:50:39.960Z","path":"docs/e4.unwrap_and_expect.html","comments":1,"layout":"page","_id":"cjtfwbizm000qdwgp17msm0jl","content":"<h2 id=\"unwrap\"><a href=\"#unwrap\" class=\"headerlink\" title=\"unwrap()\"></a>unwrap()</h2><ul>\n<li>If an <code>Option</code> type has <strong><code>Some</code></strong> value or a <code>Result</code> type has a <strong><code>Ok</code></strong> value, <strong>the value inside them</strong> passes to the next step.</li>\n<li>If the <code>Option</code> type has <strong><code>None</code></strong> value or the <code>Result</code> type has <strong><code>Err</code></strong> value, <strong>program panics</strong>; If <code>Err</code>, panics with the error message.</li>\n</ul>\n<p>The functionality is bit similar to the following codes, which are using <code>match</code> instead <code>unwrap()</code>.</p>\n<p>Example with <code>Option</code> and <code>match</code>, before using <code>unwrap()</code></p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let x;\n    match get_an_optional_value() {\n        Some(v) =&gt; x = v, // if Some(&quot;abc&quot;), set x to &quot;abc&quot;\n        None =&gt; panic!(), // if None, panic without any message\n    }\n\n    println!(&quot;{}&quot;, x); // &quot;abc&quot; ; if you change line 14 `false` to `true`\n}\n\nfn get_an_optional_value() -&gt; Option&lt;&amp;&#39;static str&gt; {\n\n    //if the optional value is not empty\n    if false {\n        return Some(&quot;abc&quot;);\n    }\n\n    //else\n    None\n}\n\n\n// --------------- Compile-time error ---------------\nthread &#39;main&#39; panicked at &#39;explicit panic&#39;, src/main.rs:5:17\n</code></pre>\n<p>Example with <code>Result</code> and <code>match</code>, before using <code>unwrap()</code></p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let x;\n    match function_with_error() {\n        Ok(v) =&gt; x = v, // if Ok(255), set x to 255\n        Err(e) =&gt; panic!(e), // if Err(&quot;some message&quot;), panic with error message &quot;some message&quot;\n    }\n\n    println!(&quot;{}&quot;, x); // 255 ; if you change line 13 `true` to `false`\n}\n\nfn function_with_error() -&gt; Result&lt;u64, String&gt; {\n    //if error happens\n    if true {\n        return Err(&quot;some message&quot;.to_string());\n    }\n\n    // else, return valid output\n    Ok(255)\n}\n\n\n// ---------- Compile-time error ----------\nthread &#39;main&#39; panicked at &#39;some message&#39;, src/main.rs:5:19\n</code></pre>\n<p>Same codes in above <code>main</code> functions can be written with <code>unwrap()</code> using two lines.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// 01. unwrap error message for None\nfn main() {\n    let x = get_an_optional_value().unwrap();\n\n    println!(&quot;{}&quot;, x);\n}\n\n// --------------- Compile-time error ---------------\nthread &#39;main&#39; panicked at &#39;called `Option::unwrap()` on a `None` value&#39;, libcore/option.rs:345:21\n\n\n// 02. unwrap error message for Err\nfn main() {\n    let x = function_with_error().unwrap();\n\n    println!(&quot;{}&quot;, x);\n}\n\n// --------------- Compile-time error ---------------\nthread &#39;main&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: &quot;some message&quot;&#39;, libcore/result.rs:945:5\n</code></pre>\n<p>‚≠ê But as you can see, when using <code>unwrap()</code> error messages are not showing the exact line numbers where the panic happens.</p>\n<h2 id=\"expect\"><a href=\"#expect\" class=\"headerlink\" title=\"expect()\"></a>expect()</h2><p>Similar to <code>unwrap()</code> but can set a custom message for the panics.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// 01. expect error message for None\nfn main() {\n    let n: Option&lt;i8&gt; = None;\n\n    n.expect(&quot;empty value returned&quot;);\n}\n\n// --------------- Compile-time error ---------------\nthread &#39;main&#39; panicked at &#39;empty value returned&#39;, libcore/option.rs:989:5\n\n\n// 02. expect error message for Err\nfn main() {\n    let e: Result&lt;i8, &amp;str&gt; = Err(&quot;some message&quot;);\n\n    e.expect(&quot;expect error message&quot;);\n}\n\n// --------------- Compile-time error ---------------\nthread &#39;main&#39; panicked at &#39;expect error message: &quot;some message&quot;&#39;, libcore/result.rs:945:5\n</code></pre>\n<h2 id=\"unwrap-err-and-expect-err-for-Result-types\"><a href=\"#unwrap-err-and-expect-err-for-Result-types\" class=\"headerlink\" title=\"unwrap_err() and expect_err() for Result types\"></a>unwrap_err() and expect_err() for Result types</h2><p>The opposite case of <code>unwrap()</code> and <code>expect()</code>; Panics with <code>Ok</code> values, instead <code>Err</code>. Both print the value inside <code>Ok</code> on the error message.</p>\n<p>üí° Usually use with tests.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// 01. unwrap_err error message for Ok\nfn main() {\n    let o: Result&lt;i8, &amp;str&gt; = Ok(8);\n\n    o.unwrap_err();\n}\n\n// ---------- Compile-time error ----------\nthread &#39;main&#39; panicked at &#39;called `Result::unwrap_err()` on an `Ok` value: 8&#39;, libcore/result.rs:945:5\n\n\n// 02. expect_err error message for Ok\nfn main() {\n    let o: Result&lt;i8, &amp;str&gt; = Ok(8);\n\n    o.expect_err(&quot;Should not get Ok value&quot;);\n}\n\n// ---------- Compile-time error ----------\nthread &#39;main&#39; panicked at &#39;Should not get Ok value: 8&#39;, libcore/result.rs:945:5\n</code></pre>\n<h2 id=\"unwrap-or-unwrap-or-default-and-unwrap-or-else\"><a href=\"#unwrap-or-unwrap-or-default-and-unwrap-or-else\" class=\"headerlink\" title=\"unwrap_or(), unwrap_or_default() and unwrap_or_else()\"></a>unwrap_or(), unwrap_or_default() and unwrap_or_else()</h2><blockquote>\n<p>üí° These are bit similar to <code>unwrap()</code>, If an <code>Option</code> type has <code>Some</code> value or a <code>Result</code> type has a <code>Ok</code> value, the value inside them passes to the next step. But when having <code>None</code> or <code>Err</code>, the functionalities are bit different.</p>\n</blockquote>\n<ul>\n<li><code>unwrap_or()</code> : With <code>None</code> or <code>Err</code>, <strong>the value you passes to <code>unwrap_or()</code></strong> is passing to the next step. But the data type of the value you passes  should match with the data type of the relevant <code>Some</code> or <code>Ok</code>.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let v1 = 8;\n    let v2 = 16;\n\n    let s_v1 = Some(8);\n    let n = None;\n\n    assert_eq!(s_v1.unwrap_or(v2), v1); // Some(v1) unwrap_or v2 = v1\n    assert_eq!(n.unwrap_or(v2), v2);    // None unwrap_or v2 = v2\n\n    let o_v1: Result&lt;i8, &amp;str&gt; = Ok(8);\n    let e: Result&lt;i8, &amp;str&gt; = Err(&quot;error&quot;);\n\n    assert_eq!(o_v1.unwrap_or(v2), v1); // Ok(v1) unwrap_or v2 = v1\n    assert_eq!(e.unwrap_or(v2), v2);    // Err unwrap_or v2 = v2\n}\n</code></pre>\n<ul>\n<li><code>unwrap_or_default()</code> :  With <code>None</code> or <code>Err</code>, <strong>the default value of the data type of the relevant <code>Some</code> or <code>Ok</code></strong>, is passing to the next step.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let v = 8;\n    let v_default = 0;\n\n    let s_v: Option&lt;i8&gt; = Some(8);\n    let n: Option&lt;i8&gt; = None;\n\n    assert_eq!(s_v.unwrap_or_default(), v);       // Some(v) unwrap_or_default = v\n    assert_eq!(n.unwrap_or_default(), v_default); // None unwrap_or_default = default value of v\n\n    let o_v: Result&lt;i8, &amp;str&gt; = Ok(8);\n    let e: Result&lt;i8, &amp;str&gt; = Err(&quot;error&quot;);\n\n    assert_eq!(o_v.unwrap_or_default(), v);       // Ok(v) unwrap_or_default = v\n    assert_eq!(e.unwrap_or_default(), v_default); // Err unwrap_or_default = default value of v\n}\n</code></pre>\n<ul>\n<li><code>unwrap_or_else()</code> : Similar to <code>unwrap_or()</code>. The only difference is, instead of passing a value, you have to pass a <strong><a href=\"a7.functions.html#Closures\">closure</a></strong> which returns a value with the same data type of the relevant <code>Some</code> or <code>Ok</code>.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let v1 = 8;\n    let v2 = 16;\n\n    let s_v1 = Some(8);\n    let n = None;\n    let fn_v2_for_option = || 16;\n\n    assert_eq!(s_v1.unwrap_or_else(fn_v2_for_option), v1); // Some(v1) unwrap_or_else fn_v2 = v1\n    assert_eq!(n.unwrap_or_else(fn_v2_for_option), v2);    // None unwrap_or_else fn_v2 = v2\n\n    let o_v1: Result&lt;i8, &amp;str&gt; = Ok(8);\n    let e: Result&lt;i8, &amp;str&gt; = Err(&quot;error&quot;);\n    let fn_v2_for_result = |_| 16;\n\n    assert_eq!(o_v1.unwrap_or_else(fn_v2_for_result), v1); // Ok(v1) unwrap_or_else fn_v2 = v1\n    assert_eq!(e.unwrap_or_else(fn_v2_for_result), v2);    // Err unwrap_or_else fn_v2 = v2\n}\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<h2 id=\"unwrap\"><a href=\"#unwrap\" class=\"headerlink\" title=\"unwrap()\"></a>unwrap()</h2><ul>\n<li>If an <code>Option</code> type has <strong><code>Some</code></strong> value or a <code>Result</code> type has a <strong><code>Ok</code></strong> value, <strong>the value inside them</strong> passes to the next step.</li>\n<li>If the <code>Option</code> type has <strong><code>None</code></strong> value or the <code>Result</code> type has <strong><code>Err</code></strong> value, <strong>program panics</strong>; If <code>Err</code>, panics with the error message.</li>\n</ul>\n<p>The functionality is bit similar to the following codes, which are using <code>match</code> instead <code>unwrap()</code>.</p>\n<p>Example with <code>Option</code> and <code>match</code>, before using <code>unwrap()</code></p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let x;\n    match get_an_optional_value() {\n        Some(v) =&gt; x = v, // if Some(&quot;abc&quot;), set x to &quot;abc&quot;\n        None =&gt; panic!(), // if None, panic without any message\n    }\n\n    println!(&quot;{}&quot;, x); // &quot;abc&quot; ; if you change line 14 `false` to `true`\n}\n\nfn get_an_optional_value() -&gt; Option&lt;&amp;&#39;static str&gt; {\n\n    //if the optional value is not empty\n    if false {\n        return Some(&quot;abc&quot;);\n    }\n\n    //else\n    None\n}\n\n\n// --------------- Compile-time error ---------------\nthread &#39;main&#39; panicked at &#39;explicit panic&#39;, src/main.rs:5:17\n</code></pre>\n<p>Example with <code>Result</code> and <code>match</code>, before using <code>unwrap()</code></p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let x;\n    match function_with_error() {\n        Ok(v) =&gt; x = v, // if Ok(255), set x to 255\n        Err(e) =&gt; panic!(e), // if Err(&quot;some message&quot;), panic with error message &quot;some message&quot;\n    }\n\n    println!(&quot;{}&quot;, x); // 255 ; if you change line 13 `true` to `false`\n}\n\nfn function_with_error() -&gt; Result&lt;u64, String&gt; {\n    //if error happens\n    if true {\n        return Err(&quot;some message&quot;.to_string());\n    }\n\n    // else, return valid output\n    Ok(255)\n}\n\n\n// ---------- Compile-time error ----------\nthread &#39;main&#39; panicked at &#39;some message&#39;, src/main.rs:5:19\n</code></pre>\n<p>Same codes in above <code>main</code> functions can be written with <code>unwrap()</code> using two lines.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// 01. unwrap error message for None\nfn main() {\n    let x = get_an_optional_value().unwrap();\n\n    println!(&quot;{}&quot;, x);\n}\n\n// --------------- Compile-time error ---------------\nthread &#39;main&#39; panicked at &#39;called `Option::unwrap()` on a `None` value&#39;, libcore/option.rs:345:21\n\n\n// 02. unwrap error message for Err\nfn main() {\n    let x = function_with_error().unwrap();\n\n    println!(&quot;{}&quot;, x);\n}\n\n// --------------- Compile-time error ---------------\nthread &#39;main&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: &quot;some message&quot;&#39;, libcore/result.rs:945:5\n</code></pre>\n<p>‚≠ê But as you can see, when using <code>unwrap()</code> error messages are not showing the exact line numbers where the panic happens.</p>\n<h2 id=\"expect\"><a href=\"#expect\" class=\"headerlink\" title=\"expect()\"></a>expect()</h2><p>Similar to <code>unwrap()</code> but can set a custom message for the panics.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// 01. expect error message for None\nfn main() {\n    let n: Option&lt;i8&gt; = None;\n\n    n.expect(&quot;empty value returned&quot;);\n}\n\n// --------------- Compile-time error ---------------\nthread &#39;main&#39; panicked at &#39;empty value returned&#39;, libcore/option.rs:989:5\n\n\n// 02. expect error message for Err\nfn main() {\n    let e: Result&lt;i8, &amp;str&gt; = Err(&quot;some message&quot;);\n\n    e.expect(&quot;expect error message&quot;);\n}\n\n// --------------- Compile-time error ---------------\nthread &#39;main&#39; panicked at &#39;expect error message: &quot;some message&quot;&#39;, libcore/result.rs:945:5\n</code></pre>\n<h2 id=\"unwrap-err-and-expect-err-for-Result-types\"><a href=\"#unwrap-err-and-expect-err-for-Result-types\" class=\"headerlink\" title=\"unwrap_err() and expect_err() for Result types\"></a>unwrap_err() and expect_err() for Result types</h2><p>The opposite case of <code>unwrap()</code> and <code>expect()</code>; Panics with <code>Ok</code> values, instead <code>Err</code>. Both print the value inside <code>Ok</code> on the error message.</p>\n<p>üí° Usually use with tests.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// 01. unwrap_err error message for Ok\nfn main() {\n    let o: Result&lt;i8, &amp;str&gt; = Ok(8);\n\n    o.unwrap_err();\n}\n\n// ---------- Compile-time error ----------\nthread &#39;main&#39; panicked at &#39;called `Result::unwrap_err()` on an `Ok` value: 8&#39;, libcore/result.rs:945:5\n\n\n// 02. expect_err error message for Ok\nfn main() {\n    let o: Result&lt;i8, &amp;str&gt; = Ok(8);\n\n    o.expect_err(&quot;Should not get Ok value&quot;);\n}\n\n// ---------- Compile-time error ----------\nthread &#39;main&#39; panicked at &#39;Should not get Ok value: 8&#39;, libcore/result.rs:945:5\n</code></pre>\n<h2 id=\"unwrap-or-unwrap-or-default-and-unwrap-or-else\"><a href=\"#unwrap-or-unwrap-or-default-and-unwrap-or-else\" class=\"headerlink\" title=\"unwrap_or(), unwrap_or_default() and unwrap_or_else()\"></a>unwrap_or(), unwrap_or_default() and unwrap_or_else()</h2><blockquote>\n<p>üí° These are bit similar to <code>unwrap()</code>, If an <code>Option</code> type has <code>Some</code> value or a <code>Result</code> type has a <code>Ok</code> value, the value inside them passes to the next step. But when having <code>None</code> or <code>Err</code>, the functionalities are bit different.</p>\n</blockquote>\n<ul>\n<li><code>unwrap_or()</code> : With <code>None</code> or <code>Err</code>, <strong>the value you passes to <code>unwrap_or()</code></strong> is passing to the next step. But the data type of the value you passes  should match with the data type of the relevant <code>Some</code> or <code>Ok</code>.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let v1 = 8;\n    let v2 = 16;\n\n    let s_v1 = Some(8);\n    let n = None;\n\n    assert_eq!(s_v1.unwrap_or(v2), v1); // Some(v1) unwrap_or v2 = v1\n    assert_eq!(n.unwrap_or(v2), v2);    // None unwrap_or v2 = v2\n\n    let o_v1: Result&lt;i8, &amp;str&gt; = Ok(8);\n    let e: Result&lt;i8, &amp;str&gt; = Err(&quot;error&quot;);\n\n    assert_eq!(o_v1.unwrap_or(v2), v1); // Ok(v1) unwrap_or v2 = v1\n    assert_eq!(e.unwrap_or(v2), v2);    // Err unwrap_or v2 = v2\n}\n</code></pre>\n<ul>\n<li><code>unwrap_or_default()</code> :  With <code>None</code> or <code>Err</code>, <strong>the default value of the data type of the relevant <code>Some</code> or <code>Ok</code></strong>, is passing to the next step.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let v = 8;\n    let v_default = 0;\n\n    let s_v: Option&lt;i8&gt; = Some(8);\n    let n: Option&lt;i8&gt; = None;\n\n    assert_eq!(s_v.unwrap_or_default(), v);       // Some(v) unwrap_or_default = v\n    assert_eq!(n.unwrap_or_default(), v_default); // None unwrap_or_default = default value of v\n\n    let o_v: Result&lt;i8, &amp;str&gt; = Ok(8);\n    let e: Result&lt;i8, &amp;str&gt; = Err(&quot;error&quot;);\n\n    assert_eq!(o_v.unwrap_or_default(), v);       // Ok(v) unwrap_or_default = v\n    assert_eq!(e.unwrap_or_default(), v_default); // Err unwrap_or_default = default value of v\n}\n</code></pre>\n<ul>\n<li><code>unwrap_or_else()</code> : Similar to <code>unwrap_or()</code>. The only difference is, instead of passing a value, you have to pass a <strong><a href=\"a7.functions.html#Closures\">closure</a></strong> which returns a value with the same data type of the relevant <code>Some</code> or <code>Ok</code>.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let v1 = 8;\n    let v2 = 16;\n\n    let s_v1 = Some(8);\n    let n = None;\n    let fn_v2_for_option = || 16;\n\n    assert_eq!(s_v1.unwrap_or_else(fn_v2_for_option), v1); // Some(v1) unwrap_or_else fn_v2 = v1\n    assert_eq!(n.unwrap_or_else(fn_v2_for_option), v2);    // None unwrap_or_else fn_v2 = v2\n\n    let o_v1: Result&lt;i8, &amp;str&gt; = Ok(8);\n    let e: Result&lt;i8, &amp;str&gt; = Err(&quot;error&quot;);\n    let fn_v2_for_result = |_| 16;\n\n    assert_eq!(o_v1.unwrap_or_else(fn_v2_for_result), v1); // Ok(v1) unwrap_or_else fn_v2 = v1\n    assert_eq!(e.unwrap_or_else(fn_v2_for_result), v2);    // Err unwrap_or_else fn_v2 = v2\n}\n</code></pre>\n"},{"title":"Option and Result","_content":"\n## Why Option and Result?\n\nMany languages use **`null`\\ `nil`\\ `undefined` types** to represent empty outputs, and **`Exceptions`** to handle errors. Rust skips using both, especially to prevent issues like **null pointer exceptions, sensitive data leakages through exceptions** and etc. Instead, Rust provides two special **generic enums**;`Option` and `Result` to deal with above cases.\n\n> üí≠ In the previous sections, we have discussed about the basics of [enums](b3.enums.html), [generics](b4.generics.html) and [`Result` & `Option` types](b4.generics.html#Generalizing-enums).\n\nAs you know,\n- An **optional value** can have either **Some** value or no value/ **None**.\n- A **result** can represent either success/ **Ok** or failure/ **Err**\n\n```rust\n// An output can have either Some value or no value/ None.\nenum Option<T> { // T is a generic and it can contain any type of value.\n    Some(T),\n    None,\n}\n\n// A result can represent either success/ Ok or failure/ Err.\nenum Result<T, E> { // T and E are generics. T can contain any type of value, E can be any error.\n    Ok(T),\n    Err(E),\n}\n```\n\nüí≠ Also as we discussed in [preludes](d7.std_primitives_and_preludes.html#Preludes), not only `Option` and `Result`, and also their variants are in preludes. So, we can use them directly without using namespaces in the code.\n\n## Basic usages of Option\n\nWhen writing a function or data type, \n- if an **argument** of the function is optional,\n- If the function is non-void and if the output it **returns** can be empty,\n- If the value, of a **property of the data type** can be empty,\nWe have to use their data type as an `Option` type\n\nFor example, if the function outputs a `&str` value and the output can be empty, the return type of the function should set as `Option<&str>`.\n\n```rust\nfn get_an_optional_value() -> Option<&str> {\n\n    //if the optional value is not empty\n    return Some(\"Some value\");\n    \n    //else\n    None\n}\n```\n\nSame way, if the value of a property of a data type can be empty or optional like the `middle_name` of `Name` data type in the following example, we should set its data type as an `Option` type.\n\n```rust\nstruct Name {\n  first_name: String,\n  middle_name: Option<String>, // middle_name can be empty\n  last_name: String,\n}\n```\n\nüí≠ As you know, we can use pattern matching to catch the relevant return type (`Some`/ `None`) via `match`. There is a function to get the current user‚Äôs home directory in **`std::env`** as **[`home_dir()`](https://doc.rust-lang.org/std/env/fn.home_dir.html)**. Because of all users doesn‚Äôt have a home directory in the systems like Linux, home directory of the user can be optional. So it returns an `Option` type; [`Option<PathBuf>`](https://doc.rust-lang.org/std/path/struct.PathBuf.html).\n\n```rust\nuse std::env;\n\nfn main() {\n    let home_path = env::home_dir();\n    match home_path {\n        Some(p) => println!(\"{:?}\", p), // This prints \"/root\", if you run this in Rust playground\n        None => println!(\"Can not find the home directory!\"),\n    }\n}\n```\n\n‚≠ê However, when using optional arguments with functions, we have to pass `None` values for empty arguments while calling the function.\n\n```rust\nfn get_full_name(fname: &str, lname: &str, mname: Option<&str>) -> String { // middle name can be empty\n  match mname {\n    Some(n) => format!(\"{} {} {}\", fname, n, lname),\n    None => format!(\"{} {}\", fname, lname),\n  }\n}\n\nfn main() {\n  println!(\"{}\", get_full_name(\"Galileo\", \"Galilei\", None));\n  println!(\"{}\", get_full_name(\"Leonardo\", \"Vinci\", Some(\"Da\")));\n}\n\n// üí° Better create a struct as Person with fname, lname, mname fields and create a impl function as full_name()\n```\n\nüîé Other than that, `Option` types are used with **nullable pointers** in Rust. Because of there is **no null pointers in Rust**, the pointer types should point to a valid location. So if a pointer can be nullable, we have use `Option<Box<T>>`¬†.\n\n## Basic usages of Result\n\nIf a function can produce an error, we have to use a `Result` type by **combining the data type of the valid output and the data type of the error**. For example, if the data type of the valid output is `u64` and error type is `String`, return type should be `Result<u64, String>`.\n\n```rust\nfn function_with_error() -> Result<u64, String> {\n  \n    //if error happens\n    return Err(\"The error message\".to_string());\n\n    // else, return valid output\n    Ok(255)\n}\n```\n\nüí≠ As you know, we can use the pattern matching to catch the relevant return types (`Ok`/`Err`) via `match`. There is a function to fetch the value of any environment variable in **`std::env`** as **[`var()`](https://doc.rust-lang.org/std/env/fn.var.html)** . Its input is the environment variable name. This can produce an error, if we passes a wrong environment variable or the program can not extract the value of the environment variable while running. So, its return type is a `Result` type; [`Result<String, VarError>`](https://doc.rust-lang.org/std/env/enum.VarError.html).\n\n```rust\nuse std::env;\n\nfn main() {\n    let key = \"HOME\";\n    match env::var(key) {\n        Ok(v) => println!(\"{}\", v), // This prints \"/root\", if you run this in Rust playground\n        Err(e) => println!(\"{}\", e), // This prints \"environment variable not found\", if you give a nonexistent environment variable\n    }\n}\n```\n\n## is_some(), is_none(), is_ok(), is_err()\n\nOther than `match` expressions, Rust provides `is_some()` , `is_none()` and `is_ok()` , `is_err()` functions to identify the return type.\n\n```rust\nfn main() {\n    let x: Option<&str> = Some(\"Hello, world!\");\n    assert_eq!(x.is_some(), true);\n    assert_eq!(x.is_none(), false);\n\n    let y: Result<i8, &str> = Ok(10);\n    assert_eq!(y.is_ok(), true);\n    assert_eq!(y.is_err(), false);\n}\n```\n\n## ok(), err() for Result types\n\nIn addition to that Rust provides `ok()` and `err()` for `Result` types. They convert the `Ok<T>` and `Err<E>` values of a **`Result` type to `Option` types**.\n\n```rust\nfn main() {\n    let o: Result<i8, &str> = Ok(8);\n    let e: Result<i8, &str> = Err(\"message\");\n    \n    assert_eq!(o.ok(), Some(8)); // Ok(v) ok = Some(v)\n    assert_eq!(e.ok(), None);    // Err(v) ok = None\n    \n    assert_eq!(o.err(), None);            // Ok(v) err = None\n    assert_eq!(e.err(), Some(\"message\")); // Err(v) err = Some(v)\n}\n```","source":"docs/e3.option_and_result.md","raw":"title: Option and Result\n---\n\n## Why Option and Result?\n\nMany languages use **`null`\\ `nil`\\ `undefined` types** to represent empty outputs, and **`Exceptions`** to handle errors. Rust skips using both, especially to prevent issues like **null pointer exceptions, sensitive data leakages through exceptions** and etc. Instead, Rust provides two special **generic enums**;`Option` and `Result` to deal with above cases.\n\n> üí≠ In the previous sections, we have discussed about the basics of [enums](b3.enums.html), [generics](b4.generics.html) and [`Result` & `Option` types](b4.generics.html#Generalizing-enums).\n\nAs you know,\n- An **optional value** can have either **Some** value or no value/ **None**.\n- A **result** can represent either success/ **Ok** or failure/ **Err**\n\n```rust\n// An output can have either Some value or no value/ None.\nenum Option<T> { // T is a generic and it can contain any type of value.\n    Some(T),\n    None,\n}\n\n// A result can represent either success/ Ok or failure/ Err.\nenum Result<T, E> { // T and E are generics. T can contain any type of value, E can be any error.\n    Ok(T),\n    Err(E),\n}\n```\n\nüí≠ Also as we discussed in [preludes](d7.std_primitives_and_preludes.html#Preludes), not only `Option` and `Result`, and also their variants are in preludes. So, we can use them directly without using namespaces in the code.\n\n## Basic usages of Option\n\nWhen writing a function or data type, \n- if an **argument** of the function is optional,\n- If the function is non-void and if the output it **returns** can be empty,\n- If the value, of a **property of the data type** can be empty,\nWe have to use their data type as an `Option` type\n\nFor example, if the function outputs a `&str` value and the output can be empty, the return type of the function should set as `Option<&str>`.\n\n```rust\nfn get_an_optional_value() -> Option<&str> {\n\n    //if the optional value is not empty\n    return Some(\"Some value\");\n    \n    //else\n    None\n}\n```\n\nSame way, if the value of a property of a data type can be empty or optional like the `middle_name` of `Name` data type in the following example, we should set its data type as an `Option` type.\n\n```rust\nstruct Name {\n  first_name: String,\n  middle_name: Option<String>, // middle_name can be empty\n  last_name: String,\n}\n```\n\nüí≠ As you know, we can use pattern matching to catch the relevant return type (`Some`/ `None`) via `match`. There is a function to get the current user‚Äôs home directory in **`std::env`** as **[`home_dir()`](https://doc.rust-lang.org/std/env/fn.home_dir.html)**. Because of all users doesn‚Äôt have a home directory in the systems like Linux, home directory of the user can be optional. So it returns an `Option` type; [`Option<PathBuf>`](https://doc.rust-lang.org/std/path/struct.PathBuf.html).\n\n```rust\nuse std::env;\n\nfn main() {\n    let home_path = env::home_dir();\n    match home_path {\n        Some(p) => println!(\"{:?}\", p), // This prints \"/root\", if you run this in Rust playground\n        None => println!(\"Can not find the home directory!\"),\n    }\n}\n```\n\n‚≠ê However, when using optional arguments with functions, we have to pass `None` values for empty arguments while calling the function.\n\n```rust\nfn get_full_name(fname: &str, lname: &str, mname: Option<&str>) -> String { // middle name can be empty\n  match mname {\n    Some(n) => format!(\"{} {} {}\", fname, n, lname),\n    None => format!(\"{} {}\", fname, lname),\n  }\n}\n\nfn main() {\n  println!(\"{}\", get_full_name(\"Galileo\", \"Galilei\", None));\n  println!(\"{}\", get_full_name(\"Leonardo\", \"Vinci\", Some(\"Da\")));\n}\n\n// üí° Better create a struct as Person with fname, lname, mname fields and create a impl function as full_name()\n```\n\nüîé Other than that, `Option` types are used with **nullable pointers** in Rust. Because of there is **no null pointers in Rust**, the pointer types should point to a valid location. So if a pointer can be nullable, we have use `Option<Box<T>>`¬†.\n\n## Basic usages of Result\n\nIf a function can produce an error, we have to use a `Result` type by **combining the data type of the valid output and the data type of the error**. For example, if the data type of the valid output is `u64` and error type is `String`, return type should be `Result<u64, String>`.\n\n```rust\nfn function_with_error() -> Result<u64, String> {\n  \n    //if error happens\n    return Err(\"The error message\".to_string());\n\n    // else, return valid output\n    Ok(255)\n}\n```\n\nüí≠ As you know, we can use the pattern matching to catch the relevant return types (`Ok`/`Err`) via `match`. There is a function to fetch the value of any environment variable in **`std::env`** as **[`var()`](https://doc.rust-lang.org/std/env/fn.var.html)** . Its input is the environment variable name. This can produce an error, if we passes a wrong environment variable or the program can not extract the value of the environment variable while running. So, its return type is a `Result` type; [`Result<String, VarError>`](https://doc.rust-lang.org/std/env/enum.VarError.html).\n\n```rust\nuse std::env;\n\nfn main() {\n    let key = \"HOME\";\n    match env::var(key) {\n        Ok(v) => println!(\"{}\", v), // This prints \"/root\", if you run this in Rust playground\n        Err(e) => println!(\"{}\", e), // This prints \"environment variable not found\", if you give a nonexistent environment variable\n    }\n}\n```\n\n## is_some(), is_none(), is_ok(), is_err()\n\nOther than `match` expressions, Rust provides `is_some()` , `is_none()` and `is_ok()` , `is_err()` functions to identify the return type.\n\n```rust\nfn main() {\n    let x: Option<&str> = Some(\"Hello, world!\");\n    assert_eq!(x.is_some(), true);\n    assert_eq!(x.is_none(), false);\n\n    let y: Result<i8, &str> = Ok(10);\n    assert_eq!(y.is_ok(), true);\n    assert_eq!(y.is_err(), false);\n}\n```\n\n## ok(), err() for Result types\n\nIn addition to that Rust provides `ok()` and `err()` for `Result` types. They convert the `Ok<T>` and `Err<E>` values of a **`Result` type to `Option` types**.\n\n```rust\nfn main() {\n    let o: Result<i8, &str> = Ok(8);\n    let e: Result<i8, &str> = Err(\"message\");\n    \n    assert_eq!(o.ok(), Some(8)); // Ok(v) ok = Some(v)\n    assert_eq!(e.ok(), None);    // Err(v) ok = None\n    \n    assert_eq!(o.err(), None);            // Ok(v) err = None\n    assert_eq!(e.err(), Some(\"message\")); // Err(v) err = Some(v)\n}\n```","date":"2019-01-19T16:53:20.795Z","updated":"2019-01-19T16:53:20.795Z","path":"docs/e3.option_and_result.html","comments":1,"layout":"page","_id":"cjtfwbizm000rdwgpyer7yyvd","content":"<h2 id=\"Why-Option-and-Result\"><a href=\"#Why-Option-and-Result\" class=\"headerlink\" title=\"Why Option and Result?\"></a>Why Option and Result?</h2><p>Many languages use <strong><code>null</code>\\ <code>nil</code>\\ <code>undefined</code> types</strong> to represent empty outputs, and <strong><code>Exceptions</code></strong> to handle errors. Rust skips using both, especially to prevent issues like <strong>null pointer exceptions, sensitive data leakages through exceptions</strong> and etc. Instead, Rust provides two special <strong>generic enums</strong>;<code>Option</code> and <code>Result</code> to deal with above cases.</p>\n<blockquote>\n<p>üí≠ In the previous sections, we have discussed about the basics of <a href=\"b3.enums.html\">enums</a>, <a href=\"b4.generics.html\">generics</a> and <a href=\"b4.generics.html#Generalizing-enums\"><code>Result</code> &amp; <code>Option</code> types</a>.</p>\n</blockquote>\n<p>As you know,</p>\n<ul>\n<li>An <strong>optional value</strong> can have either <strong>Some</strong> value or no value/ <strong>None</strong>.</li>\n<li>A <strong>result</strong> can represent either success/ <strong>Ok</strong> or failure/ <strong>Err</strong></li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// An output can have either Some value or no value/ None.\nenum Option&lt;T&gt; { // T is a generic and it can contain any type of value.\n    Some(T),\n    None,\n}\n\n// A result can represent either success/ Ok or failure/ Err.\nenum Result&lt;T, E&gt; { // T and E are generics. T can contain any type of value, E can be any error.\n    Ok(T),\n    Err(E),\n}\n</code></pre>\n<p>üí≠ Also as we discussed in <a href=\"d7.std_primitives_and_preludes.html#Preludes\">preludes</a>, not only <code>Option</code> and <code>Result</code>, and also their variants are in preludes. So, we can use them directly without using namespaces in the code.</p>\n<h2 id=\"Basic-usages-of-Option\"><a href=\"#Basic-usages-of-Option\" class=\"headerlink\" title=\"Basic usages of Option\"></a>Basic usages of Option</h2><p>When writing a function or data type, </p>\n<ul>\n<li>if an <strong>argument</strong> of the function is optional,</li>\n<li>If the function is non-void and if the output it <strong>returns</strong> can be empty,</li>\n<li>If the value, of a <strong>property of the data type</strong> can be empty,<br>We have to use their data type as an <code>Option</code> type</li>\n</ul>\n<p>For example, if the function outputs a <code>&amp;str</code> value and the output can be empty, the return type of the function should set as <code>Option&lt;&amp;str&gt;</code>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn get_an_optional_value() -&gt; Option&lt;&amp;str&gt; {\n\n    //if the optional value is not empty\n    return Some(&quot;Some value&quot;);\n\n    //else\n    None\n}\n</code></pre>\n<p>Same way, if the value of a property of a data type can be empty or optional like the <code>middle_name</code> of <code>Name</code> data type in the following example, we should set its data type as an <code>Option</code> type.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Name {\n  first_name: String,\n  middle_name: Option&lt;String&gt;, // middle_name can be empty\n  last_name: String,\n}\n</code></pre>\n<p>üí≠ As you know, we can use pattern matching to catch the relevant return type (<code>Some</code>/ <code>None</code>) via <code>match</code>. There is a function to get the current user‚Äôs home directory in <strong><code>std::env</code></strong> as <strong><a href=\"https://doc.rust-lang.org/std/env/fn.home_dir.html\" target=\"_blank\" rel=\"noopener\"><code>home_dir()</code></a></strong>. Because of all users doesn‚Äôt have a home directory in the systems like Linux, home directory of the user can be optional. So it returns an <code>Option</code> type; <a href=\"https://doc.rust-lang.org/std/path/struct.PathBuf.html\" target=\"_blank\" rel=\"noopener\"><code>Option&lt;PathBuf&gt;</code></a>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">use std::env;\n\nfn main() {\n    let home_path = env::home_dir();\n    match home_path {\n        Some(p) =&gt; println!(&quot;{:?}&quot;, p), // This prints &quot;/root&quot;, if you run this in Rust playground\n        None =&gt; println!(&quot;Can not find the home directory!&quot;),\n    }\n}\n</code></pre>\n<p>‚≠ê However, when using optional arguments with functions, we have to pass <code>None</code> values for empty arguments while calling the function.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn get_full_name(fname: &amp;str, lname: &amp;str, mname: Option&lt;&amp;str&gt;) -&gt; String { // middle name can be empty\n  match mname {\n    Some(n) =&gt; format!(&quot;{} {} {}&quot;, fname, n, lname),\n    None =&gt; format!(&quot;{} {}&quot;, fname, lname),\n  }\n}\n\nfn main() {\n  println!(&quot;{}&quot;, get_full_name(&quot;Galileo&quot;, &quot;Galilei&quot;, None));\n  println!(&quot;{}&quot;, get_full_name(&quot;Leonardo&quot;, &quot;Vinci&quot;, Some(&quot;Da&quot;)));\n}\n\n// üí° Better create a struct as Person with fname, lname, mname fields and create a impl function as full_name()\n</code></pre>\n<p>üîé Other than that, <code>Option</code> types are used with <strong>nullable pointers</strong> in Rust. Because of there is <strong>no null pointers in Rust</strong>, the pointer types should point to a valid location. So if a pointer can be nullable, we have use <code>Option&lt;Box&lt;T&gt;&gt;</code> .</p>\n<h2 id=\"Basic-usages-of-Result\"><a href=\"#Basic-usages-of-Result\" class=\"headerlink\" title=\"Basic usages of Result\"></a>Basic usages of Result</h2><p>If a function can produce an error, we have to use a <code>Result</code> type by <strong>combining the data type of the valid output and the data type of the error</strong>. For example, if the data type of the valid output is <code>u64</code> and error type is <code>String</code>, return type should be <code>Result&lt;u64, String&gt;</code>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn function_with_error() -&gt; Result&lt;u64, String&gt; {\n\n    //if error happens\n    return Err(&quot;The error message&quot;.to_string());\n\n    // else, return valid output\n    Ok(255)\n}\n</code></pre>\n<p>üí≠ As you know, we can use the pattern matching to catch the relevant return types (<code>Ok</code>/<code>Err</code>) via <code>match</code>. There is a function to fetch the value of any environment variable in <strong><code>std::env</code></strong> as <strong><a href=\"https://doc.rust-lang.org/std/env/fn.var.html\" target=\"_blank\" rel=\"noopener\"><code>var()</code></a></strong> . Its input is the environment variable name. This can produce an error, if we passes a wrong environment variable or the program can not extract the value of the environment variable while running. So, its return type is a <code>Result</code> type; <a href=\"https://doc.rust-lang.org/std/env/enum.VarError.html\" target=\"_blank\" rel=\"noopener\"><code>Result&lt;String, VarError&gt;</code></a>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">use std::env;\n\nfn main() {\n    let key = &quot;HOME&quot;;\n    match env::var(key) {\n        Ok(v) =&gt; println!(&quot;{}&quot;, v), // This prints &quot;/root&quot;, if you run this in Rust playground\n        Err(e) =&gt; println!(&quot;{}&quot;, e), // This prints &quot;environment variable not found&quot;, if you give a nonexistent environment variable\n    }\n}\n</code></pre>\n<h2 id=\"is-some-is-none-is-ok-is-err\"><a href=\"#is-some-is-none-is-ok-is-err\" class=\"headerlink\" title=\"is_some(), is_none(), is_ok(), is_err()\"></a>is_some(), is_none(), is_ok(), is_err()</h2><p>Other than <code>match</code> expressions, Rust provides <code>is_some()</code> , <code>is_none()</code> and <code>is_ok()</code> , <code>is_err()</code> functions to identify the return type.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let x: Option&lt;&amp;str&gt; = Some(&quot;Hello, world!&quot;);\n    assert_eq!(x.is_some(), true);\n    assert_eq!(x.is_none(), false);\n\n    let y: Result&lt;i8, &amp;str&gt; = Ok(10);\n    assert_eq!(y.is_ok(), true);\n    assert_eq!(y.is_err(), false);\n}\n</code></pre>\n<h2 id=\"ok-err-for-Result-types\"><a href=\"#ok-err-for-Result-types\" class=\"headerlink\" title=\"ok(), err() for Result types\"></a>ok(), err() for Result types</h2><p>In addition to that Rust provides <code>ok()</code> and <code>err()</code> for <code>Result</code> types. They convert the <code>Ok&lt;T&gt;</code> and <code>Err&lt;E&gt;</code> values of a <strong><code>Result</code> type to <code>Option</code> types</strong>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let o: Result&lt;i8, &amp;str&gt; = Ok(8);\n    let e: Result&lt;i8, &amp;str&gt; = Err(&quot;message&quot;);\n\n    assert_eq!(o.ok(), Some(8)); // Ok(v) ok = Some(v)\n    assert_eq!(e.ok(), None);    // Err(v) ok = None\n\n    assert_eq!(o.err(), None);            // Ok(v) err = None\n    assert_eq!(e.err(), Some(&quot;message&quot;)); // Err(v) err = Some(v)\n}\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<h2 id=\"Why-Option-and-Result\"><a href=\"#Why-Option-and-Result\" class=\"headerlink\" title=\"Why Option and Result?\"></a>Why Option and Result?</h2><p>Many languages use <strong><code>null</code>\\ <code>nil</code>\\ <code>undefined</code> types</strong> to represent empty outputs, and <strong><code>Exceptions</code></strong> to handle errors. Rust skips using both, especially to prevent issues like <strong>null pointer exceptions, sensitive data leakages through exceptions</strong> and etc. Instead, Rust provides two special <strong>generic enums</strong>;<code>Option</code> and <code>Result</code> to deal with above cases.</p>\n<blockquote>\n<p>üí≠ In the previous sections, we have discussed about the basics of <a href=\"b3.enums.html\">enums</a>, <a href=\"b4.generics.html\">generics</a> and <a href=\"b4.generics.html#Generalizing-enums\"><code>Result</code> &amp; <code>Option</code> types</a>.</p>\n</blockquote>\n<p>As you know,</p>\n<ul>\n<li>An <strong>optional value</strong> can have either <strong>Some</strong> value or no value/ <strong>None</strong>.</li>\n<li>A <strong>result</strong> can represent either success/ <strong>Ok</strong> or failure/ <strong>Err</strong></li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// An output can have either Some value or no value/ None.\nenum Option&lt;T&gt; { // T is a generic and it can contain any type of value.\n    Some(T),\n    None,\n}\n\n// A result can represent either success/ Ok or failure/ Err.\nenum Result&lt;T, E&gt; { // T and E are generics. T can contain any type of value, E can be any error.\n    Ok(T),\n    Err(E),\n}\n</code></pre>\n<p>üí≠ Also as we discussed in <a href=\"d7.std_primitives_and_preludes.html#Preludes\">preludes</a>, not only <code>Option</code> and <code>Result</code>, and also their variants are in preludes. So, we can use them directly without using namespaces in the code.</p>\n<h2 id=\"Basic-usages-of-Option\"><a href=\"#Basic-usages-of-Option\" class=\"headerlink\" title=\"Basic usages of Option\"></a>Basic usages of Option</h2><p>When writing a function or data type, </p>\n<ul>\n<li>if an <strong>argument</strong> of the function is optional,</li>\n<li>If the function is non-void and if the output it <strong>returns</strong> can be empty,</li>\n<li>If the value, of a <strong>property of the data type</strong> can be empty,<br>We have to use their data type as an <code>Option</code> type</li>\n</ul>\n<p>For example, if the function outputs a <code>&amp;str</code> value and the output can be empty, the return type of the function should set as <code>Option&lt;&amp;str&gt;</code>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn get_an_optional_value() -&gt; Option&lt;&amp;str&gt; {\n\n    //if the optional value is not empty\n    return Some(&quot;Some value&quot;);\n\n    //else\n    None\n}\n</code></pre>\n<p>Same way, if the value of a property of a data type can be empty or optional like the <code>middle_name</code> of <code>Name</code> data type in the following example, we should set its data type as an <code>Option</code> type.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Name {\n  first_name: String,\n  middle_name: Option&lt;String&gt;, // middle_name can be empty\n  last_name: String,\n}\n</code></pre>\n<p>üí≠ As you know, we can use pattern matching to catch the relevant return type (<code>Some</code>/ <code>None</code>) via <code>match</code>. There is a function to get the current user‚Äôs home directory in <strong><code>std::env</code></strong> as <strong><a href=\"https://doc.rust-lang.org/std/env/fn.home_dir.html\" target=\"_blank\" rel=\"noopener\"><code>home_dir()</code></a></strong>. Because of all users doesn‚Äôt have a home directory in the systems like Linux, home directory of the user can be optional. So it returns an <code>Option</code> type; <a href=\"https://doc.rust-lang.org/std/path/struct.PathBuf.html\" target=\"_blank\" rel=\"noopener\"><code>Option&lt;PathBuf&gt;</code></a>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">use std::env;\n\nfn main() {\n    let home_path = env::home_dir();\n    match home_path {\n        Some(p) =&gt; println!(&quot;{:?}&quot;, p), // This prints &quot;/root&quot;, if you run this in Rust playground\n        None =&gt; println!(&quot;Can not find the home directory!&quot;),\n    }\n}\n</code></pre>\n<p>‚≠ê However, when using optional arguments with functions, we have to pass <code>None</code> values for empty arguments while calling the function.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn get_full_name(fname: &amp;str, lname: &amp;str, mname: Option&lt;&amp;str&gt;) -&gt; String { // middle name can be empty\n  match mname {\n    Some(n) =&gt; format!(&quot;{} {} {}&quot;, fname, n, lname),\n    None =&gt; format!(&quot;{} {}&quot;, fname, lname),\n  }\n}\n\nfn main() {\n  println!(&quot;{}&quot;, get_full_name(&quot;Galileo&quot;, &quot;Galilei&quot;, None));\n  println!(&quot;{}&quot;, get_full_name(&quot;Leonardo&quot;, &quot;Vinci&quot;, Some(&quot;Da&quot;)));\n}\n\n// üí° Better create a struct as Person with fname, lname, mname fields and create a impl function as full_name()\n</code></pre>\n<p>üîé Other than that, <code>Option</code> types are used with <strong>nullable pointers</strong> in Rust. Because of there is <strong>no null pointers in Rust</strong>, the pointer types should point to a valid location. So if a pointer can be nullable, we have use <code>Option&lt;Box&lt;T&gt;&gt;</code> .</p>\n<h2 id=\"Basic-usages-of-Result\"><a href=\"#Basic-usages-of-Result\" class=\"headerlink\" title=\"Basic usages of Result\"></a>Basic usages of Result</h2><p>If a function can produce an error, we have to use a <code>Result</code> type by <strong>combining the data type of the valid output and the data type of the error</strong>. For example, if the data type of the valid output is <code>u64</code> and error type is <code>String</code>, return type should be <code>Result&lt;u64, String&gt;</code>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn function_with_error() -&gt; Result&lt;u64, String&gt; {\n\n    //if error happens\n    return Err(&quot;The error message&quot;.to_string());\n\n    // else, return valid output\n    Ok(255)\n}\n</code></pre>\n<p>üí≠ As you know, we can use the pattern matching to catch the relevant return types (<code>Ok</code>/<code>Err</code>) via <code>match</code>. There is a function to fetch the value of any environment variable in <strong><code>std::env</code></strong> as <strong><a href=\"https://doc.rust-lang.org/std/env/fn.var.html\" target=\"_blank\" rel=\"noopener\"><code>var()</code></a></strong> . Its input is the environment variable name. This can produce an error, if we passes a wrong environment variable or the program can not extract the value of the environment variable while running. So, its return type is a <code>Result</code> type; <a href=\"https://doc.rust-lang.org/std/env/enum.VarError.html\" target=\"_blank\" rel=\"noopener\"><code>Result&lt;String, VarError&gt;</code></a>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">use std::env;\n\nfn main() {\n    let key = &quot;HOME&quot;;\n    match env::var(key) {\n        Ok(v) =&gt; println!(&quot;{}&quot;, v), // This prints &quot;/root&quot;, if you run this in Rust playground\n        Err(e) =&gt; println!(&quot;{}&quot;, e), // This prints &quot;environment variable not found&quot;, if you give a nonexistent environment variable\n    }\n}\n</code></pre>\n<h2 id=\"is-some-is-none-is-ok-is-err\"><a href=\"#is-some-is-none-is-ok-is-err\" class=\"headerlink\" title=\"is_some(), is_none(), is_ok(), is_err()\"></a>is_some(), is_none(), is_ok(), is_err()</h2><p>Other than <code>match</code> expressions, Rust provides <code>is_some()</code> , <code>is_none()</code> and <code>is_ok()</code> , <code>is_err()</code> functions to identify the return type.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let x: Option&lt;&amp;str&gt; = Some(&quot;Hello, world!&quot;);\n    assert_eq!(x.is_some(), true);\n    assert_eq!(x.is_none(), false);\n\n    let y: Result&lt;i8, &amp;str&gt; = Ok(10);\n    assert_eq!(y.is_ok(), true);\n    assert_eq!(y.is_err(), false);\n}\n</code></pre>\n<h2 id=\"ok-err-for-Result-types\"><a href=\"#ok-err-for-Result-types\" class=\"headerlink\" title=\"ok(), err() for Result types\"></a>ok(), err() for Result types</h2><p>In addition to that Rust provides <code>ok()</code> and <code>err()</code> for <code>Result</code> types. They convert the <code>Ok&lt;T&gt;</code> and <code>Err&lt;E&gt;</code> values of a <strong><code>Result</code> type to <code>Option</code> types</strong>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let o: Result&lt;i8, &amp;str&gt; = Ok(8);\n    let e: Result&lt;i8, &amp;str&gt; = Err(&quot;message&quot;);\n\n    assert_eq!(o.ok(), Some(8)); // Ok(v) ok = Some(v)\n    assert_eq!(e.ok(), None);    // Err(v) ok = None\n\n    assert_eq!(o.err(), None);            // Ok(v) err = None\n    assert_eq!(e.err(), Some(&quot;message&quot;)); // Err(v) err = Some(v)\n}\n</code></pre>\n"},{"title":"Error and None Propagation","_content":"\nWe should use panics like `panic!()`, `unwrap()`, `expect()` only if we can not handle the situation in a better way. Also if a function contains expressions which can produce either `None` or `Err`, \n- we can handle them inside the same function. Or,\n- we can return `None` and `Err` types immediately to the caller. So the caller can decide how to handle them.\n\nüí° `None` types no need to handle by the caller of the function always. But Rusts‚Äô convention to handle **`Err`** types is, **return them immediately to the caller to give more control to the caller to decide how to handle them.**\n\n## ? Operator\n\n- If an `Option` type has **`Some`** value or a `Result` type has a **`Ok`** value, **the value inside them** passes to the next step.\n- If the `Option` type has **`None`** value or the `Result` type has **`Err`** value, **return them immediately** to the caller of the function.\n\nExample with `Option` type,\n\n```rust\nfn main() {\n    if complex_function().is_none() {\n        println!(\"X not exists!\");\n    }\n}\n\nfn complex_function() -> Option<&'static str> {\n    let x = get_an_optional_value()?; // if None, returns immidiately; if Some(\"abc\"), set x to \"abc\"\n\n    // some other code, ex\n    println!(\"{}\", x); // \"abc\" ; if you change line 19 `false` to `true` \n\n    Some(\"\")\n}\n\nfn get_an_optional_value() -> Option<&'static str> {\n\n    //if the optional value is not empty\n    if false {\n        return Some(\"abc\");\n    }\n    \n    //else\n    None\n}\n```\n\nExample with `Result` Type,\n\n```rust\nfn main() {\n    // `main` function is the caller of `complex_function` function\n    // So we handle errors of complex_function(), inside main()\n    if complex_function().is_err() {\n        println!(\"Can not calculate X!\");\n    }\n}\n\nfn complex_function() -> Result<u64, String> {\n    let x = function_with_error()?; // if Err, returns immidiately; if Ok(255), set x to 255\n\n    // some other code, ex\n    println!(\"{}\", x); // 255 ; if you change line 20 `true` to `false`\n\n    Ok(0)\n}\n\nfn function_with_error() -> Result<u64, String> {\n    //if error happens\n    if true {\n        return Err(\"some message\".to_string());\n    }\n\n    // else, return valid output\n    Ok(255)\n}\n```\n\n## try!()\n\n‚≠ê `?` operator was added in Rust version 1.13. `try!()` macro is the old way to propagate errors before that. So we **should avoid** using this now.\n\n- If a `Result` type has **`Ok`** value, **the value inside it** passes to the next step. If it has **`Err`** value, **returns it immediately** to the caller of the function.\n\n```rust\n// using `?`\nlet x = function_with_error()?; // if Err, returns immidiately; if Ok(255), set x to 255\n\n// using `try!()`\nlet x = try!(function_with_error());\n```\n\n## Error propagation from¬†main()\n\nBefore Rust version 1.26, we couldn't propagate `Result` and `Option` types from the `main()` function. But now, we **can propagate `Result` types** from the `main()` function and it prints the **`Debug` representation of the `Err`**.\n\nüí° We are going to discuss about `Debug` representations under [Error trait section](e7.custom_error_types.html#Error-trait).\n\n```rust\nuse std::fs::File;\n\nfn main() -> std::io::Result<()> {\n    let _ = File::open(\"not-existing-file.txt\")?;\n\n    Ok(()) // Because of the default return value of Rust functions is an empty tuple/ ()\n}\n\n// Because of the program can not find not-existing-file.txt , it produces,\n//    Err(Os { code: 2, kind: NotFound, message: \"No such file or directory\" })\n// While propagating error, the program prints,\n//    Error: Os { code: 2, kind: NotFound, message: \"No such file or directory\" }\n```\n\n> üíØ If you want to know about the all kind of errors `std::fs::File::open()` can produce, check the [error list on `std::fs::OpenOptions`](https://doc.rust-lang.org/std/fs/struct.OpenOptions.html#errors).","source":"docs/e5.error_and_none_propagation.md","raw":"title: Error and None Propagation\n---\n\nWe should use panics like `panic!()`, `unwrap()`, `expect()` only if we can not handle the situation in a better way. Also if a function contains expressions which can produce either `None` or `Err`, \n- we can handle them inside the same function. Or,\n- we can return `None` and `Err` types immediately to the caller. So the caller can decide how to handle them.\n\nüí° `None` types no need to handle by the caller of the function always. But Rusts‚Äô convention to handle **`Err`** types is, **return them immediately to the caller to give more control to the caller to decide how to handle them.**\n\n## ? Operator\n\n- If an `Option` type has **`Some`** value or a `Result` type has a **`Ok`** value, **the value inside them** passes to the next step.\n- If the `Option` type has **`None`** value or the `Result` type has **`Err`** value, **return them immediately** to the caller of the function.\n\nExample with `Option` type,\n\n```rust\nfn main() {\n    if complex_function().is_none() {\n        println!(\"X not exists!\");\n    }\n}\n\nfn complex_function() -> Option<&'static str> {\n    let x = get_an_optional_value()?; // if None, returns immidiately; if Some(\"abc\"), set x to \"abc\"\n\n    // some other code, ex\n    println!(\"{}\", x); // \"abc\" ; if you change line 19 `false` to `true` \n\n    Some(\"\")\n}\n\nfn get_an_optional_value() -> Option<&'static str> {\n\n    //if the optional value is not empty\n    if false {\n        return Some(\"abc\");\n    }\n    \n    //else\n    None\n}\n```\n\nExample with `Result` Type,\n\n```rust\nfn main() {\n    // `main` function is the caller of `complex_function` function\n    // So we handle errors of complex_function(), inside main()\n    if complex_function().is_err() {\n        println!(\"Can not calculate X!\");\n    }\n}\n\nfn complex_function() -> Result<u64, String> {\n    let x = function_with_error()?; // if Err, returns immidiately; if Ok(255), set x to 255\n\n    // some other code, ex\n    println!(\"{}\", x); // 255 ; if you change line 20 `true` to `false`\n\n    Ok(0)\n}\n\nfn function_with_error() -> Result<u64, String> {\n    //if error happens\n    if true {\n        return Err(\"some message\".to_string());\n    }\n\n    // else, return valid output\n    Ok(255)\n}\n```\n\n## try!()\n\n‚≠ê `?` operator was added in Rust version 1.13. `try!()` macro is the old way to propagate errors before that. So we **should avoid** using this now.\n\n- If a `Result` type has **`Ok`** value, **the value inside it** passes to the next step. If it has **`Err`** value, **returns it immediately** to the caller of the function.\n\n```rust\n// using `?`\nlet x = function_with_error()?; // if Err, returns immidiately; if Ok(255), set x to 255\n\n// using `try!()`\nlet x = try!(function_with_error());\n```\n\n## Error propagation from¬†main()\n\nBefore Rust version 1.26, we couldn't propagate `Result` and `Option` types from the `main()` function. But now, we **can propagate `Result` types** from the `main()` function and it prints the **`Debug` representation of the `Err`**.\n\nüí° We are going to discuss about `Debug` representations under [Error trait section](e7.custom_error_types.html#Error-trait).\n\n```rust\nuse std::fs::File;\n\nfn main() -> std::io::Result<()> {\n    let _ = File::open(\"not-existing-file.txt\")?;\n\n    Ok(()) // Because of the default return value of Rust functions is an empty tuple/ ()\n}\n\n// Because of the program can not find not-existing-file.txt , it produces,\n//    Err(Os { code: 2, kind: NotFound, message: \"No such file or directory\" })\n// While propagating error, the program prints,\n//    Error: Os { code: 2, kind: NotFound, message: \"No such file or directory\" }\n```\n\n> üíØ If you want to know about the all kind of errors `std::fs::File::open()` can produce, check the [error list on `std::fs::OpenOptions`](https://doc.rust-lang.org/std/fs/struct.OpenOptions.html#errors).","date":"2019-01-19T16:53:20.795Z","updated":"2019-01-19T16:53:20.795Z","path":"docs/e5.error_and_none_propagation.html","comments":1,"layout":"page","_id":"cjtfwbizm000sdwgpq2sxyzp9","content":"<p>We should use panics like <code>panic!()</code>, <code>unwrap()</code>, <code>expect()</code> only if we can not handle the situation in a better way. Also if a function contains expressions which can produce either <code>None</code> or <code>Err</code>, </p>\n<ul>\n<li>we can handle them inside the same function. Or,</li>\n<li>we can return <code>None</code> and <code>Err</code> types immediately to the caller. So the caller can decide how to handle them.</li>\n</ul>\n<p>üí° <code>None</code> types no need to handle by the caller of the function always. But Rusts‚Äô convention to handle <strong><code>Err</code></strong> types is, <strong>return them immediately to the caller to give more control to the caller to decide how to handle them.</strong></p>\n<h2 id=\"Operator\"><a href=\"#Operator\" class=\"headerlink\" title=\"? Operator\"></a>? Operator</h2><ul>\n<li>If an <code>Option</code> type has <strong><code>Some</code></strong> value or a <code>Result</code> type has a <strong><code>Ok</code></strong> value, <strong>the value inside them</strong> passes to the next step.</li>\n<li>If the <code>Option</code> type has <strong><code>None</code></strong> value or the <code>Result</code> type has <strong><code>Err</code></strong> value, <strong>return them immediately</strong> to the caller of the function.</li>\n</ul>\n<p>Example with <code>Option</code> type,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    if complex_function().is_none() {\n        println!(&quot;X not exists!&quot;);\n    }\n}\n\nfn complex_function() -&gt; Option&lt;&amp;&#39;static str&gt; {\n    let x = get_an_optional_value()?; // if None, returns immidiately; if Some(&quot;abc&quot;), set x to &quot;abc&quot;\n\n    // some other code, ex\n    println!(&quot;{}&quot;, x); // &quot;abc&quot; ; if you change line 19 `false` to `true` \n\n    Some(&quot;&quot;)\n}\n\nfn get_an_optional_value() -&gt; Option&lt;&amp;&#39;static str&gt; {\n\n    //if the optional value is not empty\n    if false {\n        return Some(&quot;abc&quot;);\n    }\n\n    //else\n    None\n}\n</code></pre>\n<p>Example with <code>Result</code> Type,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    // `main` function is the caller of `complex_function` function\n    // So we handle errors of complex_function(), inside main()\n    if complex_function().is_err() {\n        println!(&quot;Can not calculate X!&quot;);\n    }\n}\n\nfn complex_function() -&gt; Result&lt;u64, String&gt; {\n    let x = function_with_error()?; // if Err, returns immidiately; if Ok(255), set x to 255\n\n    // some other code, ex\n    println!(&quot;{}&quot;, x); // 255 ; if you change line 20 `true` to `false`\n\n    Ok(0)\n}\n\nfn function_with_error() -&gt; Result&lt;u64, String&gt; {\n    //if error happens\n    if true {\n        return Err(&quot;some message&quot;.to_string());\n    }\n\n    // else, return valid output\n    Ok(255)\n}\n</code></pre>\n<h2 id=\"try\"><a href=\"#try\" class=\"headerlink\" title=\"try!()\"></a>try!()</h2><p>‚≠ê <code>?</code> operator was added in Rust version 1.13. <code>try!()</code> macro is the old way to propagate errors before that. So we <strong>should avoid</strong> using this now.</p>\n<ul>\n<li>If a <code>Result</code> type has <strong><code>Ok</code></strong> value, <strong>the value inside it</strong> passes to the next step. If it has <strong><code>Err</code></strong> value, <strong>returns it immediately</strong> to the caller of the function.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// using `?`\nlet x = function_with_error()?; // if Err, returns immidiately; if Ok(255), set x to 255\n\n// using `try!()`\nlet x = try!(function_with_error());\n</code></pre>\n<h2 id=\"Error-propagation-from-main\"><a href=\"#Error-propagation-from-main\" class=\"headerlink\" title=\"Error propagation from main()\"></a>Error propagation from main()</h2><p>Before Rust version 1.26, we couldn‚Äôt propagate <code>Result</code> and <code>Option</code> types from the <code>main()</code> function. But now, we <strong>can propagate <code>Result</code> types</strong> from the <code>main()</code> function and it prints the <strong><code>Debug</code> representation of the <code>Err</code></strong>.</p>\n<p>üí° We are going to discuss about <code>Debug</code> representations under <a href=\"e7.custom_error_types.html#Error-trait\">Error trait section</a>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">use std::fs::File;\n\nfn main() -&gt; std::io::Result&lt;()&gt; {\n    let _ = File::open(&quot;not-existing-file.txt&quot;)?;\n\n    Ok(()) // Because of the default return value of Rust functions is an empty tuple/ ()\n}\n\n// Because of the program can not find not-existing-file.txt , it produces,\n//    Err(Os { code: 2, kind: NotFound, message: &quot;No such file or directory&quot; })\n// While propagating error, the program prints,\n//    Error: Os { code: 2, kind: NotFound, message: &quot;No such file or directory&quot; }\n</code></pre>\n<blockquote>\n<p>üíØ If you want to know about the all kind of errors <code>std::fs::File::open()</code> can produce, check the <a href=\"https://doc.rust-lang.org/std/fs/struct.OpenOptions.html#errors\" target=\"_blank\" rel=\"noopener\">error list on <code>std::fs::OpenOptions</code></a>.</p>\n</blockquote>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<p>We should use panics like <code>panic!()</code>, <code>unwrap()</code>, <code>expect()</code> only if we can not handle the situation in a better way. Also if a function contains expressions which can produce either <code>None</code> or <code>Err</code>, </p>\n<ul>\n<li>we can handle them inside the same function. Or,</li>\n<li>we can return <code>None</code> and <code>Err</code> types immediately to the caller. So the caller can decide how to handle them.</li>\n</ul>\n<p>üí° <code>None</code> types no need to handle by the caller of the function always. But Rusts‚Äô convention to handle <strong><code>Err</code></strong> types is, <strong>return them immediately to the caller to give more control to the caller to decide how to handle them.</strong></p>\n<h2 id=\"Operator\"><a href=\"#Operator\" class=\"headerlink\" title=\"? Operator\"></a>? Operator</h2><ul>\n<li>If an <code>Option</code> type has <strong><code>Some</code></strong> value or a <code>Result</code> type has a <strong><code>Ok</code></strong> value, <strong>the value inside them</strong> passes to the next step.</li>\n<li>If the <code>Option</code> type has <strong><code>None</code></strong> value or the <code>Result</code> type has <strong><code>Err</code></strong> value, <strong>return them immediately</strong> to the caller of the function.</li>\n</ul>\n<p>Example with <code>Option</code> type,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    if complex_function().is_none() {\n        println!(&quot;X not exists!&quot;);\n    }\n}\n\nfn complex_function() -&gt; Option&lt;&amp;&#39;static str&gt; {\n    let x = get_an_optional_value()?; // if None, returns immidiately; if Some(&quot;abc&quot;), set x to &quot;abc&quot;\n\n    // some other code, ex\n    println!(&quot;{}&quot;, x); // &quot;abc&quot; ; if you change line 19 `false` to `true` \n\n    Some(&quot;&quot;)\n}\n\nfn get_an_optional_value() -&gt; Option&lt;&amp;&#39;static str&gt; {\n\n    //if the optional value is not empty\n    if false {\n        return Some(&quot;abc&quot;);\n    }\n\n    //else\n    None\n}\n</code></pre>\n<p>Example with <code>Result</code> Type,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    // `main` function is the caller of `complex_function` function\n    // So we handle errors of complex_function(), inside main()\n    if complex_function().is_err() {\n        println!(&quot;Can not calculate X!&quot;);\n    }\n}\n\nfn complex_function() -&gt; Result&lt;u64, String&gt; {\n    let x = function_with_error()?; // if Err, returns immidiately; if Ok(255), set x to 255\n\n    // some other code, ex\n    println!(&quot;{}&quot;, x); // 255 ; if you change line 20 `true` to `false`\n\n    Ok(0)\n}\n\nfn function_with_error() -&gt; Result&lt;u64, String&gt; {\n    //if error happens\n    if true {\n        return Err(&quot;some message&quot;.to_string());\n    }\n\n    // else, return valid output\n    Ok(255)\n}\n</code></pre>\n<h2 id=\"try\"><a href=\"#try\" class=\"headerlink\" title=\"try!()\"></a>try!()</h2><p>‚≠ê <code>?</code> operator was added in Rust version 1.13. <code>try!()</code> macro is the old way to propagate errors before that. So we <strong>should avoid</strong> using this now.</p>\n<ul>\n<li>If a <code>Result</code> type has <strong><code>Ok</code></strong> value, <strong>the value inside it</strong> passes to the next step. If it has <strong><code>Err</code></strong> value, <strong>returns it immediately</strong> to the caller of the function.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// using `?`\nlet x = function_with_error()?; // if Err, returns immidiately; if Ok(255), set x to 255\n\n// using `try!()`\nlet x = try!(function_with_error());\n</code></pre>\n<h2 id=\"Error-propagation-from-main\"><a href=\"#Error-propagation-from-main\" class=\"headerlink\" title=\"Error propagation from main()\"></a>Error propagation from main()</h2><p>Before Rust version 1.26, we couldn‚Äôt propagate <code>Result</code> and <code>Option</code> types from the <code>main()</code> function. But now, we <strong>can propagate <code>Result</code> types</strong> from the <code>main()</code> function and it prints the <strong><code>Debug</code> representation of the <code>Err</code></strong>.</p>\n<p>üí° We are going to discuss about <code>Debug</code> representations under <a href=\"e7.custom_error_types.html#Error-trait\">Error trait section</a>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">use std::fs::File;\n\nfn main() -&gt; std::io::Result&lt;()&gt; {\n    let _ = File::open(&quot;not-existing-file.txt&quot;)?;\n\n    Ok(()) // Because of the default return value of Rust functions is an empty tuple/ ()\n}\n\n// Because of the program can not find not-existing-file.txt , it produces,\n//    Err(Os { code: 2, kind: NotFound, message: &quot;No such file or directory&quot; })\n// While propagating error, the program prints,\n//    Error: Os { code: 2, kind: NotFound, message: &quot;No such file or directory&quot; }\n</code></pre>\n<blockquote>\n<p>üíØ If you want to know about the all kind of errors <code>std::fs::File::open()</code> can produce, check the <a href=\"https://doc.rust-lang.org/std/fs/struct.OpenOptions.html#errors\" target=\"_blank\" rel=\"noopener\">error list on <code>std::fs::OpenOptions</code></a>.</p>\n</blockquote>\n"},{"title":"Lifetimes","_content":"\nWhen we are dealing with references, we have to make sure that the referencing data stay alive until we stop using the references.\n\nThink,\n\n* We have a **variable binding**, `a`.\n* We are **referencing** the value of `a`, **from another variable binding** `x`.\n  We have to make sure that **`a` lives until we stop using `x`**.\n\n> üîé **Memory management** is a form of resource management applied to computer memory. Up until the mid-1990s, the majority of programming languages used **Manual Memory Management** which **requires the programmer to give manual instructions** to identify and deallocate unused objects/ garbage. Around 1959 John McCarthy invented **Garbage collection**\\(GC\\), a form of **Automatic Memory Management**\\(AMM\\). It determines what memory is no longer used and frees it automatically instead of relying on the programmer. However **Objective-C and Swift** provide similar functionality through **Automatic Reference Counting**\\(ARC\\).\n\n\n## What is Lifetime?\n\nIn Rust,\n\n* A resource can only have **one owner** at a time. When it goes **out of the scope**, Rust removes it from the Memory.\n* When we want to reuse the same resource, we are **referencing** it/ **borrowing** its content.\n* When dealing with **references**, we have to specify **lifetime annotations** to provide instructions for the **compiler** to set **how long** those referenced resources **should be alive**.\n* ‚≠ê But because of lifetime annotations make the **code more verbose**, in order to make **common patterns** more ergonomic, Rust allows lifetimes to be **elided/omitted** in `fn` definitions. In this case, the compiler assigns lifetime annotations **implicitly**.\n\nLifetime annotations are **checked at compile-time**. Compiler checks when a data is used for the first and the last times. According to that, Rust manages memory in **run time**. This is the major reason for **slower compilation times** in Rust.\n\n> * Unlike C and C++, **usually**, Rust doesn‚Äôt explicitly drop values at all.\n> * Unlike GC, Rust doesn‚Äôt place deallocation calls where the data is no longer referenced.\n> * Rust places deallocation calls where the data is about to go out of the scope and then enforces that no references to that resource exist after that point.\n\n\n## Usage\n\nLifetimes are denoted with an apostrophe. By convention, a lowercase letter is used for naming. Usually **starts with** `'a` and **follows alphabetic order** when we need to add **multiple lifetime** annotations.\n\nWhen using references,\n\n### 01. On Function Declaration\n\n* Input and output parameters with references should attach lifetimes after the `&` sign.\n  ex. `..(x: &'a str)` , `..(x: &'a mut str)`\n\n* After the function name, we should mention that the given lifetimes are generic types.\n  ex. `fn foo<'a>(..)` , `fn foo<'a, 'b>(..)`\n\n```rust\n// No inputs, return a reference\nfn function<'a>() -> &'a str {}\n\n// Single input\nfn function<'a>(x: &'a str) {}\n\n// Single input and output, both have the same lifetime\n// The output should live at least as long as input exists\nfn function<'a>(x: &'a str) -> &'a str {}\n\n// Multiple inputs, only one input and the output share same lifetime\n// The output should live at least as long as y exists\nfn function<'a>(x: i32, y: &'a str) -> &'a str {}\n\n// Multiple inputs, both inputs and the output share same lifetime\n// The output should live at least as long as x and y exist\nfn function<'a>(x: &'a str, y: &'a str) -> &'a str {}\n\n// Multiple inputs, inputs can have different lifetimes üîé\n// The output should live at least as long as x exists\nfn function<'a, 'b>(x: &'a str, y: &'b str) -> &'a str {}\n```\n\n### 02. On Struct or Enum Declaration\n\n* Elements with references should attach lifetimes after the `&` sign.\n* After the name of the struct or enum, we should mention that the given lifetimes are generic types.\n\n```rust\n// Single element\n// Data of x should live at least as long as Struct exists\nstruct Struct<'a> {\n    x: &'a str\n}\n\n// Multiple elements\n// Data of x and y should live at least as long as Struct exists\nstruct Struct<'a> {\n    x: &'a str,\n    y: &'a str\n}\n\n\n// Variant with a single element\n// Data of the variant should live at least as long as Enum exists\nenum Enum<'a> {\n    Variant(&'a Type)\n}\n```\n\n### 03. With Impls and Traits\n\n```rust\nstruct Struct<'a> {\n    x: &'a str\n}\n    impl<'a> Struct<'a> {\n        fn function<'a>(&self) -> &'a str {\n            self.x\n        }\n    }\n\n\nstruct Struct<'a> {\n    x: &'a str,\n    y: &'a str\n}\n    impl<'a> Struct<'a> {\n        fn new(x: &'a str, y: &'a str) -> Struct<'a> { // No need to specify <'a> after new; impl already has it\n          Struct {\n              x : x,\n              y : y\n          }\n        }\n    }\n\n\n// üîé\nimpl<'a> Trait<'a> for Type\nimpl<'a> Trait for Type<'a>\n```\n\n### 04. With Generic Types\n\n```rust\n// üîé\nfn function<F>(f: F) where for<'a> F: FnOnce(&'a Type)\nstruct Struct<F> where for<'a> F: FnOnce(&'a Type) { x: F }\nenum Enum<F> where for<'a> F: FnOnce(&'a Type) { Variant(F) }\nimpl<F> Struct<F> where for<'a> F: FnOnce(&'a Type) { fn x(&self) -> &F { &self.x } }\n```\n\n\n## Lifetime Elision\n\nAs I mentioned earlier, in order to make **common patterns** more ergonomic, Rust allows lifetimes to be **elided/omitted**. This process is called **Lifetime Elision**.\n\nüí° For the moment Rust supports Lifetime Elisions only on `fn` definitions. But in the future, it will support for `impl` headers as well.\n\nLifetime annotations of `fn` definitions can be elided  \nif its **parameter list** has either,\n\n* **only one input parameter passes by reference**.\n* a parameter with **either** `&self` **or** **&mut self** reference.\n\n```rust\nfn triple(x: &u64) -> u64 { // Only one input parameter passes by reference\n    x * 3\n}\n\n\nfn filter(x: u8, y: &str) -> &str { // Only one input parameter passes by reference\n    if x > 5 { y } else { \"invalid inputs\" }\n}\n\n\nstruct Player<'a> {\n    id: u8,\n    name: &'a str\n}\n    impl<'a> Player<'a> { // So far Lifetime Elisions are allowed only on fn definitions. But in the future, they might support on impl headers as well.\n        fn new(id: u8, name: &str) -> Player { // Only one input parameter passes by reference\n            Player {\n                id : id,\n                name : name\n            }\n        }\n\n        fn heading_text(&self) -> String { // An fn definition with &self (or &mut self) reference\n            format!(\"{}: {}\", self.id, self.name)\n        }\n    }\n\nfn main() {\n    let player1 = Player::new(1, \"Serena Williams\");\n    let player1_heading_text = player1.heading_text()\n    println!(\"{}\", player1_heading_text);\n}\n```\n\n> üí° In the Lifetime Elision process of fn definitions,\n>\n> * Each parameter passes by reference is got a distinct lifetime annotation.\n>     ex. `..(x: &str, y: &str)` ‚Üí `..<'a, 'b>(x: &'a str, y: &'b str)`\n> * If the parameter list has only one parameter passes by reference, that lifetime is assigned to all elided lifetimes in the return values of that function.\n>     ex. `..(x: i32, y: &str) -> &str` ‚Üí `..<'a>(x: i32, y: &'a str) -> &'a str`\n> * Even it has multiple parameters pass by reference, if one of them has &self or &mut self, the lifetime of self is assigned to all elided output lifetimes.\n>     ex. `impl Impl{ fn function(&self, x: &str) -> &str {} }` ‚Üí\n>     `impl<'a> Impl<'a>{ fn function(&'a self, x: &'b str) -> &'a str {} }`\n> * For all other cases, we have to write lifetime annotations manually.\n\n\n## `'static` Annotations\n\n`'static` lifetime annotation is a **reserved** lifetime annotation. These **references are valid for the entire program**. They are saved in the data segment of the binary and the data referred to will never go out of scope.\n\n```rust\nstatic N: i32 = 5; // A constant with 'static lifetime\n\nlet a = \"Hello, world.\"; // a: &'static str\n\n\nfn index() -> &'static str { // No need to mention <'static> ; fn index Ã∂<Ã∂'Ã∂sÃ∂tÃ∂aÃ∂tÃ∂iÃ∂cÃ∂>Ã∂ \n\t\"Hello, world!\"\n}\n```\n\n\n## Few more examples about the usage of Rust lifetimes.\n\n```rust\nfn greeting<'a>() -> &'a str {\n  \"Hi!\"\n}\n\n\nfn fullname<'a>(fname: &'a str, lname: &'a str) -> String {\n  format!(\"{} {}\", fname, lname)\n}\n\n\nstruct Person<'a> {\n    fname: &'a str,\n    lname: &'a str\n}\n  impl<'a> Person<'a> {\n      fn new(fname: &'a str, lname: &'a str) -> Person<'a> { // No need to specify <'a> after new; impl already has it\n          Person {\n              fname : fname,\n              lname : lname\n          }\n      }\n\n      fn fullname(&self) -> String {\n          format!(\"{} {}\", self.fname , self.lname)\n      }\n  }\n\nfn main() {\n    let player = Person::new(\"Serena\", \"Williams\");\n    let player_fullname = player.fullname();\n\n    println!(\"Player: {}\", player_fullname);\n}\n```\n","source":"docs/c3.lifetimes.md","raw":"title: Lifetimes\n---\n\nWhen we are dealing with references, we have to make sure that the referencing data stay alive until we stop using the references.\n\nThink,\n\n* We have a **variable binding**, `a`.\n* We are **referencing** the value of `a`, **from another variable binding** `x`.\n  We have to make sure that **`a` lives until we stop using `x`**.\n\n> üîé **Memory management** is a form of resource management applied to computer memory. Up until the mid-1990s, the majority of programming languages used **Manual Memory Management** which **requires the programmer to give manual instructions** to identify and deallocate unused objects/ garbage. Around 1959 John McCarthy invented **Garbage collection**\\(GC\\), a form of **Automatic Memory Management**\\(AMM\\). It determines what memory is no longer used and frees it automatically instead of relying on the programmer. However **Objective-C and Swift** provide similar functionality through **Automatic Reference Counting**\\(ARC\\).\n\n\n## What is Lifetime?\n\nIn Rust,\n\n* A resource can only have **one owner** at a time. When it goes **out of the scope**, Rust removes it from the Memory.\n* When we want to reuse the same resource, we are **referencing** it/ **borrowing** its content.\n* When dealing with **references**, we have to specify **lifetime annotations** to provide instructions for the **compiler** to set **how long** those referenced resources **should be alive**.\n* ‚≠ê But because of lifetime annotations make the **code more verbose**, in order to make **common patterns** more ergonomic, Rust allows lifetimes to be **elided/omitted** in `fn` definitions. In this case, the compiler assigns lifetime annotations **implicitly**.\n\nLifetime annotations are **checked at compile-time**. Compiler checks when a data is used for the first and the last times. According to that, Rust manages memory in **run time**. This is the major reason for **slower compilation times** in Rust.\n\n> * Unlike C and C++, **usually**, Rust doesn‚Äôt explicitly drop values at all.\n> * Unlike GC, Rust doesn‚Äôt place deallocation calls where the data is no longer referenced.\n> * Rust places deallocation calls where the data is about to go out of the scope and then enforces that no references to that resource exist after that point.\n\n\n## Usage\n\nLifetimes are denoted with an apostrophe. By convention, a lowercase letter is used for naming. Usually **starts with** `'a` and **follows alphabetic order** when we need to add **multiple lifetime** annotations.\n\nWhen using references,\n\n### 01. On Function Declaration\n\n* Input and output parameters with references should attach lifetimes after the `&` sign.\n  ex. `..(x: &'a str)` , `..(x: &'a mut str)`\n\n* After the function name, we should mention that the given lifetimes are generic types.\n  ex. `fn foo<'a>(..)` , `fn foo<'a, 'b>(..)`\n\n```rust\n// No inputs, return a reference\nfn function<'a>() -> &'a str {}\n\n// Single input\nfn function<'a>(x: &'a str) {}\n\n// Single input and output, both have the same lifetime\n// The output should live at least as long as input exists\nfn function<'a>(x: &'a str) -> &'a str {}\n\n// Multiple inputs, only one input and the output share same lifetime\n// The output should live at least as long as y exists\nfn function<'a>(x: i32, y: &'a str) -> &'a str {}\n\n// Multiple inputs, both inputs and the output share same lifetime\n// The output should live at least as long as x and y exist\nfn function<'a>(x: &'a str, y: &'a str) -> &'a str {}\n\n// Multiple inputs, inputs can have different lifetimes üîé\n// The output should live at least as long as x exists\nfn function<'a, 'b>(x: &'a str, y: &'b str) -> &'a str {}\n```\n\n### 02. On Struct or Enum Declaration\n\n* Elements with references should attach lifetimes after the `&` sign.\n* After the name of the struct or enum, we should mention that the given lifetimes are generic types.\n\n```rust\n// Single element\n// Data of x should live at least as long as Struct exists\nstruct Struct<'a> {\n    x: &'a str\n}\n\n// Multiple elements\n// Data of x and y should live at least as long as Struct exists\nstruct Struct<'a> {\n    x: &'a str,\n    y: &'a str\n}\n\n\n// Variant with a single element\n// Data of the variant should live at least as long as Enum exists\nenum Enum<'a> {\n    Variant(&'a Type)\n}\n```\n\n### 03. With Impls and Traits\n\n```rust\nstruct Struct<'a> {\n    x: &'a str\n}\n    impl<'a> Struct<'a> {\n        fn function<'a>(&self) -> &'a str {\n            self.x\n        }\n    }\n\n\nstruct Struct<'a> {\n    x: &'a str,\n    y: &'a str\n}\n    impl<'a> Struct<'a> {\n        fn new(x: &'a str, y: &'a str) -> Struct<'a> { // No need to specify <'a> after new; impl already has it\n          Struct {\n              x : x,\n              y : y\n          }\n        }\n    }\n\n\n// üîé\nimpl<'a> Trait<'a> for Type\nimpl<'a> Trait for Type<'a>\n```\n\n### 04. With Generic Types\n\n```rust\n// üîé\nfn function<F>(f: F) where for<'a> F: FnOnce(&'a Type)\nstruct Struct<F> where for<'a> F: FnOnce(&'a Type) { x: F }\nenum Enum<F> where for<'a> F: FnOnce(&'a Type) { Variant(F) }\nimpl<F> Struct<F> where for<'a> F: FnOnce(&'a Type) { fn x(&self) -> &F { &self.x } }\n```\n\n\n## Lifetime Elision\n\nAs I mentioned earlier, in order to make **common patterns** more ergonomic, Rust allows lifetimes to be **elided/omitted**. This process is called **Lifetime Elision**.\n\nüí° For the moment Rust supports Lifetime Elisions only on `fn` definitions. But in the future, it will support for `impl` headers as well.\n\nLifetime annotations of `fn` definitions can be elided  \nif its **parameter list** has either,\n\n* **only one input parameter passes by reference**.\n* a parameter with **either** `&self` **or** **&mut self** reference.\n\n```rust\nfn triple(x: &u64) -> u64 { // Only one input parameter passes by reference\n    x * 3\n}\n\n\nfn filter(x: u8, y: &str) -> &str { // Only one input parameter passes by reference\n    if x > 5 { y } else { \"invalid inputs\" }\n}\n\n\nstruct Player<'a> {\n    id: u8,\n    name: &'a str\n}\n    impl<'a> Player<'a> { // So far Lifetime Elisions are allowed only on fn definitions. But in the future, they might support on impl headers as well.\n        fn new(id: u8, name: &str) -> Player { // Only one input parameter passes by reference\n            Player {\n                id : id,\n                name : name\n            }\n        }\n\n        fn heading_text(&self) -> String { // An fn definition with &self (or &mut self) reference\n            format!(\"{}: {}\", self.id, self.name)\n        }\n    }\n\nfn main() {\n    let player1 = Player::new(1, \"Serena Williams\");\n    let player1_heading_text = player1.heading_text()\n    println!(\"{}\", player1_heading_text);\n}\n```\n\n> üí° In the Lifetime Elision process of fn definitions,\n>\n> * Each parameter passes by reference is got a distinct lifetime annotation.\n>     ex. `..(x: &str, y: &str)` ‚Üí `..<'a, 'b>(x: &'a str, y: &'b str)`\n> * If the parameter list has only one parameter passes by reference, that lifetime is assigned to all elided lifetimes in the return values of that function.\n>     ex. `..(x: i32, y: &str) -> &str` ‚Üí `..<'a>(x: i32, y: &'a str) -> &'a str`\n> * Even it has multiple parameters pass by reference, if one of them has &self or &mut self, the lifetime of self is assigned to all elided output lifetimes.\n>     ex. `impl Impl{ fn function(&self, x: &str) -> &str {} }` ‚Üí\n>     `impl<'a> Impl<'a>{ fn function(&'a self, x: &'b str) -> &'a str {} }`\n> * For all other cases, we have to write lifetime annotations manually.\n\n\n## `'static` Annotations\n\n`'static` lifetime annotation is a **reserved** lifetime annotation. These **references are valid for the entire program**. They are saved in the data segment of the binary and the data referred to will never go out of scope.\n\n```rust\nstatic N: i32 = 5; // A constant with 'static lifetime\n\nlet a = \"Hello, world.\"; // a: &'static str\n\n\nfn index() -> &'static str { // No need to mention <'static> ; fn index Ã∂<Ã∂'Ã∂sÃ∂tÃ∂aÃ∂tÃ∂iÃ∂cÃ∂>Ã∂ \n\t\"Hello, world!\"\n}\n```\n\n\n## Few more examples about the usage of Rust lifetimes.\n\n```rust\nfn greeting<'a>() -> &'a str {\n  \"Hi!\"\n}\n\n\nfn fullname<'a>(fname: &'a str, lname: &'a str) -> String {\n  format!(\"{} {}\", fname, lname)\n}\n\n\nstruct Person<'a> {\n    fname: &'a str,\n    lname: &'a str\n}\n  impl<'a> Person<'a> {\n      fn new(fname: &'a str, lname: &'a str) -> Person<'a> { // No need to specify <'a> after new; impl already has it\n          Person {\n              fname : fname,\n              lname : lname\n          }\n      }\n\n      fn fullname(&self) -> String {\n          format!(\"{} {}\", self.fname , self.lname)\n      }\n  }\n\nfn main() {\n    let player = Person::new(\"Serena\", \"Williams\");\n    let player_fullname = player.fullname();\n\n    println!(\"Player: {}\", player_fullname);\n}\n```\n","date":"2019-03-19T14:50:39.954Z","updated":"2019-03-19T14:50:39.954Z","path":"docs/c3.lifetimes.html","comments":1,"layout":"page","_id":"cjtfwbizz000tdwgp24fqpt4a","content":"<p>When we are dealing with references, we have to make sure that the referencing data stay alive until we stop using the references.</p>\n<p>Think,</p>\n<ul>\n<li>We have a <strong>variable binding</strong>, <code>a</code>.</li>\n<li>We are <strong>referencing</strong> the value of <code>a</code>, <strong>from another variable binding</strong> <code>x</code>.<br>We have to make sure that <strong><code>a</code> lives until we stop using <code>x</code></strong>.</li>\n</ul>\n<blockquote>\n<p>üîé <strong>Memory management</strong> is a form of resource management applied to computer memory. Up until the mid-1990s, the majority of programming languages used <strong>Manual Memory Management</strong> which <strong>requires the programmer to give manual instructions</strong> to identify and deallocate unused objects/ garbage. Around 1959 John McCarthy invented <strong>Garbage collection</strong>(GC), a form of <strong>Automatic Memory Management</strong>(AMM). It determines what memory is no longer used and frees it automatically instead of relying on the programmer. However <strong>Objective-C and Swift</strong> provide similar functionality through <strong>Automatic Reference Counting</strong>(ARC).</p>\n</blockquote>\n<h2 id=\"What-is-Lifetime\"><a href=\"#What-is-Lifetime\" class=\"headerlink\" title=\"What is Lifetime?\"></a>What is Lifetime?</h2><p>In Rust,</p>\n<ul>\n<li>A resource can only have <strong>one owner</strong> at a time. When it goes <strong>out of the scope</strong>, Rust removes it from the Memory.</li>\n<li>When we want to reuse the same resource, we are <strong>referencing</strong> it/ <strong>borrowing</strong> its content.</li>\n<li>When dealing with <strong>references</strong>, we have to specify <strong>lifetime annotations</strong> to provide instructions for the <strong>compiler</strong> to set <strong>how long</strong> those referenced resources <strong>should be alive</strong>.</li>\n<li>‚≠ê But because of lifetime annotations make the <strong>code more verbose</strong>, in order to make <strong>common patterns</strong> more ergonomic, Rust allows lifetimes to be <strong>elided/omitted</strong> in <code>fn</code> definitions. In this case, the compiler assigns lifetime annotations <strong>implicitly</strong>.</li>\n</ul>\n<p>Lifetime annotations are <strong>checked at compile-time</strong>. Compiler checks when a data is used for the first and the last times. According to that, Rust manages memory in <strong>run time</strong>. This is the major reason for <strong>slower compilation times</strong> in Rust.</p>\n<blockquote>\n<ul>\n<li>Unlike C and C++, <strong>usually</strong>, Rust doesn‚Äôt explicitly drop values at all.</li>\n<li>Unlike GC, Rust doesn‚Äôt place deallocation calls where the data is no longer referenced.</li>\n<li>Rust places deallocation calls where the data is about to go out of the scope and then enforces that no references to that resource exist after that point.</li>\n</ul>\n</blockquote>\n<h2 id=\"Usage\"><a href=\"#Usage\" class=\"headerlink\" title=\"Usage\"></a>Usage</h2><p>Lifetimes are denoted with an apostrophe. By convention, a lowercase letter is used for naming. Usually <strong>starts with</strong> <code>&#39;a</code> and <strong>follows alphabetic order</strong> when we need to add <strong>multiple lifetime</strong> annotations.</p>\n<p>When using references,</p>\n<h3 id=\"01-On-Function-Declaration\"><a href=\"#01-On-Function-Declaration\" class=\"headerlink\" title=\"01. On Function Declaration\"></a>01. On Function Declaration</h3><ul>\n<li><p>Input and output parameters with references should attach lifetimes after the <code>&amp;</code> sign.<br>ex. <code>..(x: &amp;&#39;a str)</code> , <code>..(x: &amp;&#39;a mut str)</code></p>\n</li>\n<li><p>After the function name, we should mention that the given lifetimes are generic types.<br>ex. <code>fn foo&lt;&#39;a&gt;(..)</code> , <code>fn foo&lt;&#39;a, &#39;b&gt;(..)</code></p>\n</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// No inputs, return a reference\nfn function&lt;&#39;a&gt;() -&gt; &amp;&#39;a str {}\n\n// Single input\nfn function&lt;&#39;a&gt;(x: &amp;&#39;a str) {}\n\n// Single input and output, both have the same lifetime\n// The output should live at least as long as input exists\nfn function&lt;&#39;a&gt;(x: &amp;&#39;a str) -&gt; &amp;&#39;a str {}\n\n// Multiple inputs, only one input and the output share same lifetime\n// The output should live at least as long as y exists\nfn function&lt;&#39;a&gt;(x: i32, y: &amp;&#39;a str) -&gt; &amp;&#39;a str {}\n\n// Multiple inputs, both inputs and the output share same lifetime\n// The output should live at least as long as x and y exist\nfn function&lt;&#39;a&gt;(x: &amp;&#39;a str, y: &amp;&#39;a str) -&gt; &amp;&#39;a str {}\n\n// Multiple inputs, inputs can have different lifetimes üîé\n// The output should live at least as long as x exists\nfn function&lt;&#39;a, &#39;b&gt;(x: &amp;&#39;a str, y: &amp;&#39;b str) -&gt; &amp;&#39;a str {}\n</code></pre>\n<h3 id=\"02-On-Struct-or-Enum-Declaration\"><a href=\"#02-On-Struct-or-Enum-Declaration\" class=\"headerlink\" title=\"02. On Struct or Enum Declaration\"></a>02. On Struct or Enum Declaration</h3><ul>\n<li>Elements with references should attach lifetimes after the <code>&amp;</code> sign.</li>\n<li>After the name of the struct or enum, we should mention that the given lifetimes are generic types.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Single element\n// Data of x should live at least as long as Struct exists\nstruct Struct&lt;&#39;a&gt; {\n    x: &amp;&#39;a str\n}\n\n// Multiple elements\n// Data of x and y should live at least as long as Struct exists\nstruct Struct&lt;&#39;a&gt; {\n    x: &amp;&#39;a str,\n    y: &amp;&#39;a str\n}\n\n\n// Variant with a single element\n// Data of the variant should live at least as long as Enum exists\nenum Enum&lt;&#39;a&gt; {\n    Variant(&amp;&#39;a Type)\n}\n</code></pre>\n<h3 id=\"03-With-Impls-and-Traits\"><a href=\"#03-With-Impls-and-Traits\" class=\"headerlink\" title=\"03. With Impls and Traits\"></a>03. With Impls and Traits</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Struct&lt;&#39;a&gt; {\n    x: &amp;&#39;a str\n}\n    impl&lt;&#39;a&gt; Struct&lt;&#39;a&gt; {\n        fn function&lt;&#39;a&gt;(&amp;self) -&gt; &amp;&#39;a str {\n            self.x\n        }\n    }\n\n\nstruct Struct&lt;&#39;a&gt; {\n    x: &amp;&#39;a str,\n    y: &amp;&#39;a str\n}\n    impl&lt;&#39;a&gt; Struct&lt;&#39;a&gt; {\n        fn new(x: &amp;&#39;a str, y: &amp;&#39;a str) -&gt; Struct&lt;&#39;a&gt; { // No need to specify &lt;&#39;a&gt; after new; impl already has it\n          Struct {\n              x : x,\n              y : y\n          }\n        }\n    }\n\n\n// üîé\nimpl&lt;&#39;a&gt; Trait&lt;&#39;a&gt; for Type\nimpl&lt;&#39;a&gt; Trait for Type&lt;&#39;a&gt;\n</code></pre>\n<h3 id=\"04-With-Generic-Types\"><a href=\"#04-With-Generic-Types\" class=\"headerlink\" title=\"04. With Generic Types\"></a>04. With Generic Types</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// üîé\nfn function&lt;F&gt;(f: F) where for&lt;&#39;a&gt; F: FnOnce(&amp;&#39;a Type)\nstruct Struct&lt;F&gt; where for&lt;&#39;a&gt; F: FnOnce(&amp;&#39;a Type) { x: F }\nenum Enum&lt;F&gt; where for&lt;&#39;a&gt; F: FnOnce(&amp;&#39;a Type) { Variant(F) }\nimpl&lt;F&gt; Struct&lt;F&gt; where for&lt;&#39;a&gt; F: FnOnce(&amp;&#39;a Type) { fn x(&amp;self) -&gt; &amp;F { &amp;self.x } }\n</code></pre>\n<h2 id=\"Lifetime-Elision\"><a href=\"#Lifetime-Elision\" class=\"headerlink\" title=\"Lifetime Elision\"></a>Lifetime Elision</h2><p>As I mentioned earlier, in order to make <strong>common patterns</strong> more ergonomic, Rust allows lifetimes to be <strong>elided/omitted</strong>. This process is called <strong>Lifetime Elision</strong>.</p>\n<p>üí° For the moment Rust supports Lifetime Elisions only on <code>fn</code> definitions. But in the future, it will support for <code>impl</code> headers as well.</p>\n<p>Lifetime annotations of <code>fn</code> definitions can be elided<br>if its <strong>parameter list</strong> has either,</p>\n<ul>\n<li><strong>only one input parameter passes by reference</strong>.</li>\n<li>a parameter with <strong>either</strong> <code>&amp;self</code> <strong>or</strong> <strong>&amp;mut self</strong> reference.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn triple(x: &amp;u64) -&gt; u64 { // Only one input parameter passes by reference\n    x * 3\n}\n\n\nfn filter(x: u8, y: &amp;str) -&gt; &amp;str { // Only one input parameter passes by reference\n    if x &gt; 5 { y } else { &quot;invalid inputs&quot; }\n}\n\n\nstruct Player&lt;&#39;a&gt; {\n    id: u8,\n    name: &amp;&#39;a str\n}\n    impl&lt;&#39;a&gt; Player&lt;&#39;a&gt; { // So far Lifetime Elisions are allowed only on fn definitions. But in the future, they might support on impl headers as well.\n        fn new(id: u8, name: &amp;str) -&gt; Player { // Only one input parameter passes by reference\n            Player {\n                id : id,\n                name : name\n            }\n        }\n\n        fn heading_text(&amp;self) -&gt; String { // An fn definition with &amp;self (or &amp;mut self) reference\n            format!(&quot;{}: {}&quot;, self.id, self.name)\n        }\n    }\n\nfn main() {\n    let player1 = Player::new(1, &quot;Serena Williams&quot;);\n    let player1_heading_text = player1.heading_text()\n    println!(&quot;{}&quot;, player1_heading_text);\n}\n</code></pre>\n<blockquote>\n<p>üí° In the Lifetime Elision process of fn definitions,</p>\n<ul>\n<li>Each parameter passes by reference is got a distinct lifetime annotation.<br>  ex. <code>..(x: &amp;str, y: &amp;str)</code> ‚Üí <code>..&lt;&#39;a, &#39;b&gt;(x: &amp;&#39;a str, y: &amp;&#39;b str)</code></li>\n<li>If the parameter list has only one parameter passes by reference, that lifetime is assigned to all elided lifetimes in the return values of that function.<br>  ex. <code>..(x: i32, y: &amp;str) -&gt; &amp;str</code> ‚Üí <code>..&lt;&#39;a&gt;(x: i32, y: &amp;&#39;a str) -&gt; &amp;&#39;a str</code></li>\n<li>Even it has multiple parameters pass by reference, if one of them has &amp;self or &amp;mut self, the lifetime of self is assigned to all elided output lifetimes.<br>  ex. <code>impl Impl{ fn function(&amp;self, x: &amp;str) -&gt; &amp;str {} }</code> ‚Üí<br>  <code>impl&lt;&#39;a&gt; Impl&lt;&#39;a&gt;{ fn function(&amp;&#39;a self, x: &amp;&#39;b str) -&gt; &amp;&#39;a str {} }</code></li>\n<li>For all other cases, we have to write lifetime annotations manually.</li>\n</ul>\n</blockquote>\n<h2 id=\"39-static-Annotations\"><a href=\"#39-static-Annotations\" class=\"headerlink\" title=\"&#39;static Annotations\"></a><code>&#39;static</code> Annotations</h2><p><code>&#39;static</code> lifetime annotation is a <strong>reserved</strong> lifetime annotation. These <strong>references are valid for the entire program</strong>. They are saved in the data segment of the binary and the data referred to will never go out of scope.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">static N: i32 = 5; // A constant with &#39;static lifetime\n\nlet a = &quot;Hello, world.&quot;; // a: &amp;&#39;static str\n\n\nfn index() -&gt; &amp;&#39;static str { // No need to mention &lt;&#39;static&gt; ; fn index Ã∂&lt;Ã∂&#39;Ã∂sÃ∂tÃ∂aÃ∂tÃ∂iÃ∂cÃ∂&gt;Ã∂ \n    &quot;Hello, world!&quot;\n}\n</code></pre>\n<h2 id=\"Few-more-examples-about-the-usage-of-Rust-lifetimes\"><a href=\"#Few-more-examples-about-the-usage-of-Rust-lifetimes\" class=\"headerlink\" title=\"Few more examples about the usage of Rust lifetimes.\"></a>Few more examples about the usage of Rust lifetimes.</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn greeting&lt;&#39;a&gt;() -&gt; &amp;&#39;a str {\n  &quot;Hi!&quot;\n}\n\n\nfn fullname&lt;&#39;a&gt;(fname: &amp;&#39;a str, lname: &amp;&#39;a str) -&gt; String {\n  format!(&quot;{} {}&quot;, fname, lname)\n}\n\n\nstruct Person&lt;&#39;a&gt; {\n    fname: &amp;&#39;a str,\n    lname: &amp;&#39;a str\n}\n  impl&lt;&#39;a&gt; Person&lt;&#39;a&gt; {\n      fn new(fname: &amp;&#39;a str, lname: &amp;&#39;a str) -&gt; Person&lt;&#39;a&gt; { // No need to specify &lt;&#39;a&gt; after new; impl already has it\n          Person {\n              fname : fname,\n              lname : lname\n          }\n      }\n\n      fn fullname(&amp;self) -&gt; String {\n          format!(&quot;{} {}&quot;, self.fname , self.lname)\n      }\n  }\n\nfn main() {\n    let player = Person::new(&quot;Serena&quot;, &quot;Williams&quot;);\n    let player_fullname = player.fullname();\n\n    println!(&quot;Player: {}&quot;, player_fullname);\n}\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<p>When we are dealing with references, we have to make sure that the referencing data stay alive until we stop using the references.</p>\n<p>Think,</p>\n<ul>\n<li>We have a <strong>variable binding</strong>, <code>a</code>.</li>\n<li>We are <strong>referencing</strong> the value of <code>a</code>, <strong>from another variable binding</strong> <code>x</code>.<br>We have to make sure that <strong><code>a</code> lives until we stop using <code>x</code></strong>.</li>\n</ul>\n<blockquote>\n<p>üîé <strong>Memory management</strong> is a form of resource management applied to computer memory. Up until the mid-1990s, the majority of programming languages used <strong>Manual Memory Management</strong> which <strong>requires the programmer to give manual instructions</strong> to identify and deallocate unused objects/ garbage. Around 1959 John McCarthy invented <strong>Garbage collection</strong>(GC), a form of <strong>Automatic Memory Management</strong>(AMM). It determines what memory is no longer used and frees it automatically instead of relying on the programmer. However <strong>Objective-C and Swift</strong> provide similar functionality through <strong>Automatic Reference Counting</strong>(ARC).</p>\n</blockquote>\n<h2 id=\"What-is-Lifetime\"><a href=\"#What-is-Lifetime\" class=\"headerlink\" title=\"What is Lifetime?\"></a>What is Lifetime?</h2><p>In Rust,</p>\n<ul>\n<li>A resource can only have <strong>one owner</strong> at a time. When it goes <strong>out of the scope</strong>, Rust removes it from the Memory.</li>\n<li>When we want to reuse the same resource, we are <strong>referencing</strong> it/ <strong>borrowing</strong> its content.</li>\n<li>When dealing with <strong>references</strong>, we have to specify <strong>lifetime annotations</strong> to provide instructions for the <strong>compiler</strong> to set <strong>how long</strong> those referenced resources <strong>should be alive</strong>.</li>\n<li>‚≠ê But because of lifetime annotations make the <strong>code more verbose</strong>, in order to make <strong>common patterns</strong> more ergonomic, Rust allows lifetimes to be <strong>elided/omitted</strong> in <code>fn</code> definitions. In this case, the compiler assigns lifetime annotations <strong>implicitly</strong>.</li>\n</ul>\n<p>Lifetime annotations are <strong>checked at compile-time</strong>. Compiler checks when a data is used for the first and the last times. According to that, Rust manages memory in <strong>run time</strong>. This is the major reason for <strong>slower compilation times</strong> in Rust.</p>\n<blockquote>\n<ul>\n<li>Unlike C and C++, <strong>usually</strong>, Rust doesn‚Äôt explicitly drop values at all.</li>\n<li>Unlike GC, Rust doesn‚Äôt place deallocation calls where the data is no longer referenced.</li>\n<li>Rust places deallocation calls where the data is about to go out of the scope and then enforces that no references to that resource exist after that point.</li>\n</ul>\n</blockquote>\n<h2 id=\"Usage\"><a href=\"#Usage\" class=\"headerlink\" title=\"Usage\"></a>Usage</h2><p>Lifetimes are denoted with an apostrophe. By convention, a lowercase letter is used for naming. Usually <strong>starts with</strong> <code>&#39;a</code> and <strong>follows alphabetic order</strong> when we need to add <strong>multiple lifetime</strong> annotations.</p>\n<p>When using references,</p>\n<h3 id=\"01-On-Function-Declaration\"><a href=\"#01-On-Function-Declaration\" class=\"headerlink\" title=\"01. On Function Declaration\"></a>01. On Function Declaration</h3><ul>\n<li><p>Input and output parameters with references should attach lifetimes after the <code>&amp;</code> sign.<br>ex. <code>..(x: &amp;&#39;a str)</code> , <code>..(x: &amp;&#39;a mut str)</code></p>\n</li>\n<li><p>After the function name, we should mention that the given lifetimes are generic types.<br>ex. <code>fn foo&lt;&#39;a&gt;(..)</code> , <code>fn foo&lt;&#39;a, &#39;b&gt;(..)</code></p>\n</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// No inputs, return a reference\nfn function&lt;&#39;a&gt;() -&gt; &amp;&#39;a str {}\n\n// Single input\nfn function&lt;&#39;a&gt;(x: &amp;&#39;a str) {}\n\n// Single input and output, both have the same lifetime\n// The output should live at least as long as input exists\nfn function&lt;&#39;a&gt;(x: &amp;&#39;a str) -&gt; &amp;&#39;a str {}\n\n// Multiple inputs, only one input and the output share same lifetime\n// The output should live at least as long as y exists\nfn function&lt;&#39;a&gt;(x: i32, y: &amp;&#39;a str) -&gt; &amp;&#39;a str {}\n\n// Multiple inputs, both inputs and the output share same lifetime\n// The output should live at least as long as x and y exist\nfn function&lt;&#39;a&gt;(x: &amp;&#39;a str, y: &amp;&#39;a str) -&gt; &amp;&#39;a str {}\n\n// Multiple inputs, inputs can have different lifetimes üîé\n// The output should live at least as long as x exists\nfn function&lt;&#39;a, &#39;b&gt;(x: &amp;&#39;a str, y: &amp;&#39;b str) -&gt; &amp;&#39;a str {}\n</code></pre>\n<h3 id=\"02-On-Struct-or-Enum-Declaration\"><a href=\"#02-On-Struct-or-Enum-Declaration\" class=\"headerlink\" title=\"02. On Struct or Enum Declaration\"></a>02. On Struct or Enum Declaration</h3><ul>\n<li>Elements with references should attach lifetimes after the <code>&amp;</code> sign.</li>\n<li>After the name of the struct or enum, we should mention that the given lifetimes are generic types.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Single element\n// Data of x should live at least as long as Struct exists\nstruct Struct&lt;&#39;a&gt; {\n    x: &amp;&#39;a str\n}\n\n// Multiple elements\n// Data of x and y should live at least as long as Struct exists\nstruct Struct&lt;&#39;a&gt; {\n    x: &amp;&#39;a str,\n    y: &amp;&#39;a str\n}\n\n\n// Variant with a single element\n// Data of the variant should live at least as long as Enum exists\nenum Enum&lt;&#39;a&gt; {\n    Variant(&amp;&#39;a Type)\n}\n</code></pre>\n<h3 id=\"03-With-Impls-and-Traits\"><a href=\"#03-With-Impls-and-Traits\" class=\"headerlink\" title=\"03. With Impls and Traits\"></a>03. With Impls and Traits</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Struct&lt;&#39;a&gt; {\n    x: &amp;&#39;a str\n}\n    impl&lt;&#39;a&gt; Struct&lt;&#39;a&gt; {\n        fn function&lt;&#39;a&gt;(&amp;self) -&gt; &amp;&#39;a str {\n            self.x\n        }\n    }\n\n\nstruct Struct&lt;&#39;a&gt; {\n    x: &amp;&#39;a str,\n    y: &amp;&#39;a str\n}\n    impl&lt;&#39;a&gt; Struct&lt;&#39;a&gt; {\n        fn new(x: &amp;&#39;a str, y: &amp;&#39;a str) -&gt; Struct&lt;&#39;a&gt; { // No need to specify &lt;&#39;a&gt; after new; impl already has it\n          Struct {\n              x : x,\n              y : y\n          }\n        }\n    }\n\n\n// üîé\nimpl&lt;&#39;a&gt; Trait&lt;&#39;a&gt; for Type\nimpl&lt;&#39;a&gt; Trait for Type&lt;&#39;a&gt;\n</code></pre>\n<h3 id=\"04-With-Generic-Types\"><a href=\"#04-With-Generic-Types\" class=\"headerlink\" title=\"04. With Generic Types\"></a>04. With Generic Types</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// üîé\nfn function&lt;F&gt;(f: F) where for&lt;&#39;a&gt; F: FnOnce(&amp;&#39;a Type)\nstruct Struct&lt;F&gt; where for&lt;&#39;a&gt; F: FnOnce(&amp;&#39;a Type) { x: F }\nenum Enum&lt;F&gt; where for&lt;&#39;a&gt; F: FnOnce(&amp;&#39;a Type) { Variant(F) }\nimpl&lt;F&gt; Struct&lt;F&gt; where for&lt;&#39;a&gt; F: FnOnce(&amp;&#39;a Type) { fn x(&amp;self) -&gt; &amp;F { &amp;self.x } }\n</code></pre>\n<h2 id=\"Lifetime-Elision\"><a href=\"#Lifetime-Elision\" class=\"headerlink\" title=\"Lifetime Elision\"></a>Lifetime Elision</h2><p>As I mentioned earlier, in order to make <strong>common patterns</strong> more ergonomic, Rust allows lifetimes to be <strong>elided/omitted</strong>. This process is called <strong>Lifetime Elision</strong>.</p>\n<p>üí° For the moment Rust supports Lifetime Elisions only on <code>fn</code> definitions. But in the future, it will support for <code>impl</code> headers as well.</p>\n<p>Lifetime annotations of <code>fn</code> definitions can be elided<br>if its <strong>parameter list</strong> has either,</p>\n<ul>\n<li><strong>only one input parameter passes by reference</strong>.</li>\n<li>a parameter with <strong>either</strong> <code>&amp;self</code> <strong>or</strong> <strong>&amp;mut self</strong> reference.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn triple(x: &amp;u64) -&gt; u64 { // Only one input parameter passes by reference\n    x * 3\n}\n\n\nfn filter(x: u8, y: &amp;str) -&gt; &amp;str { // Only one input parameter passes by reference\n    if x &gt; 5 { y } else { &quot;invalid inputs&quot; }\n}\n\n\nstruct Player&lt;&#39;a&gt; {\n    id: u8,\n    name: &amp;&#39;a str\n}\n    impl&lt;&#39;a&gt; Player&lt;&#39;a&gt; { // So far Lifetime Elisions are allowed only on fn definitions. But in the future, they might support on impl headers as well.\n        fn new(id: u8, name: &amp;str) -&gt; Player { // Only one input parameter passes by reference\n            Player {\n                id : id,\n                name : name\n            }\n        }\n\n        fn heading_text(&amp;self) -&gt; String { // An fn definition with &amp;self (or &amp;mut self) reference\n            format!(&quot;{}: {}&quot;, self.id, self.name)\n        }\n    }\n\nfn main() {\n    let player1 = Player::new(1, &quot;Serena Williams&quot;);\n    let player1_heading_text = player1.heading_text()\n    println!(&quot;{}&quot;, player1_heading_text);\n}\n</code></pre>\n<blockquote>\n<p>üí° In the Lifetime Elision process of fn definitions,</p>\n<ul>\n<li>Each parameter passes by reference is got a distinct lifetime annotation.<br>  ex. <code>..(x: &amp;str, y: &amp;str)</code> ‚Üí <code>..&lt;&#39;a, &#39;b&gt;(x: &amp;&#39;a str, y: &amp;&#39;b str)</code></li>\n<li>If the parameter list has only one parameter passes by reference, that lifetime is assigned to all elided lifetimes in the return values of that function.<br>  ex. <code>..(x: i32, y: &amp;str) -&gt; &amp;str</code> ‚Üí <code>..&lt;&#39;a&gt;(x: i32, y: &amp;&#39;a str) -&gt; &amp;&#39;a str</code></li>\n<li>Even it has multiple parameters pass by reference, if one of them has &amp;self or &amp;mut self, the lifetime of self is assigned to all elided output lifetimes.<br>  ex. <code>impl Impl{ fn function(&amp;self, x: &amp;str) -&gt; &amp;str {} }</code> ‚Üí<br>  <code>impl&lt;&#39;a&gt; Impl&lt;&#39;a&gt;{ fn function(&amp;&#39;a self, x: &amp;&#39;b str) -&gt; &amp;&#39;a str {} }</code></li>\n<li>For all other cases, we have to write lifetime annotations manually.</li>\n</ul>\n</blockquote>\n<h2 id=\"39-static-Annotations\"><a href=\"#39-static-Annotations\" class=\"headerlink\" title=\"&#39;static Annotations\"></a><code>&#39;static</code> Annotations</h2><p><code>&#39;static</code> lifetime annotation is a <strong>reserved</strong> lifetime annotation. These <strong>references are valid for the entire program</strong>. They are saved in the data segment of the binary and the data referred to will never go out of scope.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">static N: i32 = 5; // A constant with &#39;static lifetime\n\nlet a = &quot;Hello, world.&quot;; // a: &amp;&#39;static str\n\n\nfn index() -&gt; &amp;&#39;static str { // No need to mention &lt;&#39;static&gt; ; fn index Ã∂&lt;Ã∂&#39;Ã∂sÃ∂tÃ∂aÃ∂tÃ∂iÃ∂cÃ∂&gt;Ã∂ \n    &quot;Hello, world!&quot;\n}\n</code></pre>\n<h2 id=\"Few-more-examples-about-the-usage-of-Rust-lifetimes\"><a href=\"#Few-more-examples-about-the-usage-of-Rust-lifetimes\" class=\"headerlink\" title=\"Few more examples about the usage of Rust lifetimes.\"></a>Few more examples about the usage of Rust lifetimes.</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn greeting&lt;&#39;a&gt;() -&gt; &amp;&#39;a str {\n  &quot;Hi!&quot;\n}\n\n\nfn fullname&lt;&#39;a&gt;(fname: &amp;&#39;a str, lname: &amp;&#39;a str) -&gt; String {\n  format!(&quot;{} {}&quot;, fname, lname)\n}\n\n\nstruct Person&lt;&#39;a&gt; {\n    fname: &amp;&#39;a str,\n    lname: &amp;&#39;a str\n}\n  impl&lt;&#39;a&gt; Person&lt;&#39;a&gt; {\n      fn new(fname: &amp;&#39;a str, lname: &amp;&#39;a str) -&gt; Person&lt;&#39;a&gt; { // No need to specify &lt;&#39;a&gt; after new; impl already has it\n          Person {\n              fname : fname,\n              lname : lname\n          }\n      }\n\n      fn fullname(&amp;self) -&gt; String {\n          format!(&quot;{} {}&quot;, self.fname , self.lname)\n      }\n  }\n\nfn main() {\n    let player = Person::new(&quot;Serena&quot;, &quot;Williams&quot;);\n    let player_fullname = player.fullname();\n\n    println!(&quot;Player: {}&quot;, player_fullname);\n}\n</code></pre>\n"},{"title":"Crates","_content":"\nüí≠ Crates are a bit similar to the packages in some other languages. Crates compile individually. If the crate has child file modules, those files will get merged with the crate file and compile as a single unit.\n\nüí≠ A crate can produce an executable/ a binary or a library. `src/main.rs` is the crate root/ entry point for a binary crate and `src/lib.rs` is the entry point for a library crate.\n\n## 01. lib.rs on executable crate\n\nüí° When writing binary crates, we can move the main functionalities to `src/lib.rs` and use it as a library from `src/main.rs`. This pattern is quite common on executable crates.\n\n```rust\n// # Think we run,\ncargo new greetings\ntouch greetings/src/lib.rs\n\n// # It generates,\ngreetings\n ‚îú‚îÄ‚îÄ Cargo.toml\n ‚îî‚îÄ‚îÄ src\n    ‚îú‚îÄ‚îÄ lib.rs\n    ‚îî‚îÄ‚îÄ main.rs\n\n// # Think we modify following files,\n\n// 01. greetings/src/lib.rs\npub fn hello() {\n    println!(\"Hello, world!\");\n}\n\n// 02. greetings/src/main.rs\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n```\n\n> üíØ As I mentioned earlier, in here we use simplest examples to reduce the complexity of learning materials. But this is how we need to write `greetings/src/lib.rs` to make the code more testable.\n\n```rust\n// greetings/src/lib.rs\npub fn hello() -> String {\n  //! This returns `Hello, world!` String\n  (\"Hello, world!\").to_string()\n}\n\n// 01. Tests for `hello()`\n#[test] // Indicates that this is a test function\nfn test_hello() {\n  assert_eq!(hello(), \"Hello, world!\");\n}\n\n// 02. Tests for `hello()`, Idiomatic way\n#[cfg(test)] // Only compiles when running tests\nmod tests { // Separates tests from code\n  use super::hello; // Import root `hello()` function\n  \n    #[test]\n    fn test_hello() {\n        assert_eq!(hello(), \"Hello, world!\");\n    }\n}\n```\n\n> [üìñ](https://doc.rust-lang.org/book/first-edition/crates-and-modules.html) When importing a crate that has dashes in its name ‚Äúlike-this‚Äù, which is not a valid Rust identifier, it will be converted by changing the dashes to underscores, so you would write `extern crate like_this;`\n\n`lib.rs` can link with multiple files.\n\n```rust\n// # Think we run,\ncargo new phrases\ntouch phrases/src/lib.rs\ntouch phrases/src/greetings.rs\n\n// # It generates,\nphrases\n ‚îú‚îÄ‚îÄ Cargo.toml\n ‚îî‚îÄ‚îÄ src\n    ‚îú‚îÄ‚îÄ greetings.rs\n    ‚îú‚îÄ‚îÄ lib.rs\n    ‚îî‚îÄ‚îÄ main.rs\n   \n// # Think we modify following files,\n\n// 01. phrases/src/greetings.rs\npub fn hello() {\n    println!(\"Hello, world!\");\n}\n\n// 02. phrases/src/main.rs\nextern crate phrases;\n\nfn main() {\n    phrases::greetings::hello();\n}\n\n// 03. phrases/src/lib.rs\npub mod greetings; // ‚≠êÔ∏è Import `greetings` module as a public module\n```\n\n\n## 02. Dependency crate on Cargo.toml\n\nWhen the code in the `lib.rs` file is getting larger, we can move those into a separate library crate and use it as a dependency of the main crate. As we mentioned earlier, a dependency can be specified from a folder path, git repository or by crates.io.\n\n### a. Using folder path\n\nLet‚Äôs see how to create a nested crate and use it as a dependency using folder path,\n\n```rust\n// # Think we run,\ncargo new phrases\ncargo new phrases/greetings --lib\n\n// # It generates,\nphrases\n ‚îú‚îÄ‚îÄ Cargo.toml\n ‚îú‚îÄ‚îÄ greetings\n ‚îÇ  ‚îú‚îÄ‚îÄ Cargo.toml\n ‚îÇ  ‚îî‚îÄ‚îÄ src\n ‚îÇ     ‚îî‚îÄ‚îÄ lib.rs\n ‚îî‚îÄ‚îÄ src\n    ‚îî‚îÄ‚îÄ main.rs\n\n// # Think we modify following files,\n\n// 01. phrases/Cargo.toml\n[package]\nname = \"phrases\"\nversion = \"0.1.0\"\nauthors = [\"Dumindu Madunuwan\"]\n\n[dependencies]\ngreetings = { path = \"greetings\" }\n\n// 02. phrases/greetings/src/lib.rs\npub fn hello() {\n    println!(\"Hello, world!\");\n}\n\n// 03. phrases/src/main.rs\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n```\n\n\n### b. Using git repository\n\nIf you want to use a library crate on multiple projects, one way is moving crate code to a git repository and use it as a dependency when needed.\n\n```rust\n// -- Cargo.toml --\n[dependencies]\n\n// 01. Get the latest commit on the master branch\nrocket = { git = \"https://github.com/SergioBenitez/Rocket\" }\n\n// 02. Get the latest commit of a specific branch\nrocket = { git = \"https://github.com/SergioBenitez/Rocket\", branch = \"v0.3\" }\n\n// 03. Get a specific tag\nrocket = { git = \"https://github.com/SergioBenitez/Rocket\", tag = \"v0.3.2\" }\n\n// 04. Get a specific revision (on master or any branch, according to rev)\nrocket = { git = \"https://github.com/SergioBenitez/Rocket\", rev = \"8183f636305cef4adaa9525506c33cbea72d1745\" }\n```\n\n\n### c. Using crates.io\n\nThe other way is uploading it to [crates.io](http://crates.io/) and use it as a dependency when needed.\n\nüöß First, let‚Äôs `create` a simple ‚ÄúHello world‚Äù crate `and upload` it to [crates.io](http://crates.io/).\n\n```rust\n// # Think we run,\ncargo new test_crate_hello_world --lib\n\n// # It generates,\ntest_crate_hello_world\n ‚îú‚îÄ‚îÄ Cargo.toml\n ‚îî‚îÄ‚îÄ src\n    ‚îî‚îÄ‚îÄ lib.rs\n   \n// # Think we modify following files,\n\n// 01. test_crate_hello_world/Cargo.toml\n[package]\nname = \"test_crate_hello_world\"\nversion = \"0.1.0\"\nauthors = [\"Dumindu Madunuwan\"]\n\ndescription = \"A Simple Hello World Crate\"\nrepository = \"https://github.com/dumindu/test_crate_hello_world\"\nkeywords = [\"hello\", \"world\"]\nlicense = \"Apache-2.0\"\n\n[dependencies]\n\n// 02. test_crate_hello_world/src/lib.rs\n//! A Simple Hello World Crate\n\n/// This function returns the greeting; `Hello, world!`\npub fn hello() -> String {\n    (\"Hello, world!\").to_string()\n}\n\n#[cfg(test)]\nmod tests {\n\n    use super::hello;\n    \n    #[test]\n    fn test_hello() {\n        assert_eq!(hello(), \"Hello, world!\");\n    }\n}\n```\n\n> üí≠ **//! doc comments** are used to write crate and module-level documentation. On other places, we have to use /// outside of the block. And when uploading a crate to [crates.io](http://crates.io/), cargo generates the documentation from these doc comments and host it on [docs.rs](https://docs.rs/).\n\nüí° We have to add the **description** and **license** fields to `Cargo.toml`. Otherwise, we will get `error: api errors: missing or empty metadata fields: description, license. Please see http://doc.crates.io/manifest.html`\n\nTo upload this to crates.io,\n1. We have to create an account on crates.io to acquire an API token\n2. Then run `cargo login <token>` with that API token and cargo publish\n\n[üìñ](http://doc.crates.io/crates-io.html) This is [how it describes on Cargo Docs](http://doc.crates.io/crates-io.html) with more details.\n\n> - You‚Äôll need an account on crates.io to acquire an API token. To do so, [visit the home page](https://crates.io/) and log in via a GitHub account (required for now). After this, visit your [Account Settings](https://crates.io/me) page and run the `cargo login` command specified. \n  Ex. `cargo login abcdefghijklmnopqrstuvwxyz012345`\n- The next step is to package up your crate into a format that can be uploaded to crates.io. For this we‚Äôll use the `cargo package` sub-command.\n- Now, it can be uploaded to crates.io with the `cargo publish` command.\n- If you‚Äôd like to skip the `cargo package` step, the `cargo publish` sub-command will automatically package up the local crate if a copy isn‚Äôt found already.\n\nThe name of our crate is `test_crate_hello_world`. So it can be found on,\nüì¶ [https://**crates.io/crates**/test_crate_hello_world](https://crates.io/crates/test_crate_hello_world)\nüìë [https://**docs.rs**/test_crate_hello_world](https://docs.rs/test_crate_hello_world)\n\n> üíØ crates.io supports readme files as well. To enable it, we have to add the readme field to Cargo.toml. Ex: `readme=\"README.md\"`\n\nüèóÔ∏è Okay then, Let‚Äôs see how we can **use this from another crate**.\n\n```rust\n// # Think we run,\ncargo new greetings\n\n// # It generates,\ngreetings\n ‚îú‚îÄ‚îÄ Cargo.toml\n ‚îî‚îÄ‚îÄ src\n    ‚îî‚îÄ‚îÄ main.rs\n\n// # Think we modify following files,\n\n// 01. greetings/Cargo.toml\n[package]\nname = \"greetings\"\nversion = \"0.1.0\"\nauthors = [\"Dumindu Madunuwan\"]\n\n[dependencies]\ntest_crate_hello_world = \"0.1.0\"\n\n// 02. greetings/src/main.rs\nextern crate test_crate_hello_world;\n\nfn main() {\n    println!(\"{}\", test_crate_hello_world::hello());\n}\n```\n\nBy default, Cargo looks dependencies on [crates.io](https://crates.io/). So we have to add only the crate name and a version string to **`Cargo.toml`** and then run `cargo build` to fetch the dependencies and compile them.","source":"docs/d4.crates.md","raw":"title: Crates\n---\n\nüí≠ Crates are a bit similar to the packages in some other languages. Crates compile individually. If the crate has child file modules, those files will get merged with the crate file and compile as a single unit.\n\nüí≠ A crate can produce an executable/ a binary or a library. `src/main.rs` is the crate root/ entry point for a binary crate and `src/lib.rs` is the entry point for a library crate.\n\n## 01. lib.rs on executable crate\n\nüí° When writing binary crates, we can move the main functionalities to `src/lib.rs` and use it as a library from `src/main.rs`. This pattern is quite common on executable crates.\n\n```rust\n// # Think we run,\ncargo new greetings\ntouch greetings/src/lib.rs\n\n// # It generates,\ngreetings\n ‚îú‚îÄ‚îÄ Cargo.toml\n ‚îî‚îÄ‚îÄ src\n    ‚îú‚îÄ‚îÄ lib.rs\n    ‚îî‚îÄ‚îÄ main.rs\n\n// # Think we modify following files,\n\n// 01. greetings/src/lib.rs\npub fn hello() {\n    println!(\"Hello, world!\");\n}\n\n// 02. greetings/src/main.rs\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n```\n\n> üíØ As I mentioned earlier, in here we use simplest examples to reduce the complexity of learning materials. But this is how we need to write `greetings/src/lib.rs` to make the code more testable.\n\n```rust\n// greetings/src/lib.rs\npub fn hello() -> String {\n  //! This returns `Hello, world!` String\n  (\"Hello, world!\").to_string()\n}\n\n// 01. Tests for `hello()`\n#[test] // Indicates that this is a test function\nfn test_hello() {\n  assert_eq!(hello(), \"Hello, world!\");\n}\n\n// 02. Tests for `hello()`, Idiomatic way\n#[cfg(test)] // Only compiles when running tests\nmod tests { // Separates tests from code\n  use super::hello; // Import root `hello()` function\n  \n    #[test]\n    fn test_hello() {\n        assert_eq!(hello(), \"Hello, world!\");\n    }\n}\n```\n\n> [üìñ](https://doc.rust-lang.org/book/first-edition/crates-and-modules.html) When importing a crate that has dashes in its name ‚Äúlike-this‚Äù, which is not a valid Rust identifier, it will be converted by changing the dashes to underscores, so you would write `extern crate like_this;`\n\n`lib.rs` can link with multiple files.\n\n```rust\n// # Think we run,\ncargo new phrases\ntouch phrases/src/lib.rs\ntouch phrases/src/greetings.rs\n\n// # It generates,\nphrases\n ‚îú‚îÄ‚îÄ Cargo.toml\n ‚îî‚îÄ‚îÄ src\n    ‚îú‚îÄ‚îÄ greetings.rs\n    ‚îú‚îÄ‚îÄ lib.rs\n    ‚îî‚îÄ‚îÄ main.rs\n   \n// # Think we modify following files,\n\n// 01. phrases/src/greetings.rs\npub fn hello() {\n    println!(\"Hello, world!\");\n}\n\n// 02. phrases/src/main.rs\nextern crate phrases;\n\nfn main() {\n    phrases::greetings::hello();\n}\n\n// 03. phrases/src/lib.rs\npub mod greetings; // ‚≠êÔ∏è Import `greetings` module as a public module\n```\n\n\n## 02. Dependency crate on Cargo.toml\n\nWhen the code in the `lib.rs` file is getting larger, we can move those into a separate library crate and use it as a dependency of the main crate. As we mentioned earlier, a dependency can be specified from a folder path, git repository or by crates.io.\n\n### a. Using folder path\n\nLet‚Äôs see how to create a nested crate and use it as a dependency using folder path,\n\n```rust\n// # Think we run,\ncargo new phrases\ncargo new phrases/greetings --lib\n\n// # It generates,\nphrases\n ‚îú‚îÄ‚îÄ Cargo.toml\n ‚îú‚îÄ‚îÄ greetings\n ‚îÇ  ‚îú‚îÄ‚îÄ Cargo.toml\n ‚îÇ  ‚îî‚îÄ‚îÄ src\n ‚îÇ     ‚îî‚îÄ‚îÄ lib.rs\n ‚îî‚îÄ‚îÄ src\n    ‚îî‚îÄ‚îÄ main.rs\n\n// # Think we modify following files,\n\n// 01. phrases/Cargo.toml\n[package]\nname = \"phrases\"\nversion = \"0.1.0\"\nauthors = [\"Dumindu Madunuwan\"]\n\n[dependencies]\ngreetings = { path = \"greetings\" }\n\n// 02. phrases/greetings/src/lib.rs\npub fn hello() {\n    println!(\"Hello, world!\");\n}\n\n// 03. phrases/src/main.rs\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n```\n\n\n### b. Using git repository\n\nIf you want to use a library crate on multiple projects, one way is moving crate code to a git repository and use it as a dependency when needed.\n\n```rust\n// -- Cargo.toml --\n[dependencies]\n\n// 01. Get the latest commit on the master branch\nrocket = { git = \"https://github.com/SergioBenitez/Rocket\" }\n\n// 02. Get the latest commit of a specific branch\nrocket = { git = \"https://github.com/SergioBenitez/Rocket\", branch = \"v0.3\" }\n\n// 03. Get a specific tag\nrocket = { git = \"https://github.com/SergioBenitez/Rocket\", tag = \"v0.3.2\" }\n\n// 04. Get a specific revision (on master or any branch, according to rev)\nrocket = { git = \"https://github.com/SergioBenitez/Rocket\", rev = \"8183f636305cef4adaa9525506c33cbea72d1745\" }\n```\n\n\n### c. Using crates.io\n\nThe other way is uploading it to [crates.io](http://crates.io/) and use it as a dependency when needed.\n\nüöß First, let‚Äôs `create` a simple ‚ÄúHello world‚Äù crate `and upload` it to [crates.io](http://crates.io/).\n\n```rust\n// # Think we run,\ncargo new test_crate_hello_world --lib\n\n// # It generates,\ntest_crate_hello_world\n ‚îú‚îÄ‚îÄ Cargo.toml\n ‚îî‚îÄ‚îÄ src\n    ‚îî‚îÄ‚îÄ lib.rs\n   \n// # Think we modify following files,\n\n// 01. test_crate_hello_world/Cargo.toml\n[package]\nname = \"test_crate_hello_world\"\nversion = \"0.1.0\"\nauthors = [\"Dumindu Madunuwan\"]\n\ndescription = \"A Simple Hello World Crate\"\nrepository = \"https://github.com/dumindu/test_crate_hello_world\"\nkeywords = [\"hello\", \"world\"]\nlicense = \"Apache-2.0\"\n\n[dependencies]\n\n// 02. test_crate_hello_world/src/lib.rs\n//! A Simple Hello World Crate\n\n/// This function returns the greeting; `Hello, world!`\npub fn hello() -> String {\n    (\"Hello, world!\").to_string()\n}\n\n#[cfg(test)]\nmod tests {\n\n    use super::hello;\n    \n    #[test]\n    fn test_hello() {\n        assert_eq!(hello(), \"Hello, world!\");\n    }\n}\n```\n\n> üí≠ **//! doc comments** are used to write crate and module-level documentation. On other places, we have to use /// outside of the block. And when uploading a crate to [crates.io](http://crates.io/), cargo generates the documentation from these doc comments and host it on [docs.rs](https://docs.rs/).\n\nüí° We have to add the **description** and **license** fields to `Cargo.toml`. Otherwise, we will get `error: api errors: missing or empty metadata fields: description, license. Please see http://doc.crates.io/manifest.html`\n\nTo upload this to crates.io,\n1. We have to create an account on crates.io to acquire an API token\n2. Then run `cargo login <token>` with that API token and cargo publish\n\n[üìñ](http://doc.crates.io/crates-io.html) This is [how it describes on Cargo Docs](http://doc.crates.io/crates-io.html) with more details.\n\n> - You‚Äôll need an account on crates.io to acquire an API token. To do so, [visit the home page](https://crates.io/) and log in via a GitHub account (required for now). After this, visit your [Account Settings](https://crates.io/me) page and run the `cargo login` command specified. \n  Ex. `cargo login abcdefghijklmnopqrstuvwxyz012345`\n- The next step is to package up your crate into a format that can be uploaded to crates.io. For this we‚Äôll use the `cargo package` sub-command.\n- Now, it can be uploaded to crates.io with the `cargo publish` command.\n- If you‚Äôd like to skip the `cargo package` step, the `cargo publish` sub-command will automatically package up the local crate if a copy isn‚Äôt found already.\n\nThe name of our crate is `test_crate_hello_world`. So it can be found on,\nüì¶ [https://**crates.io/crates**/test_crate_hello_world](https://crates.io/crates/test_crate_hello_world)\nüìë [https://**docs.rs**/test_crate_hello_world](https://docs.rs/test_crate_hello_world)\n\n> üíØ crates.io supports readme files as well. To enable it, we have to add the readme field to Cargo.toml. Ex: `readme=\"README.md\"`\n\nüèóÔ∏è Okay then, Let‚Äôs see how we can **use this from another crate**.\n\n```rust\n// # Think we run,\ncargo new greetings\n\n// # It generates,\ngreetings\n ‚îú‚îÄ‚îÄ Cargo.toml\n ‚îî‚îÄ‚îÄ src\n    ‚îî‚îÄ‚îÄ main.rs\n\n// # Think we modify following files,\n\n// 01. greetings/Cargo.toml\n[package]\nname = \"greetings\"\nversion = \"0.1.0\"\nauthors = [\"Dumindu Madunuwan\"]\n\n[dependencies]\ntest_crate_hello_world = \"0.1.0\"\n\n// 02. greetings/src/main.rs\nextern crate test_crate_hello_world;\n\nfn main() {\n    println!(\"{}\", test_crate_hello_world::hello());\n}\n```\n\nBy default, Cargo looks dependencies on [crates.io](https://crates.io/). So we have to add only the crate name and a version string to **`Cargo.toml`** and then run `cargo build` to fetch the dependencies and compile them.","date":"2019-03-19T14:50:39.956Z","updated":"2019-03-19T14:50:39.956Z","path":"docs/d4.crates.html","comments":1,"layout":"page","_id":"cjtfwbizz000udwgpeo7tcss8","content":"<p>üí≠ Crates are a bit similar to the packages in some other languages. Crates compile individually. If the crate has child file modules, those files will get merged with the crate file and compile as a single unit.</p>\n<p>üí≠ A crate can produce an executable/ a binary or a library. <code>src/main.rs</code> is the crate root/ entry point for a binary crate and <code>src/lib.rs</code> is the entry point for a library crate.</p>\n<h2 id=\"01-lib-rs-on-executable-crate\"><a href=\"#01-lib-rs-on-executable-crate\" class=\"headerlink\" title=\"01. lib.rs on executable crate\"></a>01. lib.rs on executable crate</h2><p>üí° When writing binary crates, we can move the main functionalities to <code>src/lib.rs</code> and use it as a library from <code>src/main.rs</code>. This pattern is quite common on executable crates.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// # Think we run,\ncargo new greetings\ntouch greetings/src/lib.rs\n\n// # It generates,\ngreetings\n ‚îú‚îÄ‚îÄ Cargo.toml\n ‚îî‚îÄ‚îÄ src\n    ‚îú‚îÄ‚îÄ lib.rs\n    ‚îî‚îÄ‚îÄ main.rs\n\n// # Think we modify following files,\n\n// 01. greetings/src/lib.rs\npub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n}\n\n// 02. greetings/src/main.rs\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n</code></pre>\n<blockquote>\n<p>üíØ As I mentioned earlier, in here we use simplest examples to reduce the complexity of learning materials. But this is how we need to write <code>greetings/src/lib.rs</code> to make the code more testable.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// greetings/src/lib.rs\npub fn hello() -&gt; String {\n  //! This returns `Hello, world!` String\n  (&quot;Hello, world!&quot;).to_string()\n}\n\n// 01. Tests for `hello()`\n#[test] // Indicates that this is a test function\nfn test_hello() {\n  assert_eq!(hello(), &quot;Hello, world!&quot;);\n}\n\n// 02. Tests for `hello()`, Idiomatic way\n#[cfg(test)] // Only compiles when running tests\nmod tests { // Separates tests from code\n  use super::hello; // Import root `hello()` function\n\n    #[test]\n    fn test_hello() {\n        assert_eq!(hello(), &quot;Hello, world!&quot;);\n    }\n}\n</code></pre>\n<blockquote>\n<p><a href=\"https://doc.rust-lang.org/book/first-edition/crates-and-modules.html\" target=\"_blank\" rel=\"noopener\">üìñ</a> When importing a crate that has dashes in its name ‚Äúlike-this‚Äù, which is not a valid Rust identifier, it will be converted by changing the dashes to underscores, so you would write <code>extern crate like_this;</code></p>\n</blockquote>\n<p><code>lib.rs</code> can link with multiple files.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// # Think we run,\ncargo new phrases\ntouch phrases/src/lib.rs\ntouch phrases/src/greetings.rs\n\n// # It generates,\nphrases\n ‚îú‚îÄ‚îÄ Cargo.toml\n ‚îî‚îÄ‚îÄ src\n    ‚îú‚îÄ‚îÄ greetings.rs\n    ‚îú‚îÄ‚îÄ lib.rs\n    ‚îî‚îÄ‚îÄ main.rs\n\n// # Think we modify following files,\n\n// 01. phrases/src/greetings.rs\npub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n}\n\n// 02. phrases/src/main.rs\nextern crate phrases;\n\nfn main() {\n    phrases::greetings::hello();\n}\n\n// 03. phrases/src/lib.rs\npub mod greetings; // ‚≠êÔ∏è Import `greetings` module as a public module\n</code></pre>\n<h2 id=\"02-Dependency-crate-on-Cargo-toml\"><a href=\"#02-Dependency-crate-on-Cargo-toml\" class=\"headerlink\" title=\"02. Dependency crate on Cargo.toml\"></a>02. Dependency crate on Cargo.toml</h2><p>When the code in the <code>lib.rs</code> file is getting larger, we can move those into a separate library crate and use it as a dependency of the main crate. As we mentioned earlier, a dependency can be specified from a folder path, git repository or by crates.io.</p>\n<h3 id=\"a-Using-folder-path\"><a href=\"#a-Using-folder-path\" class=\"headerlink\" title=\"a. Using folder path\"></a>a. Using folder path</h3><p>Let‚Äôs see how to create a nested crate and use it as a dependency using folder path,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// # Think we run,\ncargo new phrases\ncargo new phrases/greetings --lib\n\n// # It generates,\nphrases\n ‚îú‚îÄ‚îÄ Cargo.toml\n ‚îú‚îÄ‚îÄ greetings\n ‚îÇ  ‚îú‚îÄ‚îÄ Cargo.toml\n ‚îÇ  ‚îî‚îÄ‚îÄ src\n ‚îÇ     ‚îî‚îÄ‚îÄ lib.rs\n ‚îî‚îÄ‚îÄ src\n    ‚îî‚îÄ‚îÄ main.rs\n\n// # Think we modify following files,\n\n// 01. phrases/Cargo.toml\n[package]\nname = &quot;phrases&quot;\nversion = &quot;0.1.0&quot;\nauthors = [&quot;Dumindu Madunuwan&quot;]\n\n[dependencies]\ngreetings = { path = &quot;greetings&quot; }\n\n// 02. phrases/greetings/src/lib.rs\npub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n}\n\n// 03. phrases/src/main.rs\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n</code></pre>\n<h3 id=\"b-Using-git-repository\"><a href=\"#b-Using-git-repository\" class=\"headerlink\" title=\"b. Using git repository\"></a>b. Using git repository</h3><p>If you want to use a library crate on multiple projects, one way is moving crate code to a git repository and use it as a dependency when needed.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// -- Cargo.toml --\n[dependencies]\n\n// 01. Get the latest commit on the master branch\nrocket = { git = &quot;https://github.com/SergioBenitez/Rocket&quot; }\n\n// 02. Get the latest commit of a specific branch\nrocket = { git = &quot;https://github.com/SergioBenitez/Rocket&quot;, branch = &quot;v0.3&quot; }\n\n// 03. Get a specific tag\nrocket = { git = &quot;https://github.com/SergioBenitez/Rocket&quot;, tag = &quot;v0.3.2&quot; }\n\n// 04. Get a specific revision (on master or any branch, according to rev)\nrocket = { git = &quot;https://github.com/SergioBenitez/Rocket&quot;, rev = &quot;8183f636305cef4adaa9525506c33cbea72d1745&quot; }\n</code></pre>\n<h3 id=\"c-Using-crates-io\"><a href=\"#c-Using-crates-io\" class=\"headerlink\" title=\"c. Using crates.io\"></a>c. Using crates.io</h3><p>The other way is uploading it to <a href=\"http://crates.io/\" target=\"_blank\" rel=\"noopener\">crates.io</a> and use it as a dependency when needed.</p>\n<p>üöß First, let‚Äôs <code>create</code> a simple ‚ÄúHello world‚Äù crate <code>and upload</code> it to <a href=\"http://crates.io/\" target=\"_blank\" rel=\"noopener\">crates.io</a>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// # Think we run,\ncargo new test_crate_hello_world --lib\n\n// # It generates,\ntest_crate_hello_world\n ‚îú‚îÄ‚îÄ Cargo.toml\n ‚îî‚îÄ‚îÄ src\n    ‚îî‚îÄ‚îÄ lib.rs\n\n// # Think we modify following files,\n\n// 01. test_crate_hello_world/Cargo.toml\n[package]\nname = &quot;test_crate_hello_world&quot;\nversion = &quot;0.1.0&quot;\nauthors = [&quot;Dumindu Madunuwan&quot;]\n\ndescription = &quot;A Simple Hello World Crate&quot;\nrepository = &quot;https://github.com/dumindu/test_crate_hello_world&quot;\nkeywords = [&quot;hello&quot;, &quot;world&quot;]\nlicense = &quot;Apache-2.0&quot;\n\n[dependencies]\n\n// 02. test_crate_hello_world/src/lib.rs\n//! A Simple Hello World Crate\n\n/// This function returns the greeting; `Hello, world!`\npub fn hello() -&gt; String {\n    (&quot;Hello, world!&quot;).to_string()\n}\n\n#[cfg(test)]\nmod tests {\n\n    use super::hello;\n\n    #[test]\n    fn test_hello() {\n        assert_eq!(hello(), &quot;Hello, world!&quot;);\n    }\n}\n</code></pre>\n<blockquote>\n<p>üí≠ <strong>//! doc comments</strong> are used to write crate and module-level documentation. On other places, we have to use /// outside of the block. And when uploading a crate to <a href=\"http://crates.io/\" target=\"_blank\" rel=\"noopener\">crates.io</a>, cargo generates the documentation from these doc comments and host it on <a href=\"https://docs.rs/\" target=\"_blank\" rel=\"noopener\">docs.rs</a>.</p>\n</blockquote>\n<p>üí° We have to add the <strong>description</strong> and <strong>license</strong> fields to <code>Cargo.toml</code>. Otherwise, we will get <code>error: api errors: missing or empty metadata fields: description, license. Please see http://doc.crates.io/manifest.html</code></p>\n<p>To upload this to crates.io,</p>\n<ol>\n<li>We have to create an account on crates.io to acquire an API token</li>\n<li>Then run <code>cargo login &lt;token&gt;</code> with that API token and cargo publish</li>\n</ol>\n<p><a href=\"http://doc.crates.io/crates-io.html\" target=\"_blank\" rel=\"noopener\">üìñ</a> This is <a href=\"http://doc.crates.io/crates-io.html\" target=\"_blank\" rel=\"noopener\">how it describes on Cargo Docs</a> with more details.</p>\n<blockquote>\n<ul>\n<li>You‚Äôll need an account on crates.io to acquire an API token. To do so, <a href=\"https://crates.io/\" target=\"_blank\" rel=\"noopener\">visit the home page</a> and log in via a GitHub account (required for now). After this, visit your <a href=\"https://crates.io/me\" target=\"_blank\" rel=\"noopener\">Account Settings</a> page and run the <code>cargo login</code> command specified.<br>Ex. <code>cargo login abcdefghijklmnopqrstuvwxyz012345</code></li>\n<li>The next step is to package up your crate into a format that can be uploaded to crates.io. For this we‚Äôll use the <code>cargo package</code> sub-command.</li>\n<li>Now, it can be uploaded to crates.io with the <code>cargo publish</code> command.</li>\n<li>If you‚Äôd like to skip the <code>cargo package</code> step, the <code>cargo publish</code> sub-command will automatically package up the local crate if a copy isn‚Äôt found already.</li>\n</ul>\n</blockquote>\n<p>The name of our crate is <code>test_crate_hello_world</code>. So it can be found on,<br>üì¶ <a href=\"https://crates.io/crates/test_crate_hello_world\" target=\"_blank\" rel=\"noopener\">https://<strong>crates.io/crates</strong>/test_crate_hello_world</a><br>üìë <a href=\"https://docs.rs/test_crate_hello_world\" target=\"_blank\" rel=\"noopener\">https://<strong>docs.rs</strong>/test_crate_hello_world</a></p>\n<blockquote>\n<p>üíØ crates.io supports readme files as well. To enable it, we have to add the readme field to Cargo.toml. Ex: <code>readme=&quot;README.md&quot;</code></p>\n</blockquote>\n<p>üèóÔ∏è Okay then, Let‚Äôs see how we can <strong>use this from another crate</strong>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// # Think we run,\ncargo new greetings\n\n// # It generates,\ngreetings\n ‚îú‚îÄ‚îÄ Cargo.toml\n ‚îî‚îÄ‚îÄ src\n    ‚îî‚îÄ‚îÄ main.rs\n\n// # Think we modify following files,\n\n// 01. greetings/Cargo.toml\n[package]\nname = &quot;greetings&quot;\nversion = &quot;0.1.0&quot;\nauthors = [&quot;Dumindu Madunuwan&quot;]\n\n[dependencies]\ntest_crate_hello_world = &quot;0.1.0&quot;\n\n// 02. greetings/src/main.rs\nextern crate test_crate_hello_world;\n\nfn main() {\n    println!(&quot;{}&quot;, test_crate_hello_world::hello());\n}\n</code></pre>\n<p>By default, Cargo looks dependencies on <a href=\"https://crates.io/\" target=\"_blank\" rel=\"noopener\">crates.io</a>. So we have to add only the crate name and a version string to <strong><code>Cargo.toml</code></strong> and then run <code>cargo build</code> to fetch the dependencies and compile them.</p>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<p>üí≠ Crates are a bit similar to the packages in some other languages. Crates compile individually. If the crate has child file modules, those files will get merged with the crate file and compile as a single unit.</p>\n<p>üí≠ A crate can produce an executable/ a binary or a library. <code>src/main.rs</code> is the crate root/ entry point for a binary crate and <code>src/lib.rs</code> is the entry point for a library crate.</p>\n<h2 id=\"01-lib-rs-on-executable-crate\"><a href=\"#01-lib-rs-on-executable-crate\" class=\"headerlink\" title=\"01. lib.rs on executable crate\"></a>01. lib.rs on executable crate</h2><p>üí° When writing binary crates, we can move the main functionalities to <code>src/lib.rs</code> and use it as a library from <code>src/main.rs</code>. This pattern is quite common on executable crates.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// # Think we run,\ncargo new greetings\ntouch greetings/src/lib.rs\n\n// # It generates,\ngreetings\n ‚îú‚îÄ‚îÄ Cargo.toml\n ‚îî‚îÄ‚îÄ src\n    ‚îú‚îÄ‚îÄ lib.rs\n    ‚îî‚îÄ‚îÄ main.rs\n\n// # Think we modify following files,\n\n// 01. greetings/src/lib.rs\npub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n}\n\n// 02. greetings/src/main.rs\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n</code></pre>\n<blockquote>\n<p>üíØ As I mentioned earlier, in here we use simplest examples to reduce the complexity of learning materials. But this is how we need to write <code>greetings/src/lib.rs</code> to make the code more testable.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// greetings/src/lib.rs\npub fn hello() -&gt; String {\n  //! This returns `Hello, world!` String\n  (&quot;Hello, world!&quot;).to_string()\n}\n\n// 01. Tests for `hello()`\n#[test] // Indicates that this is a test function\nfn test_hello() {\n  assert_eq!(hello(), &quot;Hello, world!&quot;);\n}\n\n// 02. Tests for `hello()`, Idiomatic way\n#[cfg(test)] // Only compiles when running tests\nmod tests { // Separates tests from code\n  use super::hello; // Import root `hello()` function\n\n    #[test]\n    fn test_hello() {\n        assert_eq!(hello(), &quot;Hello, world!&quot;);\n    }\n}\n</code></pre>\n<blockquote>\n<p><a href=\"https://doc.rust-lang.org/book/first-edition/crates-and-modules.html\" target=\"_blank\" rel=\"noopener\">üìñ</a> When importing a crate that has dashes in its name ‚Äúlike-this‚Äù, which is not a valid Rust identifier, it will be converted by changing the dashes to underscores, so you would write <code>extern crate like_this;</code></p>\n</blockquote>\n<p><code>lib.rs</code> can link with multiple files.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// # Think we run,\ncargo new phrases\ntouch phrases/src/lib.rs\ntouch phrases/src/greetings.rs\n\n// # It generates,\nphrases\n ‚îú‚îÄ‚îÄ Cargo.toml\n ‚îî‚îÄ‚îÄ src\n    ‚îú‚îÄ‚îÄ greetings.rs\n    ‚îú‚îÄ‚îÄ lib.rs\n    ‚îî‚îÄ‚îÄ main.rs\n\n// # Think we modify following files,\n\n// 01. phrases/src/greetings.rs\npub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n}\n\n// 02. phrases/src/main.rs\nextern crate phrases;\n\nfn main() {\n    phrases::greetings::hello();\n}\n\n// 03. phrases/src/lib.rs\npub mod greetings; // ‚≠êÔ∏è Import `greetings` module as a public module\n</code></pre>\n<h2 id=\"02-Dependency-crate-on-Cargo-toml\"><a href=\"#02-Dependency-crate-on-Cargo-toml\" class=\"headerlink\" title=\"02. Dependency crate on Cargo.toml\"></a>02. Dependency crate on Cargo.toml</h2><p>When the code in the <code>lib.rs</code> file is getting larger, we can move those into a separate library crate and use it as a dependency of the main crate. As we mentioned earlier, a dependency can be specified from a folder path, git repository or by crates.io.</p>\n<h3 id=\"a-Using-folder-path\"><a href=\"#a-Using-folder-path\" class=\"headerlink\" title=\"a. Using folder path\"></a>a. Using folder path</h3><p>Let‚Äôs see how to create a nested crate and use it as a dependency using folder path,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// # Think we run,\ncargo new phrases\ncargo new phrases/greetings --lib\n\n// # It generates,\nphrases\n ‚îú‚îÄ‚îÄ Cargo.toml\n ‚îú‚îÄ‚îÄ greetings\n ‚îÇ  ‚îú‚îÄ‚îÄ Cargo.toml\n ‚îÇ  ‚îî‚îÄ‚îÄ src\n ‚îÇ     ‚îî‚îÄ‚îÄ lib.rs\n ‚îî‚îÄ‚îÄ src\n    ‚îî‚îÄ‚îÄ main.rs\n\n// # Think we modify following files,\n\n// 01. phrases/Cargo.toml\n[package]\nname = &quot;phrases&quot;\nversion = &quot;0.1.0&quot;\nauthors = [&quot;Dumindu Madunuwan&quot;]\n\n[dependencies]\ngreetings = { path = &quot;greetings&quot; }\n\n// 02. phrases/greetings/src/lib.rs\npub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n}\n\n// 03. phrases/src/main.rs\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n</code></pre>\n<h3 id=\"b-Using-git-repository\"><a href=\"#b-Using-git-repository\" class=\"headerlink\" title=\"b. Using git repository\"></a>b. Using git repository</h3><p>If you want to use a library crate on multiple projects, one way is moving crate code to a git repository and use it as a dependency when needed.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// -- Cargo.toml --\n[dependencies]\n\n// 01. Get the latest commit on the master branch\nrocket = { git = &quot;https://github.com/SergioBenitez/Rocket&quot; }\n\n// 02. Get the latest commit of a specific branch\nrocket = { git = &quot;https://github.com/SergioBenitez/Rocket&quot;, branch = &quot;v0.3&quot; }\n\n// 03. Get a specific tag\nrocket = { git = &quot;https://github.com/SergioBenitez/Rocket&quot;, tag = &quot;v0.3.2&quot; }\n\n// 04. Get a specific revision (on master or any branch, according to rev)\nrocket = { git = &quot;https://github.com/SergioBenitez/Rocket&quot;, rev = &quot;8183f636305cef4adaa9525506c33cbea72d1745&quot; }\n</code></pre>\n<h3 id=\"c-Using-crates-io\"><a href=\"#c-Using-crates-io\" class=\"headerlink\" title=\"c. Using crates.io\"></a>c. Using crates.io</h3><p>The other way is uploading it to <a href=\"http://crates.io/\" target=\"_blank\" rel=\"noopener\">crates.io</a> and use it as a dependency when needed.</p>\n<p>üöß First, let‚Äôs <code>create</code> a simple ‚ÄúHello world‚Äù crate <code>and upload</code> it to <a href=\"http://crates.io/\" target=\"_blank\" rel=\"noopener\">crates.io</a>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// # Think we run,\ncargo new test_crate_hello_world --lib\n\n// # It generates,\ntest_crate_hello_world\n ‚îú‚îÄ‚îÄ Cargo.toml\n ‚îî‚îÄ‚îÄ src\n    ‚îî‚îÄ‚îÄ lib.rs\n\n// # Think we modify following files,\n\n// 01. test_crate_hello_world/Cargo.toml\n[package]\nname = &quot;test_crate_hello_world&quot;\nversion = &quot;0.1.0&quot;\nauthors = [&quot;Dumindu Madunuwan&quot;]\n\ndescription = &quot;A Simple Hello World Crate&quot;\nrepository = &quot;https://github.com/dumindu/test_crate_hello_world&quot;\nkeywords = [&quot;hello&quot;, &quot;world&quot;]\nlicense = &quot;Apache-2.0&quot;\n\n[dependencies]\n\n// 02. test_crate_hello_world/src/lib.rs\n//! A Simple Hello World Crate\n\n/// This function returns the greeting; `Hello, world!`\npub fn hello() -&gt; String {\n    (&quot;Hello, world!&quot;).to_string()\n}\n\n#[cfg(test)]\nmod tests {\n\n    use super::hello;\n\n    #[test]\n    fn test_hello() {\n        assert_eq!(hello(), &quot;Hello, world!&quot;);\n    }\n}\n</code></pre>\n<blockquote>\n<p>üí≠ <strong>//! doc comments</strong> are used to write crate and module-level documentation. On other places, we have to use /// outside of the block. And when uploading a crate to <a href=\"http://crates.io/\" target=\"_blank\" rel=\"noopener\">crates.io</a>, cargo generates the documentation from these doc comments and host it on <a href=\"https://docs.rs/\" target=\"_blank\" rel=\"noopener\">docs.rs</a>.</p>\n</blockquote>\n<p>üí° We have to add the <strong>description</strong> and <strong>license</strong> fields to <code>Cargo.toml</code>. Otherwise, we will get <code>error: api errors: missing or empty metadata fields: description, license. Please see http://doc.crates.io/manifest.html</code></p>\n<p>To upload this to crates.io,</p>\n<ol>\n<li>We have to create an account on crates.io to acquire an API token</li>\n<li>Then run <code>cargo login &lt;token&gt;</code> with that API token and cargo publish</li>\n</ol>\n<p><a href=\"http://doc.crates.io/crates-io.html\" target=\"_blank\" rel=\"noopener\">üìñ</a> This is <a href=\"http://doc.crates.io/crates-io.html\" target=\"_blank\" rel=\"noopener\">how it describes on Cargo Docs</a> with more details.</p>\n<blockquote>\n<ul>\n<li>You‚Äôll need an account on crates.io to acquire an API token. To do so, <a href=\"https://crates.io/\" target=\"_blank\" rel=\"noopener\">visit the home page</a> and log in via a GitHub account (required for now). After this, visit your <a href=\"https://crates.io/me\" target=\"_blank\" rel=\"noopener\">Account Settings</a> page and run the <code>cargo login</code> command specified.<br>Ex. <code>cargo login abcdefghijklmnopqrstuvwxyz012345</code></li>\n<li>The next step is to package up your crate into a format that can be uploaded to crates.io. For this we‚Äôll use the <code>cargo package</code> sub-command.</li>\n<li>Now, it can be uploaded to crates.io with the <code>cargo publish</code> command.</li>\n<li>If you‚Äôd like to skip the <code>cargo package</code> step, the <code>cargo publish</code> sub-command will automatically package up the local crate if a copy isn‚Äôt found already.</li>\n</ul>\n</blockquote>\n<p>The name of our crate is <code>test_crate_hello_world</code>. So it can be found on,<br>üì¶ <a href=\"https://crates.io/crates/test_crate_hello_world\" target=\"_blank\" rel=\"noopener\">https://<strong>crates.io/crates</strong>/test_crate_hello_world</a><br>üìë <a href=\"https://docs.rs/test_crate_hello_world\" target=\"_blank\" rel=\"noopener\">https://<strong>docs.rs</strong>/test_crate_hello_world</a></p>\n<blockquote>\n<p>üíØ crates.io supports readme files as well. To enable it, we have to add the readme field to Cargo.toml. Ex: <code>readme=&quot;README.md&quot;</code></p>\n</blockquote>\n<p>üèóÔ∏è Okay then, Let‚Äôs see how we can <strong>use this from another crate</strong>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// # Think we run,\ncargo new greetings\n\n// # It generates,\ngreetings\n ‚îú‚îÄ‚îÄ Cargo.toml\n ‚îî‚îÄ‚îÄ src\n    ‚îî‚îÄ‚îÄ main.rs\n\n// # Think we modify following files,\n\n// 01. greetings/Cargo.toml\n[package]\nname = &quot;greetings&quot;\nversion = &quot;0.1.0&quot;\nauthors = [&quot;Dumindu Madunuwan&quot;]\n\n[dependencies]\ntest_crate_hello_world = &quot;0.1.0&quot;\n\n// 02. greetings/src/main.rs\nextern crate test_crate_hello_world;\n\nfn main() {\n    println!(&quot;{}&quot;, test_crate_hello_world::hello());\n}\n</code></pre>\n<p>By default, Cargo looks dependencies on <a href=\"https://crates.io/\" target=\"_blank\" rel=\"noopener\">crates.io</a>. So we have to add only the crate name and a version string to <strong><code>Cargo.toml</code></strong> and then run <code>cargo build</code> to fetch the dependencies and compile them.</p>\n"},{"title":"Combinators","_content":"\n## What is a combinator?\n\n- One meaning of ‚Äúcombinator‚Äù is a more informal sense referring to the **combinator pattern**, a style of organizing libraries centered around the idea of combining things. Usually there is **some type T**, some **functions for constructing ‚Äúprimitive‚Äù values of type T**, and some ‚Äú**combinators**‚Äù which can **combine values of type T** in various ways to **build up more complex values of type T**. The other definition is **\"function with no free variables\"**.\n__ [wiki.haskell.org](https://wiki.haskell.org/Combinator)\n\n- A combinator is **a function** which **builds program fragments from program fragments**; in a sense the programmer using combinators constructs much of the desired program automatically, rather that writing every detail by hand. \n__ John Hughes‚Äî[Generalizing Monads to Arrows](http://www.cse.chalmers.se/~rjmh/Papers/arrows.pdf) via [Functional Programming Concepts](https://github.com/caiorss/Functional-Programming/blob/master/haskell/Functional_Programming_Concepts.org)\n\nThe exact definition of \"combinators\" in Rust ecosystem is bit unclear.¬†\n\n- `or()`, `and()`, `or_else()`, `and_then()` \n  ‚ñ∏ **Combine two values of type T** and **return same type T**.\n\n- `filter()` for `Option` types\n  ‚ñ∏ **Filter type T** by using a closure as a conditional function\n  ‚ñ∏ **Return same type T**\n  \n- `map()`, `map_err()` \n  ‚ñ∏ **Convert type T by applying a closure**. \n  ‚ñ∏ The **data type of the value inside T can be changed**. \n  ex. `Some<&str>` can be converted to `Some<usize>` or `Err<&str>` to `Err<isize>` and etc.\n\n- `map_or()`, `map_or_else()`\n  ‚ñ∏ **Transform type T by applying a closure** & **return the value inside type T**.\n  ‚ñ∏ For **`None` and `Err`, a default value or another closure** is applied.\n\n- `ok_or()`, `ok_or_else()` for `Option` types\n  ‚ñ∏ **Transform `Option` type into a `Result` type**.\n\n- `as_ref()`, `as_mut()` \n  ‚ñ∏ **Transform type T into a reference or a mutable reference**.\n\n## or() and and()\n\nWhile combining two expressions, which return either `Option`/ `Result`\n- `or()`: If either one got `Some` or `Ok`, that value returns immediately.\n- `and()`: If both got `Some` or `Ok`, the value in the second expression returns. If either one got `None` or `Err` that value returns immediately.\n\n```rust\nfn main() {\n  let s1 = Some(\"some1\");\n  let s2 = Some(\"some2\");\n  let n: Option<&str> = None;\n\n  let o1: Result<&str, &str> = Ok(\"ok1\");\n  let o2: Result<&str, &str> = Ok(\"ok2\");\n  let e1: Result<&str, &str> = Err(\"error1\");\n  let e2: Result<&str, &str> = Err(\"error2\");\n\n  assert_eq!(s1.or(s2), s1); // Some1 or Some2 = Some1\n  assert_eq!(s1.or(n), s1);  // Some or None = Some\n  assert_eq!(n.or(s1), s1);  // None or Some = Some\n  assert_eq!(n.or(n), n);    // None1 or None2 = None2\n\n  assert_eq!(o1.or(o2), o1); // Ok1 or Ok2 = Ok1\n  assert_eq!(o1.or(e1), o1); // Ok or Err = Ok\n  assert_eq!(e1.or(o1), o1); // Err or Ok = Ok\n  assert_eq!(e1.or(e2), e2); // Err1 or Err2 = Err2\n\n  assert_eq!(s1.and(s2), s2); // Some1 and Some2 = Some2\n  assert_eq!(s1.and(n), n);   // Some and None = None\n  assert_eq!(n.and(s1), n);   // None and Some = None\n  assert_eq!(n.and(n), n);    // None1 and None2 = None1\n  \n  assert_eq!(o1.and(o2), o2); // Ok1 and Ok2 = Ok2\n  assert_eq!(o1.and(e1), e1); // Ok and Err = Err\n  assert_eq!(e1.and(o1), e1); // Err and Ok = Err\n  assert_eq!(e1.and(e2), e1); // Err1 and Err2 = Err1\n}\n```\n\n> üîé Rust nightly support [`xor()`](https://doc.rust-lang.org/std/option/enum.Option.html#method.xor) for `Option` types, which returns `Some` only if one expression got `Some`, but not both.\n\n## or_else()\n\nSimilar to `or()`. The only difference is, the second expression should be a **[closure](a7.functions.html#Closures)** which returns same type T.\n\n```rust\nfn main() {\n    // or_else with Option\n    let s1 = Some(\"some1\");\n    let s2 = Some(\"some2\");\n    let fn_some = || Some(\"some2\"); // similar to: let fn_some = || -> Option<&str> { Some(\"some2\") };\n\n    let n: Option<&str> = None;\n    let fn_none = || None;\n\n    assert_eq!(s1.or_else(fn_some), s1);  // Some1 or_else Some2 = Some1\n    assert_eq!(s1.or_else(fn_none), s1);  // Some or_else None = Some\n    assert_eq!(n.or_else(fn_some), s2);   // None or_else Some = Some\n    assert_eq!(n.or_else(fn_none), None); // None1 or_else None2 = None2\n\n    // or_else with Result\n    let o1: Result<&str, &str> = Ok(\"ok1\");\n    let o2: Result<&str, &str> = Ok(\"ok2\");\n    let fn_ok = |_| Ok(\"ok2\"); // similar to: let fn_ok = |_| -> Result<&str, &str> { Ok(\"ok2\") };\n\n    let e1: Result<&str, &str> = Err(\"error1\");\n    let e2: Result<&str, &str> = Err(\"error2\");\n    let fn_err = |_| Err(\"error2\");\n\n    assert_eq!(o1.or_else(fn_ok), o1);  // Ok1 or_else Ok2 = Ok1\n    assert_eq!(o1.or_else(fn_err), o1); // Ok or_else Err = Ok\n    assert_eq!(e1.or_else(fn_ok), o2);  // Err or_else Ok = Ok\n    assert_eq!(e1.or_else(fn_err), e2); // Err1 or_else Err2 = Err2\n}\n```\n\n## and_then()\n\nSimilar to `and()`. The only difference is, the second expression should be a **[closure](a7.functions.html#Closures)** which returns same type T.\n\n```rust\nfn main() {\n    // and_then with Option\n    let s1 = Some(\"some1\");\n    let s2 = Some(\"some2\");\n    let fn_some = |_| Some(\"some2\"); // similar to: let fn_some = |_| -> Option<&str> { Some(\"some2\") };\n\n    let n: Option<&str> = None;\n    let fn_none = |_| None;\n\n    assert_eq!(s1.and_then(fn_some), s2); // Some1 and_then Some2 = Some2\n    assert_eq!(s1.and_then(fn_none), n);  // Some and_then None = None\n    assert_eq!(n.and_then(fn_some), n);   // None and_then Some = None\n    assert_eq!(n.and_then(fn_none), n);   // None1 and_then None2 = None1\n\n    // and_then with Result\n    let o1: Result<&str, &str> = Ok(\"ok1\");\n    let o2: Result<&str, &str> = Ok(\"ok2\");\n    let fn_ok = |_| Ok(\"ok2\"); // similar to: let fn_ok = |_| -> Result<&str, &str> { Ok(\"ok2\") };\n\n    let e1: Result<&str, &str> = Err(\"error1\");\n    let e2: Result<&str, &str> = Err(\"error2\");\n    let fn_err = |_| Err(\"error2\");\n\n    assert_eq!(o1.and_then(fn_ok), o2);  // Ok1 and_then Ok2 = Ok2\n    assert_eq!(o1.and_then(fn_err), e2); // Ok and_then Err = Err\n    assert_eq!(e1.and_then(fn_ok), e1);  // Err and_then Ok = Err\n    assert_eq!(e1.and_then(fn_err), e1); // Err1 and_then Err2 = Err1\n}\n```\n\n## filter()\n\n> üí° Usually in programming languages `filter` functions are used with arrays or iterators to create a new array/ iterator by filtering own elements via a function/ closure. Rust also provides [`filter()` **as an iterator adaptor**](https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.filter) to apply a closure on each element of an iterator to transform it into another iterator. However in here we are talking about the functionality of `filter()` with `Option` types.\n\nThe same `Some` type is returned, only if we pass a `Some` value and the given closure returned true for it. `None` is returned, if `None` type passed or the closure returned false. The closure uses the value inside `Some` as an argument. Still Rust support `filter()` only for `Option` types.\n\n```rust\nfn main() {\n    let s1 = Some(3);\n    let s2 = Some(6);\n    let n = None;\n\n    let fn_is_even = |x: &i8| x % 2 == 0;\n\n    assert_eq!(s1.filter(fn_is_even), n);  // Some(3) -> 3 is not even -> None\n    assert_eq!(s2.filter(fn_is_even), s2); // Some(6) -> 6 is even -> Some(6)\n    assert_eq!(n.filter(fn_is_even), n);   // None -> no value -> None\n}\n```\n\n## map() and map_err()\n\n>üí° Usually in programming languages `map()` functions are used with arrays or iterators, **to apply a closure on each element** of the array or iterator. Rust also provides [`map()` **as an iterator adaptor**](https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.map) to apply a closure on each element of an iterator to transform it into another iterator. However in here we are talking about the functionality of `map()` with `Option` and `Result` types. \n\n- `map()` : Convert type T by applying a closure. **The data type of `Some` or `Ok` blocks can be changed** according to the return type of the closure. Convert `Option<T>` to `Option<U>`, `Result<T, E>` to `Result<U, E>`\n\n‚≠ê Via `map()`, only `Some` and `Ok` values are getting changed. No affect to the values inside `Err` (`None` doesn‚Äôt contain any value at all).\n\n```rust\nfn main() {\n    let s1 = Some(\"abcde\");\n    let s2 = Some(5);\n\n    let n1: Option<&str> = None;\n    let n2: Option<usize> = None;\n\n    let o1: Result<&str, &str> = Ok(\"abcde\");\n    let o2: Result<usize, &str> = Ok(5);\n    \n    let e1: Result<&str, &str> = Err(\"abcde\");\n    let e2: Result<usize, &str> = Err(\"abcde\");\n    \n    let fn_character_count = |s: &str| s.chars().count();\n\n    assert_eq!(s1.map(fn_character_count), s2); // Some1 map = Some2\n    assert_eq!(n1.map(fn_character_count), n2); // None1 map = None2\n\n    assert_eq!(o1.map(fn_character_count), o2); // Ok1 map = Ok2\n    assert_eq!(e1.map(fn_character_count), e2); // Err1 map = Err2\n}\n```\n\n- `map_err()` for `Result` types : **The data type of `Err` blocks can be changed** according to the return type of the closure. Convert `Result<T, E>` to `Result<T, F>`.\n\n‚≠ê Via `map_err()`, only `Err` values are getting changed. No affect to the values inside `Ok`.\n\n```rust\nfn main() {\n    let o1: Result<&str, &str> = Ok(\"abcde\");\n    let o2: Result<&str, isize> = Ok(\"abcde\");\n\n    let e1: Result<&str, &str> = Err(\"404\");\n    let e2: Result<&str, isize> = Err(404);\n\n    let fn_character_count = |s: &str| -> isize { s.parse().unwrap() }; // convert str to isize\n\n    assert_eq!(o1.map_err(fn_character_count), o2); // Ok1 map = Ok2\n    assert_eq!(e1.map_err(fn_character_count), e2); // Err1 map = Err2\n}\n```\n\n## map_or() and map_or_else()\n\nHope you remember the functionality of [`unwrap_or()` and `unwrap_or_else()`](e4.unwrap_and_expect.html#unwrap-or-unwrap-or-default-and-unwrap-or-else) functions. These functions also bit similar to them. But `map_or()` and `map_or_else()` apply a closure on `Some` and `Ok` values and **return the value inside type T**.\n\n- `map_or()` : Support only for `Option` types (not supporting `Result`). Apply the closure to the value inside `Some` and return the output according to the closure. The given default value is returned for `None` types.\n\n```rust\nfn main() {\n    const V_DEFAULT: i8 = 1;\n    \n    let s = Some(10);\n    let n: Option<i8> = None;\n    let fn_closure = |v: i8| v + 2;\n\n    assert_eq!(s.map_or(V_DEFAULT, fn_closure), 12);\n    assert_eq!(n.map_or(V_DEFAULT, fn_closure), V_DEFAULT);\n}\n```\n\n- `map_or_else()` : Support for both `Option` and `Result` types (`Result` still nightly only). Similar to `map_or()` but should provide another closure instead a default value for the first parameter.\n\n‚≠ê `None` types doesn‚Äôt contain any value. So no need to pass anything to the closure as input with `Option` types. But `Err` types contain some value inside it. So default closure should able to read it as an input, while using this with `Result` types.\n\n```rust\n#![feature(result_map_or_else)] // enable unstable library feature 'result_map_or_else' on nightly\nfn main() {\n    let s = Some(10);\n    let n: Option<i8> = None;\n\n    let fn_closure = |v: i8| v + 2;\n    let fn_default = || 1; // None doesn't contain any value. So no need to pass anything to closure as input.\n\n    assert_eq!(s.map_or_else(fn_default, fn_closure), 12);\n    assert_eq!(n.map_or_else(fn_default, fn_closure), 1);\n\n    let o = Ok(10);\n    let e = Err(5);\n    let fn_default_for_result = |v: i8| v + 1; // Err contain some value inside it. So default closure should able to read it as input\n\n    assert_eq!(o.map_or_else(fn_default_for_result, fn_closure), 12);\n    assert_eq!(e.map_or_else(fn_default_for_result, fn_closure), 6);\n}\n```\n\n## ok_or() and ok_or_else()\n\nAs mentioned earlier, `ok_or()`, `ok_or_else()` transform `Option` type into `Result` type. **`Some` to `Ok` and `None` to `Err`**.\n\n- `ok_or()` : A default `Err` message should pass as argument.\n\n```rust\nfn main() {\n    const ERR_DEFAULT: &str = \"error message\";\n\n    let s = Some(\"abcde\");\n    let n: Option<&str> = None;\n\n    let o: Result<&str, &str> = Ok(\"abcde\");\n    let e: Result<&str, &str> = Err(ERR_DEFAULT);\n\n    assert_eq!(s.ok_or(ERR_DEFAULT), o); // Some(T) -> Ok(T)\n    assert_eq!(n.ok_or(ERR_DEFAULT), e); // None -> Err(default)\n}\n```\n\n- `ok_or_else()` : Similar to `ok_or()`. A closure should be passed as the argument.\n\n```rust\nfn main() {\n    let s = Some(\"abcde\");\n    let n: Option<&str> = None;\n    let fn_err_message = || \"error message\";\n\n    let o: Result<&str, &str> = Ok(\"abcde\");\n    let e: Result<&str, &str> = Err(\"error message\");\n\n    assert_eq!(s.ok_or_else(fn_err_message), o); // Some(T) -> Ok(T)\n    assert_eq!(n.ok_or_else(fn_err_message), e); // None -> Err(default)\n}\n```\n\n## as_ref() and as_mut()\n\nüîé As mentioned earlier, these functions are used to **borrow type T as a reference or as a mutable reference**.\n\n- `as_ref()` : Convert `Option<T>` to `Option<&T>` and `Result<T, E>` to `Result<&T, &E>` \n- `as_mut()` : Converts `Option<T>` to `Option<&mut T>` and `Result<T, E>` to `Result<&mut T, &mut E>`\n","source":"docs/e6.combinators.md","raw":"title: Combinators\n---\n\n## What is a combinator?\n\n- One meaning of ‚Äúcombinator‚Äù is a more informal sense referring to the **combinator pattern**, a style of organizing libraries centered around the idea of combining things. Usually there is **some type T**, some **functions for constructing ‚Äúprimitive‚Äù values of type T**, and some ‚Äú**combinators**‚Äù which can **combine values of type T** in various ways to **build up more complex values of type T**. The other definition is **\"function with no free variables\"**.\n__ [wiki.haskell.org](https://wiki.haskell.org/Combinator)\n\n- A combinator is **a function** which **builds program fragments from program fragments**; in a sense the programmer using combinators constructs much of the desired program automatically, rather that writing every detail by hand. \n__ John Hughes‚Äî[Generalizing Monads to Arrows](http://www.cse.chalmers.se/~rjmh/Papers/arrows.pdf) via [Functional Programming Concepts](https://github.com/caiorss/Functional-Programming/blob/master/haskell/Functional_Programming_Concepts.org)\n\nThe exact definition of \"combinators\" in Rust ecosystem is bit unclear.¬†\n\n- `or()`, `and()`, `or_else()`, `and_then()` \n  ‚ñ∏ **Combine two values of type T** and **return same type T**.\n\n- `filter()` for `Option` types\n  ‚ñ∏ **Filter type T** by using a closure as a conditional function\n  ‚ñ∏ **Return same type T**\n  \n- `map()`, `map_err()` \n  ‚ñ∏ **Convert type T by applying a closure**. \n  ‚ñ∏ The **data type of the value inside T can be changed**. \n  ex. `Some<&str>` can be converted to `Some<usize>` or `Err<&str>` to `Err<isize>` and etc.\n\n- `map_or()`, `map_or_else()`\n  ‚ñ∏ **Transform type T by applying a closure** & **return the value inside type T**.\n  ‚ñ∏ For **`None` and `Err`, a default value or another closure** is applied.\n\n- `ok_or()`, `ok_or_else()` for `Option` types\n  ‚ñ∏ **Transform `Option` type into a `Result` type**.\n\n- `as_ref()`, `as_mut()` \n  ‚ñ∏ **Transform type T into a reference or a mutable reference**.\n\n## or() and and()\n\nWhile combining two expressions, which return either `Option`/ `Result`\n- `or()`: If either one got `Some` or `Ok`, that value returns immediately.\n- `and()`: If both got `Some` or `Ok`, the value in the second expression returns. If either one got `None` or `Err` that value returns immediately.\n\n```rust\nfn main() {\n  let s1 = Some(\"some1\");\n  let s2 = Some(\"some2\");\n  let n: Option<&str> = None;\n\n  let o1: Result<&str, &str> = Ok(\"ok1\");\n  let o2: Result<&str, &str> = Ok(\"ok2\");\n  let e1: Result<&str, &str> = Err(\"error1\");\n  let e2: Result<&str, &str> = Err(\"error2\");\n\n  assert_eq!(s1.or(s2), s1); // Some1 or Some2 = Some1\n  assert_eq!(s1.or(n), s1);  // Some or None = Some\n  assert_eq!(n.or(s1), s1);  // None or Some = Some\n  assert_eq!(n.or(n), n);    // None1 or None2 = None2\n\n  assert_eq!(o1.or(o2), o1); // Ok1 or Ok2 = Ok1\n  assert_eq!(o1.or(e1), o1); // Ok or Err = Ok\n  assert_eq!(e1.or(o1), o1); // Err or Ok = Ok\n  assert_eq!(e1.or(e2), e2); // Err1 or Err2 = Err2\n\n  assert_eq!(s1.and(s2), s2); // Some1 and Some2 = Some2\n  assert_eq!(s1.and(n), n);   // Some and None = None\n  assert_eq!(n.and(s1), n);   // None and Some = None\n  assert_eq!(n.and(n), n);    // None1 and None2 = None1\n  \n  assert_eq!(o1.and(o2), o2); // Ok1 and Ok2 = Ok2\n  assert_eq!(o1.and(e1), e1); // Ok and Err = Err\n  assert_eq!(e1.and(o1), e1); // Err and Ok = Err\n  assert_eq!(e1.and(e2), e1); // Err1 and Err2 = Err1\n}\n```\n\n> üîé Rust nightly support [`xor()`](https://doc.rust-lang.org/std/option/enum.Option.html#method.xor) for `Option` types, which returns `Some` only if one expression got `Some`, but not both.\n\n## or_else()\n\nSimilar to `or()`. The only difference is, the second expression should be a **[closure](a7.functions.html#Closures)** which returns same type T.\n\n```rust\nfn main() {\n    // or_else with Option\n    let s1 = Some(\"some1\");\n    let s2 = Some(\"some2\");\n    let fn_some = || Some(\"some2\"); // similar to: let fn_some = || -> Option<&str> { Some(\"some2\") };\n\n    let n: Option<&str> = None;\n    let fn_none = || None;\n\n    assert_eq!(s1.or_else(fn_some), s1);  // Some1 or_else Some2 = Some1\n    assert_eq!(s1.or_else(fn_none), s1);  // Some or_else None = Some\n    assert_eq!(n.or_else(fn_some), s2);   // None or_else Some = Some\n    assert_eq!(n.or_else(fn_none), None); // None1 or_else None2 = None2\n\n    // or_else with Result\n    let o1: Result<&str, &str> = Ok(\"ok1\");\n    let o2: Result<&str, &str> = Ok(\"ok2\");\n    let fn_ok = |_| Ok(\"ok2\"); // similar to: let fn_ok = |_| -> Result<&str, &str> { Ok(\"ok2\") };\n\n    let e1: Result<&str, &str> = Err(\"error1\");\n    let e2: Result<&str, &str> = Err(\"error2\");\n    let fn_err = |_| Err(\"error2\");\n\n    assert_eq!(o1.or_else(fn_ok), o1);  // Ok1 or_else Ok2 = Ok1\n    assert_eq!(o1.or_else(fn_err), o1); // Ok or_else Err = Ok\n    assert_eq!(e1.or_else(fn_ok), o2);  // Err or_else Ok = Ok\n    assert_eq!(e1.or_else(fn_err), e2); // Err1 or_else Err2 = Err2\n}\n```\n\n## and_then()\n\nSimilar to `and()`. The only difference is, the second expression should be a **[closure](a7.functions.html#Closures)** which returns same type T.\n\n```rust\nfn main() {\n    // and_then with Option\n    let s1 = Some(\"some1\");\n    let s2 = Some(\"some2\");\n    let fn_some = |_| Some(\"some2\"); // similar to: let fn_some = |_| -> Option<&str> { Some(\"some2\") };\n\n    let n: Option<&str> = None;\n    let fn_none = |_| None;\n\n    assert_eq!(s1.and_then(fn_some), s2); // Some1 and_then Some2 = Some2\n    assert_eq!(s1.and_then(fn_none), n);  // Some and_then None = None\n    assert_eq!(n.and_then(fn_some), n);   // None and_then Some = None\n    assert_eq!(n.and_then(fn_none), n);   // None1 and_then None2 = None1\n\n    // and_then with Result\n    let o1: Result<&str, &str> = Ok(\"ok1\");\n    let o2: Result<&str, &str> = Ok(\"ok2\");\n    let fn_ok = |_| Ok(\"ok2\"); // similar to: let fn_ok = |_| -> Result<&str, &str> { Ok(\"ok2\") };\n\n    let e1: Result<&str, &str> = Err(\"error1\");\n    let e2: Result<&str, &str> = Err(\"error2\");\n    let fn_err = |_| Err(\"error2\");\n\n    assert_eq!(o1.and_then(fn_ok), o2);  // Ok1 and_then Ok2 = Ok2\n    assert_eq!(o1.and_then(fn_err), e2); // Ok and_then Err = Err\n    assert_eq!(e1.and_then(fn_ok), e1);  // Err and_then Ok = Err\n    assert_eq!(e1.and_then(fn_err), e1); // Err1 and_then Err2 = Err1\n}\n```\n\n## filter()\n\n> üí° Usually in programming languages `filter` functions are used with arrays or iterators to create a new array/ iterator by filtering own elements via a function/ closure. Rust also provides [`filter()` **as an iterator adaptor**](https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.filter) to apply a closure on each element of an iterator to transform it into another iterator. However in here we are talking about the functionality of `filter()` with `Option` types.\n\nThe same `Some` type is returned, only if we pass a `Some` value and the given closure returned true for it. `None` is returned, if `None` type passed or the closure returned false. The closure uses the value inside `Some` as an argument. Still Rust support `filter()` only for `Option` types.\n\n```rust\nfn main() {\n    let s1 = Some(3);\n    let s2 = Some(6);\n    let n = None;\n\n    let fn_is_even = |x: &i8| x % 2 == 0;\n\n    assert_eq!(s1.filter(fn_is_even), n);  // Some(3) -> 3 is not even -> None\n    assert_eq!(s2.filter(fn_is_even), s2); // Some(6) -> 6 is even -> Some(6)\n    assert_eq!(n.filter(fn_is_even), n);   // None -> no value -> None\n}\n```\n\n## map() and map_err()\n\n>üí° Usually in programming languages `map()` functions are used with arrays or iterators, **to apply a closure on each element** of the array or iterator. Rust also provides [`map()` **as an iterator adaptor**](https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.map) to apply a closure on each element of an iterator to transform it into another iterator. However in here we are talking about the functionality of `map()` with `Option` and `Result` types. \n\n- `map()` : Convert type T by applying a closure. **The data type of `Some` or `Ok` blocks can be changed** according to the return type of the closure. Convert `Option<T>` to `Option<U>`, `Result<T, E>` to `Result<U, E>`\n\n‚≠ê Via `map()`, only `Some` and `Ok` values are getting changed. No affect to the values inside `Err` (`None` doesn‚Äôt contain any value at all).\n\n```rust\nfn main() {\n    let s1 = Some(\"abcde\");\n    let s2 = Some(5);\n\n    let n1: Option<&str> = None;\n    let n2: Option<usize> = None;\n\n    let o1: Result<&str, &str> = Ok(\"abcde\");\n    let o2: Result<usize, &str> = Ok(5);\n    \n    let e1: Result<&str, &str> = Err(\"abcde\");\n    let e2: Result<usize, &str> = Err(\"abcde\");\n    \n    let fn_character_count = |s: &str| s.chars().count();\n\n    assert_eq!(s1.map(fn_character_count), s2); // Some1 map = Some2\n    assert_eq!(n1.map(fn_character_count), n2); // None1 map = None2\n\n    assert_eq!(o1.map(fn_character_count), o2); // Ok1 map = Ok2\n    assert_eq!(e1.map(fn_character_count), e2); // Err1 map = Err2\n}\n```\n\n- `map_err()` for `Result` types : **The data type of `Err` blocks can be changed** according to the return type of the closure. Convert `Result<T, E>` to `Result<T, F>`.\n\n‚≠ê Via `map_err()`, only `Err` values are getting changed. No affect to the values inside `Ok`.\n\n```rust\nfn main() {\n    let o1: Result<&str, &str> = Ok(\"abcde\");\n    let o2: Result<&str, isize> = Ok(\"abcde\");\n\n    let e1: Result<&str, &str> = Err(\"404\");\n    let e2: Result<&str, isize> = Err(404);\n\n    let fn_character_count = |s: &str| -> isize { s.parse().unwrap() }; // convert str to isize\n\n    assert_eq!(o1.map_err(fn_character_count), o2); // Ok1 map = Ok2\n    assert_eq!(e1.map_err(fn_character_count), e2); // Err1 map = Err2\n}\n```\n\n## map_or() and map_or_else()\n\nHope you remember the functionality of [`unwrap_or()` and `unwrap_or_else()`](e4.unwrap_and_expect.html#unwrap-or-unwrap-or-default-and-unwrap-or-else) functions. These functions also bit similar to them. But `map_or()` and `map_or_else()` apply a closure on `Some` and `Ok` values and **return the value inside type T**.\n\n- `map_or()` : Support only for `Option` types (not supporting `Result`). Apply the closure to the value inside `Some` and return the output according to the closure. The given default value is returned for `None` types.\n\n```rust\nfn main() {\n    const V_DEFAULT: i8 = 1;\n    \n    let s = Some(10);\n    let n: Option<i8> = None;\n    let fn_closure = |v: i8| v + 2;\n\n    assert_eq!(s.map_or(V_DEFAULT, fn_closure), 12);\n    assert_eq!(n.map_or(V_DEFAULT, fn_closure), V_DEFAULT);\n}\n```\n\n- `map_or_else()` : Support for both `Option` and `Result` types (`Result` still nightly only). Similar to `map_or()` but should provide another closure instead a default value for the first parameter.\n\n‚≠ê `None` types doesn‚Äôt contain any value. So no need to pass anything to the closure as input with `Option` types. But `Err` types contain some value inside it. So default closure should able to read it as an input, while using this with `Result` types.\n\n```rust\n#![feature(result_map_or_else)] // enable unstable library feature 'result_map_or_else' on nightly\nfn main() {\n    let s = Some(10);\n    let n: Option<i8> = None;\n\n    let fn_closure = |v: i8| v + 2;\n    let fn_default = || 1; // None doesn't contain any value. So no need to pass anything to closure as input.\n\n    assert_eq!(s.map_or_else(fn_default, fn_closure), 12);\n    assert_eq!(n.map_or_else(fn_default, fn_closure), 1);\n\n    let o = Ok(10);\n    let e = Err(5);\n    let fn_default_for_result = |v: i8| v + 1; // Err contain some value inside it. So default closure should able to read it as input\n\n    assert_eq!(o.map_or_else(fn_default_for_result, fn_closure), 12);\n    assert_eq!(e.map_or_else(fn_default_for_result, fn_closure), 6);\n}\n```\n\n## ok_or() and ok_or_else()\n\nAs mentioned earlier, `ok_or()`, `ok_or_else()` transform `Option` type into `Result` type. **`Some` to `Ok` and `None` to `Err`**.\n\n- `ok_or()` : A default `Err` message should pass as argument.\n\n```rust\nfn main() {\n    const ERR_DEFAULT: &str = \"error message\";\n\n    let s = Some(\"abcde\");\n    let n: Option<&str> = None;\n\n    let o: Result<&str, &str> = Ok(\"abcde\");\n    let e: Result<&str, &str> = Err(ERR_DEFAULT);\n\n    assert_eq!(s.ok_or(ERR_DEFAULT), o); // Some(T) -> Ok(T)\n    assert_eq!(n.ok_or(ERR_DEFAULT), e); // None -> Err(default)\n}\n```\n\n- `ok_or_else()` : Similar to `ok_or()`. A closure should be passed as the argument.\n\n```rust\nfn main() {\n    let s = Some(\"abcde\");\n    let n: Option<&str> = None;\n    let fn_err_message = || \"error message\";\n\n    let o: Result<&str, &str> = Ok(\"abcde\");\n    let e: Result<&str, &str> = Err(\"error message\");\n\n    assert_eq!(s.ok_or_else(fn_err_message), o); // Some(T) -> Ok(T)\n    assert_eq!(n.ok_or_else(fn_err_message), e); // None -> Err(default)\n}\n```\n\n## as_ref() and as_mut()\n\nüîé As mentioned earlier, these functions are used to **borrow type T as a reference or as a mutable reference**.\n\n- `as_ref()` : Convert `Option<T>` to `Option<&T>` and `Result<T, E>` to `Result<&T, &E>` \n- `as_mut()` : Converts `Option<T>` to `Option<&mut T>` and `Result<T, E>` to `Result<&mut T, &mut E>`\n","date":"2019-01-19T16:53:20.795Z","updated":"2019-01-19T16:53:20.795Z","path":"docs/e6.combinators.html","comments":1,"layout":"page","_id":"cjtfwbj00000vdwgpg6c74wnn","content":"<h2 id=\"What-is-a-combinator\"><a href=\"#What-is-a-combinator\" class=\"headerlink\" title=\"What is a combinator?\"></a>What is a combinator?</h2><ul>\n<li><p>One meaning of ‚Äúcombinator‚Äù is a more informal sense referring to the <strong>combinator pattern</strong>, a style of organizing libraries centered around the idea of combining things. Usually there is <strong>some type T</strong>, some <strong>functions for constructing ‚Äúprimitive‚Äù values of type T</strong>, and some ‚Äú<strong>combinators</strong>‚Äù which can <strong>combine values of type T</strong> in various ways to <strong>build up more complex values of type T</strong>. The other definition is <strong>‚Äúfunction with no free variables‚Äù</strong>.<br>__ <a href=\"https://wiki.haskell.org/Combinator\" target=\"_blank\" rel=\"noopener\">wiki.haskell.org</a></p>\n</li>\n<li><p>A combinator is <strong>a function</strong> which <strong>builds program fragments from program fragments</strong>; in a sense the programmer using combinators constructs much of the desired program automatically, rather that writing every detail by hand.<br>__ John Hughes‚Äî<a href=\"http://www.cse.chalmers.se/~rjmh/Papers/arrows.pdf\" target=\"_blank\" rel=\"noopener\">Generalizing Monads to Arrows</a> via <a href=\"https://github.com/caiorss/Functional-Programming/blob/master/haskell/Functional_Programming_Concepts.org\" target=\"_blank\" rel=\"noopener\">Functional Programming Concepts</a></p>\n</li>\n</ul>\n<p>The exact definition of ‚Äúcombinators‚Äù in Rust ecosystem is bit unclear. </p>\n<ul>\n<li><p><code>or()</code>, <code>and()</code>, <code>or_else()</code>, <code>and_then()</code><br>‚ñ∏ <strong>Combine two values of type T</strong> and <strong>return same type T</strong>.</p>\n</li>\n<li><p><code>filter()</code> for <code>Option</code> types<br>‚ñ∏ <strong>Filter type T</strong> by using a closure as a conditional function<br>‚ñ∏ <strong>Return same type T</strong></p>\n</li>\n<li><p><code>map()</code>, <code>map_err()</code><br>‚ñ∏ <strong>Convert type T by applying a closure</strong>.<br>‚ñ∏ The <strong>data type of the value inside T can be changed</strong>.<br>ex. <code>Some&lt;&amp;str&gt;</code> can be converted to <code>Some&lt;usize&gt;</code> or <code>Err&lt;&amp;str&gt;</code> to <code>Err&lt;isize&gt;</code> and etc.</p>\n</li>\n<li><p><code>map_or()</code>, <code>map_or_else()</code><br>‚ñ∏ <strong>Transform type T by applying a closure</strong> &amp; <strong>return the value inside type T</strong>.<br>‚ñ∏ For <strong><code>None</code> and <code>Err</code>, a default value or another closure</strong> is applied.</p>\n</li>\n<li><p><code>ok_or()</code>, <code>ok_or_else()</code> for <code>Option</code> types<br>‚ñ∏ <strong>Transform <code>Option</code> type into a <code>Result</code> type</strong>.</p>\n</li>\n<li><p><code>as_ref()</code>, <code>as_mut()</code><br>‚ñ∏ <strong>Transform type T into a reference or a mutable reference</strong>.</p>\n</li>\n</ul>\n<h2 id=\"or-and-and\"><a href=\"#or-and-and\" class=\"headerlink\" title=\"or() and and()\"></a>or() and and()</h2><p>While combining two expressions, which return either <code>Option</code>/ <code>Result</code></p>\n<ul>\n<li><code>or()</code>: If either one got <code>Some</code> or <code>Ok</code>, that value returns immediately.</li>\n<li><code>and()</code>: If both got <code>Some</code> or <code>Ok</code>, the value in the second expression returns. If either one got <code>None</code> or <code>Err</code> that value returns immediately.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n  let s1 = Some(&quot;some1&quot;);\n  let s2 = Some(&quot;some2&quot;);\n  let n: Option&lt;&amp;str&gt; = None;\n\n  let o1: Result&lt;&amp;str, &amp;str&gt; = Ok(&quot;ok1&quot;);\n  let o2: Result&lt;&amp;str, &amp;str&gt; = Ok(&quot;ok2&quot;);\n  let e1: Result&lt;&amp;str, &amp;str&gt; = Err(&quot;error1&quot;);\n  let e2: Result&lt;&amp;str, &amp;str&gt; = Err(&quot;error2&quot;);\n\n  assert_eq!(s1.or(s2), s1); // Some1 or Some2 = Some1\n  assert_eq!(s1.or(n), s1);  // Some or None = Some\n  assert_eq!(n.or(s1), s1);  // None or Some = Some\n  assert_eq!(n.or(n), n);    // None1 or None2 = None2\n\n  assert_eq!(o1.or(o2), o1); // Ok1 or Ok2 = Ok1\n  assert_eq!(o1.or(e1), o1); // Ok or Err = Ok\n  assert_eq!(e1.or(o1), o1); // Err or Ok = Ok\n  assert_eq!(e1.or(e2), e2); // Err1 or Err2 = Err2\n\n  assert_eq!(s1.and(s2), s2); // Some1 and Some2 = Some2\n  assert_eq!(s1.and(n), n);   // Some and None = None\n  assert_eq!(n.and(s1), n);   // None and Some = None\n  assert_eq!(n.and(n), n);    // None1 and None2 = None1\n\n  assert_eq!(o1.and(o2), o2); // Ok1 and Ok2 = Ok2\n  assert_eq!(o1.and(e1), e1); // Ok and Err = Err\n  assert_eq!(e1.and(o1), e1); // Err and Ok = Err\n  assert_eq!(e1.and(e2), e1); // Err1 and Err2 = Err1\n}\n</code></pre>\n<blockquote>\n<p>üîé Rust nightly support <a href=\"https://doc.rust-lang.org/std/option/enum.Option.html#method.xor\" target=\"_blank\" rel=\"noopener\"><code>xor()</code></a> for <code>Option</code> types, which returns <code>Some</code> only if one expression got <code>Some</code>, but not both.</p>\n</blockquote>\n<h2 id=\"or-else\"><a href=\"#or-else\" class=\"headerlink\" title=\"or_else()\"></a>or_else()</h2><p>Similar to <code>or()</code>. The only difference is, the second expression should be a <strong><a href=\"a7.functions.html#Closures\">closure</a></strong> which returns same type T.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    // or_else with Option\n    let s1 = Some(&quot;some1&quot;);\n    let s2 = Some(&quot;some2&quot;);\n    let fn_some = || Some(&quot;some2&quot;); // similar to: let fn_some = || -&gt; Option&lt;&amp;str&gt; { Some(&quot;some2&quot;) };\n\n    let n: Option&lt;&amp;str&gt; = None;\n    let fn_none = || None;\n\n    assert_eq!(s1.or_else(fn_some), s1);  // Some1 or_else Some2 = Some1\n    assert_eq!(s1.or_else(fn_none), s1);  // Some or_else None = Some\n    assert_eq!(n.or_else(fn_some), s2);   // None or_else Some = Some\n    assert_eq!(n.or_else(fn_none), None); // None1 or_else None2 = None2\n\n    // or_else with Result\n    let o1: Result&lt;&amp;str, &amp;str&gt; = Ok(&quot;ok1&quot;);\n    let o2: Result&lt;&amp;str, &amp;str&gt; = Ok(&quot;ok2&quot;);\n    let fn_ok = |_| Ok(&quot;ok2&quot;); // similar to: let fn_ok = |_| -&gt; Result&lt;&amp;str, &amp;str&gt; { Ok(&quot;ok2&quot;) };\n\n    let e1: Result&lt;&amp;str, &amp;str&gt; = Err(&quot;error1&quot;);\n    let e2: Result&lt;&amp;str, &amp;str&gt; = Err(&quot;error2&quot;);\n    let fn_err = |_| Err(&quot;error2&quot;);\n\n    assert_eq!(o1.or_else(fn_ok), o1);  // Ok1 or_else Ok2 = Ok1\n    assert_eq!(o1.or_else(fn_err), o1); // Ok or_else Err = Ok\n    assert_eq!(e1.or_else(fn_ok), o2);  // Err or_else Ok = Ok\n    assert_eq!(e1.or_else(fn_err), e2); // Err1 or_else Err2 = Err2\n}\n</code></pre>\n<h2 id=\"and-then\"><a href=\"#and-then\" class=\"headerlink\" title=\"and_then()\"></a>and_then()</h2><p>Similar to <code>and()</code>. The only difference is, the second expression should be a <strong><a href=\"a7.functions.html#Closures\">closure</a></strong> which returns same type T.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    // and_then with Option\n    let s1 = Some(&quot;some1&quot;);\n    let s2 = Some(&quot;some2&quot;);\n    let fn_some = |_| Some(&quot;some2&quot;); // similar to: let fn_some = |_| -&gt; Option&lt;&amp;str&gt; { Some(&quot;some2&quot;) };\n\n    let n: Option&lt;&amp;str&gt; = None;\n    let fn_none = |_| None;\n\n    assert_eq!(s1.and_then(fn_some), s2); // Some1 and_then Some2 = Some2\n    assert_eq!(s1.and_then(fn_none), n);  // Some and_then None = None\n    assert_eq!(n.and_then(fn_some), n);   // None and_then Some = None\n    assert_eq!(n.and_then(fn_none), n);   // None1 and_then None2 = None1\n\n    // and_then with Result\n    let o1: Result&lt;&amp;str, &amp;str&gt; = Ok(&quot;ok1&quot;);\n    let o2: Result&lt;&amp;str, &amp;str&gt; = Ok(&quot;ok2&quot;);\n    let fn_ok = |_| Ok(&quot;ok2&quot;); // similar to: let fn_ok = |_| -&gt; Result&lt;&amp;str, &amp;str&gt; { Ok(&quot;ok2&quot;) };\n\n    let e1: Result&lt;&amp;str, &amp;str&gt; = Err(&quot;error1&quot;);\n    let e2: Result&lt;&amp;str, &amp;str&gt; = Err(&quot;error2&quot;);\n    let fn_err = |_| Err(&quot;error2&quot;);\n\n    assert_eq!(o1.and_then(fn_ok), o2);  // Ok1 and_then Ok2 = Ok2\n    assert_eq!(o1.and_then(fn_err), e2); // Ok and_then Err = Err\n    assert_eq!(e1.and_then(fn_ok), e1);  // Err and_then Ok = Err\n    assert_eq!(e1.and_then(fn_err), e1); // Err1 and_then Err2 = Err1\n}\n</code></pre>\n<h2 id=\"filter\"><a href=\"#filter\" class=\"headerlink\" title=\"filter()\"></a>filter()</h2><blockquote>\n<p>üí° Usually in programming languages <code>filter</code> functions are used with arrays or iterators to create a new array/ iterator by filtering own elements via a function/ closure. Rust also provides <a href=\"https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.filter\" target=\"_blank\" rel=\"noopener\"><code>filter()</code> <strong>as an iterator adaptor</strong></a> to apply a closure on each element of an iterator to transform it into another iterator. However in here we are talking about the functionality of <code>filter()</code> with <code>Option</code> types.</p>\n</blockquote>\n<p>The same <code>Some</code> type is returned, only if we pass a <code>Some</code> value and the given closure returned true for it. <code>None</code> is returned, if <code>None</code> type passed or the closure returned false. The closure uses the value inside <code>Some</code> as an argument. Still Rust support <code>filter()</code> only for <code>Option</code> types.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let s1 = Some(3);\n    let s2 = Some(6);\n    let n = None;\n\n    let fn_is_even = |x: &amp;i8| x % 2 == 0;\n\n    assert_eq!(s1.filter(fn_is_even), n);  // Some(3) -&gt; 3 is not even -&gt; None\n    assert_eq!(s2.filter(fn_is_even), s2); // Some(6) -&gt; 6 is even -&gt; Some(6)\n    assert_eq!(n.filter(fn_is_even), n);   // None -&gt; no value -&gt; None\n}\n</code></pre>\n<h2 id=\"map-and-map-err\"><a href=\"#map-and-map-err\" class=\"headerlink\" title=\"map() and map_err()\"></a>map() and map_err()</h2><blockquote>\n<p>üí° Usually in programming languages <code>map()</code> functions are used with arrays or iterators, <strong>to apply a closure on each element</strong> of the array or iterator. Rust also provides <a href=\"https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.map\" target=\"_blank\" rel=\"noopener\"><code>map()</code> <strong>as an iterator adaptor</strong></a> to apply a closure on each element of an iterator to transform it into another iterator. However in here we are talking about the functionality of <code>map()</code> with <code>Option</code> and <code>Result</code> types. </p>\n</blockquote>\n<ul>\n<li><code>map()</code> : Convert type T by applying a closure. <strong>The data type of <code>Some</code> or <code>Ok</code> blocks can be changed</strong> according to the return type of the closure. Convert <code>Option&lt;T&gt;</code> to <code>Option&lt;U&gt;</code>, <code>Result&lt;T, E&gt;</code> to <code>Result&lt;U, E&gt;</code></li>\n</ul>\n<p>‚≠ê Via <code>map()</code>, only <code>Some</code> and <code>Ok</code> values are getting changed. No affect to the values inside <code>Err</code> (<code>None</code> doesn‚Äôt contain any value at all).</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let s1 = Some(&quot;abcde&quot;);\n    let s2 = Some(5);\n\n    let n1: Option&lt;&amp;str&gt; = None;\n    let n2: Option&lt;usize&gt; = None;\n\n    let o1: Result&lt;&amp;str, &amp;str&gt; = Ok(&quot;abcde&quot;);\n    let o2: Result&lt;usize, &amp;str&gt; = Ok(5);\n\n    let e1: Result&lt;&amp;str, &amp;str&gt; = Err(&quot;abcde&quot;);\n    let e2: Result&lt;usize, &amp;str&gt; = Err(&quot;abcde&quot;);\n\n    let fn_character_count = |s: &amp;str| s.chars().count();\n\n    assert_eq!(s1.map(fn_character_count), s2); // Some1 map = Some2\n    assert_eq!(n1.map(fn_character_count), n2); // None1 map = None2\n\n    assert_eq!(o1.map(fn_character_count), o2); // Ok1 map = Ok2\n    assert_eq!(e1.map(fn_character_count), e2); // Err1 map = Err2\n}\n</code></pre>\n<ul>\n<li><code>map_err()</code> for <code>Result</code> types : <strong>The data type of <code>Err</code> blocks can be changed</strong> according to the return type of the closure. Convert <code>Result&lt;T, E&gt;</code> to <code>Result&lt;T, F&gt;</code>.</li>\n</ul>\n<p>‚≠ê Via <code>map_err()</code>, only <code>Err</code> values are getting changed. No affect to the values inside <code>Ok</code>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let o1: Result&lt;&amp;str, &amp;str&gt; = Ok(&quot;abcde&quot;);\n    let o2: Result&lt;&amp;str, isize&gt; = Ok(&quot;abcde&quot;);\n\n    let e1: Result&lt;&amp;str, &amp;str&gt; = Err(&quot;404&quot;);\n    let e2: Result&lt;&amp;str, isize&gt; = Err(404);\n\n    let fn_character_count = |s: &amp;str| -&gt; isize { s.parse().unwrap() }; // convert str to isize\n\n    assert_eq!(o1.map_err(fn_character_count), o2); // Ok1 map = Ok2\n    assert_eq!(e1.map_err(fn_character_count), e2); // Err1 map = Err2\n}\n</code></pre>\n<h2 id=\"map-or-and-map-or-else\"><a href=\"#map-or-and-map-or-else\" class=\"headerlink\" title=\"map_or() and map_or_else()\"></a>map_or() and map_or_else()</h2><p>Hope you remember the functionality of <a href=\"e4.unwrap_and_expect.html#unwrap-or-unwrap-or-default-and-unwrap-or-else\"><code>unwrap_or()</code> and <code>unwrap_or_else()</code></a> functions. These functions also bit similar to them. But <code>map_or()</code> and <code>map_or_else()</code> apply a closure on <code>Some</code> and <code>Ok</code> values and <strong>return the value inside type T</strong>.</p>\n<ul>\n<li><code>map_or()</code> : Support only for <code>Option</code> types (not supporting <code>Result</code>). Apply the closure to the value inside <code>Some</code> and return the output according to the closure. The given default value is returned for <code>None</code> types.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    const V_DEFAULT: i8 = 1;\n\n    let s = Some(10);\n    let n: Option&lt;i8&gt; = None;\n    let fn_closure = |v: i8| v + 2;\n\n    assert_eq!(s.map_or(V_DEFAULT, fn_closure), 12);\n    assert_eq!(n.map_or(V_DEFAULT, fn_closure), V_DEFAULT);\n}\n</code></pre>\n<ul>\n<li><code>map_or_else()</code> : Support for both <code>Option</code> and <code>Result</code> types (<code>Result</code> still nightly only). Similar to <code>map_or()</code> but should provide another closure instead a default value for the first parameter.</li>\n</ul>\n<p>‚≠ê <code>None</code> types doesn‚Äôt contain any value. So no need to pass anything to the closure as input with <code>Option</code> types. But <code>Err</code> types contain some value inside it. So default closure should able to read it as an input, while using this with <code>Result</code> types.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">#![feature(result_map_or_else)] // enable unstable library feature &#39;result_map_or_else&#39; on nightly\nfn main() {\n    let s = Some(10);\n    let n: Option&lt;i8&gt; = None;\n\n    let fn_closure = |v: i8| v + 2;\n    let fn_default = || 1; // None doesn&#39;t contain any value. So no need to pass anything to closure as input.\n\n    assert_eq!(s.map_or_else(fn_default, fn_closure), 12);\n    assert_eq!(n.map_or_else(fn_default, fn_closure), 1);\n\n    let o = Ok(10);\n    let e = Err(5);\n    let fn_default_for_result = |v: i8| v + 1; // Err contain some value inside it. So default closure should able to read it as input\n\n    assert_eq!(o.map_or_else(fn_default_for_result, fn_closure), 12);\n    assert_eq!(e.map_or_else(fn_default_for_result, fn_closure), 6);\n}\n</code></pre>\n<h2 id=\"ok-or-and-ok-or-else\"><a href=\"#ok-or-and-ok-or-else\" class=\"headerlink\" title=\"ok_or() and ok_or_else()\"></a>ok_or() and ok_or_else()</h2><p>As mentioned earlier, <code>ok_or()</code>, <code>ok_or_else()</code> transform <code>Option</code> type into <code>Result</code> type. <strong><code>Some</code> to <code>Ok</code> and <code>None</code> to <code>Err</code></strong>.</p>\n<ul>\n<li><code>ok_or()</code> : A default <code>Err</code> message should pass as argument.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    const ERR_DEFAULT: &amp;str = &quot;error message&quot;;\n\n    let s = Some(&quot;abcde&quot;);\n    let n: Option&lt;&amp;str&gt; = None;\n\n    let o: Result&lt;&amp;str, &amp;str&gt; = Ok(&quot;abcde&quot;);\n    let e: Result&lt;&amp;str, &amp;str&gt; = Err(ERR_DEFAULT);\n\n    assert_eq!(s.ok_or(ERR_DEFAULT), o); // Some(T) -&gt; Ok(T)\n    assert_eq!(n.ok_or(ERR_DEFAULT), e); // None -&gt; Err(default)\n}\n</code></pre>\n<ul>\n<li><code>ok_or_else()</code> : Similar to <code>ok_or()</code>. A closure should be passed as the argument.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let s = Some(&quot;abcde&quot;);\n    let n: Option&lt;&amp;str&gt; = None;\n    let fn_err_message = || &quot;error message&quot;;\n\n    let o: Result&lt;&amp;str, &amp;str&gt; = Ok(&quot;abcde&quot;);\n    let e: Result&lt;&amp;str, &amp;str&gt; = Err(&quot;error message&quot;);\n\n    assert_eq!(s.ok_or_else(fn_err_message), o); // Some(T) -&gt; Ok(T)\n    assert_eq!(n.ok_or_else(fn_err_message), e); // None -&gt; Err(default)\n}\n</code></pre>\n<h2 id=\"as-ref-and-as-mut\"><a href=\"#as-ref-and-as-mut\" class=\"headerlink\" title=\"as_ref() and as_mut()\"></a>as_ref() and as_mut()</h2><p>üîé As mentioned earlier, these functions are used to <strong>borrow type T as a reference or as a mutable reference</strong>.</p>\n<ul>\n<li><code>as_ref()</code> : Convert <code>Option&lt;T&gt;</code> to <code>Option&lt;&amp;T&gt;</code> and <code>Result&lt;T, E&gt;</code> to <code>Result&lt;&amp;T, &amp;E&gt;</code> </li>\n<li><code>as_mut()</code> : Converts <code>Option&lt;T&gt;</code> to <code>Option&lt;&amp;mut T&gt;</code> and <code>Result&lt;T, E&gt;</code> to <code>Result&lt;&amp;mut T, &amp;mut E&gt;</code></li>\n</ul>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<h2 id=\"What-is-a-combinator\"><a href=\"#What-is-a-combinator\" class=\"headerlink\" title=\"What is a combinator?\"></a>What is a combinator?</h2><ul>\n<li><p>One meaning of ‚Äúcombinator‚Äù is a more informal sense referring to the <strong>combinator pattern</strong>, a style of organizing libraries centered around the idea of combining things. Usually there is <strong>some type T</strong>, some <strong>functions for constructing ‚Äúprimitive‚Äù values of type T</strong>, and some ‚Äú<strong>combinators</strong>‚Äù which can <strong>combine values of type T</strong> in various ways to <strong>build up more complex values of type T</strong>. The other definition is <strong>‚Äúfunction with no free variables‚Äù</strong>.<br>__ <a href=\"https://wiki.haskell.org/Combinator\" target=\"_blank\" rel=\"noopener\">wiki.haskell.org</a></p>\n</li>\n<li><p>A combinator is <strong>a function</strong> which <strong>builds program fragments from program fragments</strong>; in a sense the programmer using combinators constructs much of the desired program automatically, rather that writing every detail by hand.<br>__ John Hughes‚Äî<a href=\"http://www.cse.chalmers.se/~rjmh/Papers/arrows.pdf\" target=\"_blank\" rel=\"noopener\">Generalizing Monads to Arrows</a> via <a href=\"https://github.com/caiorss/Functional-Programming/blob/master/haskell/Functional_Programming_Concepts.org\" target=\"_blank\" rel=\"noopener\">Functional Programming Concepts</a></p>\n</li>\n</ul>\n<p>The exact definition of ‚Äúcombinators‚Äù in Rust ecosystem is bit unclear. </p>\n<ul>\n<li><p><code>or()</code>, <code>and()</code>, <code>or_else()</code>, <code>and_then()</code><br>‚ñ∏ <strong>Combine two values of type T</strong> and <strong>return same type T</strong>.</p>\n</li>\n<li><p><code>filter()</code> for <code>Option</code> types<br>‚ñ∏ <strong>Filter type T</strong> by using a closure as a conditional function<br>‚ñ∏ <strong>Return same type T</strong></p>\n</li>\n<li><p><code>map()</code>, <code>map_err()</code><br>‚ñ∏ <strong>Convert type T by applying a closure</strong>.<br>‚ñ∏ The <strong>data type of the value inside T can be changed</strong>.<br>ex. <code>Some&lt;&amp;str&gt;</code> can be converted to <code>Some&lt;usize&gt;</code> or <code>Err&lt;&amp;str&gt;</code> to <code>Err&lt;isize&gt;</code> and etc.</p>\n</li>\n<li><p><code>map_or()</code>, <code>map_or_else()</code><br>‚ñ∏ <strong>Transform type T by applying a closure</strong> &amp; <strong>return the value inside type T</strong>.<br>‚ñ∏ For <strong><code>None</code> and <code>Err</code>, a default value or another closure</strong> is applied.</p>\n</li>\n<li><p><code>ok_or()</code>, <code>ok_or_else()</code> for <code>Option</code> types<br>‚ñ∏ <strong>Transform <code>Option</code> type into a <code>Result</code> type</strong>.</p>\n</li>\n<li><p><code>as_ref()</code>, <code>as_mut()</code><br>‚ñ∏ <strong>Transform type T into a reference or a mutable reference</strong>.</p>\n</li>\n</ul>\n<h2 id=\"or-and-and\"><a href=\"#or-and-and\" class=\"headerlink\" title=\"or() and and()\"></a>or() and and()</h2><p>While combining two expressions, which return either <code>Option</code>/ <code>Result</code></p>\n<ul>\n<li><code>or()</code>: If either one got <code>Some</code> or <code>Ok</code>, that value returns immediately.</li>\n<li><code>and()</code>: If both got <code>Some</code> or <code>Ok</code>, the value in the second expression returns. If either one got <code>None</code> or <code>Err</code> that value returns immediately.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n  let s1 = Some(&quot;some1&quot;);\n  let s2 = Some(&quot;some2&quot;);\n  let n: Option&lt;&amp;str&gt; = None;\n\n  let o1: Result&lt;&amp;str, &amp;str&gt; = Ok(&quot;ok1&quot;);\n  let o2: Result&lt;&amp;str, &amp;str&gt; = Ok(&quot;ok2&quot;);\n  let e1: Result&lt;&amp;str, &amp;str&gt; = Err(&quot;error1&quot;);\n  let e2: Result&lt;&amp;str, &amp;str&gt; = Err(&quot;error2&quot;);\n\n  assert_eq!(s1.or(s2), s1); // Some1 or Some2 = Some1\n  assert_eq!(s1.or(n), s1);  // Some or None = Some\n  assert_eq!(n.or(s1), s1);  // None or Some = Some\n  assert_eq!(n.or(n), n);    // None1 or None2 = None2\n\n  assert_eq!(o1.or(o2), o1); // Ok1 or Ok2 = Ok1\n  assert_eq!(o1.or(e1), o1); // Ok or Err = Ok\n  assert_eq!(e1.or(o1), o1); // Err or Ok = Ok\n  assert_eq!(e1.or(e2), e2); // Err1 or Err2 = Err2\n\n  assert_eq!(s1.and(s2), s2); // Some1 and Some2 = Some2\n  assert_eq!(s1.and(n), n);   // Some and None = None\n  assert_eq!(n.and(s1), n);   // None and Some = None\n  assert_eq!(n.and(n), n);    // None1 and None2 = None1\n\n  assert_eq!(o1.and(o2), o2); // Ok1 and Ok2 = Ok2\n  assert_eq!(o1.and(e1), e1); // Ok and Err = Err\n  assert_eq!(e1.and(o1), e1); // Err and Ok = Err\n  assert_eq!(e1.and(e2), e1); // Err1 and Err2 = Err1\n}\n</code></pre>\n<blockquote>\n<p>üîé Rust nightly support <a href=\"https://doc.rust-lang.org/std/option/enum.Option.html#method.xor\" target=\"_blank\" rel=\"noopener\"><code>xor()</code></a> for <code>Option</code> types, which returns <code>Some</code> only if one expression got <code>Some</code>, but not both.</p>\n</blockquote>\n<h2 id=\"or-else\"><a href=\"#or-else\" class=\"headerlink\" title=\"or_else()\"></a>or_else()</h2><p>Similar to <code>or()</code>. The only difference is, the second expression should be a <strong><a href=\"a7.functions.html#Closures\">closure</a></strong> which returns same type T.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    // or_else with Option\n    let s1 = Some(&quot;some1&quot;);\n    let s2 = Some(&quot;some2&quot;);\n    let fn_some = || Some(&quot;some2&quot;); // similar to: let fn_some = || -&gt; Option&lt;&amp;str&gt; { Some(&quot;some2&quot;) };\n\n    let n: Option&lt;&amp;str&gt; = None;\n    let fn_none = || None;\n\n    assert_eq!(s1.or_else(fn_some), s1);  // Some1 or_else Some2 = Some1\n    assert_eq!(s1.or_else(fn_none), s1);  // Some or_else None = Some\n    assert_eq!(n.or_else(fn_some), s2);   // None or_else Some = Some\n    assert_eq!(n.or_else(fn_none), None); // None1 or_else None2 = None2\n\n    // or_else with Result\n    let o1: Result&lt;&amp;str, &amp;str&gt; = Ok(&quot;ok1&quot;);\n    let o2: Result&lt;&amp;str, &amp;str&gt; = Ok(&quot;ok2&quot;);\n    let fn_ok = |_| Ok(&quot;ok2&quot;); // similar to: let fn_ok = |_| -&gt; Result&lt;&amp;str, &amp;str&gt; { Ok(&quot;ok2&quot;) };\n\n    let e1: Result&lt;&amp;str, &amp;str&gt; = Err(&quot;error1&quot;);\n    let e2: Result&lt;&amp;str, &amp;str&gt; = Err(&quot;error2&quot;);\n    let fn_err = |_| Err(&quot;error2&quot;);\n\n    assert_eq!(o1.or_else(fn_ok), o1);  // Ok1 or_else Ok2 = Ok1\n    assert_eq!(o1.or_else(fn_err), o1); // Ok or_else Err = Ok\n    assert_eq!(e1.or_else(fn_ok), o2);  // Err or_else Ok = Ok\n    assert_eq!(e1.or_else(fn_err), e2); // Err1 or_else Err2 = Err2\n}\n</code></pre>\n<h2 id=\"and-then\"><a href=\"#and-then\" class=\"headerlink\" title=\"and_then()\"></a>and_then()</h2><p>Similar to <code>and()</code>. The only difference is, the second expression should be a <strong><a href=\"a7.functions.html#Closures\">closure</a></strong> which returns same type T.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    // and_then with Option\n    let s1 = Some(&quot;some1&quot;);\n    let s2 = Some(&quot;some2&quot;);\n    let fn_some = |_| Some(&quot;some2&quot;); // similar to: let fn_some = |_| -&gt; Option&lt;&amp;str&gt; { Some(&quot;some2&quot;) };\n\n    let n: Option&lt;&amp;str&gt; = None;\n    let fn_none = |_| None;\n\n    assert_eq!(s1.and_then(fn_some), s2); // Some1 and_then Some2 = Some2\n    assert_eq!(s1.and_then(fn_none), n);  // Some and_then None = None\n    assert_eq!(n.and_then(fn_some), n);   // None and_then Some = None\n    assert_eq!(n.and_then(fn_none), n);   // None1 and_then None2 = None1\n\n    // and_then with Result\n    let o1: Result&lt;&amp;str, &amp;str&gt; = Ok(&quot;ok1&quot;);\n    let o2: Result&lt;&amp;str, &amp;str&gt; = Ok(&quot;ok2&quot;);\n    let fn_ok = |_| Ok(&quot;ok2&quot;); // similar to: let fn_ok = |_| -&gt; Result&lt;&amp;str, &amp;str&gt; { Ok(&quot;ok2&quot;) };\n\n    let e1: Result&lt;&amp;str, &amp;str&gt; = Err(&quot;error1&quot;);\n    let e2: Result&lt;&amp;str, &amp;str&gt; = Err(&quot;error2&quot;);\n    let fn_err = |_| Err(&quot;error2&quot;);\n\n    assert_eq!(o1.and_then(fn_ok), o2);  // Ok1 and_then Ok2 = Ok2\n    assert_eq!(o1.and_then(fn_err), e2); // Ok and_then Err = Err\n    assert_eq!(e1.and_then(fn_ok), e1);  // Err and_then Ok = Err\n    assert_eq!(e1.and_then(fn_err), e1); // Err1 and_then Err2 = Err1\n}\n</code></pre>\n<h2 id=\"filter\"><a href=\"#filter\" class=\"headerlink\" title=\"filter()\"></a>filter()</h2><blockquote>\n<p>üí° Usually in programming languages <code>filter</code> functions are used with arrays or iterators to create a new array/ iterator by filtering own elements via a function/ closure. Rust also provides <a href=\"https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.filter\" target=\"_blank\" rel=\"noopener\"><code>filter()</code> <strong>as an iterator adaptor</strong></a> to apply a closure on each element of an iterator to transform it into another iterator. However in here we are talking about the functionality of <code>filter()</code> with <code>Option</code> types.</p>\n</blockquote>\n<p>The same <code>Some</code> type is returned, only if we pass a <code>Some</code> value and the given closure returned true for it. <code>None</code> is returned, if <code>None</code> type passed or the closure returned false. The closure uses the value inside <code>Some</code> as an argument. Still Rust support <code>filter()</code> only for <code>Option</code> types.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let s1 = Some(3);\n    let s2 = Some(6);\n    let n = None;\n\n    let fn_is_even = |x: &amp;i8| x % 2 == 0;\n\n    assert_eq!(s1.filter(fn_is_even), n);  // Some(3) -&gt; 3 is not even -&gt; None\n    assert_eq!(s2.filter(fn_is_even), s2); // Some(6) -&gt; 6 is even -&gt; Some(6)\n    assert_eq!(n.filter(fn_is_even), n);   // None -&gt; no value -&gt; None\n}\n</code></pre>\n<h2 id=\"map-and-map-err\"><a href=\"#map-and-map-err\" class=\"headerlink\" title=\"map() and map_err()\"></a>map() and map_err()</h2><blockquote>\n<p>üí° Usually in programming languages <code>map()</code> functions are used with arrays or iterators, <strong>to apply a closure on each element</strong> of the array or iterator. Rust also provides <a href=\"https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.map\" target=\"_blank\" rel=\"noopener\"><code>map()</code> <strong>as an iterator adaptor</strong></a> to apply a closure on each element of an iterator to transform it into another iterator. However in here we are talking about the functionality of <code>map()</code> with <code>Option</code> and <code>Result</code> types. </p>\n</blockquote>\n<ul>\n<li><code>map()</code> : Convert type T by applying a closure. <strong>The data type of <code>Some</code> or <code>Ok</code> blocks can be changed</strong> according to the return type of the closure. Convert <code>Option&lt;T&gt;</code> to <code>Option&lt;U&gt;</code>, <code>Result&lt;T, E&gt;</code> to <code>Result&lt;U, E&gt;</code></li>\n</ul>\n<p>‚≠ê Via <code>map()</code>, only <code>Some</code> and <code>Ok</code> values are getting changed. No affect to the values inside <code>Err</code> (<code>None</code> doesn‚Äôt contain any value at all).</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let s1 = Some(&quot;abcde&quot;);\n    let s2 = Some(5);\n\n    let n1: Option&lt;&amp;str&gt; = None;\n    let n2: Option&lt;usize&gt; = None;\n\n    let o1: Result&lt;&amp;str, &amp;str&gt; = Ok(&quot;abcde&quot;);\n    let o2: Result&lt;usize, &amp;str&gt; = Ok(5);\n\n    let e1: Result&lt;&amp;str, &amp;str&gt; = Err(&quot;abcde&quot;);\n    let e2: Result&lt;usize, &amp;str&gt; = Err(&quot;abcde&quot;);\n\n    let fn_character_count = |s: &amp;str| s.chars().count();\n\n    assert_eq!(s1.map(fn_character_count), s2); // Some1 map = Some2\n    assert_eq!(n1.map(fn_character_count), n2); // None1 map = None2\n\n    assert_eq!(o1.map(fn_character_count), o2); // Ok1 map = Ok2\n    assert_eq!(e1.map(fn_character_count), e2); // Err1 map = Err2\n}\n</code></pre>\n<ul>\n<li><code>map_err()</code> for <code>Result</code> types : <strong>The data type of <code>Err</code> blocks can be changed</strong> according to the return type of the closure. Convert <code>Result&lt;T, E&gt;</code> to <code>Result&lt;T, F&gt;</code>.</li>\n</ul>\n<p>‚≠ê Via <code>map_err()</code>, only <code>Err</code> values are getting changed. No affect to the values inside <code>Ok</code>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let o1: Result&lt;&amp;str, &amp;str&gt; = Ok(&quot;abcde&quot;);\n    let o2: Result&lt;&amp;str, isize&gt; = Ok(&quot;abcde&quot;);\n\n    let e1: Result&lt;&amp;str, &amp;str&gt; = Err(&quot;404&quot;);\n    let e2: Result&lt;&amp;str, isize&gt; = Err(404);\n\n    let fn_character_count = |s: &amp;str| -&gt; isize { s.parse().unwrap() }; // convert str to isize\n\n    assert_eq!(o1.map_err(fn_character_count), o2); // Ok1 map = Ok2\n    assert_eq!(e1.map_err(fn_character_count), e2); // Err1 map = Err2\n}\n</code></pre>\n<h2 id=\"map-or-and-map-or-else\"><a href=\"#map-or-and-map-or-else\" class=\"headerlink\" title=\"map_or() and map_or_else()\"></a>map_or() and map_or_else()</h2><p>Hope you remember the functionality of <a href=\"e4.unwrap_and_expect.html#unwrap-or-unwrap-or-default-and-unwrap-or-else\"><code>unwrap_or()</code> and <code>unwrap_or_else()</code></a> functions. These functions also bit similar to them. But <code>map_or()</code> and <code>map_or_else()</code> apply a closure on <code>Some</code> and <code>Ok</code> values and <strong>return the value inside type T</strong>.</p>\n<ul>\n<li><code>map_or()</code> : Support only for <code>Option</code> types (not supporting <code>Result</code>). Apply the closure to the value inside <code>Some</code> and return the output according to the closure. The given default value is returned for <code>None</code> types.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    const V_DEFAULT: i8 = 1;\n\n    let s = Some(10);\n    let n: Option&lt;i8&gt; = None;\n    let fn_closure = |v: i8| v + 2;\n\n    assert_eq!(s.map_or(V_DEFAULT, fn_closure), 12);\n    assert_eq!(n.map_or(V_DEFAULT, fn_closure), V_DEFAULT);\n}\n</code></pre>\n<ul>\n<li><code>map_or_else()</code> : Support for both <code>Option</code> and <code>Result</code> types (<code>Result</code> still nightly only). Similar to <code>map_or()</code> but should provide another closure instead a default value for the first parameter.</li>\n</ul>\n<p>‚≠ê <code>None</code> types doesn‚Äôt contain any value. So no need to pass anything to the closure as input with <code>Option</code> types. But <code>Err</code> types contain some value inside it. So default closure should able to read it as an input, while using this with <code>Result</code> types.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">#![feature(result_map_or_else)] // enable unstable library feature &#39;result_map_or_else&#39; on nightly\nfn main() {\n    let s = Some(10);\n    let n: Option&lt;i8&gt; = None;\n\n    let fn_closure = |v: i8| v + 2;\n    let fn_default = || 1; // None doesn&#39;t contain any value. So no need to pass anything to closure as input.\n\n    assert_eq!(s.map_or_else(fn_default, fn_closure), 12);\n    assert_eq!(n.map_or_else(fn_default, fn_closure), 1);\n\n    let o = Ok(10);\n    let e = Err(5);\n    let fn_default_for_result = |v: i8| v + 1; // Err contain some value inside it. So default closure should able to read it as input\n\n    assert_eq!(o.map_or_else(fn_default_for_result, fn_closure), 12);\n    assert_eq!(e.map_or_else(fn_default_for_result, fn_closure), 6);\n}\n</code></pre>\n<h2 id=\"ok-or-and-ok-or-else\"><a href=\"#ok-or-and-ok-or-else\" class=\"headerlink\" title=\"ok_or() and ok_or_else()\"></a>ok_or() and ok_or_else()</h2><p>As mentioned earlier, <code>ok_or()</code>, <code>ok_or_else()</code> transform <code>Option</code> type into <code>Result</code> type. <strong><code>Some</code> to <code>Ok</code> and <code>None</code> to <code>Err</code></strong>.</p>\n<ul>\n<li><code>ok_or()</code> : A default <code>Err</code> message should pass as argument.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    const ERR_DEFAULT: &amp;str = &quot;error message&quot;;\n\n    let s = Some(&quot;abcde&quot;);\n    let n: Option&lt;&amp;str&gt; = None;\n\n    let o: Result&lt;&amp;str, &amp;str&gt; = Ok(&quot;abcde&quot;);\n    let e: Result&lt;&amp;str, &amp;str&gt; = Err(ERR_DEFAULT);\n\n    assert_eq!(s.ok_or(ERR_DEFAULT), o); // Some(T) -&gt; Ok(T)\n    assert_eq!(n.ok_or(ERR_DEFAULT), e); // None -&gt; Err(default)\n}\n</code></pre>\n<ul>\n<li><code>ok_or_else()</code> : Similar to <code>ok_or()</code>. A closure should be passed as the argument.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let s = Some(&quot;abcde&quot;);\n    let n: Option&lt;&amp;str&gt; = None;\n    let fn_err_message = || &quot;error message&quot;;\n\n    let o: Result&lt;&amp;str, &amp;str&gt; = Ok(&quot;abcde&quot;);\n    let e: Result&lt;&amp;str, &amp;str&gt; = Err(&quot;error message&quot;);\n\n    assert_eq!(s.ok_or_else(fn_err_message), o); // Some(T) -&gt; Ok(T)\n    assert_eq!(n.ok_or_else(fn_err_message), e); // None -&gt; Err(default)\n}\n</code></pre>\n<h2 id=\"as-ref-and-as-mut\"><a href=\"#as-ref-and-as-mut\" class=\"headerlink\" title=\"as_ref() and as_mut()\"></a>as_ref() and as_mut()</h2><p>üîé As mentioned earlier, these functions are used to <strong>borrow type T as a reference or as a mutable reference</strong>.</p>\n<ul>\n<li><code>as_ref()</code> : Convert <code>Option&lt;T&gt;</code> to <code>Option&lt;&amp;T&gt;</code> and <code>Result&lt;T, E&gt;</code> to <code>Result&lt;&amp;T, &amp;E&gt;</code> </li>\n<li><code>as_mut()</code> : Converts <code>Option&lt;T&gt;</code> to <code>Option&lt;&amp;mut T&gt;</code> and <code>Result&lt;T, E&gt;</code> to <code>Result&lt;&amp;mut T, &amp;mut E&gt;</code></li>\n</ul>\n"},{"title":"Overview","_content":"\nThis is based on the posts I wrote on **Medium**, https://medium.com/learning-rust\n\n[![Rust Playground](images/learning_rust_medium.png)](https://medium.com/learning-rust)\n\n> üê£ I am a **Sri Lankan** üá±üá∞ Web Developer who lives in **Vietnam** üáªüá≥. So I am not a native English speaker and just learning Rust, If you found any mistake or something need to be changed, even a spelling or a grammar mistake, feel free to create a pull request. Thanks.","source":"docs/index.md","raw":"title: Overview\n---\n\nThis is based on the posts I wrote on **Medium**, https://medium.com/learning-rust\n\n[![Rust Playground](images/learning_rust_medium.png)](https://medium.com/learning-rust)\n\n> üê£ I am a **Sri Lankan** üá±üá∞ Web Developer who lives in **Vietnam** üáªüá≥. So I am not a native English speaker and just learning Rust, If you found any mistake or something need to be changed, even a spelling or a grammar mistake, feel free to create a pull request. Thanks.","date":"2019-01-19T16:53:20.797Z","updated":"2019-01-19T16:53:20.797Z","path":"docs/index.html","comments":1,"layout":"page","_id":"cjtfwbj01000wdwgpbpcltvgj","content":"<p>This is based on the posts I wrote on <strong>Medium</strong>, <a href=\"https://medium.com/learning-rust\" target=\"_blank\" rel=\"noopener\">https://medium.com/learning-rust</a></p>\n<p><a href=\"https://medium.com/learning-rust\" target=\"_blank\" rel=\"noopener\"><img src=\"images/learning_rust_medium.png\" alt=\"Rust Playground\"></a></p>\n<blockquote>\n<p>üê£ I am a <strong>Sri Lankan</strong> üá±üá∞ Web Developer who lives in <strong>Vietnam</strong> üáªüá≥. So I am not a native English speaker and just learning Rust, If you found any mistake or something need to be changed, even a spelling or a grammar mistake, feel free to create a pull request. Thanks.</p>\n</blockquote>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<p>This is based on the posts I wrote on <strong>Medium</strong>, <a href=\"https://medium.com/learning-rust\" target=\"_blank\" rel=\"noopener\">https://medium.com/learning-rust</a></p>\n<p><a href=\"https://medium.com/learning-rust\" target=\"_blank\" rel=\"noopener\"><img src=\"images/learning_rust_medium.png\" alt=\"Rust Playground\"></a></p>\n<blockquote>\n<p>üê£ I am a <strong>Sri Lankan</strong> üá±üá∞ Web Developer who lives in <strong>Vietnam</strong> üáªüá≥. So I am not a native English speaker and just learning Rust, If you found any mistake or something need to be changed, even a spelling or a grammar mistake, feel free to create a pull request. Thanks.</p>\n</blockquote>\n"},{"layout":"index","description":"Hexo is a fast, simple & powerful blog framework powered by Node.js.","subtitle":"Learning Rust","lang":"zh-cn","_content":"ul#intro-feature-list\n  li.intro-feature-wrap\n    .intro-feature\n      .intro-feature-icon\n        i.fa.fa-street-view\n      h3.intro-feature-title\n        a(href='/docs/zh-cn/a1.why_rust.html') Âü∫Á°ÄÁü•ËØÜ\n      p.intro-feature-desc Â¶Ç‰ΩïÂÆâË£ÖÔºåHello WorldÔºåCargoÔºåCratesÔºåÂèòÈáèÁªëÂÆöÔºåÂáΩÊï∞ÔºåÂéüÁîüÊï∞ÊçÆÁ±ªÂûãÔºåÊìç‰Ωú‰∏éÊéßÂà∂ÊµÅ„ÄÇ\n  li.intro-feature-wrap\n    .intro-feature\n      .intro-feature-icon\n        i.fa.fa-road\n      h3.intro-feature-title\n        a(href='/docs/zh-cn/b1.vectors.html') Âü∫Á°Ä‰πã‰∏ä\n      p.intro-feature-desc VectorsÔºåÁªìÊûÑ‰ΩìÔºàStructsÔºâÔºåÊûö‰∏æÔºàEnumsÔºâÔºåËåÉÂûãÔºàGenericsÔºâÔºåÁâπÊÄß‰∏éÁâπÊÄßÂÆûÁé∞ÔºàImpls & TraitsÔºâ„ÄÇ\n  li.intro-feature-wrap\n    .intro-feature\n      .intro-feature-icon\n        i.fa.fa-plane\n      h3.intro-feature-title\n        a(href='/docs/zh-cn/c1.ownership.html') ÈöæÂïÉÁöÑÈÉ®ÂàÜ\n      p.intro-feature-desc ÊâÄÊúâÊùÉÔºàOwnershipÔºâÔºåÊâÄÊúâÊùÉÂÄüÁî®ÔºàBorrowingÔºâÔºåÁîüÂ≠òÊúü‰∏éÁîüÂ≠òÊúüÁúÅÁï•ÔºàLifetimes & Lifetime ElisionÔºâ„ÄÇ\n  li.intro-feature-wrap\n    .intro-feature\n      .intro-feature-icon\n        i.fa.fa-space-shuttle\n      h3.intro-feature-title\n        a(href='/docs/zh-cn/d1.code_organization.html') ÂºÄÂßã‰Ω†ÁöÑÈ°πÁõÆ\n      p.intro-feature-desc Ê®°ÂùóÔºàModulesÔºâÔºå‰ª£Á†ÅÁÆ±ÔºàCratesÔºâÔºåÂ∑•‰ΩúÂå∫ÔºàWorkspacesÔºâÔºåÊ†áÂáÜÊ®°ÂùóÔºàstd moduleÔºâÂíåÈ¢ÑËÆæ‰∏ä‰∏ãÊñáÔºàPreludesÔºâ„ÄÇ\n","source":"zh-cn/index.jade","raw":"layout: index\ndescription: Hexo is a fast, simple & powerful blog framework powered by Node.js.\nsubtitle: Learning Rust\nlang: zh-cn\n---\nul#intro-feature-list\n  li.intro-feature-wrap\n    .intro-feature\n      .intro-feature-icon\n        i.fa.fa-street-view\n      h3.intro-feature-title\n        a(href='/docs/zh-cn/a1.why_rust.html') Âü∫Á°ÄÁü•ËØÜ\n      p.intro-feature-desc Â¶Ç‰ΩïÂÆâË£ÖÔºåHello WorldÔºåCargoÔºåCratesÔºåÂèòÈáèÁªëÂÆöÔºåÂáΩÊï∞ÔºåÂéüÁîüÊï∞ÊçÆÁ±ªÂûãÔºåÊìç‰Ωú‰∏éÊéßÂà∂ÊµÅ„ÄÇ\n  li.intro-feature-wrap\n    .intro-feature\n      .intro-feature-icon\n        i.fa.fa-road\n      h3.intro-feature-title\n        a(href='/docs/zh-cn/b1.vectors.html') Âü∫Á°Ä‰πã‰∏ä\n      p.intro-feature-desc VectorsÔºåÁªìÊûÑ‰ΩìÔºàStructsÔºâÔºåÊûö‰∏æÔºàEnumsÔºâÔºåËåÉÂûãÔºàGenericsÔºâÔºåÁâπÊÄß‰∏éÁâπÊÄßÂÆûÁé∞ÔºàImpls & TraitsÔºâ„ÄÇ\n  li.intro-feature-wrap\n    .intro-feature\n      .intro-feature-icon\n        i.fa.fa-plane\n      h3.intro-feature-title\n        a(href='/docs/zh-cn/c1.ownership.html') ÈöæÂïÉÁöÑÈÉ®ÂàÜ\n      p.intro-feature-desc ÊâÄÊúâÊùÉÔºàOwnershipÔºâÔºåÊâÄÊúâÊùÉÂÄüÁî®ÔºàBorrowingÔºâÔºåÁîüÂ≠òÊúü‰∏éÁîüÂ≠òÊúüÁúÅÁï•ÔºàLifetimes & Lifetime ElisionÔºâ„ÄÇ\n  li.intro-feature-wrap\n    .intro-feature\n      .intro-feature-icon\n        i.fa.fa-space-shuttle\n      h3.intro-feature-title\n        a(href='/docs/zh-cn/d1.code_organization.html') ÂºÄÂßã‰Ω†ÁöÑÈ°πÁõÆ\n      p.intro-feature-desc Ê®°ÂùóÔºàModulesÔºâÔºå‰ª£Á†ÅÁÆ±ÔºàCratesÔºâÔºåÂ∑•‰ΩúÂå∫ÔºàWorkspacesÔºâÔºåÊ†áÂáÜÊ®°ÂùóÔºàstd moduleÔºâÂíåÈ¢ÑËÆæ‰∏ä‰∏ãÊñáÔºàPreludesÔºâ„ÄÇ\n","date":"2019-03-19T14:50:31.988Z","updated":"2019-03-19T14:50:31.988Z","path":"zh-cn/index.html","title":"","comments":1,"_id":"cjtfwbj03000xdwgp7jlemzhe","content":"<ul id=\"intro-feature-list\"><li class=\"intro-feature-wrap\"><div class=\"intro-feature\"><div class=\"intro-feature-icon\"><i class=\"fa fa-street-view\"></i></div><h3 class=\"intro-feature-title\"><a href=\"/docs/zh-cn/a1.why_rust.html\">Âü∫Á°ÄÁü•ËØÜ</a></h3><p class=\"intro-feature-desc\">Â¶Ç‰ΩïÂÆâË£ÖÔºåHello WorldÔºåCargoÔºåCratesÔºåÂèòÈáèÁªëÂÆöÔºåÂáΩÊï∞ÔºåÂéüÁîüÊï∞ÊçÆÁ±ªÂûãÔºåÊìç‰Ωú‰∏éÊéßÂà∂ÊµÅ„ÄÇ</p></div></li><li class=\"intro-feature-wrap\"><div class=\"intro-feature\"><div class=\"intro-feature-icon\"><i class=\"fa fa-road\"></i></div><h3 class=\"intro-feature-title\"><a href=\"/docs/zh-cn/b1.vectors.html\">Âü∫Á°Ä‰πã‰∏ä</a></h3><p class=\"intro-feature-desc\">VectorsÔºåÁªìÊûÑ‰ΩìÔºàStructsÔºâÔºåÊûö‰∏æÔºàEnumsÔºâÔºåËåÉÂûãÔºàGenericsÔºâÔºåÁâπÊÄß‰∏éÁâπÊÄßÂÆûÁé∞ÔºàImpls & TraitsÔºâ„ÄÇ</p></div></li><li class=\"intro-feature-wrap\"><div class=\"intro-feature\"><div class=\"intro-feature-icon\"><i class=\"fa fa-plane\"></i></div><h3 class=\"intro-feature-title\"><a href=\"/docs/zh-cn/c1.ownership.html\">ÈöæÂïÉÁöÑÈÉ®ÂàÜ</a></h3><p class=\"intro-feature-desc\">ÊâÄÊúâÊùÉÔºàOwnershipÔºâÔºåÊâÄÊúâÊùÉÂÄüÁî®ÔºàBorrowingÔºâÔºåÁîüÂ≠òÊúü‰∏éÁîüÂ≠òÊúüÁúÅÁï•ÔºàLifetimes & Lifetime ElisionÔºâ„ÄÇ</p></div></li><li class=\"intro-feature-wrap\"><div class=\"intro-feature\"><div class=\"intro-feature-icon\"><i class=\"fa fa-space-shuttle\"></i></div><h3 class=\"intro-feature-title\"><a href=\"/docs/zh-cn/d1.code_organization.html\">ÂºÄÂßã‰Ω†ÁöÑÈ°πÁõÆ</a></h3><p class=\"intro-feature-desc\">Ê®°ÂùóÔºàModulesÔºâÔºå‰ª£Á†ÅÁÆ±ÔºàCratesÔºâÔºåÂ∑•‰ΩúÂå∫ÔºàWorkspacesÔºâÔºåÊ†áÂáÜÊ®°ÂùóÔºàstd moduleÔºâÂíåÈ¢ÑËÆæ‰∏ä‰∏ãÊñáÔºàPreludesÔºâ„ÄÇ</p></div></li></ul>","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<ul id=\"intro-feature-list\"><li class=\"intro-feature-wrap\"><div class=\"intro-feature\"><div class=\"intro-feature-icon\"><i class=\"fa fa-street-view\"></i></div><h3 class=\"intro-feature-title\"><a href=\"/docs/zh-cn/a1.why_rust.html\">Âü∫Á°ÄÁü•ËØÜ</a></h3><p class=\"intro-feature-desc\">Â¶Ç‰ΩïÂÆâË£ÖÔºåHello WorldÔºåCargoÔºåCratesÔºåÂèòÈáèÁªëÂÆöÔºåÂáΩÊï∞ÔºåÂéüÁîüÊï∞ÊçÆÁ±ªÂûãÔºåÊìç‰Ωú‰∏éÊéßÂà∂ÊµÅ„ÄÇ</p></div></li><li class=\"intro-feature-wrap\"><div class=\"intro-feature\"><div class=\"intro-feature-icon\"><i class=\"fa fa-road\"></i></div><h3 class=\"intro-feature-title\"><a href=\"/docs/zh-cn/b1.vectors.html\">Âü∫Á°Ä‰πã‰∏ä</a></h3><p class=\"intro-feature-desc\">VectorsÔºåÁªìÊûÑ‰ΩìÔºàStructsÔºâÔºåÊûö‰∏æÔºàEnumsÔºâÔºåËåÉÂûãÔºàGenericsÔºâÔºåÁâπÊÄß‰∏éÁâπÊÄßÂÆûÁé∞ÔºàImpls & TraitsÔºâ„ÄÇ</p></div></li><li class=\"intro-feature-wrap\"><div class=\"intro-feature\"><div class=\"intro-feature-icon\"><i class=\"fa fa-plane\"></i></div><h3 class=\"intro-feature-title\"><a href=\"/docs/zh-cn/c1.ownership.html\">ÈöæÂïÉÁöÑÈÉ®ÂàÜ</a></h3><p class=\"intro-feature-desc\">ÊâÄÊúâÊùÉÔºàOwnershipÔºâÔºåÊâÄÊúâÊùÉÂÄüÁî®ÔºàBorrowingÔºâÔºåÁîüÂ≠òÊúü‰∏éÁîüÂ≠òÊúüÁúÅÁï•ÔºàLifetimes & Lifetime ElisionÔºâ„ÄÇ</p></div></li><li class=\"intro-feature-wrap\"><div class=\"intro-feature\"><div class=\"intro-feature-icon\"><i class=\"fa fa-space-shuttle\"></i></div><h3 class=\"intro-feature-title\"><a href=\"/docs/zh-cn/d1.code_organization.html\">ÂºÄÂßã‰Ω†ÁöÑÈ°πÁõÆ</a></h3><p class=\"intro-feature-desc\">Ê®°ÂùóÔºàModulesÔºâÔºå‰ª£Á†ÅÁÆ±ÔºàCratesÔºâÔºåÂ∑•‰ΩúÂå∫ÔºàWorkspacesÔºâÔºåÊ†áÂáÜÊ®°ÂùóÔºàstd moduleÔºâÂíåÈ¢ÑËÆæ‰∏ä‰∏ãÊñáÔºàPreludesÔºâ„ÄÇ</p></div></li></ul>"},{"title":"Custom Error Types","_content":"\nRust allow us to create our own `Err` types. We call them ‚Äú*Custom Error Types*‚Äù.\n\n## Error trait\n\nAs you know **traits define the functionality a type must provide**. But we don‚Äôt need to define new traits for common functionalities always, because Rust **standard library provides some reusable traits** which can be implemented on our own types. While creating custom error types [`std::error::Error` trait](https://doc.rust-lang.org/std/error/trait.Error.html) help us to convert any type to an `Err` type.\n\n```rust\nuse std::fmt::{Debug, Display};\n\npub trait Error: Debug + Display {\n    fn source(&self) -> Option<&(Error + 'static)> { ... }\n}\n```\n\n> As we discussed under [traits inheritance](b5.impls_and_traits.html#Traits-inheritance), a trait can be inherited from another traits. `trait Error: Debug + Display` means `Error` trait inherits from `fmt::Debug` and `fmt::Display` traits.\n\n```rust\n// traits inside Rust standard library core fmt module/ std::fmt\npub trait Display {\n    fn fmt(&self, f: &mut Formatter) -> Result<(), Error>;\n}\n\npub trait Debug {\n    fn fmt(&self, f: &mut Formatter) -> Result<(), Error>;\n}\n```\n\n- `Display`\n  - How should the end user see this error as a message/ user-facing output.\n  - Usually print via `println!(\"{}\")` or `eprintln!(\"{}\")`\n\n- `Debug`\n  - How should display the `Err` while debugging/ programmer-facing output.\n  - Usually print via `println!(\"{:?}\")` or `eprintln!(\"{:?}\")`\n  - To pretty-print, `println!(\"{:#?}\")` or `eprintln!(\"{:#?}\")` can be used.\n\n- `source()`\n  - The lower-level source of this error, if any.\n  - Optional.\n\nFirst, let‚Äôs see how to implement `std::error::Error` trait on a simplest custom error type.\n\n```rust\nuse std::fmt;\n\n// Custom error type; can be any type which defined in the current crate\n// üí° In here, we use a simple \"unit struct\" to simplify the example\nstruct AppError;\n\n// Implement std::fmt::Display for AppError\nimpl fmt::Display for AppError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"An Error Occurred, Please Try Again!\") // user-facing output\n    }\n}\n\n// Implement std::fmt::Debug for AppError\nimpl fmt::Debug for AppError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"{{ file: {}, line: {} }}\", file!(), line!()) // programmer-facing output\n    }\n}\n\n// A sample function to produce an AppError Err\nfn produce_error() -> Result<(), AppError> {\n    Err(AppError)\n}\n\nfn main() {\n    match produce_error() {\n        Err(e) => eprintln!(\"{}\", e), // An Error Occurred, Please Try Again!\n        _ => println!(\"No error\"),\n    }\n\n    eprintln!(\"{:?}\", produce_error()); // Err({ file: src/main.rs, line: 17 })\n}\n```\n\nHope you understood the main points. Now, let‚Äôs see some custom error type with **an error code and an error message**.\n\n```rust\nuse std::fmt;\n\nstruct AppError {\n    code: usize,\n    message: String,\n}\n\n// Different error messages according to AppError.code\nimpl fmt::Display for AppError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let err_msg = match self.code {\n            404 => \"Sorry, Can not find the Page!\",\n            _ => \"Sorry, something is wrong! Please Try Again!\",\n        };\n\n        write!(f, \"{}\", err_msg)\n    }\n}\n\n// A unique format for dubugging output\nimpl fmt::Debug for AppError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(\n            f,\n            \"AppError {{ code: {}, message: {} }}\",\n            self.code, self.message\n        )\n    }\n}\n\nfn produce_error() -> Result<(), AppError> {\n    Err(AppError {\n        code: 404,\n        message: String::from(\"Page not found\"),\n    })\n}\n\nfn main() {\n    match produce_error() {\n        Err(e) => eprintln!(\"{}\", e), // Sorry, Can not find the Page!\n        _ => println!(\"No error\"),\n    }\n\n    eprintln!(\"{:?}\", produce_error()); // Err(AppError { code: 404, message: Page not found })\n\n    eprintln!(\"{:#?}\", produce_error());\n    // Err(\n    //     AppError { code: 404, message: Page not found }\n    // )\n}\n```\n\n‚≠êÔ∏è Rust standard library provides not only reusable traits and also it facilitates to **magically generate implementations for few traits** via `#[derive]` attribute. Rust support `derive` `std::fmt::Debug`, to provide a default format for debug messages. So we **can skip `std::fmt::Debug` implementation** for custom error types and use `#[derive(Debug)]` before `struct` declaration.\n\n> For a struct `#[derive(Debug)]` prints, the name of the `struct` , `{` , comma-separated list of each field‚Äôs name and debug value and `}`.\n\n```rust\nuse std::fmt;\n\n#[derive(Debug)] // derive std::fmt::Debug on AppError\nstruct AppError {\n    code: usize,\n    message: String,\n}\n\nimpl fmt::Display for AppError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let err_msg = match self.code {\n            404 => \"Sorry, Can not find the Page!\",\n            _ => \"Sorry, something is wrong! Please Try Again!\",\n        };\n\n        write!(f, \"{}\", err_msg)\n    }\n}\n\nfn produce_error() -> Result<(), AppError> {\n    Err(AppError {\n        code: 404,\n        message: String::from(\"Page not found\"),\n    })\n}\n\nfn main() {\n    match produce_error() {\n        Err(e) => eprintln!(\"{}\", e), // Sorry, Can not find the Page!\n        _ => println!(\"No error\"),\n    }\n\n    eprintln!(\"{:?}\", produce_error()); // Err(AppError { code: 404, message: Page not found })\n\n    eprintln!(\"{:#?}\", produce_error());\n    // Err(\n    //     AppError {\n    //         code: 404,\n    //         message: \"Page not found\"\n    //     }\n    // )\n}\n```\n\n\n## From trait\n\nWhen writing real programs, mostly we have to deal with different modules, different `std` and third party crates at the same time. But each crate uses their own error types and if we are using our own error type, we should convert those errors into our error type. There is a standardized trait we can use for these conversions, `std::convert::From`.\n\n```rust\n// traits inside Rust standard library core convert module/ std::convert\npub trait From<T>: Sized {\n  fn from(_: T) -> Self;\n}\n```\n\n> üí° As you know, `String::from()` function is used to create a `String` from `&str` data type. Actually this also an implementation of `std::convert::From` trait.\n\nLet‚Äôs see how to implement `std::convert::From` trait on a custom error type.\n\n```rust\nuse std::fs::File;\nuse std::io;\n\n#[derive(Debug)]\nstruct AppError {\n    kind: String,    // type of the error\n    message: String, // error message\n}\n\n// Implement std::convert::From for AppError; from io::Error\nimpl From<io::Error> for AppError {\n    fn from(error: io::Error) -> Self {\n        AppError {\n            kind: String::from(\"io\"),\n            message: error.to_string(),\n        }\n    }\n}\n\nfn main() -> Result<(), AppError> {\n    let _file = File::open(\"nonexistent_file.txt\")?; // This generates an io::Error. But because of return type is Result<(), AppError>, it converts to AppError\n\n    Ok(())\n}\n\n\n// --------------- Run time error ---------------\nError: AppError { kind: \"io\", message: \"No such file or directory (os error 2)\" }\n```\n\nIn the above example, `File::open(‚Äúnonexistent.txt‚Äù)?` produces `std::io::Error`. But because of the return type is `Result<(), AppError>`, it converts to an `AppError`. Because of we are propagating the error from `main()` function, it prints the `Debug` representation of the `Err`.\n\nIn the above example we deal with only one `std` error type, `std::io::Error`. Let‚Äôs see some example which handles multiple `std` error types.\n\n```rust\nuse std::fs::File;\nuse std::io::{self, Read};\nuse std::num;\n\n#[derive(Debug)]\nstruct AppError {\n    kind: String,\n    message: String,\n}\n\n// Implement std::convert::From for AppError; from io::Error\nimpl From<io::Error> for AppError {\n    fn from(error: io::Error) -> Self {\n        AppError {\n            kind: String::from(\"io\"),\n            message: error.to_string(),\n        }\n    }\n}\n\n// Implement std::convert::From for AppError; from num::ParseIntError\nimpl From<num::ParseIntError> for AppError {\n    fn from(error: num::ParseIntError) -> Self {\n        AppError {\n            kind: String::from(\"parse\"),\n            message: error.to_string(),\n        }\n    }\n}\n\nfn main() -> Result<(), AppError> {\n    let mut file = File::open(\"hello_world.txt\")?; // generates an io::Error, if can not open the file and converts to an AppError\n\n    let mut content = String::new();\n    file.read_to_string(&mut content)?; // generates an io::Error, if can not read file content and converts to an AppError\n\n    let _number: usize;\n    _number = content.parse()?; // generates num::ParseIntError, if can not convert file content to usize and converts to an AppError\n\n    Ok(())\n}\n\n\n// --------------- Few possible run time errors ---------------\n\n// 01. If hello_world.txt is a nonexistent file\nError: AppError { kind: \"io\", message: \"No such file or directory (os error 2)\" }\n\n// 02. If user doesn't have relevant permission to access hello_world.txt\nError: AppError { kind: \"io\", message: \"Permission denied (os error 13)\" }\n\n// 03. If hello_world.txt contains non-numeric content. ex Hello, world!\nError: AppError { kind: \"parse\", message: \"invalid digit found in string\" }\n```\n\n> üîé Search about the implementation of [`std::io::ErrorKind`](https://doc.rust-lang.org/std/io/enum.ErrorKind.html), to see how to organize error types further.","source":"docs/e7.custom_error_types.md","raw":"title: Custom Error Types\n---\n\nRust allow us to create our own `Err` types. We call them ‚Äú*Custom Error Types*‚Äù.\n\n## Error trait\n\nAs you know **traits define the functionality a type must provide**. But we don‚Äôt need to define new traits for common functionalities always, because Rust **standard library provides some reusable traits** which can be implemented on our own types. While creating custom error types [`std::error::Error` trait](https://doc.rust-lang.org/std/error/trait.Error.html) help us to convert any type to an `Err` type.\n\n```rust\nuse std::fmt::{Debug, Display};\n\npub trait Error: Debug + Display {\n    fn source(&self) -> Option<&(Error + 'static)> { ... }\n}\n```\n\n> As we discussed under [traits inheritance](b5.impls_and_traits.html#Traits-inheritance), a trait can be inherited from another traits. `trait Error: Debug + Display` means `Error` trait inherits from `fmt::Debug` and `fmt::Display` traits.\n\n```rust\n// traits inside Rust standard library core fmt module/ std::fmt\npub trait Display {\n    fn fmt(&self, f: &mut Formatter) -> Result<(), Error>;\n}\n\npub trait Debug {\n    fn fmt(&self, f: &mut Formatter) -> Result<(), Error>;\n}\n```\n\n- `Display`\n  - How should the end user see this error as a message/ user-facing output.\n  - Usually print via `println!(\"{}\")` or `eprintln!(\"{}\")`\n\n- `Debug`\n  - How should display the `Err` while debugging/ programmer-facing output.\n  - Usually print via `println!(\"{:?}\")` or `eprintln!(\"{:?}\")`\n  - To pretty-print, `println!(\"{:#?}\")` or `eprintln!(\"{:#?}\")` can be used.\n\n- `source()`\n  - The lower-level source of this error, if any.\n  - Optional.\n\nFirst, let‚Äôs see how to implement `std::error::Error` trait on a simplest custom error type.\n\n```rust\nuse std::fmt;\n\n// Custom error type; can be any type which defined in the current crate\n// üí° In here, we use a simple \"unit struct\" to simplify the example\nstruct AppError;\n\n// Implement std::fmt::Display for AppError\nimpl fmt::Display for AppError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"An Error Occurred, Please Try Again!\") // user-facing output\n    }\n}\n\n// Implement std::fmt::Debug for AppError\nimpl fmt::Debug for AppError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"{{ file: {}, line: {} }}\", file!(), line!()) // programmer-facing output\n    }\n}\n\n// A sample function to produce an AppError Err\nfn produce_error() -> Result<(), AppError> {\n    Err(AppError)\n}\n\nfn main() {\n    match produce_error() {\n        Err(e) => eprintln!(\"{}\", e), // An Error Occurred, Please Try Again!\n        _ => println!(\"No error\"),\n    }\n\n    eprintln!(\"{:?}\", produce_error()); // Err({ file: src/main.rs, line: 17 })\n}\n```\n\nHope you understood the main points. Now, let‚Äôs see some custom error type with **an error code and an error message**.\n\n```rust\nuse std::fmt;\n\nstruct AppError {\n    code: usize,\n    message: String,\n}\n\n// Different error messages according to AppError.code\nimpl fmt::Display for AppError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let err_msg = match self.code {\n            404 => \"Sorry, Can not find the Page!\",\n            _ => \"Sorry, something is wrong! Please Try Again!\",\n        };\n\n        write!(f, \"{}\", err_msg)\n    }\n}\n\n// A unique format for dubugging output\nimpl fmt::Debug for AppError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(\n            f,\n            \"AppError {{ code: {}, message: {} }}\",\n            self.code, self.message\n        )\n    }\n}\n\nfn produce_error() -> Result<(), AppError> {\n    Err(AppError {\n        code: 404,\n        message: String::from(\"Page not found\"),\n    })\n}\n\nfn main() {\n    match produce_error() {\n        Err(e) => eprintln!(\"{}\", e), // Sorry, Can not find the Page!\n        _ => println!(\"No error\"),\n    }\n\n    eprintln!(\"{:?}\", produce_error()); // Err(AppError { code: 404, message: Page not found })\n\n    eprintln!(\"{:#?}\", produce_error());\n    // Err(\n    //     AppError { code: 404, message: Page not found }\n    // )\n}\n```\n\n‚≠êÔ∏è Rust standard library provides not only reusable traits and also it facilitates to **magically generate implementations for few traits** via `#[derive]` attribute. Rust support `derive` `std::fmt::Debug`, to provide a default format for debug messages. So we **can skip `std::fmt::Debug` implementation** for custom error types and use `#[derive(Debug)]` before `struct` declaration.\n\n> For a struct `#[derive(Debug)]` prints, the name of the `struct` , `{` , comma-separated list of each field‚Äôs name and debug value and `}`.\n\n```rust\nuse std::fmt;\n\n#[derive(Debug)] // derive std::fmt::Debug on AppError\nstruct AppError {\n    code: usize,\n    message: String,\n}\n\nimpl fmt::Display for AppError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let err_msg = match self.code {\n            404 => \"Sorry, Can not find the Page!\",\n            _ => \"Sorry, something is wrong! Please Try Again!\",\n        };\n\n        write!(f, \"{}\", err_msg)\n    }\n}\n\nfn produce_error() -> Result<(), AppError> {\n    Err(AppError {\n        code: 404,\n        message: String::from(\"Page not found\"),\n    })\n}\n\nfn main() {\n    match produce_error() {\n        Err(e) => eprintln!(\"{}\", e), // Sorry, Can not find the Page!\n        _ => println!(\"No error\"),\n    }\n\n    eprintln!(\"{:?}\", produce_error()); // Err(AppError { code: 404, message: Page not found })\n\n    eprintln!(\"{:#?}\", produce_error());\n    // Err(\n    //     AppError {\n    //         code: 404,\n    //         message: \"Page not found\"\n    //     }\n    // )\n}\n```\n\n\n## From trait\n\nWhen writing real programs, mostly we have to deal with different modules, different `std` and third party crates at the same time. But each crate uses their own error types and if we are using our own error type, we should convert those errors into our error type. There is a standardized trait we can use for these conversions, `std::convert::From`.\n\n```rust\n// traits inside Rust standard library core convert module/ std::convert\npub trait From<T>: Sized {\n  fn from(_: T) -> Self;\n}\n```\n\n> üí° As you know, `String::from()` function is used to create a `String` from `&str` data type. Actually this also an implementation of `std::convert::From` trait.\n\nLet‚Äôs see how to implement `std::convert::From` trait on a custom error type.\n\n```rust\nuse std::fs::File;\nuse std::io;\n\n#[derive(Debug)]\nstruct AppError {\n    kind: String,    // type of the error\n    message: String, // error message\n}\n\n// Implement std::convert::From for AppError; from io::Error\nimpl From<io::Error> for AppError {\n    fn from(error: io::Error) -> Self {\n        AppError {\n            kind: String::from(\"io\"),\n            message: error.to_string(),\n        }\n    }\n}\n\nfn main() -> Result<(), AppError> {\n    let _file = File::open(\"nonexistent_file.txt\")?; // This generates an io::Error. But because of return type is Result<(), AppError>, it converts to AppError\n\n    Ok(())\n}\n\n\n// --------------- Run time error ---------------\nError: AppError { kind: \"io\", message: \"No such file or directory (os error 2)\" }\n```\n\nIn the above example, `File::open(‚Äúnonexistent.txt‚Äù)?` produces `std::io::Error`. But because of the return type is `Result<(), AppError>`, it converts to an `AppError`. Because of we are propagating the error from `main()` function, it prints the `Debug` representation of the `Err`.\n\nIn the above example we deal with only one `std` error type, `std::io::Error`. Let‚Äôs see some example which handles multiple `std` error types.\n\n```rust\nuse std::fs::File;\nuse std::io::{self, Read};\nuse std::num;\n\n#[derive(Debug)]\nstruct AppError {\n    kind: String,\n    message: String,\n}\n\n// Implement std::convert::From for AppError; from io::Error\nimpl From<io::Error> for AppError {\n    fn from(error: io::Error) -> Self {\n        AppError {\n            kind: String::from(\"io\"),\n            message: error.to_string(),\n        }\n    }\n}\n\n// Implement std::convert::From for AppError; from num::ParseIntError\nimpl From<num::ParseIntError> for AppError {\n    fn from(error: num::ParseIntError) -> Self {\n        AppError {\n            kind: String::from(\"parse\"),\n            message: error.to_string(),\n        }\n    }\n}\n\nfn main() -> Result<(), AppError> {\n    let mut file = File::open(\"hello_world.txt\")?; // generates an io::Error, if can not open the file and converts to an AppError\n\n    let mut content = String::new();\n    file.read_to_string(&mut content)?; // generates an io::Error, if can not read file content and converts to an AppError\n\n    let _number: usize;\n    _number = content.parse()?; // generates num::ParseIntError, if can not convert file content to usize and converts to an AppError\n\n    Ok(())\n}\n\n\n// --------------- Few possible run time errors ---------------\n\n// 01. If hello_world.txt is a nonexistent file\nError: AppError { kind: \"io\", message: \"No such file or directory (os error 2)\" }\n\n// 02. If user doesn't have relevant permission to access hello_world.txt\nError: AppError { kind: \"io\", message: \"Permission denied (os error 13)\" }\n\n// 03. If hello_world.txt contains non-numeric content. ex Hello, world!\nError: AppError { kind: \"parse\", message: \"invalid digit found in string\" }\n```\n\n> üîé Search about the implementation of [`std::io::ErrorKind`](https://doc.rust-lang.org/std/io/enum.ErrorKind.html), to see how to organize error types further.","date":"2019-01-19T16:53:20.795Z","updated":"2019-01-19T16:53:20.795Z","path":"docs/e7.custom_error_types.html","comments":1,"layout":"page","_id":"cjtfwbj06000ydwgpfsuu6qyn","content":"<p>Rust allow us to create our own <code>Err</code> types. We call them ‚Äú<em>Custom Error Types</em>‚Äù.</p>\n<h2 id=\"Error-trait\"><a href=\"#Error-trait\" class=\"headerlink\" title=\"Error trait\"></a>Error trait</h2><p>As you know <strong>traits define the functionality a type must provide</strong>. But we don‚Äôt need to define new traits for common functionalities always, because Rust <strong>standard library provides some reusable traits</strong> which can be implemented on our own types. While creating custom error types <a href=\"https://doc.rust-lang.org/std/error/trait.Error.html\" target=\"_blank\" rel=\"noopener\"><code>std::error::Error</code> trait</a> help us to convert any type to an <code>Err</code> type.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">use std::fmt::{Debug, Display};\n\npub trait Error: Debug + Display {\n    fn source(&amp;self) -&gt; Option&lt;&amp;(Error + &#39;static)&gt; { ... }\n}\n</code></pre>\n<blockquote>\n<p>As we discussed under <a href=\"b5.impls_and_traits.html#Traits-inheritance\">traits inheritance</a>, a trait can be inherited from another traits. <code>trait Error: Debug + Display</code> means <code>Error</code> trait inherits from <code>fmt::Debug</code> and <code>fmt::Display</code> traits.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// traits inside Rust standard library core fmt module/ std::fmt\npub trait Display {\n    fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; Result&lt;(), Error&gt;;\n}\n\npub trait Debug {\n    fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; Result&lt;(), Error&gt;;\n}\n</code></pre>\n<ul>\n<li><p><code>Display</code></p>\n<ul>\n<li>How should the end user see this error as a message/ user-facing output.</li>\n<li>Usually print via <code>println!(&quot;{}&quot;)</code> or <code>eprintln!(&quot;{}&quot;)</code></li>\n</ul>\n</li>\n<li><p><code>Debug</code></p>\n<ul>\n<li>How should display the <code>Err</code> while debugging/ programmer-facing output.</li>\n<li>Usually print via <code>println!(&quot;{:?}&quot;)</code> or <code>eprintln!(&quot;{:?}&quot;)</code></li>\n<li>To pretty-print, <code>println!(&quot;{:#?}&quot;)</code> or <code>eprintln!(&quot;{:#?}&quot;)</code> can be used.</li>\n</ul>\n</li>\n<li><p><code>source()</code></p>\n<ul>\n<li>The lower-level source of this error, if any.</li>\n<li>Optional.</li>\n</ul>\n</li>\n</ul>\n<p>First, let‚Äôs see how to implement <code>std::error::Error</code> trait on a simplest custom error type.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">use std::fmt;\n\n// Custom error type; can be any type which defined in the current crate\n// üí° In here, we use a simple &quot;unit struct&quot; to simplify the example\nstruct AppError;\n\n// Implement std::fmt::Display for AppError\nimpl fmt::Display for AppError {\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {\n        write!(f, &quot;An Error Occurred, Please Try Again!&quot;) // user-facing output\n    }\n}\n\n// Implement std::fmt::Debug for AppError\nimpl fmt::Debug for AppError {\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {\n        write!(f, &quot;{{ file: {}, line: {} }}&quot;, file!(), line!()) // programmer-facing output\n    }\n}\n\n// A sample function to produce an AppError Err\nfn produce_error() -&gt; Result&lt;(), AppError&gt; {\n    Err(AppError)\n}\n\nfn main() {\n    match produce_error() {\n        Err(e) =&gt; eprintln!(&quot;{}&quot;, e), // An Error Occurred, Please Try Again!\n        _ =&gt; println!(&quot;No error&quot;),\n    }\n\n    eprintln!(&quot;{:?}&quot;, produce_error()); // Err({ file: src/main.rs, line: 17 })\n}\n</code></pre>\n<p>Hope you understood the main points. Now, let‚Äôs see some custom error type with <strong>an error code and an error message</strong>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">use std::fmt;\n\nstruct AppError {\n    code: usize,\n    message: String,\n}\n\n// Different error messages according to AppError.code\nimpl fmt::Display for AppError {\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {\n        let err_msg = match self.code {\n            404 =&gt; &quot;Sorry, Can not find the Page!&quot;,\n            _ =&gt; &quot;Sorry, something is wrong! Please Try Again!&quot;,\n        };\n\n        write!(f, &quot;{}&quot;, err_msg)\n    }\n}\n\n// A unique format for dubugging output\nimpl fmt::Debug for AppError {\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {\n        write!(\n            f,\n            &quot;AppError {{ code: {}, message: {} }}&quot;,\n            self.code, self.message\n        )\n    }\n}\n\nfn produce_error() -&gt; Result&lt;(), AppError&gt; {\n    Err(AppError {\n        code: 404,\n        message: String::from(&quot;Page not found&quot;),\n    })\n}\n\nfn main() {\n    match produce_error() {\n        Err(e) =&gt; eprintln!(&quot;{}&quot;, e), // Sorry, Can not find the Page!\n        _ =&gt; println!(&quot;No error&quot;),\n    }\n\n    eprintln!(&quot;{:?}&quot;, produce_error()); // Err(AppError { code: 404, message: Page not found })\n\n    eprintln!(&quot;{:#?}&quot;, produce_error());\n    // Err(\n    //     AppError { code: 404, message: Page not found }\n    // )\n}\n</code></pre>\n<p>‚≠êÔ∏è Rust standard library provides not only reusable traits and also it facilitates to <strong>magically generate implementations for few traits</strong> via <code>#[derive]</code> attribute. Rust support <code>derive</code> <code>std::fmt::Debug</code>, to provide a default format for debug messages. So we <strong>can skip <code>std::fmt::Debug</code> implementation</strong> for custom error types and use <code>#[derive(Debug)]</code> before <code>struct</code> declaration.</p>\n<blockquote>\n<p>For a struct <code>#[derive(Debug)]</code> prints, the name of the <code>struct</code> , <code>{</code> , comma-separated list of each field‚Äôs name and debug value and <code>}</code>.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">use std::fmt;\n\n#[derive(Debug)] // derive std::fmt::Debug on AppError\nstruct AppError {\n    code: usize,\n    message: String,\n}\n\nimpl fmt::Display for AppError {\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {\n        let err_msg = match self.code {\n            404 =&gt; &quot;Sorry, Can not find the Page!&quot;,\n            _ =&gt; &quot;Sorry, something is wrong! Please Try Again!&quot;,\n        };\n\n        write!(f, &quot;{}&quot;, err_msg)\n    }\n}\n\nfn produce_error() -&gt; Result&lt;(), AppError&gt; {\n    Err(AppError {\n        code: 404,\n        message: String::from(&quot;Page not found&quot;),\n    })\n}\n\nfn main() {\n    match produce_error() {\n        Err(e) =&gt; eprintln!(&quot;{}&quot;, e), // Sorry, Can not find the Page!\n        _ =&gt; println!(&quot;No error&quot;),\n    }\n\n    eprintln!(&quot;{:?}&quot;, produce_error()); // Err(AppError { code: 404, message: Page not found })\n\n    eprintln!(&quot;{:#?}&quot;, produce_error());\n    // Err(\n    //     AppError {\n    //         code: 404,\n    //         message: &quot;Page not found&quot;\n    //     }\n    // )\n}\n</code></pre>\n<h2 id=\"From-trait\"><a href=\"#From-trait\" class=\"headerlink\" title=\"From trait\"></a>From trait</h2><p>When writing real programs, mostly we have to deal with different modules, different <code>std</code> and third party crates at the same time. But each crate uses their own error types and if we are using our own error type, we should convert those errors into our error type. There is a standardized trait we can use for these conversions, <code>std::convert::From</code>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// traits inside Rust standard library core convert module/ std::convert\npub trait From&lt;T&gt;: Sized {\n  fn from(_: T) -&gt; Self;\n}\n</code></pre>\n<blockquote>\n<p>üí° As you know, <code>String::from()</code> function is used to create a <code>String</code> from <code>&amp;str</code> data type. Actually this also an implementation of <code>std::convert::From</code> trait.</p>\n</blockquote>\n<p>Let‚Äôs see how to implement <code>std::convert::From</code> trait on a custom error type.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">use std::fs::File;\nuse std::io;\n\n#[derive(Debug)]\nstruct AppError {\n    kind: String,    // type of the error\n    message: String, // error message\n}\n\n// Implement std::convert::From for AppError; from io::Error\nimpl From&lt;io::Error&gt; for AppError {\n    fn from(error: io::Error) -&gt; Self {\n        AppError {\n            kind: String::from(&quot;io&quot;),\n            message: error.to_string(),\n        }\n    }\n}\n\nfn main() -&gt; Result&lt;(), AppError&gt; {\n    let _file = File::open(&quot;nonexistent_file.txt&quot;)?; // This generates an io::Error. But because of return type is Result&lt;(), AppError&gt;, it converts to AppError\n\n    Ok(())\n}\n\n\n// --------------- Run time error ---------------\nError: AppError { kind: &quot;io&quot;, message: &quot;No such file or directory (os error 2)&quot; }\n</code></pre>\n<p>In the above example, <code>File::open(‚Äúnonexistent.txt‚Äù)?</code> produces <code>std::io::Error</code>. But because of the return type is <code>Result&lt;(), AppError&gt;</code>, it converts to an <code>AppError</code>. Because of we are propagating the error from <code>main()</code> function, it prints the <code>Debug</code> representation of the <code>Err</code>.</p>\n<p>In the above example we deal with only one <code>std</code> error type, <code>std::io::Error</code>. Let‚Äôs see some example which handles multiple <code>std</code> error types.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">use std::fs::File;\nuse std::io::{self, Read};\nuse std::num;\n\n#[derive(Debug)]\nstruct AppError {\n    kind: String,\n    message: String,\n}\n\n// Implement std::convert::From for AppError; from io::Error\nimpl From&lt;io::Error&gt; for AppError {\n    fn from(error: io::Error) -&gt; Self {\n        AppError {\n            kind: String::from(&quot;io&quot;),\n            message: error.to_string(),\n        }\n    }\n}\n\n// Implement std::convert::From for AppError; from num::ParseIntError\nimpl From&lt;num::ParseIntError&gt; for AppError {\n    fn from(error: num::ParseIntError) -&gt; Self {\n        AppError {\n            kind: String::from(&quot;parse&quot;),\n            message: error.to_string(),\n        }\n    }\n}\n\nfn main() -&gt; Result&lt;(), AppError&gt; {\n    let mut file = File::open(&quot;hello_world.txt&quot;)?; // generates an io::Error, if can not open the file and converts to an AppError\n\n    let mut content = String::new();\n    file.read_to_string(&amp;mut content)?; // generates an io::Error, if can not read file content and converts to an AppError\n\n    let _number: usize;\n    _number = content.parse()?; // generates num::ParseIntError, if can not convert file content to usize and converts to an AppError\n\n    Ok(())\n}\n\n\n// --------------- Few possible run time errors ---------------\n\n// 01. If hello_world.txt is a nonexistent file\nError: AppError { kind: &quot;io&quot;, message: &quot;No such file or directory (os error 2)&quot; }\n\n// 02. If user doesn&#39;t have relevant permission to access hello_world.txt\nError: AppError { kind: &quot;io&quot;, message: &quot;Permission denied (os error 13)&quot; }\n\n// 03. If hello_world.txt contains non-numeric content. ex Hello, world!\nError: AppError { kind: &quot;parse&quot;, message: &quot;invalid digit found in string&quot; }\n</code></pre>\n<blockquote>\n<p>üîé Search about the implementation of <a href=\"https://doc.rust-lang.org/std/io/enum.ErrorKind.html\" target=\"_blank\" rel=\"noopener\"><code>std::io::ErrorKind</code></a>, to see how to organize error types further.</p>\n</blockquote>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<p>Rust allow us to create our own <code>Err</code> types. We call them ‚Äú<em>Custom Error Types</em>‚Äù.</p>\n<h2 id=\"Error-trait\"><a href=\"#Error-trait\" class=\"headerlink\" title=\"Error trait\"></a>Error trait</h2><p>As you know <strong>traits define the functionality a type must provide</strong>. But we don‚Äôt need to define new traits for common functionalities always, because Rust <strong>standard library provides some reusable traits</strong> which can be implemented on our own types. While creating custom error types <a href=\"https://doc.rust-lang.org/std/error/trait.Error.html\" target=\"_blank\" rel=\"noopener\"><code>std::error::Error</code> trait</a> help us to convert any type to an <code>Err</code> type.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">use std::fmt::{Debug, Display};\n\npub trait Error: Debug + Display {\n    fn source(&amp;self) -&gt; Option&lt;&amp;(Error + &#39;static)&gt; { ... }\n}\n</code></pre>\n<blockquote>\n<p>As we discussed under <a href=\"b5.impls_and_traits.html#Traits-inheritance\">traits inheritance</a>, a trait can be inherited from another traits. <code>trait Error: Debug + Display</code> means <code>Error</code> trait inherits from <code>fmt::Debug</code> and <code>fmt::Display</code> traits.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// traits inside Rust standard library core fmt module/ std::fmt\npub trait Display {\n    fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; Result&lt;(), Error&gt;;\n}\n\npub trait Debug {\n    fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; Result&lt;(), Error&gt;;\n}\n</code></pre>\n<ul>\n<li><p><code>Display</code></p>\n<ul>\n<li>How should the end user see this error as a message/ user-facing output.</li>\n<li>Usually print via <code>println!(&quot;{}&quot;)</code> or <code>eprintln!(&quot;{}&quot;)</code></li>\n</ul>\n</li>\n<li><p><code>Debug</code></p>\n<ul>\n<li>How should display the <code>Err</code> while debugging/ programmer-facing output.</li>\n<li>Usually print via <code>println!(&quot;{:?}&quot;)</code> or <code>eprintln!(&quot;{:?}&quot;)</code></li>\n<li>To pretty-print, <code>println!(&quot;{:#?}&quot;)</code> or <code>eprintln!(&quot;{:#?}&quot;)</code> can be used.</li>\n</ul>\n</li>\n<li><p><code>source()</code></p>\n<ul>\n<li>The lower-level source of this error, if any.</li>\n<li>Optional.</li>\n</ul>\n</li>\n</ul>\n<p>First, let‚Äôs see how to implement <code>std::error::Error</code> trait on a simplest custom error type.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">use std::fmt;\n\n// Custom error type; can be any type which defined in the current crate\n// üí° In here, we use a simple &quot;unit struct&quot; to simplify the example\nstruct AppError;\n\n// Implement std::fmt::Display for AppError\nimpl fmt::Display for AppError {\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {\n        write!(f, &quot;An Error Occurred, Please Try Again!&quot;) // user-facing output\n    }\n}\n\n// Implement std::fmt::Debug for AppError\nimpl fmt::Debug for AppError {\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {\n        write!(f, &quot;{{ file: {}, line: {} }}&quot;, file!(), line!()) // programmer-facing output\n    }\n}\n\n// A sample function to produce an AppError Err\nfn produce_error() -&gt; Result&lt;(), AppError&gt; {\n    Err(AppError)\n}\n\nfn main() {\n    match produce_error() {\n        Err(e) =&gt; eprintln!(&quot;{}&quot;, e), // An Error Occurred, Please Try Again!\n        _ =&gt; println!(&quot;No error&quot;),\n    }\n\n    eprintln!(&quot;{:?}&quot;, produce_error()); // Err({ file: src/main.rs, line: 17 })\n}\n</code></pre>\n<p>Hope you understood the main points. Now, let‚Äôs see some custom error type with <strong>an error code and an error message</strong>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">use std::fmt;\n\nstruct AppError {\n    code: usize,\n    message: String,\n}\n\n// Different error messages according to AppError.code\nimpl fmt::Display for AppError {\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {\n        let err_msg = match self.code {\n            404 =&gt; &quot;Sorry, Can not find the Page!&quot;,\n            _ =&gt; &quot;Sorry, something is wrong! Please Try Again!&quot;,\n        };\n\n        write!(f, &quot;{}&quot;, err_msg)\n    }\n}\n\n// A unique format for dubugging output\nimpl fmt::Debug for AppError {\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {\n        write!(\n            f,\n            &quot;AppError {{ code: {}, message: {} }}&quot;,\n            self.code, self.message\n        )\n    }\n}\n\nfn produce_error() -&gt; Result&lt;(), AppError&gt; {\n    Err(AppError {\n        code: 404,\n        message: String::from(&quot;Page not found&quot;),\n    })\n}\n\nfn main() {\n    match produce_error() {\n        Err(e) =&gt; eprintln!(&quot;{}&quot;, e), // Sorry, Can not find the Page!\n        _ =&gt; println!(&quot;No error&quot;),\n    }\n\n    eprintln!(&quot;{:?}&quot;, produce_error()); // Err(AppError { code: 404, message: Page not found })\n\n    eprintln!(&quot;{:#?}&quot;, produce_error());\n    // Err(\n    //     AppError { code: 404, message: Page not found }\n    // )\n}\n</code></pre>\n<p>‚≠êÔ∏è Rust standard library provides not only reusable traits and also it facilitates to <strong>magically generate implementations for few traits</strong> via <code>#[derive]</code> attribute. Rust support <code>derive</code> <code>std::fmt::Debug</code>, to provide a default format for debug messages. So we <strong>can skip <code>std::fmt::Debug</code> implementation</strong> for custom error types and use <code>#[derive(Debug)]</code> before <code>struct</code> declaration.</p>\n<blockquote>\n<p>For a struct <code>#[derive(Debug)]</code> prints, the name of the <code>struct</code> , <code>{</code> , comma-separated list of each field‚Äôs name and debug value and <code>}</code>.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">use std::fmt;\n\n#[derive(Debug)] // derive std::fmt::Debug on AppError\nstruct AppError {\n    code: usize,\n    message: String,\n}\n\nimpl fmt::Display for AppError {\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {\n        let err_msg = match self.code {\n            404 =&gt; &quot;Sorry, Can not find the Page!&quot;,\n            _ =&gt; &quot;Sorry, something is wrong! Please Try Again!&quot;,\n        };\n\n        write!(f, &quot;{}&quot;, err_msg)\n    }\n}\n\nfn produce_error() -&gt; Result&lt;(), AppError&gt; {\n    Err(AppError {\n        code: 404,\n        message: String::from(&quot;Page not found&quot;),\n    })\n}\n\nfn main() {\n    match produce_error() {\n        Err(e) =&gt; eprintln!(&quot;{}&quot;, e), // Sorry, Can not find the Page!\n        _ =&gt; println!(&quot;No error&quot;),\n    }\n\n    eprintln!(&quot;{:?}&quot;, produce_error()); // Err(AppError { code: 404, message: Page not found })\n\n    eprintln!(&quot;{:#?}&quot;, produce_error());\n    // Err(\n    //     AppError {\n    //         code: 404,\n    //         message: &quot;Page not found&quot;\n    //     }\n    // )\n}\n</code></pre>\n<h2 id=\"From-trait\"><a href=\"#From-trait\" class=\"headerlink\" title=\"From trait\"></a>From trait</h2><p>When writing real programs, mostly we have to deal with different modules, different <code>std</code> and third party crates at the same time. But each crate uses their own error types and if we are using our own error type, we should convert those errors into our error type. There is a standardized trait we can use for these conversions, <code>std::convert::From</code>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// traits inside Rust standard library core convert module/ std::convert\npub trait From&lt;T&gt;: Sized {\n  fn from(_: T) -&gt; Self;\n}\n</code></pre>\n<blockquote>\n<p>üí° As you know, <code>String::from()</code> function is used to create a <code>String</code> from <code>&amp;str</code> data type. Actually this also an implementation of <code>std::convert::From</code> trait.</p>\n</blockquote>\n<p>Let‚Äôs see how to implement <code>std::convert::From</code> trait on a custom error type.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">use std::fs::File;\nuse std::io;\n\n#[derive(Debug)]\nstruct AppError {\n    kind: String,    // type of the error\n    message: String, // error message\n}\n\n// Implement std::convert::From for AppError; from io::Error\nimpl From&lt;io::Error&gt; for AppError {\n    fn from(error: io::Error) -&gt; Self {\n        AppError {\n            kind: String::from(&quot;io&quot;),\n            message: error.to_string(),\n        }\n    }\n}\n\nfn main() -&gt; Result&lt;(), AppError&gt; {\n    let _file = File::open(&quot;nonexistent_file.txt&quot;)?; // This generates an io::Error. But because of return type is Result&lt;(), AppError&gt;, it converts to AppError\n\n    Ok(())\n}\n\n\n// --------------- Run time error ---------------\nError: AppError { kind: &quot;io&quot;, message: &quot;No such file or directory (os error 2)&quot; }\n</code></pre>\n<p>In the above example, <code>File::open(‚Äúnonexistent.txt‚Äù)?</code> produces <code>std::io::Error</code>. But because of the return type is <code>Result&lt;(), AppError&gt;</code>, it converts to an <code>AppError</code>. Because of we are propagating the error from <code>main()</code> function, it prints the <code>Debug</code> representation of the <code>Err</code>.</p>\n<p>In the above example we deal with only one <code>std</code> error type, <code>std::io::Error</code>. Let‚Äôs see some example which handles multiple <code>std</code> error types.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">use std::fs::File;\nuse std::io::{self, Read};\nuse std::num;\n\n#[derive(Debug)]\nstruct AppError {\n    kind: String,\n    message: String,\n}\n\n// Implement std::convert::From for AppError; from io::Error\nimpl From&lt;io::Error&gt; for AppError {\n    fn from(error: io::Error) -&gt; Self {\n        AppError {\n            kind: String::from(&quot;io&quot;),\n            message: error.to_string(),\n        }\n    }\n}\n\n// Implement std::convert::From for AppError; from num::ParseIntError\nimpl From&lt;num::ParseIntError&gt; for AppError {\n    fn from(error: num::ParseIntError) -&gt; Self {\n        AppError {\n            kind: String::from(&quot;parse&quot;),\n            message: error.to_string(),\n        }\n    }\n}\n\nfn main() -&gt; Result&lt;(), AppError&gt; {\n    let mut file = File::open(&quot;hello_world.txt&quot;)?; // generates an io::Error, if can not open the file and converts to an AppError\n\n    let mut content = String::new();\n    file.read_to_string(&amp;mut content)?; // generates an io::Error, if can not read file content and converts to an AppError\n\n    let _number: usize;\n    _number = content.parse()?; // generates num::ParseIntError, if can not convert file content to usize and converts to an AppError\n\n    Ok(())\n}\n\n\n// --------------- Few possible run time errors ---------------\n\n// 01. If hello_world.txt is a nonexistent file\nError: AppError { kind: &quot;io&quot;, message: &quot;No such file or directory (os error 2)&quot; }\n\n// 02. If user doesn&#39;t have relevant permission to access hello_world.txt\nError: AppError { kind: &quot;io&quot;, message: &quot;Permission denied (os error 13)&quot; }\n\n// 03. If hello_world.txt contains non-numeric content. ex Hello, world!\nError: AppError { kind: &quot;parse&quot;, message: &quot;invalid digit found in string&quot; }\n</code></pre>\n<blockquote>\n<p>üîé Search about the implementation of <a href=\"https://doc.rust-lang.org/std/io/enum.ErrorKind.html\" target=\"_blank\" rel=\"noopener\"><code>std::io::ErrorKind</code></a>, to see how to organize error types further.</p>\n</blockquote>\n"},{"title":"ÂÆâË£ÖRust","_content":"\n## Rustup\nÊÉ≥Ë¶ÅÂú®Á≥ªÁªü‰∏≠ÂÆâË£ÖRustÔºåÊúâÂæàÂ§öÊñπÊ≥ïÂèØ‰ª•‰æõÊÇ®ÈÄâÊã©„ÄÇÊ≠§Êó∂ÂÆòÊñπÊé®ËçêÁöÑÂÆâË£ÖÊñπÂºèÊòØ‰ΩøÁî®[Rustup](https://rustup.rs/)„ÄÇ\n\n[üìñ](https://github.com/rust-lang-nursery/rustup.rs) Rustup‰ºöÈÄöËøáÂÆòÊñπÁöÑÈáäÊîæÊ∏†ÈÅì‰∏ãËΩΩÂπ∂ÂÆâË£ÖRust„ÄÇÊÇ®ÂèØ‰ª•ËΩªÊùæÁöÑÂú®**stable, beta, and nightly**‰∏â‰∏™ÂàÜÊîØÁâàÊú¨‰∏≠ËøõË°åÂàáÊç¢ÔºåÂπ∂ÊúâÊïàÁöÑ‰ΩøÂÖ∂‰øùÊåÅÊõ¥Êñ∞„ÄÇËøô‰∫õÈÄöÁî®Âπ≥Âè∞‰∏äÁöÑ‰∫åËøõÂà∂Ê†áÂáÜÂ∫ìÔºå‰ºö‰ΩøÂæóÂú®ÈúÄË¶ÅËøõË°å‰∫§ÂèâÁºñËØëÂèòÂæóÁÆÄÂçïËµ∑Êù•„ÄÇ\n\n[üìñ](https://github.com/rust-lang-nursery/rustup.rs#installation) Rustup‰ºöÂÆâË£Ö**`rustc`Ôºå`cargo`Ôºå`rustup`**ÂíåÂÖ∂‰ªñ‰∏Ä‰∫õÊ†áÂáÜÂ∑•ÂÖ∑Âà∞CargoÁöÑ`bin` ÁõÆÂΩï‰∏ã„ÄÇÂú®Unix‰∏≠ÔºåÂÆÉ‰Ωç‰∫é`$HOME/.cargo/bin`Ë∑ØÂæÑ‰∏ãÔºåËÄåWindowsÁ≥ªÁªü‰∏≠ÔºåÂàô‰Ωç‰∫é`%USERPROFILE%\\.cargo\\bin`ÁõÆÂΩï‰∏ã„ÄÇËØ•ÁõÆÂΩï‰πüÊòØÂΩì‰ΩøÁî®`cargo install`ÂÆâË£ÖRustÁ®ãÂ∫èÂíåCargoÊèí‰ª∂Êó∂ÁöÑÈªòËÆ§ÁõÆÊ†á‰ΩçÁΩÆ„ÄÇ\n\n> ‚≠êÔ∏è Â¶ÇÊûú‰Ω†Âú®‰ΩøÁî®**Microsoft Windows**Êìç‰ΩúÁ≥ªÁªüÔºå‰Ω†ÈúÄË¶ÅÂÆâË£Ö**Visual C++ Build Tools** 2013ÊàñÊõ¥È´òÁâàÊú¨„ÄÇÊé®ËçêÁöÑÂÆâË£ÖÈÄîÂæÑÊòØÁõ¥Êé•ÂÆâË£ÖVisual C++ 2015 Build ToolsÔºå‰ΩÜËøôÂèØËÉΩÈúÄË¶ÅÈ¢ùÂ§ñÁöÑ3‚Äì4GBÁ©∫Èó¥„ÄÇ\n\n### ÈÄÇÁî®‰∫éMacÂíåLinuxÁî®Êà∑\n```bash\ncurl https://sh.rustup.rs -sSf | sh\n```\n\n### ÈÄÇÁî®‰∫éWindowsÁî®Êà∑\n‰ªé[www.rustup.rs](https://rustup.rs/)‰∏ãËΩΩ**`rustup-init.exe`**Âπ∂Âä†‰ª•ÊâßË°å\n\nüí° Êõ¥Â§ö‰ø°ÊÅØÂèØ‰ª•Âú®[RustupÈ°πÁõÆÁöÑGithub‰ªìÂ∫ìÈ°µÈù¢](https://github.com/rust-lang-nursery/rustup.rs)ËøõË°åÊü•ÈòÖ\n\nÂÆåÊàêRustÁöÑÂÆâË£Ö‰πãÂêéÔºå‰Ω†ÂèØ‰ª•Âú®ÁªàÁ´ØÈîÆÂÖ•`rustc --version`Êàñ`rustc -V`Êù•Ê†°È™åÂÆâË£ÖÊòØÂê¶ÊàêÂäü„ÄÇ\n","source":"docs/zh-cn/a2.installation.md","raw":"title: ÂÆâË£ÖRust\n---\n\n## Rustup\nÊÉ≥Ë¶ÅÂú®Á≥ªÁªü‰∏≠ÂÆâË£ÖRustÔºåÊúâÂæàÂ§öÊñπÊ≥ïÂèØ‰ª•‰æõÊÇ®ÈÄâÊã©„ÄÇÊ≠§Êó∂ÂÆòÊñπÊé®ËçêÁöÑÂÆâË£ÖÊñπÂºèÊòØ‰ΩøÁî®[Rustup](https://rustup.rs/)„ÄÇ\n\n[üìñ](https://github.com/rust-lang-nursery/rustup.rs) Rustup‰ºöÈÄöËøáÂÆòÊñπÁöÑÈáäÊîæÊ∏†ÈÅì‰∏ãËΩΩÂπ∂ÂÆâË£ÖRust„ÄÇÊÇ®ÂèØ‰ª•ËΩªÊùæÁöÑÂú®**stable, beta, and nightly**‰∏â‰∏™ÂàÜÊîØÁâàÊú¨‰∏≠ËøõË°åÂàáÊç¢ÔºåÂπ∂ÊúâÊïàÁöÑ‰ΩøÂÖ∂‰øùÊåÅÊõ¥Êñ∞„ÄÇËøô‰∫õÈÄöÁî®Âπ≥Âè∞‰∏äÁöÑ‰∫åËøõÂà∂Ê†áÂáÜÂ∫ìÔºå‰ºö‰ΩøÂæóÂú®ÈúÄË¶ÅËøõË°å‰∫§ÂèâÁºñËØëÂèòÂæóÁÆÄÂçïËµ∑Êù•„ÄÇ\n\n[üìñ](https://github.com/rust-lang-nursery/rustup.rs#installation) Rustup‰ºöÂÆâË£Ö**`rustc`Ôºå`cargo`Ôºå`rustup`**ÂíåÂÖ∂‰ªñ‰∏Ä‰∫õÊ†áÂáÜÂ∑•ÂÖ∑Âà∞CargoÁöÑ`bin` ÁõÆÂΩï‰∏ã„ÄÇÂú®Unix‰∏≠ÔºåÂÆÉ‰Ωç‰∫é`$HOME/.cargo/bin`Ë∑ØÂæÑ‰∏ãÔºåËÄåWindowsÁ≥ªÁªü‰∏≠ÔºåÂàô‰Ωç‰∫é`%USERPROFILE%\\.cargo\\bin`ÁõÆÂΩï‰∏ã„ÄÇËØ•ÁõÆÂΩï‰πüÊòØÂΩì‰ΩøÁî®`cargo install`ÂÆâË£ÖRustÁ®ãÂ∫èÂíåCargoÊèí‰ª∂Êó∂ÁöÑÈªòËÆ§ÁõÆÊ†á‰ΩçÁΩÆ„ÄÇ\n\n> ‚≠êÔ∏è Â¶ÇÊûú‰Ω†Âú®‰ΩøÁî®**Microsoft Windows**Êìç‰ΩúÁ≥ªÁªüÔºå‰Ω†ÈúÄË¶ÅÂÆâË£Ö**Visual C++ Build Tools** 2013ÊàñÊõ¥È´òÁâàÊú¨„ÄÇÊé®ËçêÁöÑÂÆâË£ÖÈÄîÂæÑÊòØÁõ¥Êé•ÂÆâË£ÖVisual C++ 2015 Build ToolsÔºå‰ΩÜËøôÂèØËÉΩÈúÄË¶ÅÈ¢ùÂ§ñÁöÑ3‚Äì4GBÁ©∫Èó¥„ÄÇ\n\n### ÈÄÇÁî®‰∫éMacÂíåLinuxÁî®Êà∑\n```bash\ncurl https://sh.rustup.rs -sSf | sh\n```\n\n### ÈÄÇÁî®‰∫éWindowsÁî®Êà∑\n‰ªé[www.rustup.rs](https://rustup.rs/)‰∏ãËΩΩ**`rustup-init.exe`**Âπ∂Âä†‰ª•ÊâßË°å\n\nüí° Êõ¥Â§ö‰ø°ÊÅØÂèØ‰ª•Âú®[RustupÈ°πÁõÆÁöÑGithub‰ªìÂ∫ìÈ°µÈù¢](https://github.com/rust-lang-nursery/rustup.rs)ËøõË°åÊü•ÈòÖ\n\nÂÆåÊàêRustÁöÑÂÆâË£Ö‰πãÂêéÔºå‰Ω†ÂèØ‰ª•Âú®ÁªàÁ´ØÈîÆÂÖ•`rustc --version`Êàñ`rustc -V`Êù•Ê†°È™åÂÆâË£ÖÊòØÂê¶ÊàêÂäü„ÄÇ\n","date":"2019-03-19T14:50:31.980Z","updated":"2019-03-19T14:50:31.980Z","path":"docs/zh-cn/a2.installation.html","comments":1,"layout":"page","_id":"cjtfwbj0m000zdwgpfvc6wd96","content":"<h2 id=\"Rustup\"><a href=\"#Rustup\" class=\"headerlink\" title=\"Rustup\"></a>Rustup</h2><p>ÊÉ≥Ë¶ÅÂú®Á≥ªÁªü‰∏≠ÂÆâË£ÖRustÔºåÊúâÂæàÂ§öÊñπÊ≥ïÂèØ‰ª•‰æõÊÇ®ÈÄâÊã©„ÄÇÊ≠§Êó∂ÂÆòÊñπÊé®ËçêÁöÑÂÆâË£ÖÊñπÂºèÊòØ‰ΩøÁî®<a href=\"https://rustup.rs/\" target=\"_blank\" rel=\"noopener\">Rustup</a>„ÄÇ</p>\n<p><a href=\"https://github.com/rust-lang-nursery/rustup.rs\" target=\"_blank\" rel=\"noopener\">üìñ</a> Rustup‰ºöÈÄöËøáÂÆòÊñπÁöÑÈáäÊîæÊ∏†ÈÅì‰∏ãËΩΩÂπ∂ÂÆâË£ÖRust„ÄÇÊÇ®ÂèØ‰ª•ËΩªÊùæÁöÑÂú®<strong>stable, beta, and nightly</strong>‰∏â‰∏™ÂàÜÊîØÁâàÊú¨‰∏≠ËøõË°åÂàáÊç¢ÔºåÂπ∂ÊúâÊïàÁöÑ‰ΩøÂÖ∂‰øùÊåÅÊõ¥Êñ∞„ÄÇËøô‰∫õÈÄöÁî®Âπ≥Âè∞‰∏äÁöÑ‰∫åËøõÂà∂Ê†áÂáÜÂ∫ìÔºå‰ºö‰ΩøÂæóÂú®ÈúÄË¶ÅËøõË°å‰∫§ÂèâÁºñËØëÂèòÂæóÁÆÄÂçïËµ∑Êù•„ÄÇ</p>\n<p><a href=\"https://github.com/rust-lang-nursery/rustup.rs#installation\" target=\"_blank\" rel=\"noopener\">üìñ</a> Rustup‰ºöÂÆâË£Ö<strong><code>rustc</code>Ôºå<code>cargo</code>Ôºå<code>rustup</code></strong>ÂíåÂÖ∂‰ªñ‰∏Ä‰∫õÊ†áÂáÜÂ∑•ÂÖ∑Âà∞CargoÁöÑ<code>bin</code> ÁõÆÂΩï‰∏ã„ÄÇÂú®Unix‰∏≠ÔºåÂÆÉ‰Ωç‰∫é<code>$HOME/.cargo/bin</code>Ë∑ØÂæÑ‰∏ãÔºåËÄåWindowsÁ≥ªÁªü‰∏≠ÔºåÂàô‰Ωç‰∫é<code>%USERPROFILE%\\.cargo\\bin</code>ÁõÆÂΩï‰∏ã„ÄÇËØ•ÁõÆÂΩï‰πüÊòØÂΩì‰ΩøÁî®<code>cargo install</code>ÂÆâË£ÖRustÁ®ãÂ∫èÂíåCargoÊèí‰ª∂Êó∂ÁöÑÈªòËÆ§ÁõÆÊ†á‰ΩçÁΩÆ„ÄÇ</p>\n<blockquote>\n<p>‚≠êÔ∏è Â¶ÇÊûú‰Ω†Âú®‰ΩøÁî®<strong>Microsoft Windows</strong>Êìç‰ΩúÁ≥ªÁªüÔºå‰Ω†ÈúÄË¶ÅÂÆâË£Ö<strong>Visual C++ Build Tools</strong> 2013ÊàñÊõ¥È´òÁâàÊú¨„ÄÇÊé®ËçêÁöÑÂÆâË£ÖÈÄîÂæÑÊòØÁõ¥Êé•ÂÆâË£ÖVisual C++ 2015 Build ToolsÔºå‰ΩÜËøôÂèØËÉΩÈúÄË¶ÅÈ¢ùÂ§ñÁöÑ3‚Äì4GBÁ©∫Èó¥„ÄÇ</p>\n</blockquote>\n<h3 id=\"ÈÄÇÁî®‰∫éMacÂíåLinuxÁî®Êà∑\"><a href=\"#ÈÄÇÁî®‰∫éMacÂíåLinuxÁî®Êà∑\" class=\"headerlink\" title=\"ÈÄÇÁî®‰∫éMacÂíåLinuxÁî®Êà∑\"></a>ÈÄÇÁî®‰∫éMacÂíåLinuxÁî®Êà∑</h3><p></p><p class=\"code-caption\" data-lang=\"bash\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"bash\">curl https://sh.rustup.rs -sSf | sh\n</code></pre>\n<h3 id=\"ÈÄÇÁî®‰∫éWindowsÁî®Êà∑\"><a href=\"#ÈÄÇÁî®‰∫éWindowsÁî®Êà∑\" class=\"headerlink\" title=\"ÈÄÇÁî®‰∫éWindowsÁî®Êà∑\"></a>ÈÄÇÁî®‰∫éWindowsÁî®Êà∑</h3><p>‰ªé<a href=\"https://rustup.rs/\" target=\"_blank\" rel=\"noopener\">www.rustup.rs</a>‰∏ãËΩΩ<strong><code>rustup-init.exe</code></strong>Âπ∂Âä†‰ª•ÊâßË°å</p>\n<p>üí° Êõ¥Â§ö‰ø°ÊÅØÂèØ‰ª•Âú®<a href=\"https://github.com/rust-lang-nursery/rustup.rs\" target=\"_blank\" rel=\"noopener\">RustupÈ°πÁõÆÁöÑGithub‰ªìÂ∫ìÈ°µÈù¢</a>ËøõË°åÊü•ÈòÖ</p>\n<p>ÂÆåÊàêRustÁöÑÂÆâË£Ö‰πãÂêéÔºå‰Ω†ÂèØ‰ª•Âú®ÁªàÁ´ØÈîÆÂÖ•<code>rustc --version</code>Êàñ<code>rustc -V</code>Êù•Ê†°È™åÂÆâË£ÖÊòØÂê¶ÊàêÂäü„ÄÇ</p>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<h2 id=\"Rustup\"><a href=\"#Rustup\" class=\"headerlink\" title=\"Rustup\"></a>Rustup</h2><p>ÊÉ≥Ë¶ÅÂú®Á≥ªÁªü‰∏≠ÂÆâË£ÖRustÔºåÊúâÂæàÂ§öÊñπÊ≥ïÂèØ‰ª•‰æõÊÇ®ÈÄâÊã©„ÄÇÊ≠§Êó∂ÂÆòÊñπÊé®ËçêÁöÑÂÆâË£ÖÊñπÂºèÊòØ‰ΩøÁî®<a href=\"https://rustup.rs/\" target=\"_blank\" rel=\"noopener\">Rustup</a>„ÄÇ</p>\n<p><a href=\"https://github.com/rust-lang-nursery/rustup.rs\" target=\"_blank\" rel=\"noopener\">üìñ</a> Rustup‰ºöÈÄöËøáÂÆòÊñπÁöÑÈáäÊîæÊ∏†ÈÅì‰∏ãËΩΩÂπ∂ÂÆâË£ÖRust„ÄÇÊÇ®ÂèØ‰ª•ËΩªÊùæÁöÑÂú®<strong>stable, beta, and nightly</strong>‰∏â‰∏™ÂàÜÊîØÁâàÊú¨‰∏≠ËøõË°åÂàáÊç¢ÔºåÂπ∂ÊúâÊïàÁöÑ‰ΩøÂÖ∂‰øùÊåÅÊõ¥Êñ∞„ÄÇËøô‰∫õÈÄöÁî®Âπ≥Âè∞‰∏äÁöÑ‰∫åËøõÂà∂Ê†áÂáÜÂ∫ìÔºå‰ºö‰ΩøÂæóÂú®ÈúÄË¶ÅËøõË°å‰∫§ÂèâÁºñËØëÂèòÂæóÁÆÄÂçïËµ∑Êù•„ÄÇ</p>\n<p><a href=\"https://github.com/rust-lang-nursery/rustup.rs#installation\" target=\"_blank\" rel=\"noopener\">üìñ</a> Rustup‰ºöÂÆâË£Ö<strong><code>rustc</code>Ôºå<code>cargo</code>Ôºå<code>rustup</code></strong>ÂíåÂÖ∂‰ªñ‰∏Ä‰∫õÊ†áÂáÜÂ∑•ÂÖ∑Âà∞CargoÁöÑ<code>bin</code> ÁõÆÂΩï‰∏ã„ÄÇÂú®Unix‰∏≠ÔºåÂÆÉ‰Ωç‰∫é<code>$HOME/.cargo/bin</code>Ë∑ØÂæÑ‰∏ãÔºåËÄåWindowsÁ≥ªÁªü‰∏≠ÔºåÂàô‰Ωç‰∫é<code>%USERPROFILE%\\.cargo\\bin</code>ÁõÆÂΩï‰∏ã„ÄÇËØ•ÁõÆÂΩï‰πüÊòØÂΩì‰ΩøÁî®<code>cargo install</code>ÂÆâË£ÖRustÁ®ãÂ∫èÂíåCargoÊèí‰ª∂Êó∂ÁöÑÈªòËÆ§ÁõÆÊ†á‰ΩçÁΩÆ„ÄÇ</p>\n<blockquote>\n<p>‚≠êÔ∏è Â¶ÇÊûú‰Ω†Âú®‰ΩøÁî®<strong>Microsoft Windows</strong>Êìç‰ΩúÁ≥ªÁªüÔºå‰Ω†ÈúÄË¶ÅÂÆâË£Ö<strong>Visual C++ Build Tools</strong> 2013ÊàñÊõ¥È´òÁâàÊú¨„ÄÇÊé®ËçêÁöÑÂÆâË£ÖÈÄîÂæÑÊòØÁõ¥Êé•ÂÆâË£ÖVisual C++ 2015 Build ToolsÔºå‰ΩÜËøôÂèØËÉΩÈúÄË¶ÅÈ¢ùÂ§ñÁöÑ3‚Äì4GBÁ©∫Èó¥„ÄÇ</p>\n</blockquote>\n<h3 id=\"ÈÄÇÁî®‰∫éMacÂíåLinuxÁî®Êà∑\"><a href=\"#ÈÄÇÁî®‰∫éMacÂíåLinuxÁî®Êà∑\" class=\"headerlink\" title=\"ÈÄÇÁî®‰∫éMacÂíåLinuxÁî®Êà∑\"></a>ÈÄÇÁî®‰∫éMacÂíåLinuxÁî®Êà∑</h3><p></p><p class=\"code-caption\" data-lang=\"bash\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"bash\">curl https://sh.rustup.rs -sSf | sh\n</code></pre>\n<h3 id=\"ÈÄÇÁî®‰∫éWindowsÁî®Êà∑\"><a href=\"#ÈÄÇÁî®‰∫éWindowsÁî®Êà∑\" class=\"headerlink\" title=\"ÈÄÇÁî®‰∫éWindowsÁî®Êà∑\"></a>ÈÄÇÁî®‰∫éWindowsÁî®Êà∑</h3><p>‰ªé<a href=\"https://rustup.rs/\" target=\"_blank\" rel=\"noopener\">www.rustup.rs</a>‰∏ãËΩΩ<strong><code>rustup-init.exe</code></strong>Âπ∂Âä†‰ª•ÊâßË°å</p>\n<p>üí° Êõ¥Â§ö‰ø°ÊÅØÂèØ‰ª•Âú®<a href=\"https://github.com/rust-lang-nursery/rustup.rs\" target=\"_blank\" rel=\"noopener\">RustupÈ°πÁõÆÁöÑGithub‰ªìÂ∫ìÈ°µÈù¢</a>ËøõË°åÊü•ÈòÖ</p>\n<p>ÂÆåÊàêRustÁöÑÂÆâË£Ö‰πãÂêéÔºå‰Ω†ÂèØ‰ª•Âú®ÁªàÁ´ØÈîÆÂÖ•<code>rustc --version</code>Êàñ<code>rustc -V</code>Êù•Ê†°È™åÂÆâË£ÖÊòØÂê¶ÊàêÂäü„ÄÇ</p>\n"},{"title":"‰∏∫‰ªÄ‰πà‰ºöÊúâRust?","_content":"\n## RustÁöÑÂéÜÂè≤\nRustÊúÄÂàùÁî±MozillaÁöÑÂëòÂ∑•**Graydon Hoare**‰Ωú‰∏∫‰∏™‰∫∫È°πÁõÆËÆæËÆ°Âπ∂ÂºÄÂèë„ÄÇ‰ªé2009Âπ¥ÂºÄÂßãÔºåMozillaÂºÄÂßãËµÑÂä©ËØ•È°πÁõÆÔºåÂπ∂‰∫é2010Âπ¥Ê≠£ÂºèÂèëÂ∏É„ÄÇ‰ΩÜÊòØÁ¨¨‰∏Ä‰∏™Á®≥ÂÆöÁâàÊú¨ÔºåRust 1.0Âú®2015Âπ¥5Êúà15Êó•ÊâçÊ≠£ÂºèÊîæÂá∫„ÄÇÁªèËøá‰∏âÂπ¥ÁöÑÈî§ÁÇº‰∏éÊ¥óÁ§ºÔºå2018Âπ¥12Êúà6Êó•ÔºåRustÁöÑÁ¨¨‰∏Ä‰∏™ÈáçË¶ÅÊõ¥Êñ∞ÁâàÊú¨‚Äî‚ÄîRust2018(v1.31)Ê≠£ÂºèÂèëÂ∏É„ÄÇ\n\n## RustÊÑøÊôØ\nRustÁöÑÁõÆÊ†áÊòØ‰∏∫‰∫ÜÂª∫Á´ãÈ´òÂπ∂Âèë‰ª•ÂèäÈ´òÂ∫¶ÂÆâÂÖ®ÁöÑÁ≥ªÁªü„ÄÇÂõ†Ê≠§ÔºåRustË¢´ËÆæËÆ°Áî®‰ª•ÂêåÊó∂Êèê‰æõÈÄüÂ∫¶ÂíåÂÆâÂÖ®ÊÄß„ÄÇ\n\n> \"Rust is a systems programming language focused on three goals: safety, speed, and concurrency.\"  \n> \\_\\_ Rust Documentation\n\nRustÊòØ‰∏Ä‰∏™Âπ¥ËΩªÂèàÁé∞‰ª£ÁöÑÁºñÁ®ãËØ≠Ë®Ä„ÄÇÂÆÉÊòØ‰∏ÄÁßç**È¢ÑÁºñËØëËØ≠Ë®Ä**Âπ∂‰ΩøÁî®[LLVM](https://en.wikipedia.org/wiki/LLVM)‰Ωú‰∏∫ÂêéÁõæ„ÄÇÂêåÊó∂ÔºåRustÊòØ‰∏Ä‰∏™**Â§öËåÉÂºèÁºñÁ®ãËØ≠Ë®Ä**Ôºå ÂÆÉËûçÂêà‰∫ÜËøáÁ®ãÂºèÁºñÁ®ã„ÄÅÂπ∂ÂèëËßíËâ≤Ê®°Âûã„ÄÅÈù¢ÂêëÂØπË±°ÁºñÁ®ã‰ª•ÂèäÁ∫ØÂáΩÊï∞ÂºèÁºñÁ®ãÈ£éÊ†º„ÄÇ‰πüÂêåÊ†∑Âú®ÈùôÊÄÅÂíåÂä®ÊÄÅ‰∏§ÁßçÂ±ÇÈù¢‰∏äÊîØÊåÅËåÉÂûãÁºñÁ®ãÂíåÂÖÉÁºñÁ®ãÁ≠âËåÉÂºè„ÄÇ\n\n> üîé One of Rust‚Äôs most unique and compelling features is [Ownership](c1.ownership.html), which is used to achieve memory safety. Rust creates memory pointers optimistically, checks memory pointers‚Äô limited accesses at the compiler time with the usage of [References and Borrowing](c2.borrowing.html). And it does automatic compile time memory management by checking the [Lifetimes](c3.lifetimes.html).\n\n## ÁÅµÊÑüÊù•Ê∫ê\nRustÂú®ËÆæËÆ°ÁöÑËøáÁ®ã‰∏≠Ôºå‰ªéÂæàÂ§öËØ≠Ë®ÄÊ±≤Âèñ‰∫ÜËØ∏Â§öÁÅµÊÑüÔºö\n\n* ÊäΩË±°Êú∫Âô®Ê®°Âûã - Abstract Machine Model : **C**\n* Êï∞ÊçÆÁ±ªÂûã - Data types : **C, SML, OCaml, Lisp, Limbo**\n* ÂèØÈÄâÁªëÂÆö - Optional Bindings : **Swift**\n* Ê¥ÅÂáÄÂÆè - Hygienic Macros : **Scheme**\n* ÂáΩÊï∞ÂºèÁºñÁ®ã - Functional Programming : **Haskell, OCaml, F\\#**\n* Â±ûÊÄßÊ†áÁ≠æ - Attributes : **ECMA**-335\n* ÂÜÖÂ≠òÊ®°Âûã‰∏éÂÜÖÂ≠òÁÆ°ÁêÜ - Memory Model and Memory Management : **C++, ML Kit, Cyclone**\n* Á±ªÂûãÊ®°Êùø - Type Classes : **Haskell**\n* ‰ª£Á†ÅÁÆ± - Crate : Assembly in the **ECMA**-335 CLI model\n* ÈÄöÈÅì‰∏éÂπ∂Âèë - Channels and Concurrency : **Newsqueak, Alef, Limbo**\n* Ê∂àÊÅØ‰º†ÈÄí‰∏éÁ∫øÁ®ãÂ§±Ë¥•Â§ÑÁêÜ - Message passing and Thread failure : **Erlang**  \n\n‰ª•ÂèäÂÖ∂‰ªñ„ÄÇ\n\n\nRustÈªòËÆ§ÊÉÖÂÜµ‰∏ã**Âπ∂‰∏ç‰ΩøÁî®Ëá™Âä®ÂûÉÂúæÂõûÊî∂Êú∫Âà∂ÔºàGC)**„ÄÇ\n\nRustÁºñËØëÂô®Âú®**ÁºñËØëÈò∂ÊÆµ**‰ºöÂØπ‰ª£Á†ÅÂÅöÂ§ßÈáèÊ£ÄÊü•‰ª•Â∞ΩÈáèÈò≤Ê≠¢Âú®C++‰ª£Á†Å‰∏≠ËæÉ‰∏∫Â∏∏ËßÅÁöÑ[**ÂèØËÉΩÁöÑÁ±ªÂûãÈîôËØØ**](https://doc.rust-lang.org/error-index.html) „ÄÇ\n","source":"docs/zh-cn/a1.why_rust.md","raw":"title: ‰∏∫‰ªÄ‰πà‰ºöÊúâRust?\n---\n\n## RustÁöÑÂéÜÂè≤\nRustÊúÄÂàùÁî±MozillaÁöÑÂëòÂ∑•**Graydon Hoare**‰Ωú‰∏∫‰∏™‰∫∫È°πÁõÆËÆæËÆ°Âπ∂ÂºÄÂèë„ÄÇ‰ªé2009Âπ¥ÂºÄÂßãÔºåMozillaÂºÄÂßãËµÑÂä©ËØ•È°πÁõÆÔºåÂπ∂‰∫é2010Âπ¥Ê≠£ÂºèÂèëÂ∏É„ÄÇ‰ΩÜÊòØÁ¨¨‰∏Ä‰∏™Á®≥ÂÆöÁâàÊú¨ÔºåRust 1.0Âú®2015Âπ¥5Êúà15Êó•ÊâçÊ≠£ÂºèÊîæÂá∫„ÄÇÁªèËøá‰∏âÂπ¥ÁöÑÈî§ÁÇº‰∏éÊ¥óÁ§ºÔºå2018Âπ¥12Êúà6Êó•ÔºåRustÁöÑÁ¨¨‰∏Ä‰∏™ÈáçË¶ÅÊõ¥Êñ∞ÁâàÊú¨‚Äî‚ÄîRust2018(v1.31)Ê≠£ÂºèÂèëÂ∏É„ÄÇ\n\n## RustÊÑøÊôØ\nRustÁöÑÁõÆÊ†áÊòØ‰∏∫‰∫ÜÂª∫Á´ãÈ´òÂπ∂Âèë‰ª•ÂèäÈ´òÂ∫¶ÂÆâÂÖ®ÁöÑÁ≥ªÁªü„ÄÇÂõ†Ê≠§ÔºåRustË¢´ËÆæËÆ°Áî®‰ª•ÂêåÊó∂Êèê‰æõÈÄüÂ∫¶ÂíåÂÆâÂÖ®ÊÄß„ÄÇ\n\n> \"Rust is a systems programming language focused on three goals: safety, speed, and concurrency.\"  \n> \\_\\_ Rust Documentation\n\nRustÊòØ‰∏Ä‰∏™Âπ¥ËΩªÂèàÁé∞‰ª£ÁöÑÁºñÁ®ãËØ≠Ë®Ä„ÄÇÂÆÉÊòØ‰∏ÄÁßç**È¢ÑÁºñËØëËØ≠Ë®Ä**Âπ∂‰ΩøÁî®[LLVM](https://en.wikipedia.org/wiki/LLVM)‰Ωú‰∏∫ÂêéÁõæ„ÄÇÂêåÊó∂ÔºåRustÊòØ‰∏Ä‰∏™**Â§öËåÉÂºèÁºñÁ®ãËØ≠Ë®Ä**Ôºå ÂÆÉËûçÂêà‰∫ÜËøáÁ®ãÂºèÁºñÁ®ã„ÄÅÂπ∂ÂèëËßíËâ≤Ê®°Âûã„ÄÅÈù¢ÂêëÂØπË±°ÁºñÁ®ã‰ª•ÂèäÁ∫ØÂáΩÊï∞ÂºèÁºñÁ®ãÈ£éÊ†º„ÄÇ‰πüÂêåÊ†∑Âú®ÈùôÊÄÅÂíåÂä®ÊÄÅ‰∏§ÁßçÂ±ÇÈù¢‰∏äÊîØÊåÅËåÉÂûãÁºñÁ®ãÂíåÂÖÉÁºñÁ®ãÁ≠âËåÉÂºè„ÄÇ\n\n> üîé One of Rust‚Äôs most unique and compelling features is [Ownership](c1.ownership.html), which is used to achieve memory safety. Rust creates memory pointers optimistically, checks memory pointers‚Äô limited accesses at the compiler time with the usage of [References and Borrowing](c2.borrowing.html). And it does automatic compile time memory management by checking the [Lifetimes](c3.lifetimes.html).\n\n## ÁÅµÊÑüÊù•Ê∫ê\nRustÂú®ËÆæËÆ°ÁöÑËøáÁ®ã‰∏≠Ôºå‰ªéÂæàÂ§öËØ≠Ë®ÄÊ±≤Âèñ‰∫ÜËØ∏Â§öÁÅµÊÑüÔºö\n\n* ÊäΩË±°Êú∫Âô®Ê®°Âûã - Abstract Machine Model : **C**\n* Êï∞ÊçÆÁ±ªÂûã - Data types : **C, SML, OCaml, Lisp, Limbo**\n* ÂèØÈÄâÁªëÂÆö - Optional Bindings : **Swift**\n* Ê¥ÅÂáÄÂÆè - Hygienic Macros : **Scheme**\n* ÂáΩÊï∞ÂºèÁºñÁ®ã - Functional Programming : **Haskell, OCaml, F\\#**\n* Â±ûÊÄßÊ†áÁ≠æ - Attributes : **ECMA**-335\n* ÂÜÖÂ≠òÊ®°Âûã‰∏éÂÜÖÂ≠òÁÆ°ÁêÜ - Memory Model and Memory Management : **C++, ML Kit, Cyclone**\n* Á±ªÂûãÊ®°Êùø - Type Classes : **Haskell**\n* ‰ª£Á†ÅÁÆ± - Crate : Assembly in the **ECMA**-335 CLI model\n* ÈÄöÈÅì‰∏éÂπ∂Âèë - Channels and Concurrency : **Newsqueak, Alef, Limbo**\n* Ê∂àÊÅØ‰º†ÈÄí‰∏éÁ∫øÁ®ãÂ§±Ë¥•Â§ÑÁêÜ - Message passing and Thread failure : **Erlang**  \n\n‰ª•ÂèäÂÖ∂‰ªñ„ÄÇ\n\n\nRustÈªòËÆ§ÊÉÖÂÜµ‰∏ã**Âπ∂‰∏ç‰ΩøÁî®Ëá™Âä®ÂûÉÂúæÂõûÊî∂Êú∫Âà∂ÔºàGC)**„ÄÇ\n\nRustÁºñËØëÂô®Âú®**ÁºñËØëÈò∂ÊÆµ**‰ºöÂØπ‰ª£Á†ÅÂÅöÂ§ßÈáèÊ£ÄÊü•‰ª•Â∞ΩÈáèÈò≤Ê≠¢Âú®C++‰ª£Á†Å‰∏≠ËæÉ‰∏∫Â∏∏ËßÅÁöÑ[**ÂèØËÉΩÁöÑÁ±ªÂûãÈîôËØØ**](https://doc.rust-lang.org/error-index.html) „ÄÇ\n","date":"2019-03-19T14:50:31.980Z","updated":"2019-03-19T14:50:31.980Z","path":"docs/zh-cn/a1.why_rust.html","comments":1,"layout":"page","_id":"cjtfwbj0n0010dwgpon449cpv","content":"<h2 id=\"RustÁöÑÂéÜÂè≤\"><a href=\"#RustÁöÑÂéÜÂè≤\" class=\"headerlink\" title=\"RustÁöÑÂéÜÂè≤\"></a>RustÁöÑÂéÜÂè≤</h2><p>RustÊúÄÂàùÁî±MozillaÁöÑÂëòÂ∑•<strong>Graydon Hoare</strong>‰Ωú‰∏∫‰∏™‰∫∫È°πÁõÆËÆæËÆ°Âπ∂ÂºÄÂèë„ÄÇ‰ªé2009Âπ¥ÂºÄÂßãÔºåMozillaÂºÄÂßãËµÑÂä©ËØ•È°πÁõÆÔºåÂπ∂‰∫é2010Âπ¥Ê≠£ÂºèÂèëÂ∏É„ÄÇ‰ΩÜÊòØÁ¨¨‰∏Ä‰∏™Á®≥ÂÆöÁâàÊú¨ÔºåRust 1.0Âú®2015Âπ¥5Êúà15Êó•ÊâçÊ≠£ÂºèÊîæÂá∫„ÄÇÁªèËøá‰∏âÂπ¥ÁöÑÈî§ÁÇº‰∏éÊ¥óÁ§ºÔºå2018Âπ¥12Êúà6Êó•ÔºåRustÁöÑÁ¨¨‰∏Ä‰∏™ÈáçË¶ÅÊõ¥Êñ∞ÁâàÊú¨‚Äî‚ÄîRust2018(v1.31)Ê≠£ÂºèÂèëÂ∏É„ÄÇ</p>\n<h2 id=\"RustÊÑøÊôØ\"><a href=\"#RustÊÑøÊôØ\" class=\"headerlink\" title=\"RustÊÑøÊôØ\"></a>RustÊÑøÊôØ</h2><p>RustÁöÑÁõÆÊ†áÊòØ‰∏∫‰∫ÜÂª∫Á´ãÈ´òÂπ∂Âèë‰ª•ÂèäÈ´òÂ∫¶ÂÆâÂÖ®ÁöÑÁ≥ªÁªü„ÄÇÂõ†Ê≠§ÔºåRustË¢´ËÆæËÆ°Áî®‰ª•ÂêåÊó∂Êèê‰æõÈÄüÂ∫¶ÂíåÂÆâÂÖ®ÊÄß„ÄÇ</p>\n<blockquote>\n<p>‚ÄúRust is a systems programming language focused on three goals: safety, speed, and concurrency.‚Äù<br>__ Rust Documentation</p>\n</blockquote>\n<p>RustÊòØ‰∏Ä‰∏™Âπ¥ËΩªÂèàÁé∞‰ª£ÁöÑÁºñÁ®ãËØ≠Ë®Ä„ÄÇÂÆÉÊòØ‰∏ÄÁßç<strong>È¢ÑÁºñËØëËØ≠Ë®Ä</strong>Âπ∂‰ΩøÁî®<a href=\"https://en.wikipedia.org/wiki/LLVM\" target=\"_blank\" rel=\"noopener\">LLVM</a>‰Ωú‰∏∫ÂêéÁõæ„ÄÇÂêåÊó∂ÔºåRustÊòØ‰∏Ä‰∏™<strong>Â§öËåÉÂºèÁºñÁ®ãËØ≠Ë®Ä</strong>Ôºå ÂÆÉËûçÂêà‰∫ÜËøáÁ®ãÂºèÁºñÁ®ã„ÄÅÂπ∂ÂèëËßíËâ≤Ê®°Âûã„ÄÅÈù¢ÂêëÂØπË±°ÁºñÁ®ã‰ª•ÂèäÁ∫ØÂáΩÊï∞ÂºèÁºñÁ®ãÈ£éÊ†º„ÄÇ‰πüÂêåÊ†∑Âú®ÈùôÊÄÅÂíåÂä®ÊÄÅ‰∏§ÁßçÂ±ÇÈù¢‰∏äÊîØÊåÅËåÉÂûãÁºñÁ®ãÂíåÂÖÉÁºñÁ®ãÁ≠âËåÉÂºè„ÄÇ</p>\n<blockquote>\n<p>üîé One of Rust‚Äôs most unique and compelling features is <a href=\"c1.ownership.html\">Ownership</a>, which is used to achieve memory safety. Rust creates memory pointers optimistically, checks memory pointers‚Äô limited accesses at the compiler time with the usage of <a href=\"c2.borrowing.html\">References and Borrowing</a>. And it does automatic compile time memory management by checking the <a href=\"c3.lifetimes.html\">Lifetimes</a>.</p>\n</blockquote>\n<h2 id=\"ÁÅµÊÑüÊù•Ê∫ê\"><a href=\"#ÁÅµÊÑüÊù•Ê∫ê\" class=\"headerlink\" title=\"ÁÅµÊÑüÊù•Ê∫ê\"></a>ÁÅµÊÑüÊù•Ê∫ê</h2><p>RustÂú®ËÆæËÆ°ÁöÑËøáÁ®ã‰∏≠Ôºå‰ªéÂæàÂ§öËØ≠Ë®ÄÊ±≤Âèñ‰∫ÜËØ∏Â§öÁÅµÊÑüÔºö</p>\n<ul>\n<li>ÊäΩË±°Êú∫Âô®Ê®°Âûã - Abstract Machine Model : <strong>C</strong></li>\n<li>Êï∞ÊçÆÁ±ªÂûã - Data types : <strong>C, SML, OCaml, Lisp, Limbo</strong></li>\n<li>ÂèØÈÄâÁªëÂÆö - Optional Bindings : <strong>Swift</strong></li>\n<li>Ê¥ÅÂáÄÂÆè - Hygienic Macros : <strong>Scheme</strong></li>\n<li>ÂáΩÊï∞ÂºèÁºñÁ®ã - Functional Programming : <strong>Haskell, OCaml, F#</strong></li>\n<li>Â±ûÊÄßÊ†áÁ≠æ - Attributes : <strong>ECMA</strong>-335</li>\n<li>ÂÜÖÂ≠òÊ®°Âûã‰∏éÂÜÖÂ≠òÁÆ°ÁêÜ - Memory Model and Memory Management : <strong>C++, ML Kit, Cyclone</strong></li>\n<li>Á±ªÂûãÊ®°Êùø - Type Classes : <strong>Haskell</strong></li>\n<li>‰ª£Á†ÅÁÆ± - Crate : Assembly in the <strong>ECMA</strong>-335 CLI model</li>\n<li>ÈÄöÈÅì‰∏éÂπ∂Âèë - Channels and Concurrency : <strong>Newsqueak, Alef, Limbo</strong></li>\n<li>Ê∂àÊÅØ‰º†ÈÄí‰∏éÁ∫øÁ®ãÂ§±Ë¥•Â§ÑÁêÜ - Message passing and Thread failure : <strong>Erlang</strong>  </li>\n</ul>\n<p>‰ª•ÂèäÂÖ∂‰ªñ„ÄÇ</p>\n<p>RustÈªòËÆ§ÊÉÖÂÜµ‰∏ã<strong>Âπ∂‰∏ç‰ΩøÁî®Ëá™Âä®ÂûÉÂúæÂõûÊî∂Êú∫Âà∂ÔºàGC)</strong>„ÄÇ</p>\n<p>RustÁºñËØëÂô®Âú®<strong>ÁºñËØëÈò∂ÊÆµ</strong>‰ºöÂØπ‰ª£Á†ÅÂÅöÂ§ßÈáèÊ£ÄÊü•‰ª•Â∞ΩÈáèÈò≤Ê≠¢Âú®C++‰ª£Á†Å‰∏≠ËæÉ‰∏∫Â∏∏ËßÅÁöÑ<a href=\"https://doc.rust-lang.org/error-index.html\" target=\"_blank\" rel=\"noopener\"><strong>ÂèØËÉΩÁöÑÁ±ªÂûãÈîôËØØ</strong></a> „ÄÇ</p>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<h2 id=\"RustÁöÑÂéÜÂè≤\"><a href=\"#RustÁöÑÂéÜÂè≤\" class=\"headerlink\" title=\"RustÁöÑÂéÜÂè≤\"></a>RustÁöÑÂéÜÂè≤</h2><p>RustÊúÄÂàùÁî±MozillaÁöÑÂëòÂ∑•<strong>Graydon Hoare</strong>‰Ωú‰∏∫‰∏™‰∫∫È°πÁõÆËÆæËÆ°Âπ∂ÂºÄÂèë„ÄÇ‰ªé2009Âπ¥ÂºÄÂßãÔºåMozillaÂºÄÂßãËµÑÂä©ËØ•È°πÁõÆÔºåÂπ∂‰∫é2010Âπ¥Ê≠£ÂºèÂèëÂ∏É„ÄÇ‰ΩÜÊòØÁ¨¨‰∏Ä‰∏™Á®≥ÂÆöÁâàÊú¨ÔºåRust 1.0Âú®2015Âπ¥5Êúà15Êó•ÊâçÊ≠£ÂºèÊîæÂá∫„ÄÇÁªèËøá‰∏âÂπ¥ÁöÑÈî§ÁÇº‰∏éÊ¥óÁ§ºÔºå2018Âπ¥12Êúà6Êó•ÔºåRustÁöÑÁ¨¨‰∏Ä‰∏™ÈáçË¶ÅÊõ¥Êñ∞ÁâàÊú¨‚Äî‚ÄîRust2018(v1.31)Ê≠£ÂºèÂèëÂ∏É„ÄÇ</p>\n<h2 id=\"RustÊÑøÊôØ\"><a href=\"#RustÊÑøÊôØ\" class=\"headerlink\" title=\"RustÊÑøÊôØ\"></a>RustÊÑøÊôØ</h2><p>RustÁöÑÁõÆÊ†áÊòØ‰∏∫‰∫ÜÂª∫Á´ãÈ´òÂπ∂Âèë‰ª•ÂèäÈ´òÂ∫¶ÂÆâÂÖ®ÁöÑÁ≥ªÁªü„ÄÇÂõ†Ê≠§ÔºåRustË¢´ËÆæËÆ°Áî®‰ª•ÂêåÊó∂Êèê‰æõÈÄüÂ∫¶ÂíåÂÆâÂÖ®ÊÄß„ÄÇ</p>\n<blockquote>\n<p>‚ÄúRust is a systems programming language focused on three goals: safety, speed, and concurrency.‚Äù<br>__ Rust Documentation</p>\n</blockquote>\n<p>RustÊòØ‰∏Ä‰∏™Âπ¥ËΩªÂèàÁé∞‰ª£ÁöÑÁºñÁ®ãËØ≠Ë®Ä„ÄÇÂÆÉÊòØ‰∏ÄÁßç<strong>È¢ÑÁºñËØëËØ≠Ë®Ä</strong>Âπ∂‰ΩøÁî®<a href=\"https://en.wikipedia.org/wiki/LLVM\" target=\"_blank\" rel=\"noopener\">LLVM</a>‰Ωú‰∏∫ÂêéÁõæ„ÄÇÂêåÊó∂ÔºåRustÊòØ‰∏Ä‰∏™<strong>Â§öËåÉÂºèÁºñÁ®ãËØ≠Ë®Ä</strong>Ôºå ÂÆÉËûçÂêà‰∫ÜËøáÁ®ãÂºèÁºñÁ®ã„ÄÅÂπ∂ÂèëËßíËâ≤Ê®°Âûã„ÄÅÈù¢ÂêëÂØπË±°ÁºñÁ®ã‰ª•ÂèäÁ∫ØÂáΩÊï∞ÂºèÁºñÁ®ãÈ£éÊ†º„ÄÇ‰πüÂêåÊ†∑Âú®ÈùôÊÄÅÂíåÂä®ÊÄÅ‰∏§ÁßçÂ±ÇÈù¢‰∏äÊîØÊåÅËåÉÂûãÁºñÁ®ãÂíåÂÖÉÁºñÁ®ãÁ≠âËåÉÂºè„ÄÇ</p>\n<blockquote>\n<p>üîé One of Rust‚Äôs most unique and compelling features is <a href=\"c1.ownership.html\">Ownership</a>, which is used to achieve memory safety. Rust creates memory pointers optimistically, checks memory pointers‚Äô limited accesses at the compiler time with the usage of <a href=\"c2.borrowing.html\">References and Borrowing</a>. And it does automatic compile time memory management by checking the <a href=\"c3.lifetimes.html\">Lifetimes</a>.</p>\n</blockquote>\n<h2 id=\"ÁÅµÊÑüÊù•Ê∫ê\"><a href=\"#ÁÅµÊÑüÊù•Ê∫ê\" class=\"headerlink\" title=\"ÁÅµÊÑüÊù•Ê∫ê\"></a>ÁÅµÊÑüÊù•Ê∫ê</h2><p>RustÂú®ËÆæËÆ°ÁöÑËøáÁ®ã‰∏≠Ôºå‰ªéÂæàÂ§öËØ≠Ë®ÄÊ±≤Âèñ‰∫ÜËØ∏Â§öÁÅµÊÑüÔºö</p>\n<ul>\n<li>ÊäΩË±°Êú∫Âô®Ê®°Âûã - Abstract Machine Model : <strong>C</strong></li>\n<li>Êï∞ÊçÆÁ±ªÂûã - Data types : <strong>C, SML, OCaml, Lisp, Limbo</strong></li>\n<li>ÂèØÈÄâÁªëÂÆö - Optional Bindings : <strong>Swift</strong></li>\n<li>Ê¥ÅÂáÄÂÆè - Hygienic Macros : <strong>Scheme</strong></li>\n<li>ÂáΩÊï∞ÂºèÁºñÁ®ã - Functional Programming : <strong>Haskell, OCaml, F#</strong></li>\n<li>Â±ûÊÄßÊ†áÁ≠æ - Attributes : <strong>ECMA</strong>-335</li>\n<li>ÂÜÖÂ≠òÊ®°Âûã‰∏éÂÜÖÂ≠òÁÆ°ÁêÜ - Memory Model and Memory Management : <strong>C++, ML Kit, Cyclone</strong></li>\n<li>Á±ªÂûãÊ®°Êùø - Type Classes : <strong>Haskell</strong></li>\n<li>‰ª£Á†ÅÁÆ± - Crate : Assembly in the <strong>ECMA</strong>-335 CLI model</li>\n<li>ÈÄöÈÅì‰∏éÂπ∂Âèë - Channels and Concurrency : <strong>Newsqueak, Alef, Limbo</strong></li>\n<li>Ê∂àÊÅØ‰º†ÈÄí‰∏éÁ∫øÁ®ãÂ§±Ë¥•Â§ÑÁêÜ - Message passing and Thread failure : <strong>Erlang</strong>  </li>\n</ul>\n<p>‰ª•ÂèäÂÖ∂‰ªñ„ÄÇ</p>\n<p>RustÈªòËÆ§ÊÉÖÂÜµ‰∏ã<strong>Âπ∂‰∏ç‰ΩøÁî®Ëá™Âä®ÂûÉÂúæÂõûÊî∂Êú∫Âà∂ÔºàGC)</strong>„ÄÇ</p>\n<p>RustÁºñËØëÂô®Âú®<strong>ÁºñËØëÈò∂ÊÆµ</strong>‰ºöÂØπ‰ª£Á†ÅÂÅöÂ§ßÈáèÊ£ÄÊü•‰ª•Â∞ΩÈáèÈò≤Ê≠¢Âú®C++‰ª£Á†Å‰∏≠ËæÉ‰∏∫Â∏∏ËßÅÁöÑ<a href=\"https://doc.rust-lang.org/error-index.html\" target=\"_blank\" rel=\"noopener\"><strong>ÂèØËÉΩÁöÑÁ±ªÂûãÈîôËØØ</strong></a> „ÄÇ</p>\n"},{"title":"ÊéßÂà∂ÊµÅ","_content":"\n# if - else if - else\n\n```rust\n// Simplest Example\nlet team_size = 7;\nif team_size < 5 {\n    println!(\"Small\");\n} else if team_size < 10 {\n    println!(\"Medium\");\n} else {\n    println!(\"Large\");\n}\n\n// partially refactored code\nlet team_size = 7;\nlet team_size_in_text;\nif team_size < 5 {\n    team_size_in_text = \"Small\";\n} else if team_size < 10 {\n    team_size_in_text = \"Medium\";\n} else {\n    team_size_in_text = \"Large\";\n}\nprintln!(\"Current team size : {}\", team_size_in_text);\n\n//optimistic code\nlet team_size = 7;\nlet team_size_in_text = if team_size < 5 {\n    \"Small\" //‚≠êÔ∏èno ;\n} else if team_size < 10 {\n    \"Medium\"\n} else {\n    \"Large\"\n};\nprintln!(\"Current team size : {}\", team_size_in_text);\n\n\nlet is_below_eighteen = if team_size < 18 { true } else { false };\n```\n\n‚≠êÔ∏è **Âú®Â∞ÜifÊéßÂà∂ÊµÅ‰Ωú‰∏∫Ë°®ËææÂºè‰ΩøÁî®Êó∂ÔºåÊØè‰∏™ÂàÜÊîØÂùóÊâÄËøîÂõûÁöÑÂÄºÂú®Á±ªÂûã‰∏äÂ∫î‰øùÊåÅ‰∏ÄËá¥**„ÄÇ\n\n\n# match\n\n```rust\nlet tshirt_width = 20;\nlet tshirt_size = match tshirt_width {\n    16 => \"S\", // ÂåπÈÖç 16 Êó∂ÔºåËøîÂõû S\n    17 | 18 => \"M\", // check 17 and 18\n    19 ... 21 => \"L\", // check from 19 to 21 (19,20,21)\n    22 => \"XL\",\n    _ => \"Not Available\", // ‰ª•‰∏äÂùá‰∏çÂåπÈÖçÊó∂ÔºåÈªòËÆ§ËøîÂõû Not Available\n};\nprintln!(\"{}\", tshirt_size); // L\n\n\nlet is_allowed = false;\nlet list_type = match is_allowed {\n    true => \"Full\",\n    false => \"Restricted\"\n    // no default/ _ condition can be skipped Ê≠§Â§ÑÊ≤°ÊúâÁî®‰ª•ÈªòËÆ§ËøîÂõûÁöÑÂåπÈÖç\n    // Âõ†‰∏∫is_allowedÁöÑÁ±ªÂûã‰∏∫booleanÔºåÂú®ËØ•‰æãÁöÑÊ®°ÂºèÂåπÈÖç‰∏≠ÔºåÂ∑≤Á©∑Â∞Ω‰∫ÜÊâÄÊúâÂèØËÉΩÁöÑÂåπÈÖç\n};\nprintln!(\"{}\", list_type); // Restricted\n\n\nlet marks_paper_a: u8 = 25;\nlet marks_paper_b: u8 = 30;\nlet output = match (marks_paper_a, marks_paper_b) { // Â§öÂÄºÂåπÈÖçÂèØ‰ΩøÁî®ÂÖÉÁªÑÂΩ¢Âºè\n    (50, 50) => \"Full marks for both papers\",\n    (50, _) => \"Full marks for paper A\",\n    (_, 50) => \"Full marks for paper B\",\n    (x, y) if x > 25 && y > 25 => \"Good\",\n    (_, _) => \"Work hard\" \n};\nprintln!(\"{}\", output); // Work hard\n```\n\n\n# while\n\n```rust\nlet mut a = 1;\nwhile a <= 10 {\n\tprintln!(\"Current value : {}\", a);\n\ta += 1; // Âú®rust‰∏≠Ê≤°Êúâ++Êàñ--Êìç‰ΩúÁ¨¶\n}\n\n// ‰ΩøÁî®breakÂíåcontinue\nlet mut b = 0;\nwhile b < 5 {\n\tif b == 0 {\n\t\tprintln!(\"Skip value : {}\", b);\n\t\tb += 1;\n\t\tcontinue;\n\t} else if b == 2 {\n\t\tprintln!(\"Break At : {}\", b);\n\t\tbreak;\n\t}\n\tprintln!(\"Current value : {}\", b);\n\tb += 1;\n}\n\n// Â§ñÈÉ®break\nlet mut c1 = 1;\n'outer_while: while c1 < 6 { // ËÆæÁΩÆÂæ™ÁéØÊ†áÁ≠æ outer_while\n\tlet mut c2 = 1;\n\t'inner_while: while c2 < 6 {\n\t\tprintln!(\"Current Value : [{}][{}]\", c1, c2);\n\t\tif c1 == 2 && c2 == 2 { break 'outer_while; } //‰∏≠Êñ≠ outer_whileÂæ™ÁéØ\n\t\tc2 += 1;\n\t}\n\tc1 += 1;\n}\n```\n\n\n# loop\n\n```rust\nloop {\n\tprintln!(\"Loop forever!\");\n}\n\n// Usage of break and continue\nlet mut a = 0;\nloop {\n\tif a == 0 {\n\t\tprintln!(\"Skip Value : {}\", a);\n\t\ta += 1;\n\t\tcontinue;\n\t} else if a == 2 {\n\t\tprintln!(\"Break At : {}\", a);\n\t\tbreak;\n\t}\n\tprintln!(\"Current Value : {}\", a);\n\ta += 1;\n}\n\n// Outer break\nlet mut b1 = 1;\n'outer_loop: loop { //set label outer_loop\n  let mut b2 = 1;\n  'inner_loop: loop {\n    println!(\"Current Value : [{}][{}]\", b1, b2);\n    if b1 == 2 && b2 == 2 {\n        break 'outer_loop; // kill outer_loop\n    } else if b2 == 5 {\n    \tbreak;\n    }\n    b2 += 1;\n  }\n  b1 += 1;\n}\n```\n\n\n# for\n\n```rust\nfor a in 0..10 { //(a = o; a <10; a++) // 0 to 10(‰∏çÂåÖÂê´10)\n  println!(\"Current value : {}\", a);\n}\n\n// Usage of break and continue\nfor b in 0..6 {\n  if b == 0 {\n    println!(\"Skip Value : {}\", b);\n    continue;\n  } else if b == 2 {\n    println!(\"Break At : {}\", b);\n    break;\n  }\n  println!(\"Current value : {}\", b);\n}\n\n// Outer break\n'outer_for: for c1 in 1..6 { //set label outer_for\n  'inner_for: for c2 in 1..6 {\n    println!(\"Current Value : [{}][{}]\", c1, c2);\n    if c1 == 2 && c2 == 2 { break 'outer_for; } //kill outer_for\n  }\n}\n\n\n// Â§ÑÁêÜ arrays/vectors\nlet group : [&str; 4] = [\"Mark\", \"Larry\", \"Bill\", \"Steve\"];\n\nfor n in 0..group.len() { //group.len() = 4 -> 0..4 üëé Âú®ÊØè‰∏Ä‰∏™Ëø≠‰ª£‰∏≠ÈÉΩ‰ºöÈáçÊñ∞ËÆ°ÁÆógroup.len()\n  println!(\"Current Person : {}\", group[n]);\n}\n\nfor person in group.iter() { //üëç group.iter() Â∞ÜÊï∞ÁªÑËΩ¨Êç¢‰∏∫‰∏ÄËø≠‰ª£Âô®\n  println!(\"Current Person : {}\", person);\n}\n```\n","source":"docs/zh-cn/a10.control_flows.md","raw":"title: ÊéßÂà∂ÊµÅ\n---\n\n# if - else if - else\n\n```rust\n// Simplest Example\nlet team_size = 7;\nif team_size < 5 {\n    println!(\"Small\");\n} else if team_size < 10 {\n    println!(\"Medium\");\n} else {\n    println!(\"Large\");\n}\n\n// partially refactored code\nlet team_size = 7;\nlet team_size_in_text;\nif team_size < 5 {\n    team_size_in_text = \"Small\";\n} else if team_size < 10 {\n    team_size_in_text = \"Medium\";\n} else {\n    team_size_in_text = \"Large\";\n}\nprintln!(\"Current team size : {}\", team_size_in_text);\n\n//optimistic code\nlet team_size = 7;\nlet team_size_in_text = if team_size < 5 {\n    \"Small\" //‚≠êÔ∏èno ;\n} else if team_size < 10 {\n    \"Medium\"\n} else {\n    \"Large\"\n};\nprintln!(\"Current team size : {}\", team_size_in_text);\n\n\nlet is_below_eighteen = if team_size < 18 { true } else { false };\n```\n\n‚≠êÔ∏è **Âú®Â∞ÜifÊéßÂà∂ÊµÅ‰Ωú‰∏∫Ë°®ËææÂºè‰ΩøÁî®Êó∂ÔºåÊØè‰∏™ÂàÜÊîØÂùóÊâÄËøîÂõûÁöÑÂÄºÂú®Á±ªÂûã‰∏äÂ∫î‰øùÊåÅ‰∏ÄËá¥**„ÄÇ\n\n\n# match\n\n```rust\nlet tshirt_width = 20;\nlet tshirt_size = match tshirt_width {\n    16 => \"S\", // ÂåπÈÖç 16 Êó∂ÔºåËøîÂõû S\n    17 | 18 => \"M\", // check 17 and 18\n    19 ... 21 => \"L\", // check from 19 to 21 (19,20,21)\n    22 => \"XL\",\n    _ => \"Not Available\", // ‰ª•‰∏äÂùá‰∏çÂåπÈÖçÊó∂ÔºåÈªòËÆ§ËøîÂõû Not Available\n};\nprintln!(\"{}\", tshirt_size); // L\n\n\nlet is_allowed = false;\nlet list_type = match is_allowed {\n    true => \"Full\",\n    false => \"Restricted\"\n    // no default/ _ condition can be skipped Ê≠§Â§ÑÊ≤°ÊúâÁî®‰ª•ÈªòËÆ§ËøîÂõûÁöÑÂåπÈÖç\n    // Âõ†‰∏∫is_allowedÁöÑÁ±ªÂûã‰∏∫booleanÔºåÂú®ËØ•‰æãÁöÑÊ®°ÂºèÂåπÈÖç‰∏≠ÔºåÂ∑≤Á©∑Â∞Ω‰∫ÜÊâÄÊúâÂèØËÉΩÁöÑÂåπÈÖç\n};\nprintln!(\"{}\", list_type); // Restricted\n\n\nlet marks_paper_a: u8 = 25;\nlet marks_paper_b: u8 = 30;\nlet output = match (marks_paper_a, marks_paper_b) { // Â§öÂÄºÂåπÈÖçÂèØ‰ΩøÁî®ÂÖÉÁªÑÂΩ¢Âºè\n    (50, 50) => \"Full marks for both papers\",\n    (50, _) => \"Full marks for paper A\",\n    (_, 50) => \"Full marks for paper B\",\n    (x, y) if x > 25 && y > 25 => \"Good\",\n    (_, _) => \"Work hard\" \n};\nprintln!(\"{}\", output); // Work hard\n```\n\n\n# while\n\n```rust\nlet mut a = 1;\nwhile a <= 10 {\n\tprintln!(\"Current value : {}\", a);\n\ta += 1; // Âú®rust‰∏≠Ê≤°Êúâ++Êàñ--Êìç‰ΩúÁ¨¶\n}\n\n// ‰ΩøÁî®breakÂíåcontinue\nlet mut b = 0;\nwhile b < 5 {\n\tif b == 0 {\n\t\tprintln!(\"Skip value : {}\", b);\n\t\tb += 1;\n\t\tcontinue;\n\t} else if b == 2 {\n\t\tprintln!(\"Break At : {}\", b);\n\t\tbreak;\n\t}\n\tprintln!(\"Current value : {}\", b);\n\tb += 1;\n}\n\n// Â§ñÈÉ®break\nlet mut c1 = 1;\n'outer_while: while c1 < 6 { // ËÆæÁΩÆÂæ™ÁéØÊ†áÁ≠æ outer_while\n\tlet mut c2 = 1;\n\t'inner_while: while c2 < 6 {\n\t\tprintln!(\"Current Value : [{}][{}]\", c1, c2);\n\t\tif c1 == 2 && c2 == 2 { break 'outer_while; } //‰∏≠Êñ≠ outer_whileÂæ™ÁéØ\n\t\tc2 += 1;\n\t}\n\tc1 += 1;\n}\n```\n\n\n# loop\n\n```rust\nloop {\n\tprintln!(\"Loop forever!\");\n}\n\n// Usage of break and continue\nlet mut a = 0;\nloop {\n\tif a == 0 {\n\t\tprintln!(\"Skip Value : {}\", a);\n\t\ta += 1;\n\t\tcontinue;\n\t} else if a == 2 {\n\t\tprintln!(\"Break At : {}\", a);\n\t\tbreak;\n\t}\n\tprintln!(\"Current Value : {}\", a);\n\ta += 1;\n}\n\n// Outer break\nlet mut b1 = 1;\n'outer_loop: loop { //set label outer_loop\n  let mut b2 = 1;\n  'inner_loop: loop {\n    println!(\"Current Value : [{}][{}]\", b1, b2);\n    if b1 == 2 && b2 == 2 {\n        break 'outer_loop; // kill outer_loop\n    } else if b2 == 5 {\n    \tbreak;\n    }\n    b2 += 1;\n  }\n  b1 += 1;\n}\n```\n\n\n# for\n\n```rust\nfor a in 0..10 { //(a = o; a <10; a++) // 0 to 10(‰∏çÂåÖÂê´10)\n  println!(\"Current value : {}\", a);\n}\n\n// Usage of break and continue\nfor b in 0..6 {\n  if b == 0 {\n    println!(\"Skip Value : {}\", b);\n    continue;\n  } else if b == 2 {\n    println!(\"Break At : {}\", b);\n    break;\n  }\n  println!(\"Current value : {}\", b);\n}\n\n// Outer break\n'outer_for: for c1 in 1..6 { //set label outer_for\n  'inner_for: for c2 in 1..6 {\n    println!(\"Current Value : [{}][{}]\", c1, c2);\n    if c1 == 2 && c2 == 2 { break 'outer_for; } //kill outer_for\n  }\n}\n\n\n// Â§ÑÁêÜ arrays/vectors\nlet group : [&str; 4] = [\"Mark\", \"Larry\", \"Bill\", \"Steve\"];\n\nfor n in 0..group.len() { //group.len() = 4 -> 0..4 üëé Âú®ÊØè‰∏Ä‰∏™Ëø≠‰ª£‰∏≠ÈÉΩ‰ºöÈáçÊñ∞ËÆ°ÁÆógroup.len()\n  println!(\"Current Person : {}\", group[n]);\n}\n\nfor person in group.iter() { //üëç group.iter() Â∞ÜÊï∞ÁªÑËΩ¨Êç¢‰∏∫‰∏ÄËø≠‰ª£Âô®\n  println!(\"Current Person : {}\", person);\n}\n```\n","date":"2019-03-21T03:40:47.670Z","updated":"2019-03-21T03:40:47.670Z","path":"docs/zh-cn/a10.control_flows.html","_id":"cjtfwbj0n0011dwgpcmbtjwrj","comments":1,"layout":"page","content":"<h1 id=\"if-else-if-else\"><a href=\"#if-else-if-else\" class=\"headerlink\" title=\"if - else if - else\"></a>if - else if - else</h1><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Simplest Example\nlet team_size = 7;\nif team_size &lt; 5 {\n    println!(&quot;Small&quot;);\n} else if team_size &lt; 10 {\n    println!(&quot;Medium&quot;);\n} else {\n    println!(&quot;Large&quot;);\n}\n\n// partially refactored code\nlet team_size = 7;\nlet team_size_in_text;\nif team_size &lt; 5 {\n    team_size_in_text = &quot;Small&quot;;\n} else if team_size &lt; 10 {\n    team_size_in_text = &quot;Medium&quot;;\n} else {\n    team_size_in_text = &quot;Large&quot;;\n}\nprintln!(&quot;Current team size : {}&quot;, team_size_in_text);\n\n//optimistic code\nlet team_size = 7;\nlet team_size_in_text = if team_size &lt; 5 {\n    &quot;Small&quot; //‚≠êÔ∏èno ;\n} else if team_size &lt; 10 {\n    &quot;Medium&quot;\n} else {\n    &quot;Large&quot;\n};\nprintln!(&quot;Current team size : {}&quot;, team_size_in_text);\n\n\nlet is_below_eighteen = if team_size &lt; 18 { true } else { false };\n</code></pre>\n<p>‚≠êÔ∏è <strong>Âú®Â∞ÜifÊéßÂà∂ÊµÅ‰Ωú‰∏∫Ë°®ËææÂºè‰ΩøÁî®Êó∂ÔºåÊØè‰∏™ÂàÜÊîØÂùóÊâÄËøîÂõûÁöÑÂÄºÂú®Á±ªÂûã‰∏äÂ∫î‰øùÊåÅ‰∏ÄËá¥</strong>„ÄÇ</p>\n<h1 id=\"match\"><a href=\"#match\" class=\"headerlink\" title=\"match\"></a>match</h1><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let tshirt_width = 20;\nlet tshirt_size = match tshirt_width {\n    16 =&gt; &quot;S&quot;, // ÂåπÈÖç 16 Êó∂ÔºåËøîÂõû S\n    17 | 18 =&gt; &quot;M&quot;, // check 17 and 18\n    19 ... 21 =&gt; &quot;L&quot;, // check from 19 to 21 (19,20,21)\n    22 =&gt; &quot;XL&quot;,\n    _ =&gt; &quot;Not Available&quot;, // ‰ª•‰∏äÂùá‰∏çÂåπÈÖçÊó∂ÔºåÈªòËÆ§ËøîÂõû Not Available\n};\nprintln!(&quot;{}&quot;, tshirt_size); // L\n\n\nlet is_allowed = false;\nlet list_type = match is_allowed {\n    true =&gt; &quot;Full&quot;,\n    false =&gt; &quot;Restricted&quot;\n    // no default/ _ condition can be skipped Ê≠§Â§ÑÊ≤°ÊúâÁî®‰ª•ÈªòËÆ§ËøîÂõûÁöÑÂåπÈÖç\n    // Âõ†‰∏∫is_allowedÁöÑÁ±ªÂûã‰∏∫booleanÔºåÂú®ËØ•‰æãÁöÑÊ®°ÂºèÂåπÈÖç‰∏≠ÔºåÂ∑≤Á©∑Â∞Ω‰∫ÜÊâÄÊúâÂèØËÉΩÁöÑÂåπÈÖç\n};\nprintln!(&quot;{}&quot;, list_type); // Restricted\n\n\nlet marks_paper_a: u8 = 25;\nlet marks_paper_b: u8 = 30;\nlet output = match (marks_paper_a, marks_paper_b) { // Â§öÂÄºÂåπÈÖçÂèØ‰ΩøÁî®ÂÖÉÁªÑÂΩ¢Âºè\n    (50, 50) =&gt; &quot;Full marks for both papers&quot;,\n    (50, _) =&gt; &quot;Full marks for paper A&quot;,\n    (_, 50) =&gt; &quot;Full marks for paper B&quot;,\n    (x, y) if x &gt; 25 &amp;&amp; y &gt; 25 =&gt; &quot;Good&quot;,\n    (_, _) =&gt; &quot;Work hard&quot; \n};\nprintln!(&quot;{}&quot;, output); // Work hard\n</code></pre>\n<h1 id=\"while\"><a href=\"#while\" class=\"headerlink\" title=\"while\"></a>while</h1><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let mut a = 1;\nwhile a &lt;= 10 {\n    println!(&quot;Current value : {}&quot;, a);\n    a += 1; // Âú®rust‰∏≠Ê≤°Êúâ++Êàñ--Êìç‰ΩúÁ¨¶\n}\n\n// ‰ΩøÁî®breakÂíåcontinue\nlet mut b = 0;\nwhile b &lt; 5 {\n    if b == 0 {\n        println!(&quot;Skip value : {}&quot;, b);\n        b += 1;\n        continue;\n    } else if b == 2 {\n        println!(&quot;Break At : {}&quot;, b);\n        break;\n    }\n    println!(&quot;Current value : {}&quot;, b);\n    b += 1;\n}\n\n// Â§ñÈÉ®break\nlet mut c1 = 1;\n&#39;outer_while: while c1 &lt; 6 { // ËÆæÁΩÆÂæ™ÁéØÊ†áÁ≠æ outer_while\n    let mut c2 = 1;\n    &#39;inner_while: while c2 &lt; 6 {\n        println!(&quot;Current Value : [{}][{}]&quot;, c1, c2);\n        if c1 == 2 &amp;&amp; c2 == 2 { break &#39;outer_while; } //‰∏≠Êñ≠ outer_whileÂæ™ÁéØ\n        c2 += 1;\n    }\n    c1 += 1;\n}\n</code></pre>\n<h1 id=\"loop\"><a href=\"#loop\" class=\"headerlink\" title=\"loop\"></a>loop</h1><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">loop {\n    println!(&quot;Loop forever!&quot;);\n}\n\n// Usage of break and continue\nlet mut a = 0;\nloop {\n    if a == 0 {\n        println!(&quot;Skip Value : {}&quot;, a);\n        a += 1;\n        continue;\n    } else if a == 2 {\n        println!(&quot;Break At : {}&quot;, a);\n        break;\n    }\n    println!(&quot;Current Value : {}&quot;, a);\n    a += 1;\n}\n\n// Outer break\nlet mut b1 = 1;\n&#39;outer_loop: loop { //set label outer_loop\n  let mut b2 = 1;\n  &#39;inner_loop: loop {\n    println!(&quot;Current Value : [{}][{}]&quot;, b1, b2);\n    if b1 == 2 &amp;&amp; b2 == 2 {\n        break &#39;outer_loop; // kill outer_loop\n    } else if b2 == 5 {\n        break;\n    }\n    b2 += 1;\n  }\n  b1 += 1;\n}\n</code></pre>\n<h1 id=\"for\"><a href=\"#for\" class=\"headerlink\" title=\"for\"></a>for</h1><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">for a in 0..10 { //(a = o; a &lt;10; a++) // 0 to 10(‰∏çÂåÖÂê´10)\n  println!(&quot;Current value : {}&quot;, a);\n}\n\n// Usage of break and continue\nfor b in 0..6 {\n  if b == 0 {\n    println!(&quot;Skip Value : {}&quot;, b);\n    continue;\n  } else if b == 2 {\n    println!(&quot;Break At : {}&quot;, b);\n    break;\n  }\n  println!(&quot;Current value : {}&quot;, b);\n}\n\n// Outer break\n&#39;outer_for: for c1 in 1..6 { //set label outer_for\n  &#39;inner_for: for c2 in 1..6 {\n    println!(&quot;Current Value : [{}][{}]&quot;, c1, c2);\n    if c1 == 2 &amp;&amp; c2 == 2 { break &#39;outer_for; } //kill outer_for\n  }\n}\n\n\n// Â§ÑÁêÜ arrays/vectors\nlet group : [&amp;str; 4] = [&quot;Mark&quot;, &quot;Larry&quot;, &quot;Bill&quot;, &quot;Steve&quot;];\n\nfor n in 0..group.len() { //group.len() = 4 -&gt; 0..4 üëé Âú®ÊØè‰∏Ä‰∏™Ëø≠‰ª£‰∏≠ÈÉΩ‰ºöÈáçÊñ∞ËÆ°ÁÆógroup.len()\n  println!(&quot;Current Person : {}&quot;, group[n]);\n}\n\nfor person in group.iter() { //üëç group.iter() Â∞ÜÊï∞ÁªÑËΩ¨Êç¢‰∏∫‰∏ÄËø≠‰ª£Âô®\n  println!(&quot;Current Person : {}&quot;, person);\n}\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<h1 id=\"if-else-if-else\"><a href=\"#if-else-if-else\" class=\"headerlink\" title=\"if - else if - else\"></a>if - else if - else</h1><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Simplest Example\nlet team_size = 7;\nif team_size &lt; 5 {\n    println!(&quot;Small&quot;);\n} else if team_size &lt; 10 {\n    println!(&quot;Medium&quot;);\n} else {\n    println!(&quot;Large&quot;);\n}\n\n// partially refactored code\nlet team_size = 7;\nlet team_size_in_text;\nif team_size &lt; 5 {\n    team_size_in_text = &quot;Small&quot;;\n} else if team_size &lt; 10 {\n    team_size_in_text = &quot;Medium&quot;;\n} else {\n    team_size_in_text = &quot;Large&quot;;\n}\nprintln!(&quot;Current team size : {}&quot;, team_size_in_text);\n\n//optimistic code\nlet team_size = 7;\nlet team_size_in_text = if team_size &lt; 5 {\n    &quot;Small&quot; //‚≠êÔ∏èno ;\n} else if team_size &lt; 10 {\n    &quot;Medium&quot;\n} else {\n    &quot;Large&quot;\n};\nprintln!(&quot;Current team size : {}&quot;, team_size_in_text);\n\n\nlet is_below_eighteen = if team_size &lt; 18 { true } else { false };\n</code></pre>\n<p>‚≠êÔ∏è <strong>Âú®Â∞ÜifÊéßÂà∂ÊµÅ‰Ωú‰∏∫Ë°®ËææÂºè‰ΩøÁî®Êó∂ÔºåÊØè‰∏™ÂàÜÊîØÂùóÊâÄËøîÂõûÁöÑÂÄºÂú®Á±ªÂûã‰∏äÂ∫î‰øùÊåÅ‰∏ÄËá¥</strong>„ÄÇ</p>\n<h1 id=\"match\"><a href=\"#match\" class=\"headerlink\" title=\"match\"></a>match</h1><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let tshirt_width = 20;\nlet tshirt_size = match tshirt_width {\n    16 =&gt; &quot;S&quot;, // ÂåπÈÖç 16 Êó∂ÔºåËøîÂõû S\n    17 | 18 =&gt; &quot;M&quot;, // check 17 and 18\n    19 ... 21 =&gt; &quot;L&quot;, // check from 19 to 21 (19,20,21)\n    22 =&gt; &quot;XL&quot;,\n    _ =&gt; &quot;Not Available&quot;, // ‰ª•‰∏äÂùá‰∏çÂåπÈÖçÊó∂ÔºåÈªòËÆ§ËøîÂõû Not Available\n};\nprintln!(&quot;{}&quot;, tshirt_size); // L\n\n\nlet is_allowed = false;\nlet list_type = match is_allowed {\n    true =&gt; &quot;Full&quot;,\n    false =&gt; &quot;Restricted&quot;\n    // no default/ _ condition can be skipped Ê≠§Â§ÑÊ≤°ÊúâÁî®‰ª•ÈªòËÆ§ËøîÂõûÁöÑÂåπÈÖç\n    // Âõ†‰∏∫is_allowedÁöÑÁ±ªÂûã‰∏∫booleanÔºåÂú®ËØ•‰æãÁöÑÊ®°ÂºèÂåπÈÖç‰∏≠ÔºåÂ∑≤Á©∑Â∞Ω‰∫ÜÊâÄÊúâÂèØËÉΩÁöÑÂåπÈÖç\n};\nprintln!(&quot;{}&quot;, list_type); // Restricted\n\n\nlet marks_paper_a: u8 = 25;\nlet marks_paper_b: u8 = 30;\nlet output = match (marks_paper_a, marks_paper_b) { // Â§öÂÄºÂåπÈÖçÂèØ‰ΩøÁî®ÂÖÉÁªÑÂΩ¢Âºè\n    (50, 50) =&gt; &quot;Full marks for both papers&quot;,\n    (50, _) =&gt; &quot;Full marks for paper A&quot;,\n    (_, 50) =&gt; &quot;Full marks for paper B&quot;,\n    (x, y) if x &gt; 25 &amp;&amp; y &gt; 25 =&gt; &quot;Good&quot;,\n    (_, _) =&gt; &quot;Work hard&quot; \n};\nprintln!(&quot;{}&quot;, output); // Work hard\n</code></pre>\n<h1 id=\"while\"><a href=\"#while\" class=\"headerlink\" title=\"while\"></a>while</h1><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let mut a = 1;\nwhile a &lt;= 10 {\n    println!(&quot;Current value : {}&quot;, a);\n    a += 1; // Âú®rust‰∏≠Ê≤°Êúâ++Êàñ--Êìç‰ΩúÁ¨¶\n}\n\n// ‰ΩøÁî®breakÂíåcontinue\nlet mut b = 0;\nwhile b &lt; 5 {\n    if b == 0 {\n        println!(&quot;Skip value : {}&quot;, b);\n        b += 1;\n        continue;\n    } else if b == 2 {\n        println!(&quot;Break At : {}&quot;, b);\n        break;\n    }\n    println!(&quot;Current value : {}&quot;, b);\n    b += 1;\n}\n\n// Â§ñÈÉ®break\nlet mut c1 = 1;\n&#39;outer_while: while c1 &lt; 6 { // ËÆæÁΩÆÂæ™ÁéØÊ†áÁ≠æ outer_while\n    let mut c2 = 1;\n    &#39;inner_while: while c2 &lt; 6 {\n        println!(&quot;Current Value : [{}][{}]&quot;, c1, c2);\n        if c1 == 2 &amp;&amp; c2 == 2 { break &#39;outer_while; } //‰∏≠Êñ≠ outer_whileÂæ™ÁéØ\n        c2 += 1;\n    }\n    c1 += 1;\n}\n</code></pre>\n<h1 id=\"loop\"><a href=\"#loop\" class=\"headerlink\" title=\"loop\"></a>loop</h1><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">loop {\n    println!(&quot;Loop forever!&quot;);\n}\n\n// Usage of break and continue\nlet mut a = 0;\nloop {\n    if a == 0 {\n        println!(&quot;Skip Value : {}&quot;, a);\n        a += 1;\n        continue;\n    } else if a == 2 {\n        println!(&quot;Break At : {}&quot;, a);\n        break;\n    }\n    println!(&quot;Current Value : {}&quot;, a);\n    a += 1;\n}\n\n// Outer break\nlet mut b1 = 1;\n&#39;outer_loop: loop { //set label outer_loop\n  let mut b2 = 1;\n  &#39;inner_loop: loop {\n    println!(&quot;Current Value : [{}][{}]&quot;, b1, b2);\n    if b1 == 2 &amp;&amp; b2 == 2 {\n        break &#39;outer_loop; // kill outer_loop\n    } else if b2 == 5 {\n        break;\n    }\n    b2 += 1;\n  }\n  b1 += 1;\n}\n</code></pre>\n<h1 id=\"for\"><a href=\"#for\" class=\"headerlink\" title=\"for\"></a>for</h1><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">for a in 0..10 { //(a = o; a &lt;10; a++) // 0 to 10(‰∏çÂåÖÂê´10)\n  println!(&quot;Current value : {}&quot;, a);\n}\n\n// Usage of break and continue\nfor b in 0..6 {\n  if b == 0 {\n    println!(&quot;Skip Value : {}&quot;, b);\n    continue;\n  } else if b == 2 {\n    println!(&quot;Break At : {}&quot;, b);\n    break;\n  }\n  println!(&quot;Current value : {}&quot;, b);\n}\n\n// Outer break\n&#39;outer_for: for c1 in 1..6 { //set label outer_for\n  &#39;inner_for: for c2 in 1..6 {\n    println!(&quot;Current Value : [{}][{}]&quot;, c1, c2);\n    if c1 == 2 &amp;&amp; c2 == 2 { break &#39;outer_for; } //kill outer_for\n  }\n}\n\n\n// Â§ÑÁêÜ arrays/vectors\nlet group : [&amp;str; 4] = [&quot;Mark&quot;, &quot;Larry&quot;, &quot;Bill&quot;, &quot;Steve&quot;];\n\nfor n in 0..group.len() { //group.len() = 4 -&gt; 0..4 üëé Âú®ÊØè‰∏Ä‰∏™Ëø≠‰ª£‰∏≠ÈÉΩ‰ºöÈáçÊñ∞ËÆ°ÁÆógroup.len()\n  println!(&quot;Current Person : {}&quot;, group[n]);\n}\n\nfor person in group.iter() { //üëç group.iter() Â∞ÜÊï∞ÁªÑËΩ¨Êç¢‰∏∫‰∏ÄËø≠‰ª£Âô®\n  println!(&quot;Current Person : {}&quot;, person);\n}\n</code></pre>\n"},{"title":"Hello World","_content":"\n## Hello, World!\n```rust\nfn main() {\n    println!(\"Hello, world!\");\n}\n```\n\n`fn` Ë°®Á§∫‰∏Ä‰∏™ÂáΩÊï∞‚Äî‚Äîfunction„ÄÇmainÂáΩÊï∞ÊòØÊØè‰∏Ä‰∏™RustÁ®ãÂ∫èÁöÑËµ∑ÁÇπ„ÄÇ\n`println!` Â∞Ü‰∏Ä‰∏™ÊñáÊú¨ËæìÂá∫Âà∞ÊéßÂà∂Âè∞ÔºåÁ¥ßÈöèÁöÑ*!*Ë°®Á§∫ËøôÊòØ‰∏Ä‰∏™[ÂÆè](https://doc.rust-lang.org/book/first-edition/macros.html)ËÄåÈùûÈÄöÂ∏∏ÁöÑÂáΩÊï∞„ÄÇ\n\n> üí° RustÊ∫êÊñá‰ª∂Â∫î‰ª•.rs‰Ωú‰∏∫Êñá‰ª∂Êâ©Â±ïÂêçÔºåÂ¶ÇÊûú‰Ω†Â∏åÊúõÂú®Êñá‰ª∂Âêç‰∏≠ÂåÖÂê´Â§ö‰∏™ËØçËØ≠ÔºåÂ∫îÈÅµÂæ™[ËõáÂΩ¢ÂëΩÂêç](https://en.wikipedia.org/wiki/Snake_case)ÂéüÂàô„ÄÇ\n\n- Â∞Ü‰ª•‰∏ä‰ª£Á†Å‰øùÂ≠ò‰∏∫`file.rs`Ôºå‰πüÂèØ‰ª•‰∏∫ÂÖ∂‰ªñ‰ªª‰ΩïÂ∏¶Êúâ`.rs`Êâ©Â±ïÂêçÁöÑÊñá‰ª∂Âêç„ÄÇ\n- ÈÄöËøá`rustc file.rs`ÂëΩ‰ª§ÂØπÂÖ∂ËøõË°åÁºñËØë„ÄÇ\n- Âú®LinuxÁªàÁ´Ø‰∏≠ÈîÆÂÖ•`./file`ÊàñÂú®WindowsÂëΩ‰ª§Ë°å‰∏≠ÈîÆÂÖ•`file.exe`Êù•ÊâßË°åËØ•Êñá‰ª∂„ÄÇ\n\n## Rust Playground\n\n[Rust Playground](https://play.rust-lang.org/)ÊòØ‰∏Ä‰∏™ÂèØ‰ª•Âú®Á∫øËøêË°åRust‰ª£Á†ÅÁöÑÂÆûÈ™åÂè∞„ÄÇ\n\n[![Rust Playground](images/rust_playground.png)](https://play.rust-lang.org/)\n\n## println!ÁöÑÁî®Ê≥ï\n\nüíØ println!ÂÆèÊúâÂæà‰∏∞ÂØåÁöÑ‰ΩøÁî®ÊñπÊ≥ïÔºå\n\n```rust\nfn main() {\n    println!(\"{}, {}!\", \"Hello\", \"world\"); // Hello, world!\n    println!(\"{0}, {1}!\", \"Hello\", \"world\"); // Hello, world!\n    println!(\"{greeting}, {name}!\", greeting=\"Hello\", name=\"world\"); // Hello, world!\n\n    println!(\"{:?}\", [1,2,3]); // [1, 2, 3]\n    println!(\"{:#?}\", [1,2,3]);\n    /*\n        [\n            1,\n            2,\n            3\n        ]\n    */\n\n    // üîé format! ÂÆèÂàôÁî®Êù•ÁîüÊàê‰∏Ä‰∏™Ê†ºÂºèÂåñÁöÑÂ≠ó‰∏≤\n    let x = format!(\"{}, {}!\", \"Hello\", \"world\");\n    println!(\"{}\", x); // Hello, world!\n}\n```\n","source":"docs/zh-cn/a3.hello_world.md","raw":"title: Hello World\n---\n\n## Hello, World!\n```rust\nfn main() {\n    println!(\"Hello, world!\");\n}\n```\n\n`fn` Ë°®Á§∫‰∏Ä‰∏™ÂáΩÊï∞‚Äî‚Äîfunction„ÄÇmainÂáΩÊï∞ÊòØÊØè‰∏Ä‰∏™RustÁ®ãÂ∫èÁöÑËµ∑ÁÇπ„ÄÇ\n`println!` Â∞Ü‰∏Ä‰∏™ÊñáÊú¨ËæìÂá∫Âà∞ÊéßÂà∂Âè∞ÔºåÁ¥ßÈöèÁöÑ*!*Ë°®Á§∫ËøôÊòØ‰∏Ä‰∏™[ÂÆè](https://doc.rust-lang.org/book/first-edition/macros.html)ËÄåÈùûÈÄöÂ∏∏ÁöÑÂáΩÊï∞„ÄÇ\n\n> üí° RustÊ∫êÊñá‰ª∂Â∫î‰ª•.rs‰Ωú‰∏∫Êñá‰ª∂Êâ©Â±ïÂêçÔºåÂ¶ÇÊûú‰Ω†Â∏åÊúõÂú®Êñá‰ª∂Âêç‰∏≠ÂåÖÂê´Â§ö‰∏™ËØçËØ≠ÔºåÂ∫îÈÅµÂæ™[ËõáÂΩ¢ÂëΩÂêç](https://en.wikipedia.org/wiki/Snake_case)ÂéüÂàô„ÄÇ\n\n- Â∞Ü‰ª•‰∏ä‰ª£Á†Å‰øùÂ≠ò‰∏∫`file.rs`Ôºå‰πüÂèØ‰ª•‰∏∫ÂÖ∂‰ªñ‰ªª‰ΩïÂ∏¶Êúâ`.rs`Êâ©Â±ïÂêçÁöÑÊñá‰ª∂Âêç„ÄÇ\n- ÈÄöËøá`rustc file.rs`ÂëΩ‰ª§ÂØπÂÖ∂ËøõË°åÁºñËØë„ÄÇ\n- Âú®LinuxÁªàÁ´Ø‰∏≠ÈîÆÂÖ•`./file`ÊàñÂú®WindowsÂëΩ‰ª§Ë°å‰∏≠ÈîÆÂÖ•`file.exe`Êù•ÊâßË°åËØ•Êñá‰ª∂„ÄÇ\n\n## Rust Playground\n\n[Rust Playground](https://play.rust-lang.org/)ÊòØ‰∏Ä‰∏™ÂèØ‰ª•Âú®Á∫øËøêË°åRust‰ª£Á†ÅÁöÑÂÆûÈ™åÂè∞„ÄÇ\n\n[![Rust Playground](images/rust_playground.png)](https://play.rust-lang.org/)\n\n## println!ÁöÑÁî®Ê≥ï\n\nüíØ println!ÂÆèÊúâÂæà‰∏∞ÂØåÁöÑ‰ΩøÁî®ÊñπÊ≥ïÔºå\n\n```rust\nfn main() {\n    println!(\"{}, {}!\", \"Hello\", \"world\"); // Hello, world!\n    println!(\"{0}, {1}!\", \"Hello\", \"world\"); // Hello, world!\n    println!(\"{greeting}, {name}!\", greeting=\"Hello\", name=\"world\"); // Hello, world!\n\n    println!(\"{:?}\", [1,2,3]); // [1, 2, 3]\n    println!(\"{:#?}\", [1,2,3]);\n    /*\n        [\n            1,\n            2,\n            3\n        ]\n    */\n\n    // üîé format! ÂÆèÂàôÁî®Êù•ÁîüÊàê‰∏Ä‰∏™Ê†ºÂºèÂåñÁöÑÂ≠ó‰∏≤\n    let x = format!(\"{}, {}!\", \"Hello\", \"world\");\n    println!(\"{}\", x); // Hello, world!\n}\n```\n","date":"2019-03-19T14:50:31.981Z","updated":"2019-03-19T14:50:31.981Z","path":"docs/zh-cn/a3.hello_world.html","comments":1,"layout":"page","_id":"cjtfwbj0o0012dwgpxc888tol","content":"<h2 id=\"Hello-World\"><a href=\"#Hello-World\" class=\"headerlink\" title=\"Hello, World!\"></a>Hello, World!</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<p><code>fn</code> Ë°®Á§∫‰∏Ä‰∏™ÂáΩÊï∞‚Äî‚Äîfunction„ÄÇmainÂáΩÊï∞ÊòØÊØè‰∏Ä‰∏™RustÁ®ãÂ∫èÁöÑËµ∑ÁÇπ„ÄÇ<br><code>println!</code> Â∞Ü‰∏Ä‰∏™ÊñáÊú¨ËæìÂá∫Âà∞ÊéßÂà∂Âè∞ÔºåÁ¥ßÈöèÁöÑ<em>!</em>Ë°®Á§∫ËøôÊòØ‰∏Ä‰∏™<a href=\"https://doc.rust-lang.org/book/first-edition/macros.html\" target=\"_blank\" rel=\"noopener\">ÂÆè</a>ËÄåÈùûÈÄöÂ∏∏ÁöÑÂáΩÊï∞„ÄÇ</p>\n<blockquote>\n<p>üí° RustÊ∫êÊñá‰ª∂Â∫î‰ª•.rs‰Ωú‰∏∫Êñá‰ª∂Êâ©Â±ïÂêçÔºåÂ¶ÇÊûú‰Ω†Â∏åÊúõÂú®Êñá‰ª∂Âêç‰∏≠ÂåÖÂê´Â§ö‰∏™ËØçËØ≠ÔºåÂ∫îÈÅµÂæ™<a href=\"https://en.wikipedia.org/wiki/Snake_case\" target=\"_blank\" rel=\"noopener\">ËõáÂΩ¢ÂëΩÂêç</a>ÂéüÂàô„ÄÇ</p>\n</blockquote>\n<ul>\n<li>Â∞Ü‰ª•‰∏ä‰ª£Á†Å‰øùÂ≠ò‰∏∫<code>file.rs</code>Ôºå‰πüÂèØ‰ª•‰∏∫ÂÖ∂‰ªñ‰ªª‰ΩïÂ∏¶Êúâ<code>.rs</code>Êâ©Â±ïÂêçÁöÑÊñá‰ª∂Âêç„ÄÇ</li>\n<li>ÈÄöËøá<code>rustc file.rs</code>ÂëΩ‰ª§ÂØπÂÖ∂ËøõË°åÁºñËØë„ÄÇ</li>\n<li>Âú®LinuxÁªàÁ´Ø‰∏≠ÈîÆÂÖ•<code>./file</code>ÊàñÂú®WindowsÂëΩ‰ª§Ë°å‰∏≠ÈîÆÂÖ•<code>file.exe</code>Êù•ÊâßË°åËØ•Êñá‰ª∂„ÄÇ</li>\n</ul>\n<h2 id=\"Rust-Playground\"><a href=\"#Rust-Playground\" class=\"headerlink\" title=\"Rust Playground\"></a>Rust Playground</h2><p><a href=\"https://play.rust-lang.org/\" target=\"_blank\" rel=\"noopener\">Rust Playground</a>ÊòØ‰∏Ä‰∏™ÂèØ‰ª•Âú®Á∫øËøêË°åRust‰ª£Á†ÅÁöÑÂÆûÈ™åÂè∞„ÄÇ</p>\n<p><a href=\"https://play.rust-lang.org/\" target=\"_blank\" rel=\"noopener\"><img src=\"images/rust_playground.png\" alt=\"Rust Playground\"></a></p>\n<h2 id=\"println-ÁöÑÁî®Ê≥ï\"><a href=\"#println-ÁöÑÁî®Ê≥ï\" class=\"headerlink\" title=\"println!ÁöÑÁî®Ê≥ï\"></a>println!ÁöÑÁî®Ê≥ï</h2><p>üíØ println!ÂÆèÊúâÂæà‰∏∞ÂØåÁöÑ‰ΩøÁî®ÊñπÊ≥ïÔºå</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    println!(&quot;{}, {}!&quot;, &quot;Hello&quot;, &quot;world&quot;); // Hello, world!\n    println!(&quot;{0}, {1}!&quot;, &quot;Hello&quot;, &quot;world&quot;); // Hello, world!\n    println!(&quot;{greeting}, {name}!&quot;, greeting=&quot;Hello&quot;, name=&quot;world&quot;); // Hello, world!\n\n    println!(&quot;{:?}&quot;, [1,2,3]); // [1, 2, 3]\n    println!(&quot;{:#?}&quot;, [1,2,3]);\n    /*\n        [\n            1,\n            2,\n            3\n        ]\n    */\n\n    // üîé format! ÂÆèÂàôÁî®Êù•ÁîüÊàê‰∏Ä‰∏™Ê†ºÂºèÂåñÁöÑÂ≠ó‰∏≤\n    let x = format!(&quot;{}, {}!&quot;, &quot;Hello&quot;, &quot;world&quot;);\n    println!(&quot;{}&quot;, x); // Hello, world!\n}\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<h2 id=\"Hello-World\"><a href=\"#Hello-World\" class=\"headerlink\" title=\"Hello, World!\"></a>Hello, World!</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<p><code>fn</code> Ë°®Á§∫‰∏Ä‰∏™ÂáΩÊï∞‚Äî‚Äîfunction„ÄÇmainÂáΩÊï∞ÊòØÊØè‰∏Ä‰∏™RustÁ®ãÂ∫èÁöÑËµ∑ÁÇπ„ÄÇ<br><code>println!</code> Â∞Ü‰∏Ä‰∏™ÊñáÊú¨ËæìÂá∫Âà∞ÊéßÂà∂Âè∞ÔºåÁ¥ßÈöèÁöÑ<em>!</em>Ë°®Á§∫ËøôÊòØ‰∏Ä‰∏™<a href=\"https://doc.rust-lang.org/book/first-edition/macros.html\" target=\"_blank\" rel=\"noopener\">ÂÆè</a>ËÄåÈùûÈÄöÂ∏∏ÁöÑÂáΩÊï∞„ÄÇ</p>\n<blockquote>\n<p>üí° RustÊ∫êÊñá‰ª∂Â∫î‰ª•.rs‰Ωú‰∏∫Êñá‰ª∂Êâ©Â±ïÂêçÔºåÂ¶ÇÊûú‰Ω†Â∏åÊúõÂú®Êñá‰ª∂Âêç‰∏≠ÂåÖÂê´Â§ö‰∏™ËØçËØ≠ÔºåÂ∫îÈÅµÂæ™<a href=\"https://en.wikipedia.org/wiki/Snake_case\" target=\"_blank\" rel=\"noopener\">ËõáÂΩ¢ÂëΩÂêç</a>ÂéüÂàô„ÄÇ</p>\n</blockquote>\n<ul>\n<li>Â∞Ü‰ª•‰∏ä‰ª£Á†Å‰øùÂ≠ò‰∏∫<code>file.rs</code>Ôºå‰πüÂèØ‰ª•‰∏∫ÂÖ∂‰ªñ‰ªª‰ΩïÂ∏¶Êúâ<code>.rs</code>Êâ©Â±ïÂêçÁöÑÊñá‰ª∂Âêç„ÄÇ</li>\n<li>ÈÄöËøá<code>rustc file.rs</code>ÂëΩ‰ª§ÂØπÂÖ∂ËøõË°åÁºñËØë„ÄÇ</li>\n<li>Âú®LinuxÁªàÁ´Ø‰∏≠ÈîÆÂÖ•<code>./file</code>ÊàñÂú®WindowsÂëΩ‰ª§Ë°å‰∏≠ÈîÆÂÖ•<code>file.exe</code>Êù•ÊâßË°åËØ•Êñá‰ª∂„ÄÇ</li>\n</ul>\n<h2 id=\"Rust-Playground\"><a href=\"#Rust-Playground\" class=\"headerlink\" title=\"Rust Playground\"></a>Rust Playground</h2><p><a href=\"https://play.rust-lang.org/\" target=\"_blank\" rel=\"noopener\">Rust Playground</a>ÊòØ‰∏Ä‰∏™ÂèØ‰ª•Âú®Á∫øËøêË°åRust‰ª£Á†ÅÁöÑÂÆûÈ™åÂè∞„ÄÇ</p>\n<p><a href=\"https://play.rust-lang.org/\" target=\"_blank\" rel=\"noopener\"><img src=\"images/rust_playground.png\" alt=\"Rust Playground\"></a></p>\n<h2 id=\"println-ÁöÑÁî®Ê≥ï\"><a href=\"#println-ÁöÑÁî®Ê≥ï\" class=\"headerlink\" title=\"println!ÁöÑÁî®Ê≥ï\"></a>println!ÁöÑÁî®Ê≥ï</h2><p>üíØ println!ÂÆèÊúâÂæà‰∏∞ÂØåÁöÑ‰ΩøÁî®ÊñπÊ≥ïÔºå</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    println!(&quot;{}, {}!&quot;, &quot;Hello&quot;, &quot;world&quot;); // Hello, world!\n    println!(&quot;{0}, {1}!&quot;, &quot;Hello&quot;, &quot;world&quot;); // Hello, world!\n    println!(&quot;{greeting}, {name}!&quot;, greeting=&quot;Hello&quot;, name=&quot;world&quot;); // Hello, world!\n\n    println!(&quot;{:?}&quot;, [1,2,3]); // [1, 2, 3]\n    println!(&quot;{:#?}&quot;, [1,2,3]);\n    /*\n        [\n            1,\n            2,\n            3\n        ]\n    */\n\n    // üîé format! ÂÆèÂàôÁî®Êù•ÁîüÊàê‰∏Ä‰∏™Ê†ºÂºèÂåñÁöÑÂ≠ó‰∏≤\n    let x = format!(&quot;{}, {}!&quot;, &quot;Hello&quot;, &quot;world&quot;);\n    println!(&quot;{}&quot;, x); // Hello, world!\n}\n</code></pre>\n"},{"title":"CargoÔºåCrates‰∫éÂü∫Êú¨ÁöÑÈ°πÁõÆÁªìÊûÑ","_content":"\n## Cargo\n\nCargoÊòØRustÂÜÖÂª∫ÁöÑÂåÖÁÆ°ÁêÜÂô®Ôºå‰∏ªË¶ÅÂèØ‰ª•Áî®Êù•Ôºö\n\n- ÂàõÂª∫Êñ∞È°πÁõÆÔºö`cargo new`\n- Êõ¥Êñ∞‰æùËµñÈ°π: `cargo update`\n- ÊâìÂåÖÈ°πÁõÆ: `cargo build`\n- Ëß£ÊûêÈ°πÁõÆÊòØÂê¶Â≠òÂú®‰ªª‰ΩïÂºÇÂ∏∏Ôºå‰ΩÜÂπ∂‰∏çËøõË°åÊâìÂåÖ: `cargo check`\n- ÊâìÂåÖÂπ∂ËøêË°åÈ°πÁõÆ: `cargo run`  \n- ÊâßË°åÊµãËØï: `cargo test`  \n- ÈÄöËøárustdocÁîüÊàêÊñáÊ°£: `cargo doc`\n\nÈô§Ê≠§‰πãÂ§ñËøòÊúâ‰∏Ä‰∫õCargoÁöÑÂëΩ‰ª§Ôºå‰∏ªË¶ÅÂú®ÈÄöËøáCargoÊù•ÂèëÂ∏ÉcrateÂåÖÊó∂‰ΩøÁî®„ÄÇ\n\n- `cargo login` : Ëé∑Âèñ‰∏Ä‰∏™API token\n- `cargo package` : ÂáÜÂ§áÊú¨Âú∞ÁöÑcrate‰ª•Â§á‰∏ä‰º†Ëá≥crates.io  \n- `cargo publish` : ÂáÜÂ§áÊú¨Âú∞ÁöÑcrateÔºåÂπ∂‰∏ä‰º†Âà∞crates.io\n\n## Crate\n\n‚≠êÔ∏è **‰∏Ä‰∏™crate‰ª£Ë°®‰∏Ä‰∏™‰ª£Á†ÅÂåÖ„ÄÇCratesÂåÖÂèØ‰ª•ÈÄöËøá[Cargo](https://crates.io/)ËøõË°åÂàÜ‰∫´„ÄÇ**\n\n\n‰∏Ä‰∏™crateÂåÖÂèØ‰ª•ÊòØ‰∏Ä‰∏™ÂèØÊâßË°åÂåÖÊàñÊòØ‰∏Ä‰∏™Â∫ì„ÄÇ‰πüÂ∞±ÊòØËØ¥Ôºå‰∏Ä‰∏™crateÊàñÊòØ‰∏Ä‰∏™ÂèØÊâßË°åÈ°πÁõÆÔºåÊàñÊòØ‰∏Ä‰∏™Â∫ì„ÄÇ\n01.  `cargo new crate_name --bin` Êàñ `cargo new crate_name`: ÁîüÊàê‰∏Ä‰∏™**ÂèØÊâßË°åÈ°πÁõÆ**  \n02.  `cargo new crate_name --lib` : ÁîüÊàê‰∏Ä‰∏™**Â∫ì**\n\nÁ¨¨‰∏Ä‰∏™ÂëΩ‰ª§‰ºöÁîüÊàêÔºö\n\n```\n‚îú‚îÄ‚îÄ Cargo.toml\n‚îî‚îÄ‚îÄ src\n    ‚îî‚îÄ‚îÄ main.rs\n```\n\nÁ¨¨‰∫å‰∏™‰ºöÁîüÊàêÔºö\n\n```\n‚îú‚îÄ‚îÄ Cargo.toml\n‚îî‚îÄ‚îÄ src\n    ‚îî‚îÄ‚îÄ lib.rs\n```\n\n* **Cargo.toml**\\(Â§ßÂÜôc\\)Â≠òÊîæ‰∫ÜÂΩìCargoÁî®Êù•ÁºñËØëÊÇ®ÁöÑÈ°πÁõÆÊâÄÈúÄÁöÑÂÖÉ‰ø°ÊÅØ„ÄÇ\n* **src**ÁõÆÂΩïÁî®Êù•Â≠òÊîæÊÇ®ÁöÑÊ∫ê‰ª£Á†Å„ÄÇ\n* ÊØè‰∏™crateÂåÖ‰ºöÊúâ‰∏Ä‰∏™ÊöóÁ§∫ÊÄßÁöÑÂåÖÂÖ•Âè£„ÄÇ**main.rs**ÊòØ‰∫åËøõÂà∂crateÂåÖÁöÑÂÖ•Âè£ÔºåËÄå**lib.rs**ÂàôÊòØcrateÂ∫ìÂåÖÁöÑÂÖ•Âè£„ÄÇ\n\n> üí° ÂΩìÈúÄË¶Å‰ΩøÁî®`cargo build`Êàñ`cargo run`Êù•ÁºñËØë‰∏Ä‰∏™‰∫åËøõÂà∂ÂåÖÊó∂ÔºåÂèØÊâßË°åÊñá‰ª∂‰ºöË¢´Â≠òÊîæÂú®**target/debug/**Êñá‰ª∂Â§π‰∏ã„ÄÇ‰ΩÜÂΩì‰ΩøÁî®`cargo build --release`Êù•ÊâìÂåÖ‰∏Ä‰∏™Áîü‰∫ßÈáäÊîæÂåÖÁöÑÊó∂ÂÄôÔºåÂàô‰ºöË¢´Â≠òÊîæÂú®**target/release/**Êñá‰ª∂Â§π‰∏ã„ÄÇ\n\n## Project Structure\n\n‰ª•‰∏ãÊòØ[CargoÊñáÊ°£ÊèèËø∞](http://doc.crates.io/guide.html#project-layout)‰∏≠Êé®ËçêÁöÑÈ°πÁõÆÂ∏ÉÂ±ÄÔºå\n\n```\n.\n‚îú‚îÄ‚îÄ Cargo.lock\n‚îú‚îÄ‚îÄ Cargo.toml\n‚îú‚îÄ‚îÄ benches\n‚îÇ   ‚îî‚îÄ‚îÄ large-input.rs\n‚îú‚îÄ‚îÄ examples\n‚îÇ   ‚îî‚îÄ‚îÄ simple.rs\n‚îú‚îÄ‚îÄ src\n‚îÇ   ‚îú‚îÄ‚îÄ bin\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ another_executable.rs\n‚îÇ   ‚îú‚îÄ‚îÄ lib.rs\n‚îÇ   ‚îî‚îÄ‚îÄ main.rs\n‚îî‚îÄ‚îÄ tests\n    ‚îî‚îÄ‚îÄ some-integration-tests.rs\n```\n\n- Ê∫ê‰ª£Á†ÅÂ∫îÊîæÂú®`src`Êñá‰ª∂Â§π‰∏≠„ÄÇ  \n- ÈªòËÆ§ÁöÑÂ∫ìÂÖ•Âè£Êñá‰ª∂‰∏∫`src/lib.rs`„ÄÇ\n- ÈªòËÆ§ÁöÑÂèØÊâßË°åÂÖ•Âè£Êñá‰ª∂‰∏∫`src/main.rs`„ÄÇ  \n- ÂÖ∂‰ΩôÁöÑÂèØÊâßË°åÊñá‰ª∂ÂèØ‰ª•ÊîæÂú®`src/bin/*.rs`‰∏≠„ÄÇ  \n- ÈõÜÊàêÊµãËØïÊñá‰ª∂ÂèØ‰ª•ÊîæÂú®`tests`Êñá‰ª∂Â§π‰∏≠ \\(ÂçïÂÖÉÊµãËØï‰ºöÊîæÂú®ÊØè‰∏™Êñá‰ª∂Ëá™Ë∫´‰∏≠\\)„ÄÇ\n- Ê†∑‰æãÂ∫îÊîæÂú®`examples`ÁõÆÂΩï‰∏≠„ÄÇ\n- ÂéãÂäõÊµãËØïÂ∫îÊîæÂú®`benches`Êñá‰ª∂Â§π‰∏≠„ÄÇ\n","source":"docs/zh-cn/a4.cargo,crates_and_basic_project_structure.md","raw":"title: CargoÔºåCrates‰∫éÂü∫Êú¨ÁöÑÈ°πÁõÆÁªìÊûÑ\n---\n\n## Cargo\n\nCargoÊòØRustÂÜÖÂª∫ÁöÑÂåÖÁÆ°ÁêÜÂô®Ôºå‰∏ªË¶ÅÂèØ‰ª•Áî®Êù•Ôºö\n\n- ÂàõÂª∫Êñ∞È°πÁõÆÔºö`cargo new`\n- Êõ¥Êñ∞‰æùËµñÈ°π: `cargo update`\n- ÊâìÂåÖÈ°πÁõÆ: `cargo build`\n- Ëß£ÊûêÈ°πÁõÆÊòØÂê¶Â≠òÂú®‰ªª‰ΩïÂºÇÂ∏∏Ôºå‰ΩÜÂπ∂‰∏çËøõË°åÊâìÂåÖ: `cargo check`\n- ÊâìÂåÖÂπ∂ËøêË°åÈ°πÁõÆ: `cargo run`  \n- ÊâßË°åÊµãËØï: `cargo test`  \n- ÈÄöËøárustdocÁîüÊàêÊñáÊ°£: `cargo doc`\n\nÈô§Ê≠§‰πãÂ§ñËøòÊúâ‰∏Ä‰∫õCargoÁöÑÂëΩ‰ª§Ôºå‰∏ªË¶ÅÂú®ÈÄöËøáCargoÊù•ÂèëÂ∏ÉcrateÂåÖÊó∂‰ΩøÁî®„ÄÇ\n\n- `cargo login` : Ëé∑Âèñ‰∏Ä‰∏™API token\n- `cargo package` : ÂáÜÂ§áÊú¨Âú∞ÁöÑcrate‰ª•Â§á‰∏ä‰º†Ëá≥crates.io  \n- `cargo publish` : ÂáÜÂ§áÊú¨Âú∞ÁöÑcrateÔºåÂπ∂‰∏ä‰º†Âà∞crates.io\n\n## Crate\n\n‚≠êÔ∏è **‰∏Ä‰∏™crate‰ª£Ë°®‰∏Ä‰∏™‰ª£Á†ÅÂåÖ„ÄÇCratesÂåÖÂèØ‰ª•ÈÄöËøá[Cargo](https://crates.io/)ËøõË°åÂàÜ‰∫´„ÄÇ**\n\n\n‰∏Ä‰∏™crateÂåÖÂèØ‰ª•ÊòØ‰∏Ä‰∏™ÂèØÊâßË°åÂåÖÊàñÊòØ‰∏Ä‰∏™Â∫ì„ÄÇ‰πüÂ∞±ÊòØËØ¥Ôºå‰∏Ä‰∏™crateÊàñÊòØ‰∏Ä‰∏™ÂèØÊâßË°åÈ°πÁõÆÔºåÊàñÊòØ‰∏Ä‰∏™Â∫ì„ÄÇ\n01.  `cargo new crate_name --bin` Êàñ `cargo new crate_name`: ÁîüÊàê‰∏Ä‰∏™**ÂèØÊâßË°åÈ°πÁõÆ**  \n02.  `cargo new crate_name --lib` : ÁîüÊàê‰∏Ä‰∏™**Â∫ì**\n\nÁ¨¨‰∏Ä‰∏™ÂëΩ‰ª§‰ºöÁîüÊàêÔºö\n\n```\n‚îú‚îÄ‚îÄ Cargo.toml\n‚îî‚îÄ‚îÄ src\n    ‚îî‚îÄ‚îÄ main.rs\n```\n\nÁ¨¨‰∫å‰∏™‰ºöÁîüÊàêÔºö\n\n```\n‚îú‚îÄ‚îÄ Cargo.toml\n‚îî‚îÄ‚îÄ src\n    ‚îî‚îÄ‚îÄ lib.rs\n```\n\n* **Cargo.toml**\\(Â§ßÂÜôc\\)Â≠òÊîæ‰∫ÜÂΩìCargoÁî®Êù•ÁºñËØëÊÇ®ÁöÑÈ°πÁõÆÊâÄÈúÄÁöÑÂÖÉ‰ø°ÊÅØ„ÄÇ\n* **src**ÁõÆÂΩïÁî®Êù•Â≠òÊîæÊÇ®ÁöÑÊ∫ê‰ª£Á†Å„ÄÇ\n* ÊØè‰∏™crateÂåÖ‰ºöÊúâ‰∏Ä‰∏™ÊöóÁ§∫ÊÄßÁöÑÂåÖÂÖ•Âè£„ÄÇ**main.rs**ÊòØ‰∫åËøõÂà∂crateÂåÖÁöÑÂÖ•Âè£ÔºåËÄå**lib.rs**ÂàôÊòØcrateÂ∫ìÂåÖÁöÑÂÖ•Âè£„ÄÇ\n\n> üí° ÂΩìÈúÄË¶Å‰ΩøÁî®`cargo build`Êàñ`cargo run`Êù•ÁºñËØë‰∏Ä‰∏™‰∫åËøõÂà∂ÂåÖÊó∂ÔºåÂèØÊâßË°åÊñá‰ª∂‰ºöË¢´Â≠òÊîæÂú®**target/debug/**Êñá‰ª∂Â§π‰∏ã„ÄÇ‰ΩÜÂΩì‰ΩøÁî®`cargo build --release`Êù•ÊâìÂåÖ‰∏Ä‰∏™Áîü‰∫ßÈáäÊîæÂåÖÁöÑÊó∂ÂÄôÔºåÂàô‰ºöË¢´Â≠òÊîæÂú®**target/release/**Êñá‰ª∂Â§π‰∏ã„ÄÇ\n\n## Project Structure\n\n‰ª•‰∏ãÊòØ[CargoÊñáÊ°£ÊèèËø∞](http://doc.crates.io/guide.html#project-layout)‰∏≠Êé®ËçêÁöÑÈ°πÁõÆÂ∏ÉÂ±ÄÔºå\n\n```\n.\n‚îú‚îÄ‚îÄ Cargo.lock\n‚îú‚îÄ‚îÄ Cargo.toml\n‚îú‚îÄ‚îÄ benches\n‚îÇ   ‚îî‚îÄ‚îÄ large-input.rs\n‚îú‚îÄ‚îÄ examples\n‚îÇ   ‚îî‚îÄ‚îÄ simple.rs\n‚îú‚îÄ‚îÄ src\n‚îÇ   ‚îú‚îÄ‚îÄ bin\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ another_executable.rs\n‚îÇ   ‚îú‚îÄ‚îÄ lib.rs\n‚îÇ   ‚îî‚îÄ‚îÄ main.rs\n‚îî‚îÄ‚îÄ tests\n    ‚îî‚îÄ‚îÄ some-integration-tests.rs\n```\n\n- Ê∫ê‰ª£Á†ÅÂ∫îÊîæÂú®`src`Êñá‰ª∂Â§π‰∏≠„ÄÇ  \n- ÈªòËÆ§ÁöÑÂ∫ìÂÖ•Âè£Êñá‰ª∂‰∏∫`src/lib.rs`„ÄÇ\n- ÈªòËÆ§ÁöÑÂèØÊâßË°åÂÖ•Âè£Êñá‰ª∂‰∏∫`src/main.rs`„ÄÇ  \n- ÂÖ∂‰ΩôÁöÑÂèØÊâßË°åÊñá‰ª∂ÂèØ‰ª•ÊîæÂú®`src/bin/*.rs`‰∏≠„ÄÇ  \n- ÈõÜÊàêÊµãËØïÊñá‰ª∂ÂèØ‰ª•ÊîæÂú®`tests`Êñá‰ª∂Â§π‰∏≠ \\(ÂçïÂÖÉÊµãËØï‰ºöÊîæÂú®ÊØè‰∏™Êñá‰ª∂Ëá™Ë∫´‰∏≠\\)„ÄÇ\n- Ê†∑‰æãÂ∫îÊîæÂú®`examples`ÁõÆÂΩï‰∏≠„ÄÇ\n- ÂéãÂäõÊµãËØïÂ∫îÊîæÂú®`benches`Êñá‰ª∂Â§π‰∏≠„ÄÇ\n","date":"2019-03-19T14:50:31.982Z","updated":"2019-03-19T14:50:31.982Z","path":"docs/zh-cn/a4.cargo,crates_and_basic_project_structure.html","comments":1,"layout":"page","_id":"cjtfwbj0o0013dwgpl29yr90t","content":"<h2 id=\"Cargo\"><a href=\"#Cargo\" class=\"headerlink\" title=\"Cargo\"></a>Cargo</h2><p>CargoÊòØRustÂÜÖÂª∫ÁöÑÂåÖÁÆ°ÁêÜÂô®Ôºå‰∏ªË¶ÅÂèØ‰ª•Áî®Êù•Ôºö</p>\n<ul>\n<li>ÂàõÂª∫Êñ∞È°πÁõÆÔºö<code>cargo new</code></li>\n<li>Êõ¥Êñ∞‰æùËµñÈ°π: <code>cargo update</code></li>\n<li>ÊâìÂåÖÈ°πÁõÆ: <code>cargo build</code></li>\n<li>Ëß£ÊûêÈ°πÁõÆÊòØÂê¶Â≠òÂú®‰ªª‰ΩïÂºÇÂ∏∏Ôºå‰ΩÜÂπ∂‰∏çËøõË°åÊâìÂåÖ: <code>cargo check</code></li>\n<li>ÊâìÂåÖÂπ∂ËøêË°åÈ°πÁõÆ: <code>cargo run</code>  </li>\n<li>ÊâßË°åÊµãËØï: <code>cargo test</code>  </li>\n<li>ÈÄöËøárustdocÁîüÊàêÊñáÊ°£: <code>cargo doc</code></li>\n</ul>\n<p>Èô§Ê≠§‰πãÂ§ñËøòÊúâ‰∏Ä‰∫õCargoÁöÑÂëΩ‰ª§Ôºå‰∏ªË¶ÅÂú®ÈÄöËøáCargoÊù•ÂèëÂ∏ÉcrateÂåÖÊó∂‰ΩøÁî®„ÄÇ</p>\n<ul>\n<li><code>cargo login</code> : Ëé∑Âèñ‰∏Ä‰∏™API token</li>\n<li><code>cargo package</code> : ÂáÜÂ§áÊú¨Âú∞ÁöÑcrate‰ª•Â§á‰∏ä‰º†Ëá≥crates.io  </li>\n<li><code>cargo publish</code> : ÂáÜÂ§áÊú¨Âú∞ÁöÑcrateÔºåÂπ∂‰∏ä‰º†Âà∞crates.io</li>\n</ul>\n<h2 id=\"Crate\"><a href=\"#Crate\" class=\"headerlink\" title=\"Crate\"></a>Crate</h2><p>‚≠êÔ∏è <strong>‰∏Ä‰∏™crate‰ª£Ë°®‰∏Ä‰∏™‰ª£Á†ÅÂåÖ„ÄÇCratesÂåÖÂèØ‰ª•ÈÄöËøá<a href=\"https://crates.io/\" target=\"_blank\" rel=\"noopener\">Cargo</a>ËøõË°åÂàÜ‰∫´„ÄÇ</strong></p>\n<p>‰∏Ä‰∏™crateÂåÖÂèØ‰ª•ÊòØ‰∏Ä‰∏™ÂèØÊâßË°åÂåÖÊàñÊòØ‰∏Ä‰∏™Â∫ì„ÄÇ‰πüÂ∞±ÊòØËØ¥Ôºå‰∏Ä‰∏™crateÊàñÊòØ‰∏Ä‰∏™ÂèØÊâßË°åÈ°πÁõÆÔºåÊàñÊòØ‰∏Ä‰∏™Â∫ì„ÄÇ</p>\n<ol>\n<li><code>cargo new crate_name --bin</code> Êàñ <code>cargo new crate_name</code>: ÁîüÊàê‰∏Ä‰∏™<strong>ÂèØÊâßË°åÈ°πÁõÆ</strong>  </li>\n<li><code>cargo new crate_name --lib</code> : ÁîüÊàê‰∏Ä‰∏™<strong>Â∫ì</strong></li>\n</ol>\n<p>Á¨¨‰∏Ä‰∏™ÂëΩ‰ª§‰ºöÁîüÊàêÔºö</p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code>‚îú‚îÄ‚îÄ Cargo.toml\n‚îî‚îÄ‚îÄ src\n    ‚îî‚îÄ‚îÄ main.rs\n</code></pre><p>Á¨¨‰∫å‰∏™‰ºöÁîüÊàêÔºö</p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code>‚îú‚îÄ‚îÄ Cargo.toml\n‚îî‚îÄ‚îÄ src\n    ‚îî‚îÄ‚îÄ lib.rs\n</code></pre><ul>\n<li><strong>Cargo.toml</strong>(Â§ßÂÜôc)Â≠òÊîæ‰∫ÜÂΩìCargoÁî®Êù•ÁºñËØëÊÇ®ÁöÑÈ°πÁõÆÊâÄÈúÄÁöÑÂÖÉ‰ø°ÊÅØ„ÄÇ</li>\n<li><strong>src</strong>ÁõÆÂΩïÁî®Êù•Â≠òÊîæÊÇ®ÁöÑÊ∫ê‰ª£Á†Å„ÄÇ</li>\n<li>ÊØè‰∏™crateÂåÖ‰ºöÊúâ‰∏Ä‰∏™ÊöóÁ§∫ÊÄßÁöÑÂåÖÂÖ•Âè£„ÄÇ<strong>main.rs</strong>ÊòØ‰∫åËøõÂà∂crateÂåÖÁöÑÂÖ•Âè£ÔºåËÄå<strong>lib.rs</strong>ÂàôÊòØcrateÂ∫ìÂåÖÁöÑÂÖ•Âè£„ÄÇ</li>\n</ul>\n<blockquote>\n<p>üí° ÂΩìÈúÄË¶Å‰ΩøÁî®<code>cargo build</code>Êàñ<code>cargo run</code>Êù•ÁºñËØë‰∏Ä‰∏™‰∫åËøõÂà∂ÂåÖÊó∂ÔºåÂèØÊâßË°åÊñá‰ª∂‰ºöË¢´Â≠òÊîæÂú®<strong>target/debug/</strong>Êñá‰ª∂Â§π‰∏ã„ÄÇ‰ΩÜÂΩì‰ΩøÁî®<code>cargo build --release</code>Êù•ÊâìÂåÖ‰∏Ä‰∏™Áîü‰∫ßÈáäÊîæÂåÖÁöÑÊó∂ÂÄôÔºåÂàô‰ºöË¢´Â≠òÊîæÂú®<strong>target/release/</strong>Êñá‰ª∂Â§π‰∏ã„ÄÇ</p>\n</blockquote>\n<h2 id=\"Project-Structure\"><a href=\"#Project-Structure\" class=\"headerlink\" title=\"Project Structure\"></a>Project Structure</h2><p>‰ª•‰∏ãÊòØ<a href=\"http://doc.crates.io/guide.html#project-layout\" target=\"_blank\" rel=\"noopener\">CargoÊñáÊ°£ÊèèËø∞</a>‰∏≠Êé®ËçêÁöÑÈ°πÁõÆÂ∏ÉÂ±ÄÔºå</p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code>.\n‚îú‚îÄ‚îÄ Cargo.lock\n‚îú‚îÄ‚îÄ Cargo.toml\n‚îú‚îÄ‚îÄ benches\n‚îÇ   ‚îî‚îÄ‚îÄ large-input.rs\n‚îú‚îÄ‚îÄ examples\n‚îÇ   ‚îî‚îÄ‚îÄ simple.rs\n‚îú‚îÄ‚îÄ src\n‚îÇ   ‚îú‚îÄ‚îÄ bin\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ another_executable.rs\n‚îÇ   ‚îú‚îÄ‚îÄ lib.rs\n‚îÇ   ‚îî‚îÄ‚îÄ main.rs\n‚îî‚îÄ‚îÄ tests\n    ‚îî‚îÄ‚îÄ some-integration-tests.rs\n</code></pre><ul>\n<li>Ê∫ê‰ª£Á†ÅÂ∫îÊîæÂú®<code>src</code>Êñá‰ª∂Â§π‰∏≠„ÄÇ  </li>\n<li>ÈªòËÆ§ÁöÑÂ∫ìÂÖ•Âè£Êñá‰ª∂‰∏∫<code>src/lib.rs</code>„ÄÇ</li>\n<li>ÈªòËÆ§ÁöÑÂèØÊâßË°åÂÖ•Âè£Êñá‰ª∂‰∏∫<code>src/main.rs</code>„ÄÇ  </li>\n<li>ÂÖ∂‰ΩôÁöÑÂèØÊâßË°åÊñá‰ª∂ÂèØ‰ª•ÊîæÂú®<code>src/bin/*.rs</code>‰∏≠„ÄÇ  </li>\n<li>ÈõÜÊàêÊµãËØïÊñá‰ª∂ÂèØ‰ª•ÊîæÂú®<code>tests</code>Êñá‰ª∂Â§π‰∏≠ (ÂçïÂÖÉÊµãËØï‰ºöÊîæÂú®ÊØè‰∏™Êñá‰ª∂Ëá™Ë∫´‰∏≠)„ÄÇ</li>\n<li>Ê†∑‰æãÂ∫îÊîæÂú®<code>examples</code>ÁõÆÂΩï‰∏≠„ÄÇ</li>\n<li>ÂéãÂäõÊµãËØïÂ∫îÊîæÂú®<code>benches</code>Êñá‰ª∂Â§π‰∏≠„ÄÇ</li>\n</ul>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<h2 id=\"Cargo\"><a href=\"#Cargo\" class=\"headerlink\" title=\"Cargo\"></a>Cargo</h2><p>CargoÊòØRustÂÜÖÂª∫ÁöÑÂåÖÁÆ°ÁêÜÂô®Ôºå‰∏ªË¶ÅÂèØ‰ª•Áî®Êù•Ôºö</p>\n<ul>\n<li>ÂàõÂª∫Êñ∞È°πÁõÆÔºö<code>cargo new</code></li>\n<li>Êõ¥Êñ∞‰æùËµñÈ°π: <code>cargo update</code></li>\n<li>ÊâìÂåÖÈ°πÁõÆ: <code>cargo build</code></li>\n<li>Ëß£ÊûêÈ°πÁõÆÊòØÂê¶Â≠òÂú®‰ªª‰ΩïÂºÇÂ∏∏Ôºå‰ΩÜÂπ∂‰∏çËøõË°åÊâìÂåÖ: <code>cargo check</code></li>\n<li>ÊâìÂåÖÂπ∂ËøêË°åÈ°πÁõÆ: <code>cargo run</code>  </li>\n<li>ÊâßË°åÊµãËØï: <code>cargo test</code>  </li>\n<li>ÈÄöËøárustdocÁîüÊàêÊñáÊ°£: <code>cargo doc</code></li>\n</ul>\n<p>Èô§Ê≠§‰πãÂ§ñËøòÊúâ‰∏Ä‰∫õCargoÁöÑÂëΩ‰ª§Ôºå‰∏ªË¶ÅÂú®ÈÄöËøáCargoÊù•ÂèëÂ∏ÉcrateÂåÖÊó∂‰ΩøÁî®„ÄÇ</p>\n<ul>\n<li><code>cargo login</code> : Ëé∑Âèñ‰∏Ä‰∏™API token</li>\n<li><code>cargo package</code> : ÂáÜÂ§áÊú¨Âú∞ÁöÑcrate‰ª•Â§á‰∏ä‰º†Ëá≥crates.io  </li>\n<li><code>cargo publish</code> : ÂáÜÂ§áÊú¨Âú∞ÁöÑcrateÔºåÂπ∂‰∏ä‰º†Âà∞crates.io</li>\n</ul>\n<h2 id=\"Crate\"><a href=\"#Crate\" class=\"headerlink\" title=\"Crate\"></a>Crate</h2><p>‚≠êÔ∏è <strong>‰∏Ä‰∏™crate‰ª£Ë°®‰∏Ä‰∏™‰ª£Á†ÅÂåÖ„ÄÇCratesÂåÖÂèØ‰ª•ÈÄöËøá<a href=\"https://crates.io/\" target=\"_blank\" rel=\"noopener\">Cargo</a>ËøõË°åÂàÜ‰∫´„ÄÇ</strong></p>\n<p>‰∏Ä‰∏™crateÂåÖÂèØ‰ª•ÊòØ‰∏Ä‰∏™ÂèØÊâßË°åÂåÖÊàñÊòØ‰∏Ä‰∏™Â∫ì„ÄÇ‰πüÂ∞±ÊòØËØ¥Ôºå‰∏Ä‰∏™crateÊàñÊòØ‰∏Ä‰∏™ÂèØÊâßË°åÈ°πÁõÆÔºåÊàñÊòØ‰∏Ä‰∏™Â∫ì„ÄÇ</p>\n<ol>\n<li><code>cargo new crate_name --bin</code> Êàñ <code>cargo new crate_name</code>: ÁîüÊàê‰∏Ä‰∏™<strong>ÂèØÊâßË°åÈ°πÁõÆ</strong>  </li>\n<li><code>cargo new crate_name --lib</code> : ÁîüÊàê‰∏Ä‰∏™<strong>Â∫ì</strong></li>\n</ol>\n<p>Á¨¨‰∏Ä‰∏™ÂëΩ‰ª§‰ºöÁîüÊàêÔºö</p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code>‚îú‚îÄ‚îÄ Cargo.toml\n‚îî‚îÄ‚îÄ src\n    ‚îî‚îÄ‚îÄ main.rs\n</code></pre><p>Á¨¨‰∫å‰∏™‰ºöÁîüÊàêÔºö</p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code>‚îú‚îÄ‚îÄ Cargo.toml\n‚îî‚îÄ‚îÄ src\n    ‚îî‚îÄ‚îÄ lib.rs\n</code></pre><ul>\n<li><strong>Cargo.toml</strong>(Â§ßÂÜôc)Â≠òÊîæ‰∫ÜÂΩìCargoÁî®Êù•ÁºñËØëÊÇ®ÁöÑÈ°πÁõÆÊâÄÈúÄÁöÑÂÖÉ‰ø°ÊÅØ„ÄÇ</li>\n<li><strong>src</strong>ÁõÆÂΩïÁî®Êù•Â≠òÊîæÊÇ®ÁöÑÊ∫ê‰ª£Á†Å„ÄÇ</li>\n<li>ÊØè‰∏™crateÂåÖ‰ºöÊúâ‰∏Ä‰∏™ÊöóÁ§∫ÊÄßÁöÑÂåÖÂÖ•Âè£„ÄÇ<strong>main.rs</strong>ÊòØ‰∫åËøõÂà∂crateÂåÖÁöÑÂÖ•Âè£ÔºåËÄå<strong>lib.rs</strong>ÂàôÊòØcrateÂ∫ìÂåÖÁöÑÂÖ•Âè£„ÄÇ</li>\n</ul>\n<blockquote>\n<p>üí° ÂΩìÈúÄË¶Å‰ΩøÁî®<code>cargo build</code>Êàñ<code>cargo run</code>Êù•ÁºñËØë‰∏Ä‰∏™‰∫åËøõÂà∂ÂåÖÊó∂ÔºåÂèØÊâßË°åÊñá‰ª∂‰ºöË¢´Â≠òÊîæÂú®<strong>target/debug/</strong>Êñá‰ª∂Â§π‰∏ã„ÄÇ‰ΩÜÂΩì‰ΩøÁî®<code>cargo build --release</code>Êù•ÊâìÂåÖ‰∏Ä‰∏™Áîü‰∫ßÈáäÊîæÂåÖÁöÑÊó∂ÂÄôÔºåÂàô‰ºöË¢´Â≠òÊîæÂú®<strong>target/release/</strong>Êñá‰ª∂Â§π‰∏ã„ÄÇ</p>\n</blockquote>\n<h2 id=\"Project-Structure\"><a href=\"#Project-Structure\" class=\"headerlink\" title=\"Project Structure\"></a>Project Structure</h2><p>‰ª•‰∏ãÊòØ<a href=\"http://doc.crates.io/guide.html#project-layout\" target=\"_blank\" rel=\"noopener\">CargoÊñáÊ°£ÊèèËø∞</a>‰∏≠Êé®ËçêÁöÑÈ°πÁõÆÂ∏ÉÂ±ÄÔºå</p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code>.\n‚îú‚îÄ‚îÄ Cargo.lock\n‚îú‚îÄ‚îÄ Cargo.toml\n‚îú‚îÄ‚îÄ benches\n‚îÇ   ‚îî‚îÄ‚îÄ large-input.rs\n‚îú‚îÄ‚îÄ examples\n‚îÇ   ‚îî‚îÄ‚îÄ simple.rs\n‚îú‚îÄ‚îÄ src\n‚îÇ   ‚îú‚îÄ‚îÄ bin\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ another_executable.rs\n‚îÇ   ‚îú‚îÄ‚îÄ lib.rs\n‚îÇ   ‚îî‚îÄ‚îÄ main.rs\n‚îî‚îÄ‚îÄ tests\n    ‚îî‚îÄ‚îÄ some-integration-tests.rs\n</code></pre><ul>\n<li>Ê∫ê‰ª£Á†ÅÂ∫îÊîæÂú®<code>src</code>Êñá‰ª∂Â§π‰∏≠„ÄÇ  </li>\n<li>ÈªòËÆ§ÁöÑÂ∫ìÂÖ•Âè£Êñá‰ª∂‰∏∫<code>src/lib.rs</code>„ÄÇ</li>\n<li>ÈªòËÆ§ÁöÑÂèØÊâßË°åÂÖ•Âè£Êñá‰ª∂‰∏∫<code>src/main.rs</code>„ÄÇ  </li>\n<li>ÂÖ∂‰ΩôÁöÑÂèØÊâßË°åÊñá‰ª∂ÂèØ‰ª•ÊîæÂú®<code>src/bin/*.rs</code>‰∏≠„ÄÇ  </li>\n<li>ÈõÜÊàêÊµãËØïÊñá‰ª∂ÂèØ‰ª•ÊîæÂú®<code>tests</code>Êñá‰ª∂Â§π‰∏≠ (ÂçïÂÖÉÊµãËØï‰ºöÊîæÂú®ÊØè‰∏™Êñá‰ª∂Ëá™Ë∫´‰∏≠)„ÄÇ</li>\n<li>Ê†∑‰æãÂ∫îÊîæÂú®<code>examples</code>ÁõÆÂΩï‰∏≠„ÄÇ</li>\n<li>ÂéãÂäõÊµãËØïÂ∫îÊîæÂú®<code>benches</code>Êñá‰ª∂Â§π‰∏≠„ÄÇ</li>\n</ul>\n"},{"title":"‰ª£Á†ÅÊ≥®Èáä‰∏éÊñáÊ°£","_content":"\n## Ê≥®Èáä\n\n```rust\n// ÂçïË°åÊ≥®Èáä\n/* ÂùóÊ≥®Èáä\n```\n\nÂêåÊó∂‰πüÊîØÊåÅÂµåÂ•óÁöÑÂùóÊ≥®Èáä\n\nüí° **ÈÄöÂ∏∏Êù•ËØ¥Ôºå‰ºöÂ∞ΩÈáèÈÅøÂÖç‰ΩøÁî®ÂùóÊ≥®ÈáäÔºåËÄåÈááÁî®Â§ö‰∏™Ë°åÊ≥®Èáä„ÄÇ**\n\n## ÊñáÊ°£Ê≥®Èáä\n\n```rust\n/// Line comments; document the next item\n/** Block comments; document the next item */\n\n//! Line comments; document the enclosing item\n/*! Block comments; document the enclosing item !*/\n```\n\nDoc comments support Markdown notations. Using `cargo doc`, the HTML documentation can be generated from these doc comments. Let‚Äôs see the difference between the two sets of doc comments.\n\n```rust\n/// This module contains tests\nmod test {\n    // ...\n}\n\n\nmod test {\n    //! This module contains tests\n\n    // ...\n}\n```\n\nAs you can see both use to document the same module. The first comment has been added before the module while the second one has been added inside the module.\n\nüí° **Only use //! to write crate and module-level documentation, nothing else. When using `mod` blocks, use /// outside of the block.**\n\n## Doc Attributes\n\nWe can also use **doc attributes** for documenting the code.\n\n> üîé An [attribute](https://doc.rust-lang.org/reference.html#attributes) is a general, free-form **metadatum** that is interpreted according to the name, convention, language and compiler version. Any item declaration may have an attribute applied to it.\n\nHere, for instance, each comment is equivalent to relevant data attributes.\n\n```rust\n/// Foo\n#[doc=\"Foo\"]\n\n//! Foo\n#![doc=\"Foo\"]\n```\n","source":"docs/zh-cn/a5.comments_and_documenting_the_code.md","raw":"title: ‰ª£Á†ÅÊ≥®Èáä‰∏éÊñáÊ°£\n---\n\n## Ê≥®Èáä\n\n```rust\n// ÂçïË°åÊ≥®Èáä\n/* ÂùóÊ≥®Èáä\n```\n\nÂêåÊó∂‰πüÊîØÊåÅÂµåÂ•óÁöÑÂùóÊ≥®Èáä\n\nüí° **ÈÄöÂ∏∏Êù•ËØ¥Ôºå‰ºöÂ∞ΩÈáèÈÅøÂÖç‰ΩøÁî®ÂùóÊ≥®ÈáäÔºåËÄåÈááÁî®Â§ö‰∏™Ë°åÊ≥®Èáä„ÄÇ**\n\n## ÊñáÊ°£Ê≥®Èáä\n\n```rust\n/// Line comments; document the next item\n/** Block comments; document the next item */\n\n//! Line comments; document the enclosing item\n/*! Block comments; document the enclosing item !*/\n```\n\nDoc comments support Markdown notations. Using `cargo doc`, the HTML documentation can be generated from these doc comments. Let‚Äôs see the difference between the two sets of doc comments.\n\n```rust\n/// This module contains tests\nmod test {\n    // ...\n}\n\n\nmod test {\n    //! This module contains tests\n\n    // ...\n}\n```\n\nAs you can see both use to document the same module. The first comment has been added before the module while the second one has been added inside the module.\n\nüí° **Only use //! to write crate and module-level documentation, nothing else. When using `mod` blocks, use /// outside of the block.**\n\n## Doc Attributes\n\nWe can also use **doc attributes** for documenting the code.\n\n> üîé An [attribute](https://doc.rust-lang.org/reference.html#attributes) is a general, free-form **metadatum** that is interpreted according to the name, convention, language and compiler version. Any item declaration may have an attribute applied to it.\n\nHere, for instance, each comment is equivalent to relevant data attributes.\n\n```rust\n/// Foo\n#[doc=\"Foo\"]\n\n//! Foo\n#![doc=\"Foo\"]\n```\n","date":"2019-03-19T14:50:45.775Z","updated":"2019-03-19T14:50:45.775Z","path":"docs/zh-cn/a5.comments_and_documenting_the_code.html","comments":1,"layout":"page","_id":"cjtfwbj0p0014dwgpau34wx3w","content":"<h2 id=\"Ê≥®Èáä\"><a href=\"#Ê≥®Èáä\" class=\"headerlink\" title=\"Ê≥®Èáä\"></a>Ê≥®Èáä</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ÂçïË°åÊ≥®Èáä\n/* ÂùóÊ≥®Èáä\n</code></pre>\n<p>ÂêåÊó∂‰πüÊîØÊåÅÂµåÂ•óÁöÑÂùóÊ≥®Èáä</p>\n<p>üí° <strong>ÈÄöÂ∏∏Êù•ËØ¥Ôºå‰ºöÂ∞ΩÈáèÈÅøÂÖç‰ΩøÁî®ÂùóÊ≥®ÈáäÔºåËÄåÈááÁî®Â§ö‰∏™Ë°åÊ≥®Èáä„ÄÇ</strong></p>\n<h2 id=\"ÊñáÊ°£Ê≥®Èáä\"><a href=\"#ÊñáÊ°£Ê≥®Èáä\" class=\"headerlink\" title=\"ÊñáÊ°£Ê≥®Èáä\"></a>ÊñáÊ°£Ê≥®Èáä</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">/// Line comments; document the next item\n/** Block comments; document the next item */\n\n//! Line comments; document the enclosing item\n/*! Block comments; document the enclosing item !*/\n</code></pre>\n<p>Doc comments support Markdown notations. Using <code>cargo doc</code>, the HTML documentation can be generated from these doc comments. Let‚Äôs see the difference between the two sets of doc comments.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">/// This module contains tests\nmod test {\n    // ...\n}\n\n\nmod test {\n    //! This module contains tests\n\n    // ...\n}\n</code></pre>\n<p>As you can see both use to document the same module. The first comment has been added before the module while the second one has been added inside the module.</p>\n<p>üí° <strong>Only use //! to write crate and module-level documentation, nothing else. When using <code>mod</code> blocks, use /// outside of the block.</strong></p>\n<h2 id=\"Doc-Attributes\"><a href=\"#Doc-Attributes\" class=\"headerlink\" title=\"Doc Attributes\"></a>Doc Attributes</h2><p>We can also use <strong>doc attributes</strong> for documenting the code.</p>\n<blockquote>\n<p>üîé An <a href=\"https://doc.rust-lang.org/reference.html#attributes\" target=\"_blank\" rel=\"noopener\">attribute</a> is a general, free-form <strong>metadatum</strong> that is interpreted according to the name, convention, language and compiler version. Any item declaration may have an attribute applied to it.</p>\n</blockquote>\n<p>Here, for instance, each comment is equivalent to relevant data attributes.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">/// Foo\n#[doc=&quot;Foo&quot;]\n\n//! Foo\n#![doc=&quot;Foo&quot;]\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<h2 id=\"Ê≥®Èáä\"><a href=\"#Ê≥®Èáä\" class=\"headerlink\" title=\"Ê≥®Èáä\"></a>Ê≥®Èáä</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ÂçïË°åÊ≥®Èáä\n/* ÂùóÊ≥®Èáä\n</code></pre>\n<p>ÂêåÊó∂‰πüÊîØÊåÅÂµåÂ•óÁöÑÂùóÊ≥®Èáä</p>\n<p>üí° <strong>ÈÄöÂ∏∏Êù•ËØ¥Ôºå‰ºöÂ∞ΩÈáèÈÅøÂÖç‰ΩøÁî®ÂùóÊ≥®ÈáäÔºåËÄåÈááÁî®Â§ö‰∏™Ë°åÊ≥®Èáä„ÄÇ</strong></p>\n<h2 id=\"ÊñáÊ°£Ê≥®Èáä\"><a href=\"#ÊñáÊ°£Ê≥®Èáä\" class=\"headerlink\" title=\"ÊñáÊ°£Ê≥®Èáä\"></a>ÊñáÊ°£Ê≥®Èáä</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">/// Line comments; document the next item\n/** Block comments; document the next item */\n\n//! Line comments; document the enclosing item\n/*! Block comments; document the enclosing item !*/\n</code></pre>\n<p>Doc comments support Markdown notations. Using <code>cargo doc</code>, the HTML documentation can be generated from these doc comments. Let‚Äôs see the difference between the two sets of doc comments.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">/// This module contains tests\nmod test {\n    // ...\n}\n\n\nmod test {\n    //! This module contains tests\n\n    // ...\n}\n</code></pre>\n<p>As you can see both use to document the same module. The first comment has been added before the module while the second one has been added inside the module.</p>\n<p>üí° <strong>Only use //! to write crate and module-level documentation, nothing else. When using <code>mod</code> blocks, use /// outside of the block.</strong></p>\n<h2 id=\"Doc-Attributes\"><a href=\"#Doc-Attributes\" class=\"headerlink\" title=\"Doc Attributes\"></a>Doc Attributes</h2><p>We can also use <strong>doc attributes</strong> for documenting the code.</p>\n<blockquote>\n<p>üîé An <a href=\"https://doc.rust-lang.org/reference.html#attributes\" target=\"_blank\" rel=\"noopener\">attribute</a> is a general, free-form <strong>metadatum</strong> that is interpreted according to the name, convention, language and compiler version. Any item declaration may have an attribute applied to it.</p>\n</blockquote>\n<p>Here, for instance, each comment is equivalent to relevant data attributes.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">/// Foo\n#[doc=&quot;Foo&quot;]\n\n//! Foo\n#![doc=&quot;Foo&quot;]\n</code></pre>\n"},{"title":"ÂèòÈáèÁªëÂÆöÔºåÂ∏∏Èáè‰∏éÈùôÊÄÅ Variable bindings, Constants & Statics","_content":"\n‚≠êÔ∏è Âú®Rust‰∏≠ÔºåÂèòÈáè**ÈªòËÆ§ÊòØ‰∏çÂèØÂèòÔºàimmutableÔºâÁöÑ**ÔºåÊâÄ‰ª•Áß∞‰πã‰∏∫**ÂèòÈáèÁªëÂÆö**„ÄÇÂ¶ÇÊûúÈúÄË¶Å‰ΩøÂÖ∂ÂÖ∑ÊúâÂèØÂèòÊÄßÔºàmutableÔºâÔºåÂèØ‰ª•‰ΩøÁî®ÂÖ≥ÈîÆÂ≠ó`mut`„ÄÇ\n\n‚≠êÔ∏è RustÊòØ‰∏Ä‰∏™**ÈùôÊÄÅÁ±ªÂûã**ËØ≠Ë®ÄÔºåÂÆÉ‰ºöÂú®ÁºñËØëÊó∂ÔºåÊ£ÄÊü•Êï∞ÊçÆÁöÑÁ±ªÂûã„ÄÇ‰ΩÜÊòØÂÆÉ**‰∏çÂº∫Âà∂‰Ω†Âú®Â£∞ÊòéÂèòÈáèÁªëÂÆöÊó∂‰∏ÄÂÆöË¶ÅËæìÂÖ•Êï∞ÊçÆÁ±ªÂûã**„ÄÇÂú®Êú™ÊòæÂºèÂ£∞ÊòéÁ±ªÂûãÊó∂ÔºåÁºñËØëÂô®Â∞Ü‰ºöÊ£ÄÊü•‰ΩøÁî®ËÄÖÁöÑÁ±ªÂûãÔºåÂπ∂ËÆæÁΩÆ‰∏Ä‰∏™ÈÄÇÂΩìÁöÑÁ±ªÂûãÁªôÂÆÉ„ÄÇ‰ΩÜÊòØ**Â∏∏ÈáèÂíåÈùôÊÄÅÂèòÈáèÂàôÂøÖÈ°ªÊúâÊòæÂºèÁ±ªÂûãÂ£∞Êòé**„ÄÇÁ±ªÂûãÂ£∞ÊòéÂ∫îÂú®ÂèòÈáèÂêçÂä†ÂÜíÂè∑(:)ÂêéÂá∫Áé∞„ÄÇ\n\n* ### ÂèòÈáèÁªëÂÆö\n\n```rust\nlet a = true;\nlet b: bool = true;\n\nlet (x, y) = (1, 2);\n\nlet mut z = 5;\nz = 6;\n```\n\n* ### Â∏∏Èáè\n\n```rust\nconst N: i32 = 5;\n```\n\n* ### ÈùôÊÄÅÂèòÈáè\n\n```rust\nstatic N: i32 = 5;\n```\n\nÂÖ≥ÈîÆÂ≠ó**let**ÂèØ‰ª•Áî®Âú®ÁªëÂÆöË°®ËææÂºè‰∏ä„ÄÇÊàë‰ª¨ÂèØ‰ª•Â∞Ü‰∏Ä‰∏™ÂèòÈáèÂêçÁªëÂÆöÁªôÊüê‰∏™ÂÄºÊàñÊüê‰∏™ÂáΩÊï∞„ÄÇÊ≠§Â§ñÔºåÂõ†‰∏∫letË°®ËææÂºèÁöÑÂ∑¶‰æßÊòØ‰∏Ä‰∏™‚ÄúÊ®°Âºè(pattern)‚ÄùÔºåÊâÄ‰ª•‰Ω†ÂèØ‰ª•Â∞ÜÂ§ö‰∏™ÂèòÈáèÂêçÁªëÂÆöÁªô‰∏ÄÁªÑÂÄºÊàñÂáΩÊï∞ÁöÑÂÄº„ÄÇ\n\nÂÖ≥ÈîÆÂ≠ó**const**Ë¢´Áî®Êù•ÂÆö‰πâÂ∏∏Èáè„ÄÇÂÆÉÂ∞ÜÂú®Êï¥‰∏™Á®ãÂ∫èÁöÑËøêË°åÁîüÂëΩÈáå‰∏ÄÁõ¥Â≠òÂú®‰∫é‰∏Ä‰∏™Âõ∫ÂÆöÁöÑÂÜÖÂ≠òÂú∞ÂùÄ‰∏≠„ÄÇ**static**ÂÖ≥ÈîÆÂ≠óÁî®Êù•ÂÆö‰πâ‰∏Ä‰∏™Ë¢´ËÆ§‰∏∫Êúâ‚ÄúÂÖ®Â±ÄÂèòÈáè‚ÄùÊÑè‰πâÁöÑÁ±ªÂûã„ÄÇÂØπ‰∫éÊØè‰∏™ÂÄºÊù•ËØ¥Ôºå‰ªÖÊúâ‰∏Ä‰∏™ÂÆû‰æãÔºåËÄå‰∏îËØ•ÂÆû‰æã**Âú®ÂÜÖÂ≠ò‰∏äÁöÑÂú∞ÂùÄÂõ∫ÂÆö**„ÄÇ\n\nüí° **Â∞ΩÈáè‰ΩøÁî®Â∏∏Èáè**ÔºåËÄå‰∏çÊòØÈùôÊÄÅÂèòÈáè„ÄÇÂè™ÊúâÂú®ÊûÅÂ∞ëÁöÑÊÉÖÂÜµ‰∏ãÔºå‰Ω†ÈúÄË¶Å‰Ω†ÁöÑ‚ÄúÂ∏∏Èáè‚ÄùÊúâ‰∏Ä‰∏™Âõ∫ÂÆöÁöÑÂÜÖÂ≠òÂú∞ÂùÄ„ÄÇÊ≠§Â§ñÔºåÂ∏∏ÈáèÂú®‰ΩøÁî®‰∏≠‰ºöËøõË°å‰∏Ä‰∫õ‰ºòÂåñÔºåËøô‰∫õ‰ºòÂåñ‰∏ç‰ªÖ‰ºöÂú®‰Ω†ÁöÑcrateÂåÖ‰∏≠ËøõË°åÔºå‰πü‰ºöÊÉ†Âèä‰∏ãÊ∏∏‰ΩøÁî®‰Ω†ÁöÑcrateÂåÖÁöÑÈ°πÁõÆ„ÄÇ\n\nüí° ÈÄöÂ∏∏Êù•ËØ¥ÔºåÈùôÊÄÅÈÉ®ÂàÜÈÄöÂ∏∏ÈÉΩÂú®‰ª£Á†ÅÊñá‰ª∂ÁöÑÊúÄÂâçÈù¢ÔºåÂú®ÂáΩÊï∞‰πãÂ§ñ„ÄÇ\n","source":"docs/zh-cn/a6.variable_bindings,constants_and_statics.md","raw":"title: ÂèòÈáèÁªëÂÆöÔºåÂ∏∏Èáè‰∏éÈùôÊÄÅ Variable bindings, Constants & Statics\n---\n\n‚≠êÔ∏è Âú®Rust‰∏≠ÔºåÂèòÈáè**ÈªòËÆ§ÊòØ‰∏çÂèØÂèòÔºàimmutableÔºâÁöÑ**ÔºåÊâÄ‰ª•Áß∞‰πã‰∏∫**ÂèòÈáèÁªëÂÆö**„ÄÇÂ¶ÇÊûúÈúÄË¶Å‰ΩøÂÖ∂ÂÖ∑ÊúâÂèØÂèòÊÄßÔºàmutableÔºâÔºåÂèØ‰ª•‰ΩøÁî®ÂÖ≥ÈîÆÂ≠ó`mut`„ÄÇ\n\n‚≠êÔ∏è RustÊòØ‰∏Ä‰∏™**ÈùôÊÄÅÁ±ªÂûã**ËØ≠Ë®ÄÔºåÂÆÉ‰ºöÂú®ÁºñËØëÊó∂ÔºåÊ£ÄÊü•Êï∞ÊçÆÁöÑÁ±ªÂûã„ÄÇ‰ΩÜÊòØÂÆÉ**‰∏çÂº∫Âà∂‰Ω†Âú®Â£∞ÊòéÂèòÈáèÁªëÂÆöÊó∂‰∏ÄÂÆöË¶ÅËæìÂÖ•Êï∞ÊçÆÁ±ªÂûã**„ÄÇÂú®Êú™ÊòæÂºèÂ£∞ÊòéÁ±ªÂûãÊó∂ÔºåÁºñËØëÂô®Â∞Ü‰ºöÊ£ÄÊü•‰ΩøÁî®ËÄÖÁöÑÁ±ªÂûãÔºåÂπ∂ËÆæÁΩÆ‰∏Ä‰∏™ÈÄÇÂΩìÁöÑÁ±ªÂûãÁªôÂÆÉ„ÄÇ‰ΩÜÊòØ**Â∏∏ÈáèÂíåÈùôÊÄÅÂèòÈáèÂàôÂøÖÈ°ªÊúâÊòæÂºèÁ±ªÂûãÂ£∞Êòé**„ÄÇÁ±ªÂûãÂ£∞ÊòéÂ∫îÂú®ÂèòÈáèÂêçÂä†ÂÜíÂè∑(:)ÂêéÂá∫Áé∞„ÄÇ\n\n* ### ÂèòÈáèÁªëÂÆö\n\n```rust\nlet a = true;\nlet b: bool = true;\n\nlet (x, y) = (1, 2);\n\nlet mut z = 5;\nz = 6;\n```\n\n* ### Â∏∏Èáè\n\n```rust\nconst N: i32 = 5;\n```\n\n* ### ÈùôÊÄÅÂèòÈáè\n\n```rust\nstatic N: i32 = 5;\n```\n\nÂÖ≥ÈîÆÂ≠ó**let**ÂèØ‰ª•Áî®Âú®ÁªëÂÆöË°®ËææÂºè‰∏ä„ÄÇÊàë‰ª¨ÂèØ‰ª•Â∞Ü‰∏Ä‰∏™ÂèòÈáèÂêçÁªëÂÆöÁªôÊüê‰∏™ÂÄºÊàñÊüê‰∏™ÂáΩÊï∞„ÄÇÊ≠§Â§ñÔºåÂõ†‰∏∫letË°®ËææÂºèÁöÑÂ∑¶‰æßÊòØ‰∏Ä‰∏™‚ÄúÊ®°Âºè(pattern)‚ÄùÔºåÊâÄ‰ª•‰Ω†ÂèØ‰ª•Â∞ÜÂ§ö‰∏™ÂèòÈáèÂêçÁªëÂÆöÁªô‰∏ÄÁªÑÂÄºÊàñÂáΩÊï∞ÁöÑÂÄº„ÄÇ\n\nÂÖ≥ÈîÆÂ≠ó**const**Ë¢´Áî®Êù•ÂÆö‰πâÂ∏∏Èáè„ÄÇÂÆÉÂ∞ÜÂú®Êï¥‰∏™Á®ãÂ∫èÁöÑËøêË°åÁîüÂëΩÈáå‰∏ÄÁõ¥Â≠òÂú®‰∫é‰∏Ä‰∏™Âõ∫ÂÆöÁöÑÂÜÖÂ≠òÂú∞ÂùÄ‰∏≠„ÄÇ**static**ÂÖ≥ÈîÆÂ≠óÁî®Êù•ÂÆö‰πâ‰∏Ä‰∏™Ë¢´ËÆ§‰∏∫Êúâ‚ÄúÂÖ®Â±ÄÂèòÈáè‚ÄùÊÑè‰πâÁöÑÁ±ªÂûã„ÄÇÂØπ‰∫éÊØè‰∏™ÂÄºÊù•ËØ¥Ôºå‰ªÖÊúâ‰∏Ä‰∏™ÂÆû‰æãÔºåËÄå‰∏îËØ•ÂÆû‰æã**Âú®ÂÜÖÂ≠ò‰∏äÁöÑÂú∞ÂùÄÂõ∫ÂÆö**„ÄÇ\n\nüí° **Â∞ΩÈáè‰ΩøÁî®Â∏∏Èáè**ÔºåËÄå‰∏çÊòØÈùôÊÄÅÂèòÈáè„ÄÇÂè™ÊúâÂú®ÊûÅÂ∞ëÁöÑÊÉÖÂÜµ‰∏ãÔºå‰Ω†ÈúÄË¶Å‰Ω†ÁöÑ‚ÄúÂ∏∏Èáè‚ÄùÊúâ‰∏Ä‰∏™Âõ∫ÂÆöÁöÑÂÜÖÂ≠òÂú∞ÂùÄ„ÄÇÊ≠§Â§ñÔºåÂ∏∏ÈáèÂú®‰ΩøÁî®‰∏≠‰ºöËøõË°å‰∏Ä‰∫õ‰ºòÂåñÔºåËøô‰∫õ‰ºòÂåñ‰∏ç‰ªÖ‰ºöÂú®‰Ω†ÁöÑcrateÂåÖ‰∏≠ËøõË°åÔºå‰πü‰ºöÊÉ†Âèä‰∏ãÊ∏∏‰ΩøÁî®‰Ω†ÁöÑcrateÂåÖÁöÑÈ°πÁõÆ„ÄÇ\n\nüí° ÈÄöÂ∏∏Êù•ËØ¥ÔºåÈùôÊÄÅÈÉ®ÂàÜÈÄöÂ∏∏ÈÉΩÂú®‰ª£Á†ÅÊñá‰ª∂ÁöÑÊúÄÂâçÈù¢ÔºåÂú®ÂáΩÊï∞‰πãÂ§ñ„ÄÇ\n","date":"2019-03-19T15:02:29.771Z","updated":"2019-03-19T15:02:29.771Z","path":"docs/zh-cn/a6.variable_bindings,constants_and_statics.html","_id":"cjtfwbj0p0015dwgpz58n4je6","comments":1,"layout":"page","content":"<p>‚≠êÔ∏è Âú®Rust‰∏≠ÔºåÂèòÈáè<strong>ÈªòËÆ§ÊòØ‰∏çÂèØÂèòÔºàimmutableÔºâÁöÑ</strong>ÔºåÊâÄ‰ª•Áß∞‰πã‰∏∫<strong>ÂèòÈáèÁªëÂÆö</strong>„ÄÇÂ¶ÇÊûúÈúÄË¶Å‰ΩøÂÖ∂ÂÖ∑ÊúâÂèØÂèòÊÄßÔºàmutableÔºâÔºåÂèØ‰ª•‰ΩøÁî®ÂÖ≥ÈîÆÂ≠ó<code>mut</code>„ÄÇ</p>\n<p>‚≠êÔ∏è RustÊòØ‰∏Ä‰∏™<strong>ÈùôÊÄÅÁ±ªÂûã</strong>ËØ≠Ë®ÄÔºåÂÆÉ‰ºöÂú®ÁºñËØëÊó∂ÔºåÊ£ÄÊü•Êï∞ÊçÆÁöÑÁ±ªÂûã„ÄÇ‰ΩÜÊòØÂÆÉ<strong>‰∏çÂº∫Âà∂‰Ω†Âú®Â£∞ÊòéÂèòÈáèÁªëÂÆöÊó∂‰∏ÄÂÆöË¶ÅËæìÂÖ•Êï∞ÊçÆÁ±ªÂûã</strong>„ÄÇÂú®Êú™ÊòæÂºèÂ£∞ÊòéÁ±ªÂûãÊó∂ÔºåÁºñËØëÂô®Â∞Ü‰ºöÊ£ÄÊü•‰ΩøÁî®ËÄÖÁöÑÁ±ªÂûãÔºåÂπ∂ËÆæÁΩÆ‰∏Ä‰∏™ÈÄÇÂΩìÁöÑÁ±ªÂûãÁªôÂÆÉ„ÄÇ‰ΩÜÊòØ<strong>Â∏∏ÈáèÂíåÈùôÊÄÅÂèòÈáèÂàôÂøÖÈ°ªÊúâÊòæÂºèÁ±ªÂûãÂ£∞Êòé</strong>„ÄÇÁ±ªÂûãÂ£∞ÊòéÂ∫îÂú®ÂèòÈáèÂêçÂä†ÂÜíÂè∑(:)ÂêéÂá∫Áé∞„ÄÇ</p>\n<ul>\n<li><h3 id=\"ÂèòÈáèÁªëÂÆö\"><a href=\"#ÂèòÈáèÁªëÂÆö\" class=\"headerlink\" title=\"ÂèòÈáèÁªëÂÆö\"></a>ÂèòÈáèÁªëÂÆö</h3></li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = true;\nlet b: bool = true;\n\nlet (x, y) = (1, 2);\n\nlet mut z = 5;\nz = 6;\n</code></pre>\n<ul>\n<li><h3 id=\"Â∏∏Èáè\"><a href=\"#Â∏∏Èáè\" class=\"headerlink\" title=\"Â∏∏Èáè\"></a>Â∏∏Èáè</h3></li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">const N: i32 = 5;\n</code></pre>\n<ul>\n<li><h3 id=\"ÈùôÊÄÅÂèòÈáè\"><a href=\"#ÈùôÊÄÅÂèòÈáè\" class=\"headerlink\" title=\"ÈùôÊÄÅÂèòÈáè\"></a>ÈùôÊÄÅÂèòÈáè</h3></li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">static N: i32 = 5;\n</code></pre>\n<p>ÂÖ≥ÈîÆÂ≠ó<strong>let</strong>ÂèØ‰ª•Áî®Âú®ÁªëÂÆöË°®ËææÂºè‰∏ä„ÄÇÊàë‰ª¨ÂèØ‰ª•Â∞Ü‰∏Ä‰∏™ÂèòÈáèÂêçÁªëÂÆöÁªôÊüê‰∏™ÂÄºÊàñÊüê‰∏™ÂáΩÊï∞„ÄÇÊ≠§Â§ñÔºåÂõ†‰∏∫letË°®ËææÂºèÁöÑÂ∑¶‰æßÊòØ‰∏Ä‰∏™‚ÄúÊ®°Âºè(pattern)‚ÄùÔºåÊâÄ‰ª•‰Ω†ÂèØ‰ª•Â∞ÜÂ§ö‰∏™ÂèòÈáèÂêçÁªëÂÆöÁªô‰∏ÄÁªÑÂÄºÊàñÂáΩÊï∞ÁöÑÂÄº„ÄÇ</p>\n<p>ÂÖ≥ÈîÆÂ≠ó<strong>const</strong>Ë¢´Áî®Êù•ÂÆö‰πâÂ∏∏Èáè„ÄÇÂÆÉÂ∞ÜÂú®Êï¥‰∏™Á®ãÂ∫èÁöÑËøêË°åÁîüÂëΩÈáå‰∏ÄÁõ¥Â≠òÂú®‰∫é‰∏Ä‰∏™Âõ∫ÂÆöÁöÑÂÜÖÂ≠òÂú∞ÂùÄ‰∏≠„ÄÇ<strong>static</strong>ÂÖ≥ÈîÆÂ≠óÁî®Êù•ÂÆö‰πâ‰∏Ä‰∏™Ë¢´ËÆ§‰∏∫Êúâ‚ÄúÂÖ®Â±ÄÂèòÈáè‚ÄùÊÑè‰πâÁöÑÁ±ªÂûã„ÄÇÂØπ‰∫éÊØè‰∏™ÂÄºÊù•ËØ¥Ôºå‰ªÖÊúâ‰∏Ä‰∏™ÂÆû‰æãÔºåËÄå‰∏îËØ•ÂÆû‰æã<strong>Âú®ÂÜÖÂ≠ò‰∏äÁöÑÂú∞ÂùÄÂõ∫ÂÆö</strong>„ÄÇ</p>\n<p>üí° <strong>Â∞ΩÈáè‰ΩøÁî®Â∏∏Èáè</strong>ÔºåËÄå‰∏çÊòØÈùôÊÄÅÂèòÈáè„ÄÇÂè™ÊúâÂú®ÊûÅÂ∞ëÁöÑÊÉÖÂÜµ‰∏ãÔºå‰Ω†ÈúÄË¶Å‰Ω†ÁöÑ‚ÄúÂ∏∏Èáè‚ÄùÊúâ‰∏Ä‰∏™Âõ∫ÂÆöÁöÑÂÜÖÂ≠òÂú∞ÂùÄ„ÄÇÊ≠§Â§ñÔºåÂ∏∏ÈáèÂú®‰ΩøÁî®‰∏≠‰ºöËøõË°å‰∏Ä‰∫õ‰ºòÂåñÔºåËøô‰∫õ‰ºòÂåñ‰∏ç‰ªÖ‰ºöÂú®‰Ω†ÁöÑcrateÂåÖ‰∏≠ËøõË°åÔºå‰πü‰ºöÊÉ†Âèä‰∏ãÊ∏∏‰ΩøÁî®‰Ω†ÁöÑcrateÂåÖÁöÑÈ°πÁõÆ„ÄÇ</p>\n<p>üí° ÈÄöÂ∏∏Êù•ËØ¥ÔºåÈùôÊÄÅÈÉ®ÂàÜÈÄöÂ∏∏ÈÉΩÂú®‰ª£Á†ÅÊñá‰ª∂ÁöÑÊúÄÂâçÈù¢ÔºåÂú®ÂáΩÊï∞‰πãÂ§ñ„ÄÇ</p>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<p>‚≠êÔ∏è Âú®Rust‰∏≠ÔºåÂèòÈáè<strong>ÈªòËÆ§ÊòØ‰∏çÂèØÂèòÔºàimmutableÔºâÁöÑ</strong>ÔºåÊâÄ‰ª•Áß∞‰πã‰∏∫<strong>ÂèòÈáèÁªëÂÆö</strong>„ÄÇÂ¶ÇÊûúÈúÄË¶Å‰ΩøÂÖ∂ÂÖ∑ÊúâÂèØÂèòÊÄßÔºàmutableÔºâÔºåÂèØ‰ª•‰ΩøÁî®ÂÖ≥ÈîÆÂ≠ó<code>mut</code>„ÄÇ</p>\n<p>‚≠êÔ∏è RustÊòØ‰∏Ä‰∏™<strong>ÈùôÊÄÅÁ±ªÂûã</strong>ËØ≠Ë®ÄÔºåÂÆÉ‰ºöÂú®ÁºñËØëÊó∂ÔºåÊ£ÄÊü•Êï∞ÊçÆÁöÑÁ±ªÂûã„ÄÇ‰ΩÜÊòØÂÆÉ<strong>‰∏çÂº∫Âà∂‰Ω†Âú®Â£∞ÊòéÂèòÈáèÁªëÂÆöÊó∂‰∏ÄÂÆöË¶ÅËæìÂÖ•Êï∞ÊçÆÁ±ªÂûã</strong>„ÄÇÂú®Êú™ÊòæÂºèÂ£∞ÊòéÁ±ªÂûãÊó∂ÔºåÁºñËØëÂô®Â∞Ü‰ºöÊ£ÄÊü•‰ΩøÁî®ËÄÖÁöÑÁ±ªÂûãÔºåÂπ∂ËÆæÁΩÆ‰∏Ä‰∏™ÈÄÇÂΩìÁöÑÁ±ªÂûãÁªôÂÆÉ„ÄÇ‰ΩÜÊòØ<strong>Â∏∏ÈáèÂíåÈùôÊÄÅÂèòÈáèÂàôÂøÖÈ°ªÊúâÊòæÂºèÁ±ªÂûãÂ£∞Êòé</strong>„ÄÇÁ±ªÂûãÂ£∞ÊòéÂ∫îÂú®ÂèòÈáèÂêçÂä†ÂÜíÂè∑(:)ÂêéÂá∫Áé∞„ÄÇ</p>\n<ul>\n<li><h3 id=\"ÂèòÈáèÁªëÂÆö\"><a href=\"#ÂèòÈáèÁªëÂÆö\" class=\"headerlink\" title=\"ÂèòÈáèÁªëÂÆö\"></a>ÂèòÈáèÁªëÂÆö</h3></li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = true;\nlet b: bool = true;\n\nlet (x, y) = (1, 2);\n\nlet mut z = 5;\nz = 6;\n</code></pre>\n<ul>\n<li><h3 id=\"Â∏∏Èáè\"><a href=\"#Â∏∏Èáè\" class=\"headerlink\" title=\"Â∏∏Èáè\"></a>Â∏∏Èáè</h3></li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">const N: i32 = 5;\n</code></pre>\n<ul>\n<li><h3 id=\"ÈùôÊÄÅÂèòÈáè\"><a href=\"#ÈùôÊÄÅÂèòÈáè\" class=\"headerlink\" title=\"ÈùôÊÄÅÂèòÈáè\"></a>ÈùôÊÄÅÂèòÈáè</h3></li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">static N: i32 = 5;\n</code></pre>\n<p>ÂÖ≥ÈîÆÂ≠ó<strong>let</strong>ÂèØ‰ª•Áî®Âú®ÁªëÂÆöË°®ËææÂºè‰∏ä„ÄÇÊàë‰ª¨ÂèØ‰ª•Â∞Ü‰∏Ä‰∏™ÂèòÈáèÂêçÁªëÂÆöÁªôÊüê‰∏™ÂÄºÊàñÊüê‰∏™ÂáΩÊï∞„ÄÇÊ≠§Â§ñÔºåÂõ†‰∏∫letË°®ËææÂºèÁöÑÂ∑¶‰æßÊòØ‰∏Ä‰∏™‚ÄúÊ®°Âºè(pattern)‚ÄùÔºåÊâÄ‰ª•‰Ω†ÂèØ‰ª•Â∞ÜÂ§ö‰∏™ÂèòÈáèÂêçÁªëÂÆöÁªô‰∏ÄÁªÑÂÄºÊàñÂáΩÊï∞ÁöÑÂÄº„ÄÇ</p>\n<p>ÂÖ≥ÈîÆÂ≠ó<strong>const</strong>Ë¢´Áî®Êù•ÂÆö‰πâÂ∏∏Èáè„ÄÇÂÆÉÂ∞ÜÂú®Êï¥‰∏™Á®ãÂ∫èÁöÑËøêË°åÁîüÂëΩÈáå‰∏ÄÁõ¥Â≠òÂú®‰∫é‰∏Ä‰∏™Âõ∫ÂÆöÁöÑÂÜÖÂ≠òÂú∞ÂùÄ‰∏≠„ÄÇ<strong>static</strong>ÂÖ≥ÈîÆÂ≠óÁî®Êù•ÂÆö‰πâ‰∏Ä‰∏™Ë¢´ËÆ§‰∏∫Êúâ‚ÄúÂÖ®Â±ÄÂèòÈáè‚ÄùÊÑè‰πâÁöÑÁ±ªÂûã„ÄÇÂØπ‰∫éÊØè‰∏™ÂÄºÊù•ËØ¥Ôºå‰ªÖÊúâ‰∏Ä‰∏™ÂÆû‰æãÔºåËÄå‰∏îËØ•ÂÆû‰æã<strong>Âú®ÂÜÖÂ≠ò‰∏äÁöÑÂú∞ÂùÄÂõ∫ÂÆö</strong>„ÄÇ</p>\n<p>üí° <strong>Â∞ΩÈáè‰ΩøÁî®Â∏∏Èáè</strong>ÔºåËÄå‰∏çÊòØÈùôÊÄÅÂèòÈáè„ÄÇÂè™ÊúâÂú®ÊûÅÂ∞ëÁöÑÊÉÖÂÜµ‰∏ãÔºå‰Ω†ÈúÄË¶Å‰Ω†ÁöÑ‚ÄúÂ∏∏Èáè‚ÄùÊúâ‰∏Ä‰∏™Âõ∫ÂÆöÁöÑÂÜÖÂ≠òÂú∞ÂùÄ„ÄÇÊ≠§Â§ñÔºåÂ∏∏ÈáèÂú®‰ΩøÁî®‰∏≠‰ºöËøõË°å‰∏Ä‰∫õ‰ºòÂåñÔºåËøô‰∫õ‰ºòÂåñ‰∏ç‰ªÖ‰ºöÂú®‰Ω†ÁöÑcrateÂåÖ‰∏≠ËøõË°åÔºå‰πü‰ºöÊÉ†Âèä‰∏ãÊ∏∏‰ΩøÁî®‰Ω†ÁöÑcrateÂåÖÁöÑÈ°πÁõÆ„ÄÇ</p>\n<p>üí° ÈÄöÂ∏∏Êù•ËØ¥ÔºåÈùôÊÄÅÈÉ®ÂàÜÈÄöÂ∏∏ÈÉΩÂú®‰ª£Á†ÅÊñá‰ª∂ÁöÑÊúÄÂâçÈù¢ÔºåÂú®ÂáΩÊï∞‰πãÂ§ñ„ÄÇ</p>\n"},{"title":"ÂáΩÊï∞ - Functions","_content":"\n* ÂáΩÊï∞‰ª• `fn` ÂÖ≥ÈîÆÂ≠óÊ†áËÆ∞Â£∞Êòé„ÄÇ\n* ÂΩì‰ΩøÁî® **ÂèÇÊï∞**Êó∂Ôºå‰Ω† **ÂøÖÈ°ªÂ£∞ÊòéÊï∞ÊçÆÁ±ªÂûã**„ÄÇ\n* ÈªòËÆ§ÊÉÖÂÜµ‰∏ãÔºåÂáΩÊï∞‰ºö **ËøîÂõû‰∏Ä‰∏™Á©∫ÂÖÉÁªÑ()**„ÄÇ Â¶ÇÊûú‰Ω†ÈúÄË¶ÅËøîÂõû‰∏Ä‰∏™ÂÄºÔºå**ËøîÂõûÂÄºÁ±ªÂûãÈúÄË¶ÅÂú®Ë∑üÂú®‚Äò->‚ÄôÁ¨¶Âè∑ÂêéÊåáÂÆö**\n\n### Á¨¨‰∏Ä‰∏™ÂáΩÊï∞ - Hello world\n\n```rust\nfn main() {\n    println!(\"Hello, world!\");\n}\n```\n\n### ‰º†ÂèÇ\n\n```rust\nfn print_sum(a: i8, b: i8) {\n    println!(\"sum is: {}\", a + b);\n}\n```\n\n### ‰ΩøÁî®ËøîÂõûÂÄº\n\n```rust\nfn plus_one(a: i32) -> i32 {\n    a + 1 // ‰∏çË¶ÅË∑üÈöèÂàÜÂè∑;, Ë°®Á§∫ËØ•Ë°å‰∏∫‰∏Ä‰∏™Ë°®ËææÂºèÔºåÂπ∂ËøîÂõû a+1 ÁöÑÂÄº\n}\n\nfn plus_two(a: i32) -> i32 {\n    return a + 2; // ‰πüÂèØ‰ª•‰ΩøÁî®ËøîÂõûËØ≠Âè• return a+2; ‰ΩÜËøô‰∏çÊòØ‰∏Ä‰∏™Â•ΩÁöÑÂÆûË∑µ\n    // ‰ªÖÂú®Êù°‰ª∂ÊÄßËøîÂõûÊó∂‰ΩøÁî®returnËØ≠Âè•ÔºåÂú®ÊúÄÁªàË°®ËææÂºè‰∏≠Âàô‰∏çÈúÄË¶Å‰ΩøÁî®„ÄÇ\n}\n\n// ‚≠êÔ∏è ÂáΩÊï∞ÊåáÈíàÔºåÂèØ‰ª•‰Ωú‰∏∫‰∏ÄÁßçÊï∞ÊçÆÁ±ªÂûãË¢´‰º†ÈÄíÂíå‰ΩøÁî®\nlet b = plus_one;\nlet c = b(5); //6\n\nlet b: fn(i32) -> i32 = plus_one; // Âêå‰∏äÔºåÂåÖÂê´ÁùÄÁ±ªÂûãËØ¥Êòé\nlet c = b(5); //6\n```\n","source":"docs/zh-cn/a7.functions.md","raw":"title: ÂáΩÊï∞ - Functions\n---\n\n* ÂáΩÊï∞‰ª• `fn` ÂÖ≥ÈîÆÂ≠óÊ†áËÆ∞Â£∞Êòé„ÄÇ\n* ÂΩì‰ΩøÁî® **ÂèÇÊï∞**Êó∂Ôºå‰Ω† **ÂøÖÈ°ªÂ£∞ÊòéÊï∞ÊçÆÁ±ªÂûã**„ÄÇ\n* ÈªòËÆ§ÊÉÖÂÜµ‰∏ãÔºåÂáΩÊï∞‰ºö **ËøîÂõû‰∏Ä‰∏™Á©∫ÂÖÉÁªÑ()**„ÄÇ Â¶ÇÊûú‰Ω†ÈúÄË¶ÅËøîÂõû‰∏Ä‰∏™ÂÄºÔºå**ËøîÂõûÂÄºÁ±ªÂûãÈúÄË¶ÅÂú®Ë∑üÂú®‚Äò->‚ÄôÁ¨¶Âè∑ÂêéÊåáÂÆö**\n\n### Á¨¨‰∏Ä‰∏™ÂáΩÊï∞ - Hello world\n\n```rust\nfn main() {\n    println!(\"Hello, world!\");\n}\n```\n\n### ‰º†ÂèÇ\n\n```rust\nfn print_sum(a: i8, b: i8) {\n    println!(\"sum is: {}\", a + b);\n}\n```\n\n### ‰ΩøÁî®ËøîÂõûÂÄº\n\n```rust\nfn plus_one(a: i32) -> i32 {\n    a + 1 // ‰∏çË¶ÅË∑üÈöèÂàÜÂè∑;, Ë°®Á§∫ËØ•Ë°å‰∏∫‰∏Ä‰∏™Ë°®ËææÂºèÔºåÂπ∂ËøîÂõû a+1 ÁöÑÂÄº\n}\n\nfn plus_two(a: i32) -> i32 {\n    return a + 2; // ‰πüÂèØ‰ª•‰ΩøÁî®ËøîÂõûËØ≠Âè• return a+2; ‰ΩÜËøô‰∏çÊòØ‰∏Ä‰∏™Â•ΩÁöÑÂÆûË∑µ\n    // ‰ªÖÂú®Êù°‰ª∂ÊÄßËøîÂõûÊó∂‰ΩøÁî®returnËØ≠Âè•ÔºåÂú®ÊúÄÁªàË°®ËææÂºè‰∏≠Âàô‰∏çÈúÄË¶Å‰ΩøÁî®„ÄÇ\n}\n\n// ‚≠êÔ∏è ÂáΩÊï∞ÊåáÈíàÔºåÂèØ‰ª•‰Ωú‰∏∫‰∏ÄÁßçÊï∞ÊçÆÁ±ªÂûãË¢´‰º†ÈÄíÂíå‰ΩøÁî®\nlet b = plus_one;\nlet c = b(5); //6\n\nlet b: fn(i32) -> i32 = plus_one; // Âêå‰∏äÔºåÂåÖÂê´ÁùÄÁ±ªÂûãËØ¥Êòé\nlet c = b(5); //6\n```\n","date":"2019-03-19T15:14:43.968Z","updated":"2019-03-19T15:14:43.968Z","path":"docs/zh-cn/a7.functions.html","_id":"cjtfwbj0r0016dwgpvoesav9t","comments":1,"layout":"page","content":"<ul>\n<li>ÂáΩÊï∞‰ª• <code>fn</code> ÂÖ≥ÈîÆÂ≠óÊ†áËÆ∞Â£∞Êòé„ÄÇ</li>\n<li>ÂΩì‰ΩøÁî® <strong>ÂèÇÊï∞</strong>Êó∂Ôºå‰Ω† <strong>ÂøÖÈ°ªÂ£∞ÊòéÊï∞ÊçÆÁ±ªÂûã</strong>„ÄÇ</li>\n<li>ÈªòËÆ§ÊÉÖÂÜµ‰∏ãÔºåÂáΩÊï∞‰ºö <strong>ËøîÂõû‰∏Ä‰∏™Á©∫ÂÖÉÁªÑ()</strong>„ÄÇ Â¶ÇÊûú‰Ω†ÈúÄË¶ÅËøîÂõû‰∏Ä‰∏™ÂÄºÔºå<strong>ËøîÂõûÂÄºÁ±ªÂûãÈúÄË¶ÅÂú®Ë∑üÂú®‚Äò-&gt;‚ÄôÁ¨¶Âè∑ÂêéÊåáÂÆö</strong></li>\n</ul>\n<h3 id=\"Á¨¨‰∏Ä‰∏™ÂáΩÊï∞-Hello-world\"><a href=\"#Á¨¨‰∏Ä‰∏™ÂáΩÊï∞-Hello-world\" class=\"headerlink\" title=\"Á¨¨‰∏Ä‰∏™ÂáΩÊï∞ - Hello world\"></a>Á¨¨‰∏Ä‰∏™ÂáΩÊï∞ - Hello world</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<h3 id=\"‰º†ÂèÇ\"><a href=\"#‰º†ÂèÇ\" class=\"headerlink\" title=\"‰º†ÂèÇ\"></a>‰º†ÂèÇ</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn print_sum(a: i8, b: i8) {\n    println!(&quot;sum is: {}&quot;, a + b);\n}\n</code></pre>\n<h3 id=\"‰ΩøÁî®ËøîÂõûÂÄº\"><a href=\"#‰ΩøÁî®ËøîÂõûÂÄº\" class=\"headerlink\" title=\"‰ΩøÁî®ËøîÂõûÂÄº\"></a>‰ΩøÁî®ËøîÂõûÂÄº</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn plus_one(a: i32) -&gt; i32 {\n    a + 1 // ‰∏çË¶ÅË∑üÈöèÂàÜÂè∑;, Ë°®Á§∫ËØ•Ë°å‰∏∫‰∏Ä‰∏™Ë°®ËææÂºèÔºåÂπ∂ËøîÂõû a+1 ÁöÑÂÄº\n}\n\nfn plus_two(a: i32) -&gt; i32 {\n    return a + 2; // ‰πüÂèØ‰ª•‰ΩøÁî®ËøîÂõûËØ≠Âè• return a+2; ‰ΩÜËøô‰∏çÊòØ‰∏Ä‰∏™Â•ΩÁöÑÂÆûË∑µ\n    // ‰ªÖÂú®Êù°‰ª∂ÊÄßËøîÂõûÊó∂‰ΩøÁî®returnËØ≠Âè•ÔºåÂú®ÊúÄÁªàË°®ËææÂºè‰∏≠Âàô‰∏çÈúÄË¶Å‰ΩøÁî®„ÄÇ\n}\n\n// ‚≠êÔ∏è ÂáΩÊï∞ÊåáÈíàÔºåÂèØ‰ª•‰Ωú‰∏∫‰∏ÄÁßçÊï∞ÊçÆÁ±ªÂûãË¢´‰º†ÈÄíÂíå‰ΩøÁî®\nlet b = plus_one;\nlet c = b(5); //6\n\nlet b: fn(i32) -&gt; i32 = plus_one; // Âêå‰∏äÔºåÂåÖÂê´ÁùÄÁ±ªÂûãËØ¥Êòé\nlet c = b(5); //6\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<ul>\n<li>ÂáΩÊï∞‰ª• <code>fn</code> ÂÖ≥ÈîÆÂ≠óÊ†áËÆ∞Â£∞Êòé„ÄÇ</li>\n<li>ÂΩì‰ΩøÁî® <strong>ÂèÇÊï∞</strong>Êó∂Ôºå‰Ω† <strong>ÂøÖÈ°ªÂ£∞ÊòéÊï∞ÊçÆÁ±ªÂûã</strong>„ÄÇ</li>\n<li>ÈªòËÆ§ÊÉÖÂÜµ‰∏ãÔºåÂáΩÊï∞‰ºö <strong>ËøîÂõû‰∏Ä‰∏™Á©∫ÂÖÉÁªÑ()</strong>„ÄÇ Â¶ÇÊûú‰Ω†ÈúÄË¶ÅËøîÂõû‰∏Ä‰∏™ÂÄºÔºå<strong>ËøîÂõûÂÄºÁ±ªÂûãÈúÄË¶ÅÂú®Ë∑üÂú®‚Äò-&gt;‚ÄôÁ¨¶Âè∑ÂêéÊåáÂÆö</strong></li>\n</ul>\n<h3 id=\"Á¨¨‰∏Ä‰∏™ÂáΩÊï∞-Hello-world\"><a href=\"#Á¨¨‰∏Ä‰∏™ÂáΩÊï∞-Hello-world\" class=\"headerlink\" title=\"Á¨¨‰∏Ä‰∏™ÂáΩÊï∞ - Hello world\"></a>Á¨¨‰∏Ä‰∏™ÂáΩÊï∞ - Hello world</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<h3 id=\"‰º†ÂèÇ\"><a href=\"#‰º†ÂèÇ\" class=\"headerlink\" title=\"‰º†ÂèÇ\"></a>‰º†ÂèÇ</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn print_sum(a: i8, b: i8) {\n    println!(&quot;sum is: {}&quot;, a + b);\n}\n</code></pre>\n<h3 id=\"‰ΩøÁî®ËøîÂõûÂÄº\"><a href=\"#‰ΩøÁî®ËøîÂõûÂÄº\" class=\"headerlink\" title=\"‰ΩøÁî®ËøîÂõûÂÄº\"></a>‰ΩøÁî®ËøîÂõûÂÄº</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn plus_one(a: i32) -&gt; i32 {\n    a + 1 // ‰∏çË¶ÅË∑üÈöèÂàÜÂè∑;, Ë°®Á§∫ËØ•Ë°å‰∏∫‰∏Ä‰∏™Ë°®ËææÂºèÔºåÂπ∂ËøîÂõû a+1 ÁöÑÂÄº\n}\n\nfn plus_two(a: i32) -&gt; i32 {\n    return a + 2; // ‰πüÂèØ‰ª•‰ΩøÁî®ËøîÂõûËØ≠Âè• return a+2; ‰ΩÜËøô‰∏çÊòØ‰∏Ä‰∏™Â•ΩÁöÑÂÆûË∑µ\n    // ‰ªÖÂú®Êù°‰ª∂ÊÄßËøîÂõûÊó∂‰ΩøÁî®returnËØ≠Âè•ÔºåÂú®ÊúÄÁªàË°®ËææÂºè‰∏≠Âàô‰∏çÈúÄË¶Å‰ΩøÁî®„ÄÇ\n}\n\n// ‚≠êÔ∏è ÂáΩÊï∞ÊåáÈíàÔºåÂèØ‰ª•‰Ωú‰∏∫‰∏ÄÁßçÊï∞ÊçÆÁ±ªÂûãË¢´‰º†ÈÄíÂíå‰ΩøÁî®\nlet b = plus_one;\nlet c = b(5); //6\n\nlet b: fn(i32) -&gt; i32 = plus_one; // Âêå‰∏äÔºåÂåÖÂê´ÁùÄÁ±ªÂûãËØ¥Êòé\nlet c = b(5); //6\n</code></pre>\n"},{"title":"Âü∫Á°ÄÊï∞ÊçÆÁ±ªÂûã - Primitive Data Types","_content":"\n- ## bool\ntrue or false\n\n```rust\nlet x = true;\nlet y: bool = false;\n\n// ‚≠êÔ∏è rustÊòØÂº∫Á±ªÂûãËØ≠Ë®ÄÔºåboolÁ±ªÂûã‰∏çÂèØ‰ª•‰ΩøÁî® TRUE, FALSE Êàñ 1, 0 Êù•Êõø‰ª£\n```\n\n\n- ## char\n‰∏Ä‰∏™Áã¨Á´ãÁöÑUnicodeÊ†áÈáè\n\n```rust\nlet x = 'x';\nlet y = 'üòé';\n\n// ‚≠êÔ∏è ‰∏çÊòØ \"x\"Ôºå‰ΩøÁî®ÂçïÂºïÂè∑ÂåÖË£π\n// Âá∫‰∫éÂØπUnicodeÁöÑÊîØÊåÅÔºåcharÂπ∂‰∏çÊòØÂçïÂ≠óËäÇÊï∞ÊçÆÁ±ªÂûãÔºåÊØè‰∏™char‰ºöÂç†Áî®4‰∏™Â≠óËäÇ\n```\n\n\n- ## i8, i16, i32, i64, i128\nÂõ∫ÂÆöÂ∞∫ÂØ∏Ôºàbit‰ΩçÊï∞ÔºâÊúâÁ¨¶Âè∑ÁöÑÊï¥Êï∞Á±ªÂûã(+/-)\n\n| DATA TYPE | MIN                                      | MAX                                     |\n| --------- | ---------------------------------------- | --------------------------------------- |\n| i8        | -128                                     | 127                                     |\n| i16       | -32768                                   | 32767                                   |\n| i32       | -2147483648                              | 2147483647                              |\n| i64       | -9223372036854775808                     | 9223372036854775807                     |\n| i128      | -170141183460469231731687303715884105728 | 170141183460469231731687303715884105727 |\n\nüí° ÊØè‰∏ÄÁ±ªÂûãÁöÑÊúÄÂ§ßÂíåÊúÄÂ∞èÂÄºÔºåÂèñÂÄºËåÉÂõ¥‰∏∫ **-2‚Åø‚Åª¬π Âà∞ 2‚Åø‚Åª¬π-1**„ÄÇ‰Ω†ÂèØ‰ª•‰ΩøÁî® **min_value()** Âíå **max_value()** ÊñπÊ≥ïÊù•Ëé∑ÂèñÊØè‰∏™Êï¥ÂûãÁöÑÊúÄÂ∞è‰∏éÊúÄÂ§ßÂÄºÔºåÂ¶ÇÔºöi8::min_value();\n\n\n- ## u8, u16, u32, u64, u128\nÂõ∫ÂÆöÂ∞∫ÂØ∏Ôºàbit‰ΩçÊï∞ÔºâÊó†Á¨¶Âè∑ÈùûË¥üÊï¥Âûã\n\n| Êï∞ÊçÆÁ±ªÂûã   | ÊúÄÂ∞èÂÄº | ÊúÄÂ§ßÂÄº                                 |\n| --------- | --- | --------------------------------------- |\n| u8        | 0   | 255                                     |\n| u16       | 0   | 65535                                   |\n| u32       | 0   | 4294967295                              |\n| u64       | 0   | 18446744073709551615                    |\n| u128      | 0   | 340282366920938463463374607431768211455 |\n\nüí°ÈùûË¥üÊï¥ÂûãÂèñÂÄºËåÉÂõ¥‰ªé**0**Ëá≥**2‚Åø-1**„ÄÇÂêåÊ†∑Âú∞Ôºå‰Ω†‰πüÂèØ‰ª•‰ΩøÁî®**min_value()**Âíå**max_value()**Êù•ÂØªÊâæÊØè‰∏™Êï¥ÂûãÁ±ªÂûãÁöÑÊúÄÂ∞èÂíåÊúÄÂ§ßÂÄºÔºåÂ¶ÇÔºöu8::max_value();\n\n\n- ## isize, usize\nÂêåÊåáÈíàÂ∞∫ÂØ∏ÁöÑÂ∏¶Á¨¶Âè∑Êï¥Âûã/ÈùûË¥üÊï¥ÂΩ¢\n\nËØ•Á±ªÂûãÁöÑÂÆûÈôÖÂç†Áî®bit‰ΩçÊï∞ÂèñÂÜ≥‰∫éËøêË°åÁ®ãÂ∫èÁöÑËÆ°ÁÆóÊú∫Êû∂ÊûÑ„ÄÇÈªòËÆ§ÊÉÖÂÜµ‰∏ãÔºåÂú®32‰ΩçËÆ°ÁÆóÊú∫‰∏äÔºåËØ•Á±ªÂûãÂç†Áî®32‰ΩçÔºåÂú®64‰ΩçÂπ≥Âè∞‰∏äÂàôÂç†Áî®64‰Ωç„ÄÇ\n\n> üîé Êõ¥Â§öÂÜÖÂÆπÂèØ‰ª•Êü•ÁúãRustÁ®ãÂ∫è‰∏≠ÁöÑ[‰∫§ÂèâÁºñËØë](https://github.com/rust-lang/rustup.rs#cross-compilation)Âíå[Supported Tiers](https://forge.rust-lang.org/platform-support.html)Á≠âÁ´†ËäÇ„ÄÇ\n\n\n- ## f32, f64\nÂÜÖÂ≠òÂç†Áî®‰∏∫32Âíå64‰ΩçÁöÑÊµÆÁÇπÊï∞ÔºàÂ∞èÊï∞Ôºâ\n\nRustÈÅµÂæ™IEEE‰∫åËøõÂà∂ÊµÆÁÇπÊï∞ÁÆóÊ≥ïÊ†áÂáÜ„ÄÇÂÖ∂‰∏≠`f32`Á±ªÂûãÁ±ª‰ºº‰∫éÂÖ∂‰ªñËØ≠Ë®Ä‰∏≠ÁöÑfloat(**ÂçïÁ≤æÂ∫¶ÊµÆÁÇπÊï∞**)ÔºåËÄå`f64`ÂàôÁ±ª‰ºº‰∫éÂÖ∂‰ªñËØ≠Ë®Ä‰∏≠ÁöÑdouble(**ÂèåÁ≤æÂ∫¶ÊµÆÁÇπÊï∞**)„ÄÇ\n\nüí° Âú®ÂΩìÂâçÁöÑÊÉÖÂÜµ‰∏ãÔºåÊé®ËçêÈÅøÂÖç‰ΩøÁî®f32Á±ªÂûãÊï∞ÊçÆÔºåÈô§Èùû‰Ω†Â∏åÊúõÈ´òÂ∫¶ËäÇÁúÅÁ®ãÂ∫èÁöÑÂÜÖÂ≠ò‰ΩøÁî®ÔºåÊàñËÄÖË¶ÅËøêË°å‰Ω†Á®ãÂ∫èÁöÑÁõÆÊ†áËÆæÂ§á‰∏çÊîØÊåÅ64‰ΩçÔºåÊàñÁõÆÊ†áËÆæÂ§áÂØπ32‰ΩçÁ®ãÂ∫èËøõË°å‰∫ÜÁâπÊÆä‰ºòÂåñ„ÄÇ\n\n\n- ## Êï∞ÁªÑ - arrays\nÂõ∫ÂÆöÂ∞∫ÂØ∏ÁöÑÂåÖÂê´ÂêåË¥®Êï∞ÊçÆÁöÑÊúâÂ∫èÊï∞ÊçÆÂÆπÂô®„ÄÇ\n\n```rust\nlet a = [1, 2, 3]; // a[0] = 1, a[1] = 2, a[2] = 3\nlet mut b = [1, 2, 3];\n\nlet c: [i32; 0] = []; //[Type; NO of elements] -> [] /Á©∫Êï∞ÁªÑ\nlet d: [i32; 3] = [1, 2, 3];\n\nlet e = [\"my value\"; 3]; //[\"my value\", \"my value\", \"my value\"];\n\nprintln!(\"{:?}\", a); //[1, 2, 3]\nprintln!(\"{:#?}\", a);\n//  [\n//      1,\n//      2,\n//      3\n//  ]\n```\n\n‚≠êÔ∏è ÈªòËÆ§ÊÉÖÂÜµ‰∏ãÔºåÊï∞ÁªÑÊòØ**‰∏çÂèØÂèò(immutable)**ÁöÑ„ÄÇÂπ∂‰∏îÔºåÂç≥‰Ωø**Â∏¶Êúâ`mut`ÂÖ≥ÈîÆÂ≠óÔºå‰πüÂè™ËÉΩ‰øÆÊîπÊï∞ÁªÑ‰∏≠ÁöÑÂÖÉÁ¥†ÔºåËÄåÂÖÉÁ¥†Êï∞Èáè‰πüÊòØ‰∏çÂèØÊõ¥ÊîπÁöÑ**„ÄÇ\n\n> üîé Â¶ÇÊûú‰Ω†Âú®ÂØªÊâæ‰∏Ä‰∏™Âä®ÊÄÅÁöÑ/ÂèØÂ¢ûÁöÑÊï∞ÁªÑÔºå‰Ω†ÂèØ‰ª•‰ΩøÁî®**Vec**Á±ªÂûã„ÄÇVectorÁ±ªÂûãÂèØ‰ª•ÂåÖÂê´‰ªªÊÑèÊï∞ÈáèÁöÑÂÖÉÁ¥†Ôºå‰ΩÜ‰ªçË¶Å‰øùÊåÅÊâÄÊúâÂÖÉÁ¥†ÁöÑÁ±ªÂûãÁªü‰∏Ä„ÄÇ\n\n\n- ## ÂÖÉÁªÑ - tuples\nÂõ∫ÂÆöÂ§ßÂ∞èÁöÑÊúâÂ∫èÁöÑÂêåË¥®/ÈùûÂêåË¥®Êï∞ÊçÆÊâÄÁªÑÊàêÁöÑÂàóË°®„ÄÇ\n\n```rust\nlet a = (1, 1.5, true, 'a', \"Hello, world!\");\n// a.0 = 1, a.1 = 1.5, a.2 = true, a.3 = 'a', a.4 = \"Hello, world!\"\n\nlet b: (i32, f64) = (1, 1.5);\n\nlet (c, d) = b; // c = 1, d = 1.5\nlet (e, _, _, _, f) = a; //e = 1, f = \"Hello, world!\", ‰∏ãÂàíÁ∫ø _ ÊÑèÂë≥ÁùÄÂøΩÁï•ËØ•‰ΩçÁΩÆÂÖ≥ËÅîÁöÑÂÖÉÁ¥†\n\nlet g = (0,); // ÂçïÂÖÉÁ¥†ÂÖÉÁªÑ\n\nlet h = (b, (2, 4), 5); //((1, 1.5), (2, 4), 5)\n\nprintln!(\"{:?}\", a); //(1, 1.5, true, 'a', \"Hello, world!\")\n```\n\n‚≠êÔ∏è ÂÖÉÁªÑÂú®ÈªòËÆ§ÊÉÖÂÜµ‰∏ãÂêåÊ†∑ÊòØ**‰∏çÂèØÂèò**ÁöÑÔºå**Âç≥‰Ωø‰ΩøÁî®‰∫Ü`mut`ÂÖ≥ÈîÆÂ≠óÔºåÂÖÉÁªÑÁöÑÂÖÉÁ¥†Êï∞Èáè‰πü‰∏çÂèØÊõ¥Êîπ„ÄÇÂêåÊ†∑Âú∞ÔºåÂ¶ÇÊûú‰Ω†ÈúÄË¶Å‰øÆÊîπ‰∏Ä‰∏™ÂÖÉÁ¥†ÁöÑÂÄºÔºåÊñ∞ÁöÑÂÄºÂ∫îËØ•‰∏éÂÖÉÁªÑ‰∏≠ÊóßÊúâÁöÑÂÄºÊã•ÊúâÂêå‰∏ÄÊï∞ÊçÆÁ±ªÂûã**„ÄÇ\n\n\n- ## ÂàáÁâá - slice\nÊåáÂêëÂÖ∂‰ªñÊï∞ÊçÆÁªìÊûÑÁöÑÂèØÂèòÂ∞∫ÂØ∏ÁöÑÂºïÁî®Á±ªÂûã\n\nÂú®Êüê‰∫õÂú∫ÊôØ‰∏ã‰Ω†ÂèØËÉΩÈúÄË¶ÅËé∑ÂèñÊàñ‰º†ÈÄíÊüê‰∏™Êï∞ÁªÑÊàñÂÖ∂‰ªñÊï∞ÊçÆÁ±ªÂûãÁöÑ‰∏ÄÈÉ®ÂàÜ„ÄÇÈô§‰∫ÜÂÆåÊï¥ÁöÑÂ∞ÜÂéüÂßãÊï∞ÊçÆËøõË°åÊã∑Ë¥ù‰º†ÈÄí‰ª•Â§ñÔºåRustÂÖÅËÆ∏ÂàõÂª∫Êàñ‰º†ÈÄí‰∏Ä‰∏™ÊåáÂêëÂéüÂßãÊï∞ÊçÆÁöÑÁâáÊÆµÁöÑËßÜÂõæ/ÂºïÁî®ÔºåËøô‰∏™ÂºïÁî®Êó¢ÂèØ‰ª•ÊòØÂèØÂèòÁöÑ‰πüÂèØ‰ª•ÊòØ‰∏çÂèØÂèòÁöÑ„ÄÇ \n\n```rust\nlet a: [i32; 4] = [1, 2, 3, 4];// ÂéüÂßãÊï∞ÁªÑ\n\nlet b: &[i32] = &a; // ÂÆåÊï¥ÁöÑÂéüÂßãÊï∞ÁªÑÂàáÁâá\nlet c = &a[0..4]; // ÂéüÂßãÊï∞ÁªÑ‰ªéÁ¨¨0‰∏™ÂÖÉÁ¥†Âà∞Á¨¨4‰∏™ÂÖÉÁ¥†Ôºà‰∏çÂåÖÂê´ÔºâÁöÑÂàáÁâá\nlet d = &a[..]; // ÂÆåÊï¥ÁöÑÂéüÂßãÊï∞ÁªÑÂàáÁâá\n\nlet e = &a[1..3]; //[2, 3]\nlet f = &a[1..]; //[2, 3, 4]\nlet g = &a[..3]; //[1, 2, 3]\n```\n\n\n- ## str\n‰∏çÂÆöÂ∞∫ÂØ∏ÁöÑUnicodeÂ≠ó‰∏≤ÂàáÁâáÔºåÁî±UTF-8Â≠óÁ¨¶ÁªÑÊàêÁöÑÂ∫èÂàó\n\n```rust\nlet a = \"Hello, world.\"; //a: &'static str ‰∏Ä‰∏™ÈùôÊÄÅÂ≠ó‰∏≤ÂàáÁâá\nlet b: &str = \"„Åì„Çì„Å´„Å°„ÅØ, ‰∏ñÁïå!\";\n```\n\n‚≠êÔ∏è  strÊòØ‰∏Ä‰∏™**‰∏çÂèØÂèò/ÈùôÊÄÅÁöÑÂ∑≤ÂàÜÈÖçÂÜÖÂ≠òÁöÑÂàáÁâá**ÔºåËøô‰∏™ÂàáÁâáÊåáÂêëÂú®ÂÜÖÂ≠ò‰∏≠ÊüêÂ§ÑÂ≠òÊúâÁöÑ‰∏Ä‰∏™**Êú™Áü•ÈïøÂ∫¶ÁöÑUTF-8Â∫èÂàó**„ÄÇ **&str**Áî®Êù•ÂÄüÁî®Âπ∂ÂàÜÈÖçÊï¥‰∏™Êï∞ÂàóÁªô‰∏Ä‰∏™ÁâπÂÆöÁöÑÂêëÂèòÈáèÁªëÂÆö„ÄÇ\n\n> üîé ‰∏Ä‰∏™[Â≠ó‰∏≤Á±ªÂûã - String](https://doc.rust-lang.org/std/string/struct.String.html)ÊòØ‰∏Ä‰∏™Âú®**Â†Ü - heap**‰∏≠ËøõË°åÂàÜÈÖçÁöÑÂ≠ó‰∏≤„ÄÇËøô‰∏™Â≠ó‰∏≤ÊòØÂèØÂ¢ûÁöÑUTF-8Â∫èÂàó„ÄÇÂ≠ó‰∏≤Á±ªÂûãÈÄöÂ∏∏Áî±‰∏Ä‰∏™Â≠ó‰∏≤ÂàáÁâáË∞ÉÁî®**to_string()**ÊñπÊ≥ïËΩ¨Êç¢ËÄåÊù•Ôºå‰πüÂèØÁî±StringÁ±ªÂûãÁöÑÈùôÊÄÅÊñπÊ≥ï**String::from()**ÂØπÂ≠ó‰∏≤ÂàáÁâáËøõË°åËΩ¨Êç¢ËÄåÂæóÂà∞„ÄÇÂ¶ÇÔºö`‚ÄúHello‚Äù.to_string();`Êàñ`String::from(\"Hello\");`\n\nüí° ÈÄöÂ∏∏Êù•ËØ¥ÔºåÂú®ÈúÄË¶ÅËé∑Âèñ**ÊâÄÊúâÊùÉ**Êó∂Ôºå‰Ω†‰ºö‰ΩøÁî®Âà∞**StringÁ±ªÂûã**ÔºåËÄåÂú®‰Ω†‰ªÖÈúÄË¶Å**ÂØπ‰∏Ä‰∏™Â≠ó‰∏≤ÊâßË°åÂÄüÁî®**Êó∂ÔºåÂèØ‰ª•Áõ¥Êé•‰ΩøÁî® **`&str`**„ÄÇ\n\n- ## functions\nÊ≠£Â¶ÇÊàë‰ª¨Âú®ÂáΩÊï∞‰∏ÄËäÇÊèêÂà∞ËøáÁöÑÔºå`b` ÊòØ‰∏Ä‰∏™ÊåáÂêëÂáΩÊï∞`plus_one()`ÁöÑÊåáÈíà.\n\n```rust\nfn plus_one(a: i32) -> i32 {\n    a + 1\n}\n\nlet b: fn(i32) -> i32 = plus_one;\nlet c = b(5); //6\n```\n","source":"docs/zh-cn/a8.primitive_data_types.md","raw":"title: Âü∫Á°ÄÊï∞ÊçÆÁ±ªÂûã - Primitive Data Types\n---\n\n- ## bool\ntrue or false\n\n```rust\nlet x = true;\nlet y: bool = false;\n\n// ‚≠êÔ∏è rustÊòØÂº∫Á±ªÂûãËØ≠Ë®ÄÔºåboolÁ±ªÂûã‰∏çÂèØ‰ª•‰ΩøÁî® TRUE, FALSE Êàñ 1, 0 Êù•Êõø‰ª£\n```\n\n\n- ## char\n‰∏Ä‰∏™Áã¨Á´ãÁöÑUnicodeÊ†áÈáè\n\n```rust\nlet x = 'x';\nlet y = 'üòé';\n\n// ‚≠êÔ∏è ‰∏çÊòØ \"x\"Ôºå‰ΩøÁî®ÂçïÂºïÂè∑ÂåÖË£π\n// Âá∫‰∫éÂØπUnicodeÁöÑÊîØÊåÅÔºåcharÂπ∂‰∏çÊòØÂçïÂ≠óËäÇÊï∞ÊçÆÁ±ªÂûãÔºåÊØè‰∏™char‰ºöÂç†Áî®4‰∏™Â≠óËäÇ\n```\n\n\n- ## i8, i16, i32, i64, i128\nÂõ∫ÂÆöÂ∞∫ÂØ∏Ôºàbit‰ΩçÊï∞ÔºâÊúâÁ¨¶Âè∑ÁöÑÊï¥Êï∞Á±ªÂûã(+/-)\n\n| DATA TYPE | MIN                                      | MAX                                     |\n| --------- | ---------------------------------------- | --------------------------------------- |\n| i8        | -128                                     | 127                                     |\n| i16       | -32768                                   | 32767                                   |\n| i32       | -2147483648                              | 2147483647                              |\n| i64       | -9223372036854775808                     | 9223372036854775807                     |\n| i128      | -170141183460469231731687303715884105728 | 170141183460469231731687303715884105727 |\n\nüí° ÊØè‰∏ÄÁ±ªÂûãÁöÑÊúÄÂ§ßÂíåÊúÄÂ∞èÂÄºÔºåÂèñÂÄºËåÉÂõ¥‰∏∫ **-2‚Åø‚Åª¬π Âà∞ 2‚Åø‚Åª¬π-1**„ÄÇ‰Ω†ÂèØ‰ª•‰ΩøÁî® **min_value()** Âíå **max_value()** ÊñπÊ≥ïÊù•Ëé∑ÂèñÊØè‰∏™Êï¥ÂûãÁöÑÊúÄÂ∞è‰∏éÊúÄÂ§ßÂÄºÔºåÂ¶ÇÔºöi8::min_value();\n\n\n- ## u8, u16, u32, u64, u128\nÂõ∫ÂÆöÂ∞∫ÂØ∏Ôºàbit‰ΩçÊï∞ÔºâÊó†Á¨¶Âè∑ÈùûË¥üÊï¥Âûã\n\n| Êï∞ÊçÆÁ±ªÂûã   | ÊúÄÂ∞èÂÄº | ÊúÄÂ§ßÂÄº                                 |\n| --------- | --- | --------------------------------------- |\n| u8        | 0   | 255                                     |\n| u16       | 0   | 65535                                   |\n| u32       | 0   | 4294967295                              |\n| u64       | 0   | 18446744073709551615                    |\n| u128      | 0   | 340282366920938463463374607431768211455 |\n\nüí°ÈùûË¥üÊï¥ÂûãÂèñÂÄºËåÉÂõ¥‰ªé**0**Ëá≥**2‚Åø-1**„ÄÇÂêåÊ†∑Âú∞Ôºå‰Ω†‰πüÂèØ‰ª•‰ΩøÁî®**min_value()**Âíå**max_value()**Êù•ÂØªÊâæÊØè‰∏™Êï¥ÂûãÁ±ªÂûãÁöÑÊúÄÂ∞èÂíåÊúÄÂ§ßÂÄºÔºåÂ¶ÇÔºöu8::max_value();\n\n\n- ## isize, usize\nÂêåÊåáÈíàÂ∞∫ÂØ∏ÁöÑÂ∏¶Á¨¶Âè∑Êï¥Âûã/ÈùûË¥üÊï¥ÂΩ¢\n\nËØ•Á±ªÂûãÁöÑÂÆûÈôÖÂç†Áî®bit‰ΩçÊï∞ÂèñÂÜ≥‰∫éËøêË°åÁ®ãÂ∫èÁöÑËÆ°ÁÆóÊú∫Êû∂ÊûÑ„ÄÇÈªòËÆ§ÊÉÖÂÜµ‰∏ãÔºåÂú®32‰ΩçËÆ°ÁÆóÊú∫‰∏äÔºåËØ•Á±ªÂûãÂç†Áî®32‰ΩçÔºåÂú®64‰ΩçÂπ≥Âè∞‰∏äÂàôÂç†Áî®64‰Ωç„ÄÇ\n\n> üîé Êõ¥Â§öÂÜÖÂÆπÂèØ‰ª•Êü•ÁúãRustÁ®ãÂ∫è‰∏≠ÁöÑ[‰∫§ÂèâÁºñËØë](https://github.com/rust-lang/rustup.rs#cross-compilation)Âíå[Supported Tiers](https://forge.rust-lang.org/platform-support.html)Á≠âÁ´†ËäÇ„ÄÇ\n\n\n- ## f32, f64\nÂÜÖÂ≠òÂç†Áî®‰∏∫32Âíå64‰ΩçÁöÑÊµÆÁÇπÊï∞ÔºàÂ∞èÊï∞Ôºâ\n\nRustÈÅµÂæ™IEEE‰∫åËøõÂà∂ÊµÆÁÇπÊï∞ÁÆóÊ≥ïÊ†áÂáÜ„ÄÇÂÖ∂‰∏≠`f32`Á±ªÂûãÁ±ª‰ºº‰∫éÂÖ∂‰ªñËØ≠Ë®Ä‰∏≠ÁöÑfloat(**ÂçïÁ≤æÂ∫¶ÊµÆÁÇπÊï∞**)ÔºåËÄå`f64`ÂàôÁ±ª‰ºº‰∫éÂÖ∂‰ªñËØ≠Ë®Ä‰∏≠ÁöÑdouble(**ÂèåÁ≤æÂ∫¶ÊµÆÁÇπÊï∞**)„ÄÇ\n\nüí° Âú®ÂΩìÂâçÁöÑÊÉÖÂÜµ‰∏ãÔºåÊé®ËçêÈÅøÂÖç‰ΩøÁî®f32Á±ªÂûãÊï∞ÊçÆÔºåÈô§Èùû‰Ω†Â∏åÊúõÈ´òÂ∫¶ËäÇÁúÅÁ®ãÂ∫èÁöÑÂÜÖÂ≠ò‰ΩøÁî®ÔºåÊàñËÄÖË¶ÅËøêË°å‰Ω†Á®ãÂ∫èÁöÑÁõÆÊ†áËÆæÂ§á‰∏çÊîØÊåÅ64‰ΩçÔºåÊàñÁõÆÊ†áËÆæÂ§áÂØπ32‰ΩçÁ®ãÂ∫èËøõË°å‰∫ÜÁâπÊÆä‰ºòÂåñ„ÄÇ\n\n\n- ## Êï∞ÁªÑ - arrays\nÂõ∫ÂÆöÂ∞∫ÂØ∏ÁöÑÂåÖÂê´ÂêåË¥®Êï∞ÊçÆÁöÑÊúâÂ∫èÊï∞ÊçÆÂÆπÂô®„ÄÇ\n\n```rust\nlet a = [1, 2, 3]; // a[0] = 1, a[1] = 2, a[2] = 3\nlet mut b = [1, 2, 3];\n\nlet c: [i32; 0] = []; //[Type; NO of elements] -> [] /Á©∫Êï∞ÁªÑ\nlet d: [i32; 3] = [1, 2, 3];\n\nlet e = [\"my value\"; 3]; //[\"my value\", \"my value\", \"my value\"];\n\nprintln!(\"{:?}\", a); //[1, 2, 3]\nprintln!(\"{:#?}\", a);\n//  [\n//      1,\n//      2,\n//      3\n//  ]\n```\n\n‚≠êÔ∏è ÈªòËÆ§ÊÉÖÂÜµ‰∏ãÔºåÊï∞ÁªÑÊòØ**‰∏çÂèØÂèò(immutable)**ÁöÑ„ÄÇÂπ∂‰∏îÔºåÂç≥‰Ωø**Â∏¶Êúâ`mut`ÂÖ≥ÈîÆÂ≠óÔºå‰πüÂè™ËÉΩ‰øÆÊîπÊï∞ÁªÑ‰∏≠ÁöÑÂÖÉÁ¥†ÔºåËÄåÂÖÉÁ¥†Êï∞Èáè‰πüÊòØ‰∏çÂèØÊõ¥ÊîπÁöÑ**„ÄÇ\n\n> üîé Â¶ÇÊûú‰Ω†Âú®ÂØªÊâæ‰∏Ä‰∏™Âä®ÊÄÅÁöÑ/ÂèØÂ¢ûÁöÑÊï∞ÁªÑÔºå‰Ω†ÂèØ‰ª•‰ΩøÁî®**Vec**Á±ªÂûã„ÄÇVectorÁ±ªÂûãÂèØ‰ª•ÂåÖÂê´‰ªªÊÑèÊï∞ÈáèÁöÑÂÖÉÁ¥†Ôºå‰ΩÜ‰ªçË¶Å‰øùÊåÅÊâÄÊúâÂÖÉÁ¥†ÁöÑÁ±ªÂûãÁªü‰∏Ä„ÄÇ\n\n\n- ## ÂÖÉÁªÑ - tuples\nÂõ∫ÂÆöÂ§ßÂ∞èÁöÑÊúâÂ∫èÁöÑÂêåË¥®/ÈùûÂêåË¥®Êï∞ÊçÆÊâÄÁªÑÊàêÁöÑÂàóË°®„ÄÇ\n\n```rust\nlet a = (1, 1.5, true, 'a', \"Hello, world!\");\n// a.0 = 1, a.1 = 1.5, a.2 = true, a.3 = 'a', a.4 = \"Hello, world!\"\n\nlet b: (i32, f64) = (1, 1.5);\n\nlet (c, d) = b; // c = 1, d = 1.5\nlet (e, _, _, _, f) = a; //e = 1, f = \"Hello, world!\", ‰∏ãÂàíÁ∫ø _ ÊÑèÂë≥ÁùÄÂøΩÁï•ËØ•‰ΩçÁΩÆÂÖ≥ËÅîÁöÑÂÖÉÁ¥†\n\nlet g = (0,); // ÂçïÂÖÉÁ¥†ÂÖÉÁªÑ\n\nlet h = (b, (2, 4), 5); //((1, 1.5), (2, 4), 5)\n\nprintln!(\"{:?}\", a); //(1, 1.5, true, 'a', \"Hello, world!\")\n```\n\n‚≠êÔ∏è ÂÖÉÁªÑÂú®ÈªòËÆ§ÊÉÖÂÜµ‰∏ãÂêåÊ†∑ÊòØ**‰∏çÂèØÂèò**ÁöÑÔºå**Âç≥‰Ωø‰ΩøÁî®‰∫Ü`mut`ÂÖ≥ÈîÆÂ≠óÔºåÂÖÉÁªÑÁöÑÂÖÉÁ¥†Êï∞Èáè‰πü‰∏çÂèØÊõ¥Êîπ„ÄÇÂêåÊ†∑Âú∞ÔºåÂ¶ÇÊûú‰Ω†ÈúÄË¶Å‰øÆÊîπ‰∏Ä‰∏™ÂÖÉÁ¥†ÁöÑÂÄºÔºåÊñ∞ÁöÑÂÄºÂ∫îËØ•‰∏éÂÖÉÁªÑ‰∏≠ÊóßÊúâÁöÑÂÄºÊã•ÊúâÂêå‰∏ÄÊï∞ÊçÆÁ±ªÂûã**„ÄÇ\n\n\n- ## ÂàáÁâá - slice\nÊåáÂêëÂÖ∂‰ªñÊï∞ÊçÆÁªìÊûÑÁöÑÂèØÂèòÂ∞∫ÂØ∏ÁöÑÂºïÁî®Á±ªÂûã\n\nÂú®Êüê‰∫õÂú∫ÊôØ‰∏ã‰Ω†ÂèØËÉΩÈúÄË¶ÅËé∑ÂèñÊàñ‰º†ÈÄíÊüê‰∏™Êï∞ÁªÑÊàñÂÖ∂‰ªñÊï∞ÊçÆÁ±ªÂûãÁöÑ‰∏ÄÈÉ®ÂàÜ„ÄÇÈô§‰∫ÜÂÆåÊï¥ÁöÑÂ∞ÜÂéüÂßãÊï∞ÊçÆËøõË°åÊã∑Ë¥ù‰º†ÈÄí‰ª•Â§ñÔºåRustÂÖÅËÆ∏ÂàõÂª∫Êàñ‰º†ÈÄí‰∏Ä‰∏™ÊåáÂêëÂéüÂßãÊï∞ÊçÆÁöÑÁâáÊÆµÁöÑËßÜÂõæ/ÂºïÁî®ÔºåËøô‰∏™ÂºïÁî®Êó¢ÂèØ‰ª•ÊòØÂèØÂèòÁöÑ‰πüÂèØ‰ª•ÊòØ‰∏çÂèØÂèòÁöÑ„ÄÇ \n\n```rust\nlet a: [i32; 4] = [1, 2, 3, 4];// ÂéüÂßãÊï∞ÁªÑ\n\nlet b: &[i32] = &a; // ÂÆåÊï¥ÁöÑÂéüÂßãÊï∞ÁªÑÂàáÁâá\nlet c = &a[0..4]; // ÂéüÂßãÊï∞ÁªÑ‰ªéÁ¨¨0‰∏™ÂÖÉÁ¥†Âà∞Á¨¨4‰∏™ÂÖÉÁ¥†Ôºà‰∏çÂåÖÂê´ÔºâÁöÑÂàáÁâá\nlet d = &a[..]; // ÂÆåÊï¥ÁöÑÂéüÂßãÊï∞ÁªÑÂàáÁâá\n\nlet e = &a[1..3]; //[2, 3]\nlet f = &a[1..]; //[2, 3, 4]\nlet g = &a[..3]; //[1, 2, 3]\n```\n\n\n- ## str\n‰∏çÂÆöÂ∞∫ÂØ∏ÁöÑUnicodeÂ≠ó‰∏≤ÂàáÁâáÔºåÁî±UTF-8Â≠óÁ¨¶ÁªÑÊàêÁöÑÂ∫èÂàó\n\n```rust\nlet a = \"Hello, world.\"; //a: &'static str ‰∏Ä‰∏™ÈùôÊÄÅÂ≠ó‰∏≤ÂàáÁâá\nlet b: &str = \"„Åì„Çì„Å´„Å°„ÅØ, ‰∏ñÁïå!\";\n```\n\n‚≠êÔ∏è  strÊòØ‰∏Ä‰∏™**‰∏çÂèØÂèò/ÈùôÊÄÅÁöÑÂ∑≤ÂàÜÈÖçÂÜÖÂ≠òÁöÑÂàáÁâá**ÔºåËøô‰∏™ÂàáÁâáÊåáÂêëÂú®ÂÜÖÂ≠ò‰∏≠ÊüêÂ§ÑÂ≠òÊúâÁöÑ‰∏Ä‰∏™**Êú™Áü•ÈïøÂ∫¶ÁöÑUTF-8Â∫èÂàó**„ÄÇ **&str**Áî®Êù•ÂÄüÁî®Âπ∂ÂàÜÈÖçÊï¥‰∏™Êï∞ÂàóÁªô‰∏Ä‰∏™ÁâπÂÆöÁöÑÂêëÂèòÈáèÁªëÂÆö„ÄÇ\n\n> üîé ‰∏Ä‰∏™[Â≠ó‰∏≤Á±ªÂûã - String](https://doc.rust-lang.org/std/string/struct.String.html)ÊòØ‰∏Ä‰∏™Âú®**Â†Ü - heap**‰∏≠ËøõË°åÂàÜÈÖçÁöÑÂ≠ó‰∏≤„ÄÇËøô‰∏™Â≠ó‰∏≤ÊòØÂèØÂ¢ûÁöÑUTF-8Â∫èÂàó„ÄÇÂ≠ó‰∏≤Á±ªÂûãÈÄöÂ∏∏Áî±‰∏Ä‰∏™Â≠ó‰∏≤ÂàáÁâáË∞ÉÁî®**to_string()**ÊñπÊ≥ïËΩ¨Êç¢ËÄåÊù•Ôºå‰πüÂèØÁî±StringÁ±ªÂûãÁöÑÈùôÊÄÅÊñπÊ≥ï**String::from()**ÂØπÂ≠ó‰∏≤ÂàáÁâáËøõË°åËΩ¨Êç¢ËÄåÂæóÂà∞„ÄÇÂ¶ÇÔºö`‚ÄúHello‚Äù.to_string();`Êàñ`String::from(\"Hello\");`\n\nüí° ÈÄöÂ∏∏Êù•ËØ¥ÔºåÂú®ÈúÄË¶ÅËé∑Âèñ**ÊâÄÊúâÊùÉ**Êó∂Ôºå‰Ω†‰ºö‰ΩøÁî®Âà∞**StringÁ±ªÂûã**ÔºåËÄåÂú®‰Ω†‰ªÖÈúÄË¶Å**ÂØπ‰∏Ä‰∏™Â≠ó‰∏≤ÊâßË°åÂÄüÁî®**Êó∂ÔºåÂèØ‰ª•Áõ¥Êé•‰ΩøÁî® **`&str`**„ÄÇ\n\n- ## functions\nÊ≠£Â¶ÇÊàë‰ª¨Âú®ÂáΩÊï∞‰∏ÄËäÇÊèêÂà∞ËøáÁöÑÔºå`b` ÊòØ‰∏Ä‰∏™ÊåáÂêëÂáΩÊï∞`plus_one()`ÁöÑÊåáÈíà.\n\n```rust\nfn plus_one(a: i32) -> i32 {\n    a + 1\n}\n\nlet b: fn(i32) -> i32 = plus_one;\nlet c = b(5); //6\n```\n","date":"2019-03-21T02:41:48.177Z","updated":"2019-03-21T02:41:48.177Z","path":"docs/zh-cn/a8.primitive_data_types.html","_id":"cjtfwbj0s0017dwgp1vc8zh7b","comments":1,"layout":"page","content":"<ul>\n<li><h2 id=\"bool\"><a href=\"#bool\" class=\"headerlink\" title=\"bool\"></a>bool</h2>true or false</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let x = true;\nlet y: bool = false;\n\n// ‚≠êÔ∏è rustÊòØÂº∫Á±ªÂûãËØ≠Ë®ÄÔºåboolÁ±ªÂûã‰∏çÂèØ‰ª•‰ΩøÁî® TRUE, FALSE Êàñ 1, 0 Êù•Êõø‰ª£\n</code></pre>\n<ul>\n<li><h2 id=\"char\"><a href=\"#char\" class=\"headerlink\" title=\"char\"></a>char</h2>‰∏Ä‰∏™Áã¨Á´ãÁöÑUnicodeÊ†áÈáè</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let x = &#39;x&#39;;\nlet y = &#39;üòé&#39;;\n\n// ‚≠êÔ∏è ‰∏çÊòØ &quot;x&quot;Ôºå‰ΩøÁî®ÂçïÂºïÂè∑ÂåÖË£π\n// Âá∫‰∫éÂØπUnicodeÁöÑÊîØÊåÅÔºåcharÂπ∂‰∏çÊòØÂçïÂ≠óËäÇÊï∞ÊçÆÁ±ªÂûãÔºåÊØè‰∏™char‰ºöÂç†Áî®4‰∏™Â≠óËäÇ\n</code></pre>\n<ul>\n<li><h2 id=\"i8-i16-i32-i64-i128\"><a href=\"#i8-i16-i32-i64-i128\" class=\"headerlink\" title=\"i8, i16, i32, i64, i128\"></a>i8, i16, i32, i64, i128</h2>Âõ∫ÂÆöÂ∞∫ÂØ∏Ôºàbit‰ΩçÊï∞ÔºâÊúâÁ¨¶Âè∑ÁöÑÊï¥Êï∞Á±ªÂûã(+/-)</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>DATA TYPE</th>\n<th>MIN</th>\n<th>MAX</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>i8</td>\n<td>-128</td>\n<td>127</td>\n</tr>\n<tr>\n<td>i16</td>\n<td>-32768</td>\n<td>32767</td>\n</tr>\n<tr>\n<td>i32</td>\n<td>-2147483648</td>\n<td>2147483647</td>\n</tr>\n<tr>\n<td>i64</td>\n<td>-9223372036854775808</td>\n<td>9223372036854775807</td>\n</tr>\n<tr>\n<td>i128</td>\n<td>-170141183460469231731687303715884105728</td>\n<td>170141183460469231731687303715884105727</td>\n</tr>\n</tbody>\n</table>\n<p>üí° ÊØè‰∏ÄÁ±ªÂûãÁöÑÊúÄÂ§ßÂíåÊúÄÂ∞èÂÄºÔºåÂèñÂÄºËåÉÂõ¥‰∏∫ <strong>-2‚Åø‚Åª¬π Âà∞ 2‚Åø‚Åª¬π-1</strong>„ÄÇ‰Ω†ÂèØ‰ª•‰ΩøÁî® <strong>min_value()</strong> Âíå <strong>max_value()</strong> ÊñπÊ≥ïÊù•Ëé∑ÂèñÊØè‰∏™Êï¥ÂûãÁöÑÊúÄÂ∞è‰∏éÊúÄÂ§ßÂÄºÔºåÂ¶ÇÔºöi8::min_value();</p>\n<ul>\n<li><h2 id=\"u8-u16-u32-u64-u128\"><a href=\"#u8-u16-u32-u64-u128\" class=\"headerlink\" title=\"u8, u16, u32, u64, u128\"></a>u8, u16, u32, u64, u128</h2>Âõ∫ÂÆöÂ∞∫ÂØ∏Ôºàbit‰ΩçÊï∞ÔºâÊó†Á¨¶Âè∑ÈùûË¥üÊï¥Âûã</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Êï∞ÊçÆÁ±ªÂûã</th>\n<th>ÊúÄÂ∞èÂÄº</th>\n<th>ÊúÄÂ§ßÂÄº</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>u8</td>\n<td>0</td>\n<td>255</td>\n</tr>\n<tr>\n<td>u16</td>\n<td>0</td>\n<td>65535</td>\n</tr>\n<tr>\n<td>u32</td>\n<td>0</td>\n<td>4294967295</td>\n</tr>\n<tr>\n<td>u64</td>\n<td>0</td>\n<td>18446744073709551615</td>\n</tr>\n<tr>\n<td>u128</td>\n<td>0</td>\n<td>340282366920938463463374607431768211455</td>\n</tr>\n</tbody>\n</table>\n<p>üí°ÈùûË¥üÊï¥ÂûãÂèñÂÄºËåÉÂõ¥‰ªé<strong>0</strong>Ëá≥<strong>2‚Åø-1</strong>„ÄÇÂêåÊ†∑Âú∞Ôºå‰Ω†‰πüÂèØ‰ª•‰ΩøÁî®<strong>min_value()</strong>Âíå<strong>max_value()</strong>Êù•ÂØªÊâæÊØè‰∏™Êï¥ÂûãÁ±ªÂûãÁöÑÊúÄÂ∞èÂíåÊúÄÂ§ßÂÄºÔºåÂ¶ÇÔºöu8::max_value();</p>\n<ul>\n<li><h2 id=\"isize-usize\"><a href=\"#isize-usize\" class=\"headerlink\" title=\"isize, usize\"></a>isize, usize</h2>ÂêåÊåáÈíàÂ∞∫ÂØ∏ÁöÑÂ∏¶Á¨¶Âè∑Êï¥Âûã/ÈùûË¥üÊï¥ÂΩ¢</li>\n</ul>\n<p>ËØ•Á±ªÂûãÁöÑÂÆûÈôÖÂç†Áî®bit‰ΩçÊï∞ÂèñÂÜ≥‰∫éËøêË°åÁ®ãÂ∫èÁöÑËÆ°ÁÆóÊú∫Êû∂ÊûÑ„ÄÇÈªòËÆ§ÊÉÖÂÜµ‰∏ãÔºåÂú®32‰ΩçËÆ°ÁÆóÊú∫‰∏äÔºåËØ•Á±ªÂûãÂç†Áî®32‰ΩçÔºåÂú®64‰ΩçÂπ≥Âè∞‰∏äÂàôÂç†Áî®64‰Ωç„ÄÇ</p>\n<blockquote>\n<p>üîé Êõ¥Â§öÂÜÖÂÆπÂèØ‰ª•Êü•ÁúãRustÁ®ãÂ∫è‰∏≠ÁöÑ<a href=\"https://github.com/rust-lang/rustup.rs#cross-compilation\" target=\"_blank\" rel=\"noopener\">‰∫§ÂèâÁºñËØë</a>Âíå<a href=\"https://forge.rust-lang.org/platform-support.html\" target=\"_blank\" rel=\"noopener\">Supported Tiers</a>Á≠âÁ´†ËäÇ„ÄÇ</p>\n</blockquote>\n<ul>\n<li><h2 id=\"f32-f64\"><a href=\"#f32-f64\" class=\"headerlink\" title=\"f32, f64\"></a>f32, f64</h2>ÂÜÖÂ≠òÂç†Áî®‰∏∫32Âíå64‰ΩçÁöÑÊµÆÁÇπÊï∞ÔºàÂ∞èÊï∞Ôºâ</li>\n</ul>\n<p>RustÈÅµÂæ™IEEE‰∫åËøõÂà∂ÊµÆÁÇπÊï∞ÁÆóÊ≥ïÊ†áÂáÜ„ÄÇÂÖ∂‰∏≠<code>f32</code>Á±ªÂûãÁ±ª‰ºº‰∫éÂÖ∂‰ªñËØ≠Ë®Ä‰∏≠ÁöÑfloat(<strong>ÂçïÁ≤æÂ∫¶ÊµÆÁÇπÊï∞</strong>)ÔºåËÄå<code>f64</code>ÂàôÁ±ª‰ºº‰∫éÂÖ∂‰ªñËØ≠Ë®Ä‰∏≠ÁöÑdouble(<strong>ÂèåÁ≤æÂ∫¶ÊµÆÁÇπÊï∞</strong>)„ÄÇ</p>\n<p>üí° Âú®ÂΩìÂâçÁöÑÊÉÖÂÜµ‰∏ãÔºåÊé®ËçêÈÅøÂÖç‰ΩøÁî®f32Á±ªÂûãÊï∞ÊçÆÔºåÈô§Èùû‰Ω†Â∏åÊúõÈ´òÂ∫¶ËäÇÁúÅÁ®ãÂ∫èÁöÑÂÜÖÂ≠ò‰ΩøÁî®ÔºåÊàñËÄÖË¶ÅËøêË°å‰Ω†Á®ãÂ∫èÁöÑÁõÆÊ†áËÆæÂ§á‰∏çÊîØÊåÅ64‰ΩçÔºåÊàñÁõÆÊ†áËÆæÂ§áÂØπ32‰ΩçÁ®ãÂ∫èËøõË°å‰∫ÜÁâπÊÆä‰ºòÂåñ„ÄÇ</p>\n<ul>\n<li><h2 id=\"Êï∞ÁªÑ-arrays\"><a href=\"#Êï∞ÁªÑ-arrays\" class=\"headerlink\" title=\"Êï∞ÁªÑ - arrays\"></a>Êï∞ÁªÑ - arrays</h2>Âõ∫ÂÆöÂ∞∫ÂØ∏ÁöÑÂåÖÂê´ÂêåË¥®Êï∞ÊçÆÁöÑÊúâÂ∫èÊï∞ÊçÆÂÆπÂô®„ÄÇ</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = [1, 2, 3]; // a[0] = 1, a[1] = 2, a[2] = 3\nlet mut b = [1, 2, 3];\n\nlet c: [i32; 0] = []; //[Type; NO of elements] -&gt; [] /Á©∫Êï∞ÁªÑ\nlet d: [i32; 3] = [1, 2, 3];\n\nlet e = [&quot;my value&quot;; 3]; //[&quot;my value&quot;, &quot;my value&quot;, &quot;my value&quot;];\n\nprintln!(&quot;{:?}&quot;, a); //[1, 2, 3]\nprintln!(&quot;{:#?}&quot;, a);\n//  [\n//      1,\n//      2,\n//      3\n//  ]\n</code></pre>\n<p>‚≠êÔ∏è ÈªòËÆ§ÊÉÖÂÜµ‰∏ãÔºåÊï∞ÁªÑÊòØ<strong>‰∏çÂèØÂèò(immutable)</strong>ÁöÑ„ÄÇÂπ∂‰∏îÔºåÂç≥‰Ωø<strong>Â∏¶Êúâ<code>mut</code>ÂÖ≥ÈîÆÂ≠óÔºå‰πüÂè™ËÉΩ‰øÆÊîπÊï∞ÁªÑ‰∏≠ÁöÑÂÖÉÁ¥†ÔºåËÄåÂÖÉÁ¥†Êï∞Èáè‰πüÊòØ‰∏çÂèØÊõ¥ÊîπÁöÑ</strong>„ÄÇ</p>\n<blockquote>\n<p>üîé Â¶ÇÊûú‰Ω†Âú®ÂØªÊâæ‰∏Ä‰∏™Âä®ÊÄÅÁöÑ/ÂèØÂ¢ûÁöÑÊï∞ÁªÑÔºå‰Ω†ÂèØ‰ª•‰ΩøÁî®<strong>Vec</strong>Á±ªÂûã„ÄÇVectorÁ±ªÂûãÂèØ‰ª•ÂåÖÂê´‰ªªÊÑèÊï∞ÈáèÁöÑÂÖÉÁ¥†Ôºå‰ΩÜ‰ªçË¶Å‰øùÊåÅÊâÄÊúâÂÖÉÁ¥†ÁöÑÁ±ªÂûãÁªü‰∏Ä„ÄÇ</p>\n</blockquote>\n<ul>\n<li><h2 id=\"ÂÖÉÁªÑ-tuples\"><a href=\"#ÂÖÉÁªÑ-tuples\" class=\"headerlink\" title=\"ÂÖÉÁªÑ - tuples\"></a>ÂÖÉÁªÑ - tuples</h2>Âõ∫ÂÆöÂ§ßÂ∞èÁöÑÊúâÂ∫èÁöÑÂêåË¥®/ÈùûÂêåË¥®Êï∞ÊçÆÊâÄÁªÑÊàêÁöÑÂàóË°®„ÄÇ</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = (1, 1.5, true, &#39;a&#39;, &quot;Hello, world!&quot;);\n// a.0 = 1, a.1 = 1.5, a.2 = true, a.3 = &#39;a&#39;, a.4 = &quot;Hello, world!&quot;\n\nlet b: (i32, f64) = (1, 1.5);\n\nlet (c, d) = b; // c = 1, d = 1.5\nlet (e, _, _, _, f) = a; //e = 1, f = &quot;Hello, world!&quot;, ‰∏ãÂàíÁ∫ø _ ÊÑèÂë≥ÁùÄÂøΩÁï•ËØ•‰ΩçÁΩÆÂÖ≥ËÅîÁöÑÂÖÉÁ¥†\n\nlet g = (0,); // ÂçïÂÖÉÁ¥†ÂÖÉÁªÑ\n\nlet h = (b, (2, 4), 5); //((1, 1.5), (2, 4), 5)\n\nprintln!(&quot;{:?}&quot;, a); //(1, 1.5, true, &#39;a&#39;, &quot;Hello, world!&quot;)\n</code></pre>\n<p>‚≠êÔ∏è ÂÖÉÁªÑÂú®ÈªòËÆ§ÊÉÖÂÜµ‰∏ãÂêåÊ†∑ÊòØ<strong>‰∏çÂèØÂèò</strong>ÁöÑÔºå<strong>Âç≥‰Ωø‰ΩøÁî®‰∫Ü<code>mut</code>ÂÖ≥ÈîÆÂ≠óÔºåÂÖÉÁªÑÁöÑÂÖÉÁ¥†Êï∞Èáè‰πü‰∏çÂèØÊõ¥Êîπ„ÄÇÂêåÊ†∑Âú∞ÔºåÂ¶ÇÊûú‰Ω†ÈúÄË¶Å‰øÆÊîπ‰∏Ä‰∏™ÂÖÉÁ¥†ÁöÑÂÄºÔºåÊñ∞ÁöÑÂÄºÂ∫îËØ•‰∏éÂÖÉÁªÑ‰∏≠ÊóßÊúâÁöÑÂÄºÊã•ÊúâÂêå‰∏ÄÊï∞ÊçÆÁ±ªÂûã</strong>„ÄÇ</p>\n<ul>\n<li><h2 id=\"ÂàáÁâá-slice\"><a href=\"#ÂàáÁâá-slice\" class=\"headerlink\" title=\"ÂàáÁâá - slice\"></a>ÂàáÁâá - slice</h2>ÊåáÂêëÂÖ∂‰ªñÊï∞ÊçÆÁªìÊûÑÁöÑÂèØÂèòÂ∞∫ÂØ∏ÁöÑÂºïÁî®Á±ªÂûã</li>\n</ul>\n<p>Âú®Êüê‰∫õÂú∫ÊôØ‰∏ã‰Ω†ÂèØËÉΩÈúÄË¶ÅËé∑ÂèñÊàñ‰º†ÈÄíÊüê‰∏™Êï∞ÁªÑÊàñÂÖ∂‰ªñÊï∞ÊçÆÁ±ªÂûãÁöÑ‰∏ÄÈÉ®ÂàÜ„ÄÇÈô§‰∫ÜÂÆåÊï¥ÁöÑÂ∞ÜÂéüÂßãÊï∞ÊçÆËøõË°åÊã∑Ë¥ù‰º†ÈÄí‰ª•Â§ñÔºåRustÂÖÅËÆ∏ÂàõÂª∫Êàñ‰º†ÈÄí‰∏Ä‰∏™ÊåáÂêëÂéüÂßãÊï∞ÊçÆÁöÑÁâáÊÆµÁöÑËßÜÂõæ/ÂºïÁî®ÔºåËøô‰∏™ÂºïÁî®Êó¢ÂèØ‰ª•ÊòØÂèØÂèòÁöÑ‰πüÂèØ‰ª•ÊòØ‰∏çÂèØÂèòÁöÑ„ÄÇ </p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a: [i32; 4] = [1, 2, 3, 4];// ÂéüÂßãÊï∞ÁªÑ\n\nlet b: &amp;[i32] = &amp;a; // ÂÆåÊï¥ÁöÑÂéüÂßãÊï∞ÁªÑÂàáÁâá\nlet c = &amp;a[0..4]; // ÂéüÂßãÊï∞ÁªÑ‰ªéÁ¨¨0‰∏™ÂÖÉÁ¥†Âà∞Á¨¨4‰∏™ÂÖÉÁ¥†Ôºà‰∏çÂåÖÂê´ÔºâÁöÑÂàáÁâá\nlet d = &amp;a[..]; // ÂÆåÊï¥ÁöÑÂéüÂßãÊï∞ÁªÑÂàáÁâá\n\nlet e = &amp;a[1..3]; //[2, 3]\nlet f = &amp;a[1..]; //[2, 3, 4]\nlet g = &amp;a[..3]; //[1, 2, 3]\n</code></pre>\n<ul>\n<li><h2 id=\"str\"><a href=\"#str\" class=\"headerlink\" title=\"str\"></a>str</h2>‰∏çÂÆöÂ∞∫ÂØ∏ÁöÑUnicodeÂ≠ó‰∏≤ÂàáÁâáÔºåÁî±UTF-8Â≠óÁ¨¶ÁªÑÊàêÁöÑÂ∫èÂàó</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = &quot;Hello, world.&quot;; //a: &amp;&#39;static str ‰∏Ä‰∏™ÈùôÊÄÅÂ≠ó‰∏≤ÂàáÁâá\nlet b: &amp;str = &quot;„Åì„Çì„Å´„Å°„ÅØ, ‰∏ñÁïå!&quot;;\n</code></pre>\n<p>‚≠êÔ∏è  strÊòØ‰∏Ä‰∏™<strong>‰∏çÂèØÂèò/ÈùôÊÄÅÁöÑÂ∑≤ÂàÜÈÖçÂÜÖÂ≠òÁöÑÂàáÁâá</strong>ÔºåËøô‰∏™ÂàáÁâáÊåáÂêëÂú®ÂÜÖÂ≠ò‰∏≠ÊüêÂ§ÑÂ≠òÊúâÁöÑ‰∏Ä‰∏™<strong>Êú™Áü•ÈïøÂ∫¶ÁöÑUTF-8Â∫èÂàó</strong>„ÄÇ <strong>&amp;str</strong>Áî®Êù•ÂÄüÁî®Âπ∂ÂàÜÈÖçÊï¥‰∏™Êï∞ÂàóÁªô‰∏Ä‰∏™ÁâπÂÆöÁöÑÂêëÂèòÈáèÁªëÂÆö„ÄÇ</p>\n<blockquote>\n<p>üîé ‰∏Ä‰∏™<a href=\"https://doc.rust-lang.org/std/string/struct.String.html\" target=\"_blank\" rel=\"noopener\">Â≠ó‰∏≤Á±ªÂûã - String</a>ÊòØ‰∏Ä‰∏™Âú®<strong>Â†Ü - heap</strong>‰∏≠ËøõË°åÂàÜÈÖçÁöÑÂ≠ó‰∏≤„ÄÇËøô‰∏™Â≠ó‰∏≤ÊòØÂèØÂ¢ûÁöÑUTF-8Â∫èÂàó„ÄÇÂ≠ó‰∏≤Á±ªÂûãÈÄöÂ∏∏Áî±‰∏Ä‰∏™Â≠ó‰∏≤ÂàáÁâáË∞ÉÁî®<strong>to_string()</strong>ÊñπÊ≥ïËΩ¨Êç¢ËÄåÊù•Ôºå‰πüÂèØÁî±StringÁ±ªÂûãÁöÑÈùôÊÄÅÊñπÊ≥ï<strong>String::from()</strong>ÂØπÂ≠ó‰∏≤ÂàáÁâáËøõË°åËΩ¨Êç¢ËÄåÂæóÂà∞„ÄÇÂ¶ÇÔºö<code>‚ÄúHello‚Äù.to_string();</code>Êàñ<code>String::from(&quot;Hello&quot;);</code></p>\n</blockquote>\n<p>üí° ÈÄöÂ∏∏Êù•ËØ¥ÔºåÂú®ÈúÄË¶ÅËé∑Âèñ<strong>ÊâÄÊúâÊùÉ</strong>Êó∂Ôºå‰Ω†‰ºö‰ΩøÁî®Âà∞<strong>StringÁ±ªÂûã</strong>ÔºåËÄåÂú®‰Ω†‰ªÖÈúÄË¶Å<strong>ÂØπ‰∏Ä‰∏™Â≠ó‰∏≤ÊâßË°åÂÄüÁî®</strong>Êó∂ÔºåÂèØ‰ª•Áõ¥Êé•‰ΩøÁî® <strong><code>&amp;str</code></strong>„ÄÇ</p>\n<ul>\n<li><h2 id=\"functions\"><a href=\"#functions\" class=\"headerlink\" title=\"functions\"></a>functions</h2>Ê≠£Â¶ÇÊàë‰ª¨Âú®ÂáΩÊï∞‰∏ÄËäÇÊèêÂà∞ËøáÁöÑÔºå<code>b</code> ÊòØ‰∏Ä‰∏™ÊåáÂêëÂáΩÊï∞<code>plus_one()</code>ÁöÑÊåáÈíà.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn plus_one(a: i32) -&gt; i32 {\n    a + 1\n}\n\nlet b: fn(i32) -&gt; i32 = plus_one;\nlet c = b(5); //6\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<ul>\n<li><h2 id=\"bool\"><a href=\"#bool\" class=\"headerlink\" title=\"bool\"></a>bool</h2>true or false</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let x = true;\nlet y: bool = false;\n\n// ‚≠êÔ∏è rustÊòØÂº∫Á±ªÂûãËØ≠Ë®ÄÔºåboolÁ±ªÂûã‰∏çÂèØ‰ª•‰ΩøÁî® TRUE, FALSE Êàñ 1, 0 Êù•Êõø‰ª£\n</code></pre>\n<ul>\n<li><h2 id=\"char\"><a href=\"#char\" class=\"headerlink\" title=\"char\"></a>char</h2>‰∏Ä‰∏™Áã¨Á´ãÁöÑUnicodeÊ†áÈáè</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let x = &#39;x&#39;;\nlet y = &#39;üòé&#39;;\n\n// ‚≠êÔ∏è ‰∏çÊòØ &quot;x&quot;Ôºå‰ΩøÁî®ÂçïÂºïÂè∑ÂåÖË£π\n// Âá∫‰∫éÂØπUnicodeÁöÑÊîØÊåÅÔºåcharÂπ∂‰∏çÊòØÂçïÂ≠óËäÇÊï∞ÊçÆÁ±ªÂûãÔºåÊØè‰∏™char‰ºöÂç†Áî®4‰∏™Â≠óËäÇ\n</code></pre>\n<ul>\n<li><h2 id=\"i8-i16-i32-i64-i128\"><a href=\"#i8-i16-i32-i64-i128\" class=\"headerlink\" title=\"i8, i16, i32, i64, i128\"></a>i8, i16, i32, i64, i128</h2>Âõ∫ÂÆöÂ∞∫ÂØ∏Ôºàbit‰ΩçÊï∞ÔºâÊúâÁ¨¶Âè∑ÁöÑÊï¥Êï∞Á±ªÂûã(+/-)</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>DATA TYPE</th>\n<th>MIN</th>\n<th>MAX</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>i8</td>\n<td>-128</td>\n<td>127</td>\n</tr>\n<tr>\n<td>i16</td>\n<td>-32768</td>\n<td>32767</td>\n</tr>\n<tr>\n<td>i32</td>\n<td>-2147483648</td>\n<td>2147483647</td>\n</tr>\n<tr>\n<td>i64</td>\n<td>-9223372036854775808</td>\n<td>9223372036854775807</td>\n</tr>\n<tr>\n<td>i128</td>\n<td>-170141183460469231731687303715884105728</td>\n<td>170141183460469231731687303715884105727</td>\n</tr>\n</tbody>\n</table>\n<p>üí° ÊØè‰∏ÄÁ±ªÂûãÁöÑÊúÄÂ§ßÂíåÊúÄÂ∞èÂÄºÔºåÂèñÂÄºËåÉÂõ¥‰∏∫ <strong>-2‚Åø‚Åª¬π Âà∞ 2‚Åø‚Åª¬π-1</strong>„ÄÇ‰Ω†ÂèØ‰ª•‰ΩøÁî® <strong>min_value()</strong> Âíå <strong>max_value()</strong> ÊñπÊ≥ïÊù•Ëé∑ÂèñÊØè‰∏™Êï¥ÂûãÁöÑÊúÄÂ∞è‰∏éÊúÄÂ§ßÂÄºÔºåÂ¶ÇÔºöi8::min_value();</p>\n<ul>\n<li><h2 id=\"u8-u16-u32-u64-u128\"><a href=\"#u8-u16-u32-u64-u128\" class=\"headerlink\" title=\"u8, u16, u32, u64, u128\"></a>u8, u16, u32, u64, u128</h2>Âõ∫ÂÆöÂ∞∫ÂØ∏Ôºàbit‰ΩçÊï∞ÔºâÊó†Á¨¶Âè∑ÈùûË¥üÊï¥Âûã</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Êï∞ÊçÆÁ±ªÂûã</th>\n<th>ÊúÄÂ∞èÂÄº</th>\n<th>ÊúÄÂ§ßÂÄº</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>u8</td>\n<td>0</td>\n<td>255</td>\n</tr>\n<tr>\n<td>u16</td>\n<td>0</td>\n<td>65535</td>\n</tr>\n<tr>\n<td>u32</td>\n<td>0</td>\n<td>4294967295</td>\n</tr>\n<tr>\n<td>u64</td>\n<td>0</td>\n<td>18446744073709551615</td>\n</tr>\n<tr>\n<td>u128</td>\n<td>0</td>\n<td>340282366920938463463374607431768211455</td>\n</tr>\n</tbody>\n</table>\n<p>üí°ÈùûË¥üÊï¥ÂûãÂèñÂÄºËåÉÂõ¥‰ªé<strong>0</strong>Ëá≥<strong>2‚Åø-1</strong>„ÄÇÂêåÊ†∑Âú∞Ôºå‰Ω†‰πüÂèØ‰ª•‰ΩøÁî®<strong>min_value()</strong>Âíå<strong>max_value()</strong>Êù•ÂØªÊâæÊØè‰∏™Êï¥ÂûãÁ±ªÂûãÁöÑÊúÄÂ∞èÂíåÊúÄÂ§ßÂÄºÔºåÂ¶ÇÔºöu8::max_value();</p>\n<ul>\n<li><h2 id=\"isize-usize\"><a href=\"#isize-usize\" class=\"headerlink\" title=\"isize, usize\"></a>isize, usize</h2>ÂêåÊåáÈíàÂ∞∫ÂØ∏ÁöÑÂ∏¶Á¨¶Âè∑Êï¥Âûã/ÈùûË¥üÊï¥ÂΩ¢</li>\n</ul>\n<p>ËØ•Á±ªÂûãÁöÑÂÆûÈôÖÂç†Áî®bit‰ΩçÊï∞ÂèñÂÜ≥‰∫éËøêË°åÁ®ãÂ∫èÁöÑËÆ°ÁÆóÊú∫Êû∂ÊûÑ„ÄÇÈªòËÆ§ÊÉÖÂÜµ‰∏ãÔºåÂú®32‰ΩçËÆ°ÁÆóÊú∫‰∏äÔºåËØ•Á±ªÂûãÂç†Áî®32‰ΩçÔºåÂú®64‰ΩçÂπ≥Âè∞‰∏äÂàôÂç†Áî®64‰Ωç„ÄÇ</p>\n<blockquote>\n<p>üîé Êõ¥Â§öÂÜÖÂÆπÂèØ‰ª•Êü•ÁúãRustÁ®ãÂ∫è‰∏≠ÁöÑ<a href=\"https://github.com/rust-lang/rustup.rs#cross-compilation\" target=\"_blank\" rel=\"noopener\">‰∫§ÂèâÁºñËØë</a>Âíå<a href=\"https://forge.rust-lang.org/platform-support.html\" target=\"_blank\" rel=\"noopener\">Supported Tiers</a>Á≠âÁ´†ËäÇ„ÄÇ</p>\n</blockquote>\n<ul>\n<li><h2 id=\"f32-f64\"><a href=\"#f32-f64\" class=\"headerlink\" title=\"f32, f64\"></a>f32, f64</h2>ÂÜÖÂ≠òÂç†Áî®‰∏∫32Âíå64‰ΩçÁöÑÊµÆÁÇπÊï∞ÔºàÂ∞èÊï∞Ôºâ</li>\n</ul>\n<p>RustÈÅµÂæ™IEEE‰∫åËøõÂà∂ÊµÆÁÇπÊï∞ÁÆóÊ≥ïÊ†áÂáÜ„ÄÇÂÖ∂‰∏≠<code>f32</code>Á±ªÂûãÁ±ª‰ºº‰∫éÂÖ∂‰ªñËØ≠Ë®Ä‰∏≠ÁöÑfloat(<strong>ÂçïÁ≤æÂ∫¶ÊµÆÁÇπÊï∞</strong>)ÔºåËÄå<code>f64</code>ÂàôÁ±ª‰ºº‰∫éÂÖ∂‰ªñËØ≠Ë®Ä‰∏≠ÁöÑdouble(<strong>ÂèåÁ≤æÂ∫¶ÊµÆÁÇπÊï∞</strong>)„ÄÇ</p>\n<p>üí° Âú®ÂΩìÂâçÁöÑÊÉÖÂÜµ‰∏ãÔºåÊé®ËçêÈÅøÂÖç‰ΩøÁî®f32Á±ªÂûãÊï∞ÊçÆÔºåÈô§Èùû‰Ω†Â∏åÊúõÈ´òÂ∫¶ËäÇÁúÅÁ®ãÂ∫èÁöÑÂÜÖÂ≠ò‰ΩøÁî®ÔºåÊàñËÄÖË¶ÅËøêË°å‰Ω†Á®ãÂ∫èÁöÑÁõÆÊ†áËÆæÂ§á‰∏çÊîØÊåÅ64‰ΩçÔºåÊàñÁõÆÊ†áËÆæÂ§áÂØπ32‰ΩçÁ®ãÂ∫èËøõË°å‰∫ÜÁâπÊÆä‰ºòÂåñ„ÄÇ</p>\n<ul>\n<li><h2 id=\"Êï∞ÁªÑ-arrays\"><a href=\"#Êï∞ÁªÑ-arrays\" class=\"headerlink\" title=\"Êï∞ÁªÑ - arrays\"></a>Êï∞ÁªÑ - arrays</h2>Âõ∫ÂÆöÂ∞∫ÂØ∏ÁöÑÂåÖÂê´ÂêåË¥®Êï∞ÊçÆÁöÑÊúâÂ∫èÊï∞ÊçÆÂÆπÂô®„ÄÇ</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = [1, 2, 3]; // a[0] = 1, a[1] = 2, a[2] = 3\nlet mut b = [1, 2, 3];\n\nlet c: [i32; 0] = []; //[Type; NO of elements] -&gt; [] /Á©∫Êï∞ÁªÑ\nlet d: [i32; 3] = [1, 2, 3];\n\nlet e = [&quot;my value&quot;; 3]; //[&quot;my value&quot;, &quot;my value&quot;, &quot;my value&quot;];\n\nprintln!(&quot;{:?}&quot;, a); //[1, 2, 3]\nprintln!(&quot;{:#?}&quot;, a);\n//  [\n//      1,\n//      2,\n//      3\n//  ]\n</code></pre>\n<p>‚≠êÔ∏è ÈªòËÆ§ÊÉÖÂÜµ‰∏ãÔºåÊï∞ÁªÑÊòØ<strong>‰∏çÂèØÂèò(immutable)</strong>ÁöÑ„ÄÇÂπ∂‰∏îÔºåÂç≥‰Ωø<strong>Â∏¶Êúâ<code>mut</code>ÂÖ≥ÈîÆÂ≠óÔºå‰πüÂè™ËÉΩ‰øÆÊîπÊï∞ÁªÑ‰∏≠ÁöÑÂÖÉÁ¥†ÔºåËÄåÂÖÉÁ¥†Êï∞Èáè‰πüÊòØ‰∏çÂèØÊõ¥ÊîπÁöÑ</strong>„ÄÇ</p>\n<blockquote>\n<p>üîé Â¶ÇÊûú‰Ω†Âú®ÂØªÊâæ‰∏Ä‰∏™Âä®ÊÄÅÁöÑ/ÂèØÂ¢ûÁöÑÊï∞ÁªÑÔºå‰Ω†ÂèØ‰ª•‰ΩøÁî®<strong>Vec</strong>Á±ªÂûã„ÄÇVectorÁ±ªÂûãÂèØ‰ª•ÂåÖÂê´‰ªªÊÑèÊï∞ÈáèÁöÑÂÖÉÁ¥†Ôºå‰ΩÜ‰ªçË¶Å‰øùÊåÅÊâÄÊúâÂÖÉÁ¥†ÁöÑÁ±ªÂûãÁªü‰∏Ä„ÄÇ</p>\n</blockquote>\n<ul>\n<li><h2 id=\"ÂÖÉÁªÑ-tuples\"><a href=\"#ÂÖÉÁªÑ-tuples\" class=\"headerlink\" title=\"ÂÖÉÁªÑ - tuples\"></a>ÂÖÉÁªÑ - tuples</h2>Âõ∫ÂÆöÂ§ßÂ∞èÁöÑÊúâÂ∫èÁöÑÂêåË¥®/ÈùûÂêåË¥®Êï∞ÊçÆÊâÄÁªÑÊàêÁöÑÂàóË°®„ÄÇ</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = (1, 1.5, true, &#39;a&#39;, &quot;Hello, world!&quot;);\n// a.0 = 1, a.1 = 1.5, a.2 = true, a.3 = &#39;a&#39;, a.4 = &quot;Hello, world!&quot;\n\nlet b: (i32, f64) = (1, 1.5);\n\nlet (c, d) = b; // c = 1, d = 1.5\nlet (e, _, _, _, f) = a; //e = 1, f = &quot;Hello, world!&quot;, ‰∏ãÂàíÁ∫ø _ ÊÑèÂë≥ÁùÄÂøΩÁï•ËØ•‰ΩçÁΩÆÂÖ≥ËÅîÁöÑÂÖÉÁ¥†\n\nlet g = (0,); // ÂçïÂÖÉÁ¥†ÂÖÉÁªÑ\n\nlet h = (b, (2, 4), 5); //((1, 1.5), (2, 4), 5)\n\nprintln!(&quot;{:?}&quot;, a); //(1, 1.5, true, &#39;a&#39;, &quot;Hello, world!&quot;)\n</code></pre>\n<p>‚≠êÔ∏è ÂÖÉÁªÑÂú®ÈªòËÆ§ÊÉÖÂÜµ‰∏ãÂêåÊ†∑ÊòØ<strong>‰∏çÂèØÂèò</strong>ÁöÑÔºå<strong>Âç≥‰Ωø‰ΩøÁî®‰∫Ü<code>mut</code>ÂÖ≥ÈîÆÂ≠óÔºåÂÖÉÁªÑÁöÑÂÖÉÁ¥†Êï∞Èáè‰πü‰∏çÂèØÊõ¥Êîπ„ÄÇÂêåÊ†∑Âú∞ÔºåÂ¶ÇÊûú‰Ω†ÈúÄË¶Å‰øÆÊîπ‰∏Ä‰∏™ÂÖÉÁ¥†ÁöÑÂÄºÔºåÊñ∞ÁöÑÂÄºÂ∫îËØ•‰∏éÂÖÉÁªÑ‰∏≠ÊóßÊúâÁöÑÂÄºÊã•ÊúâÂêå‰∏ÄÊï∞ÊçÆÁ±ªÂûã</strong>„ÄÇ</p>\n<ul>\n<li><h2 id=\"ÂàáÁâá-slice\"><a href=\"#ÂàáÁâá-slice\" class=\"headerlink\" title=\"ÂàáÁâá - slice\"></a>ÂàáÁâá - slice</h2>ÊåáÂêëÂÖ∂‰ªñÊï∞ÊçÆÁªìÊûÑÁöÑÂèØÂèòÂ∞∫ÂØ∏ÁöÑÂºïÁî®Á±ªÂûã</li>\n</ul>\n<p>Âú®Êüê‰∫õÂú∫ÊôØ‰∏ã‰Ω†ÂèØËÉΩÈúÄË¶ÅËé∑ÂèñÊàñ‰º†ÈÄíÊüê‰∏™Êï∞ÁªÑÊàñÂÖ∂‰ªñÊï∞ÊçÆÁ±ªÂûãÁöÑ‰∏ÄÈÉ®ÂàÜ„ÄÇÈô§‰∫ÜÂÆåÊï¥ÁöÑÂ∞ÜÂéüÂßãÊï∞ÊçÆËøõË°åÊã∑Ë¥ù‰º†ÈÄí‰ª•Â§ñÔºåRustÂÖÅËÆ∏ÂàõÂª∫Êàñ‰º†ÈÄí‰∏Ä‰∏™ÊåáÂêëÂéüÂßãÊï∞ÊçÆÁöÑÁâáÊÆµÁöÑËßÜÂõæ/ÂºïÁî®ÔºåËøô‰∏™ÂºïÁî®Êó¢ÂèØ‰ª•ÊòØÂèØÂèòÁöÑ‰πüÂèØ‰ª•ÊòØ‰∏çÂèØÂèòÁöÑ„ÄÇ </p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a: [i32; 4] = [1, 2, 3, 4];// ÂéüÂßãÊï∞ÁªÑ\n\nlet b: &amp;[i32] = &amp;a; // ÂÆåÊï¥ÁöÑÂéüÂßãÊï∞ÁªÑÂàáÁâá\nlet c = &amp;a[0..4]; // ÂéüÂßãÊï∞ÁªÑ‰ªéÁ¨¨0‰∏™ÂÖÉÁ¥†Âà∞Á¨¨4‰∏™ÂÖÉÁ¥†Ôºà‰∏çÂåÖÂê´ÔºâÁöÑÂàáÁâá\nlet d = &amp;a[..]; // ÂÆåÊï¥ÁöÑÂéüÂßãÊï∞ÁªÑÂàáÁâá\n\nlet e = &amp;a[1..3]; //[2, 3]\nlet f = &amp;a[1..]; //[2, 3, 4]\nlet g = &amp;a[..3]; //[1, 2, 3]\n</code></pre>\n<ul>\n<li><h2 id=\"str\"><a href=\"#str\" class=\"headerlink\" title=\"str\"></a>str</h2>‰∏çÂÆöÂ∞∫ÂØ∏ÁöÑUnicodeÂ≠ó‰∏≤ÂàáÁâáÔºåÁî±UTF-8Â≠óÁ¨¶ÁªÑÊàêÁöÑÂ∫èÂàó</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = &quot;Hello, world.&quot;; //a: &amp;&#39;static str ‰∏Ä‰∏™ÈùôÊÄÅÂ≠ó‰∏≤ÂàáÁâá\nlet b: &amp;str = &quot;„Åì„Çì„Å´„Å°„ÅØ, ‰∏ñÁïå!&quot;;\n</code></pre>\n<p>‚≠êÔ∏è  strÊòØ‰∏Ä‰∏™<strong>‰∏çÂèØÂèò/ÈùôÊÄÅÁöÑÂ∑≤ÂàÜÈÖçÂÜÖÂ≠òÁöÑÂàáÁâá</strong>ÔºåËøô‰∏™ÂàáÁâáÊåáÂêëÂú®ÂÜÖÂ≠ò‰∏≠ÊüêÂ§ÑÂ≠òÊúâÁöÑ‰∏Ä‰∏™<strong>Êú™Áü•ÈïøÂ∫¶ÁöÑUTF-8Â∫èÂàó</strong>„ÄÇ <strong>&amp;str</strong>Áî®Êù•ÂÄüÁî®Âπ∂ÂàÜÈÖçÊï¥‰∏™Êï∞ÂàóÁªô‰∏Ä‰∏™ÁâπÂÆöÁöÑÂêëÂèòÈáèÁªëÂÆö„ÄÇ</p>\n<blockquote>\n<p>üîé ‰∏Ä‰∏™<a href=\"https://doc.rust-lang.org/std/string/struct.String.html\" target=\"_blank\" rel=\"noopener\">Â≠ó‰∏≤Á±ªÂûã - String</a>ÊòØ‰∏Ä‰∏™Âú®<strong>Â†Ü - heap</strong>‰∏≠ËøõË°åÂàÜÈÖçÁöÑÂ≠ó‰∏≤„ÄÇËøô‰∏™Â≠ó‰∏≤ÊòØÂèØÂ¢ûÁöÑUTF-8Â∫èÂàó„ÄÇÂ≠ó‰∏≤Á±ªÂûãÈÄöÂ∏∏Áî±‰∏Ä‰∏™Â≠ó‰∏≤ÂàáÁâáË∞ÉÁî®<strong>to_string()</strong>ÊñπÊ≥ïËΩ¨Êç¢ËÄåÊù•Ôºå‰πüÂèØÁî±StringÁ±ªÂûãÁöÑÈùôÊÄÅÊñπÊ≥ï<strong>String::from()</strong>ÂØπÂ≠ó‰∏≤ÂàáÁâáËøõË°åËΩ¨Êç¢ËÄåÂæóÂà∞„ÄÇÂ¶ÇÔºö<code>‚ÄúHello‚Äù.to_string();</code>Êàñ<code>String::from(&quot;Hello&quot;);</code></p>\n</blockquote>\n<p>üí° ÈÄöÂ∏∏Êù•ËØ¥ÔºåÂú®ÈúÄË¶ÅËé∑Âèñ<strong>ÊâÄÊúâÊùÉ</strong>Êó∂Ôºå‰Ω†‰ºö‰ΩøÁî®Âà∞<strong>StringÁ±ªÂûã</strong>ÔºåËÄåÂú®‰Ω†‰ªÖÈúÄË¶Å<strong>ÂØπ‰∏Ä‰∏™Â≠ó‰∏≤ÊâßË°åÂÄüÁî®</strong>Êó∂ÔºåÂèØ‰ª•Áõ¥Êé•‰ΩøÁî® <strong><code>&amp;str</code></strong>„ÄÇ</p>\n<ul>\n<li><h2 id=\"functions\"><a href=\"#functions\" class=\"headerlink\" title=\"functions\"></a>functions</h2>Ê≠£Â¶ÇÊàë‰ª¨Âú®ÂáΩÊï∞‰∏ÄËäÇÊèêÂà∞ËøáÁöÑÔºå<code>b</code> ÊòØ‰∏Ä‰∏™ÊåáÂêëÂáΩÊï∞<code>plus_one()</code>ÁöÑÊåáÈíà.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn plus_one(a: i32) -&gt; i32 {\n    a + 1\n}\n\nlet b: fn(i32) -&gt; i32 = plus_one;\nlet c = b(5); //6\n</code></pre>\n"},{"title":"Êìç‰ΩúÁ¨¶","_content":"\n## Êï∞Â≠¶ËøêÁÆóÊìç‰ΩúÁ¨¶\n** + - * / %**\n\n```rust\nlet a = 5;\nlet b = a + 1; //6\nlet c = a - 1; //4\nlet d = a * 2; //10\nlet e = a / 2; // ‚≠êÔ∏è 2 not 2.5\nlet f = a % 2; //1\n\nlet g = 5.0 / 2.0; //2.5\n```\n\n> üí° Êìç‰ΩúÁ¨¶ **+** ‰πüË¢´Áî®Êù•ËøõË°åÊï∞ÂàóÂíåÂ≠óÁ¨¶‰∏≤ÁöÑËøûÊé•**\n\n\n## ÊØîËæÉÊìç‰ΩúÁ¨¶\n== != < > <= >=\n\n```rust\nlet a = 1;\nlet b = 2;\n\nlet c = a == b; //false\nlet d = a != b; //true\nlet e = a < b; //true\nlet f = a > b; //false\nlet g = a <= a; //true\nlet h = a >= a; //true\n\n// üîé\nlet i = true > false; //true\nlet j = 'a' > 'A'; //true\n```\n\n\n## ÈÄªËæëËøêÁÆóÊìç‰ΩúÁ¨¶\n! && ||\n\n```rust\nlet a = true;\nlet b = false;\n\nlet c = !a; //false\nlet d = a && b; //false\nlet e = a || b; //true\n```\n\n> üîé ÂØπ‰∫éÊï¥ÂûãÊù•ËØ¥Ôºå! Êìç‰ΩúÁ¨¶‰ºöÂú®Êï¥ÂûãÁöÑÂÜÖÂ≠òË°®Á§∫‰∏äÂØπÊØè‰∏Ä‰∏™Áã¨Á´ãbitÂèñÂèç„ÄÇ\n\n```rust\nlet a = !-2; //1\nlet b = !-1; //0\nlet c = !0; //-1\nlet d = !1; //-2\n```\n\n\n## ÊØîÁâπ‰ΩçÊìç‰ΩúÁ¨¶\n& | ^ << >>\n\n```rust\nlet a = 1;\nlet b = 2;\n\nlet c = a & b; //0  (01 && 10 -> 00)\nlet d = a | b; //3  (01 || 10 -> 11)\nlet e = a ^ b; //3  (01 != 10 -> 11)\nlet f = a << b; //4  (ÂÜÖÂ≠òÂÄºÂ∑¶Áßª‰∏§‰ΩçÔºåÊú´Â∞æÁî®0Ë°•Ë∂≥ -> '01'+'00' -> 100)\nlet g = a >> a; //0  (ÂÜÖÂ≠òÂÄºÂè≥Áßª‰∏§‰ΩçÔºåÊúÄÊú´‰∏§‰ΩçÊà™Êñ≠ÔºåÂ∑¶‰æßÁî®0Ë°•Ë∂≥ -> oÃ∂1Ã∂ -> 0)\n```\n\n\n## ËµãÂÄºËøêÁÆóÁ¨¶‰∏éÁ¨¶ÂêàËµãÂÄºËøêÁÆóÁ¨¶\n\nÊìç‰ΩúÁ¨¶`=`Áî®Êù•‰∏∫ÂèòÈáèÂàÜÈÖç‰∏Ä‰∏™Ë°®ËææÂºèÔºà‰∏Ä‰∏™ÂÄºÊàñËÄÖ‰∏Ä‰∏™functionÂ£∞ÊòéÔºâÔºå‰πüÂèØ‰ª•Áî®Êù•‰∏∫‰∏Ä‰∏™Á±ªÂûãÊ†áËØÜÂàÜÈÖçÁ±ªÂûãÂÆö‰πâ„ÄÇÁ¨¶ÂêàËµãÂÄºÊìç‰ΩúÁ¨¶ÊòØÁî±`+ - * / % & | ^ << >>`Á≠âÊìç‰ΩúÁ¨¶‰∏≠ÁöÑÂÖ∂‰∏≠‰∏ÄÂëò‰∏éËµãÂÄºÊìç‰ΩúÁ¨¶`=`ÁªìÂêàËÄåÊàêÁöÑ.\n\n```rust\nlet mut a = 2;\n\na += 5; //2 + 5 = 7\na -= 2; //7 - 2 = 5\na *= 5; //5 * 5 = 25\na /= 2; //25 / 2 = 12 not 12.5\na %= 5; //12 % 5 = 2\n\na &= 2; //10 && 10 -> 10 -> 2\na |= 5; //010 || 101 -> 111 -> 7\na ^= 2; //111 != 010 -> 101 -> 5\na <<= 1; //'101'+'0' -> 1010 -> 10\na >>= 2; //101Ã∂0Ã∂ -> 10 -> 2\n```\n\n\n## Á±ªÂûãËΩ¨Êç¢Êìç‰ΩúÁ¨¶\nas\n\n```rust\nlet a = 15;\nlet b = (a as f64) / 2.0; //7.5\n```\n\n\n## ÂÄüÁî®‰∏éËß£ÂºïÁî®Êìç‰ΩúÁ¨¶\n& &mut *\n\nÊìç‰ΩúÁ¨¶ **& Êàñ &mut** ‰Ωú‰∏∫ÂÄüÁî®Êìç‰ΩúÁ¨¶‰ΩøÁî®ÔºåÁî®‰ª•‰∏¥Êó∂ÂèñÂæóÊüêÂèòÈáèÁöÑÊâÄÊúâÊùÉÔºåËÄå*****Êìç‰ΩúÁ¨¶ÂàôÁî®‰ª•Âú®‰ΩøÁî®ÁöÑËøáÁ®ã‰∏≠**Ëß£ÂºïDereferencing**„ÄÇ\n\n> üîé Êõ¥Â§ö‰ø°ÊÅØÂèØ‰ª•ÂèÇËÄÉ[ÊâÄÊúâÊùÉ - Ownership](c1.ownership.html), [ÂÄüÁî® - Borrowing](c2.borrowing.html) & [ÁîüÂëΩÂë®Êúü - Lifetimes](c3.lifetimes.html)Á≠âÁ´†ËäÇ„ÄÇ\n","source":"docs/zh-cn/a9.operators.md","raw":"title: Êìç‰ΩúÁ¨¶\n---\n\n## Êï∞Â≠¶ËøêÁÆóÊìç‰ΩúÁ¨¶\n** + - * / %**\n\n```rust\nlet a = 5;\nlet b = a + 1; //6\nlet c = a - 1; //4\nlet d = a * 2; //10\nlet e = a / 2; // ‚≠êÔ∏è 2 not 2.5\nlet f = a % 2; //1\n\nlet g = 5.0 / 2.0; //2.5\n```\n\n> üí° Êìç‰ΩúÁ¨¶ **+** ‰πüË¢´Áî®Êù•ËøõË°åÊï∞ÂàóÂíåÂ≠óÁ¨¶‰∏≤ÁöÑËøûÊé•**\n\n\n## ÊØîËæÉÊìç‰ΩúÁ¨¶\n== != < > <= >=\n\n```rust\nlet a = 1;\nlet b = 2;\n\nlet c = a == b; //false\nlet d = a != b; //true\nlet e = a < b; //true\nlet f = a > b; //false\nlet g = a <= a; //true\nlet h = a >= a; //true\n\n// üîé\nlet i = true > false; //true\nlet j = 'a' > 'A'; //true\n```\n\n\n## ÈÄªËæëËøêÁÆóÊìç‰ΩúÁ¨¶\n! && ||\n\n```rust\nlet a = true;\nlet b = false;\n\nlet c = !a; //false\nlet d = a && b; //false\nlet e = a || b; //true\n```\n\n> üîé ÂØπ‰∫éÊï¥ÂûãÊù•ËØ¥Ôºå! Êìç‰ΩúÁ¨¶‰ºöÂú®Êï¥ÂûãÁöÑÂÜÖÂ≠òË°®Á§∫‰∏äÂØπÊØè‰∏Ä‰∏™Áã¨Á´ãbitÂèñÂèç„ÄÇ\n\n```rust\nlet a = !-2; //1\nlet b = !-1; //0\nlet c = !0; //-1\nlet d = !1; //-2\n```\n\n\n## ÊØîÁâπ‰ΩçÊìç‰ΩúÁ¨¶\n& | ^ << >>\n\n```rust\nlet a = 1;\nlet b = 2;\n\nlet c = a & b; //0  (01 && 10 -> 00)\nlet d = a | b; //3  (01 || 10 -> 11)\nlet e = a ^ b; //3  (01 != 10 -> 11)\nlet f = a << b; //4  (ÂÜÖÂ≠òÂÄºÂ∑¶Áßª‰∏§‰ΩçÔºåÊú´Â∞æÁî®0Ë°•Ë∂≥ -> '01'+'00' -> 100)\nlet g = a >> a; //0  (ÂÜÖÂ≠òÂÄºÂè≥Áßª‰∏§‰ΩçÔºåÊúÄÊú´‰∏§‰ΩçÊà™Êñ≠ÔºåÂ∑¶‰æßÁî®0Ë°•Ë∂≥ -> oÃ∂1Ã∂ -> 0)\n```\n\n\n## ËµãÂÄºËøêÁÆóÁ¨¶‰∏éÁ¨¶ÂêàËµãÂÄºËøêÁÆóÁ¨¶\n\nÊìç‰ΩúÁ¨¶`=`Áî®Êù•‰∏∫ÂèòÈáèÂàÜÈÖç‰∏Ä‰∏™Ë°®ËææÂºèÔºà‰∏Ä‰∏™ÂÄºÊàñËÄÖ‰∏Ä‰∏™functionÂ£∞ÊòéÔºâÔºå‰πüÂèØ‰ª•Áî®Êù•‰∏∫‰∏Ä‰∏™Á±ªÂûãÊ†áËØÜÂàÜÈÖçÁ±ªÂûãÂÆö‰πâ„ÄÇÁ¨¶ÂêàËµãÂÄºÊìç‰ΩúÁ¨¶ÊòØÁî±`+ - * / % & | ^ << >>`Á≠âÊìç‰ΩúÁ¨¶‰∏≠ÁöÑÂÖ∂‰∏≠‰∏ÄÂëò‰∏éËµãÂÄºÊìç‰ΩúÁ¨¶`=`ÁªìÂêàËÄåÊàêÁöÑ.\n\n```rust\nlet mut a = 2;\n\na += 5; //2 + 5 = 7\na -= 2; //7 - 2 = 5\na *= 5; //5 * 5 = 25\na /= 2; //25 / 2 = 12 not 12.5\na %= 5; //12 % 5 = 2\n\na &= 2; //10 && 10 -> 10 -> 2\na |= 5; //010 || 101 -> 111 -> 7\na ^= 2; //111 != 010 -> 101 -> 5\na <<= 1; //'101'+'0' -> 1010 -> 10\na >>= 2; //101Ã∂0Ã∂ -> 10 -> 2\n```\n\n\n## Á±ªÂûãËΩ¨Êç¢Êìç‰ΩúÁ¨¶\nas\n\n```rust\nlet a = 15;\nlet b = (a as f64) / 2.0; //7.5\n```\n\n\n## ÂÄüÁî®‰∏éËß£ÂºïÁî®Êìç‰ΩúÁ¨¶\n& &mut *\n\nÊìç‰ΩúÁ¨¶ **& Êàñ &mut** ‰Ωú‰∏∫ÂÄüÁî®Êìç‰ΩúÁ¨¶‰ΩøÁî®ÔºåÁî®‰ª•‰∏¥Êó∂ÂèñÂæóÊüêÂèòÈáèÁöÑÊâÄÊúâÊùÉÔºåËÄå*****Êìç‰ΩúÁ¨¶ÂàôÁî®‰ª•Âú®‰ΩøÁî®ÁöÑËøáÁ®ã‰∏≠**Ëß£ÂºïDereferencing**„ÄÇ\n\n> üîé Êõ¥Â§ö‰ø°ÊÅØÂèØ‰ª•ÂèÇËÄÉ[ÊâÄÊúâÊùÉ - Ownership](c1.ownership.html), [ÂÄüÁî® - Borrowing](c2.borrowing.html) & [ÁîüÂëΩÂë®Êúü - Lifetimes](c3.lifetimes.html)Á≠âÁ´†ËäÇ„ÄÇ\n","date":"2019-03-21T03:16:34.549Z","updated":"2019-03-21T03:16:34.549Z","path":"docs/zh-cn/a9.operators.html","_id":"cjtfwbj0s0018dwgp6ej4s072","comments":1,"layout":"page","content":"<h2 id=\"Êï∞Â≠¶ËøêÁÆóÊìç‰ΩúÁ¨¶\"><a href=\"#Êï∞Â≠¶ËøêÁÆóÊìç‰ΩúÁ¨¶\" class=\"headerlink\" title=\"Êï∞Â≠¶ËøêÁÆóÊìç‰ΩúÁ¨¶\"></a>Êï∞Â≠¶ËøêÁÆóÊìç‰ΩúÁ¨¶</h2><p><strong> + - * / %</strong></p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = 5;\nlet b = a + 1; //6\nlet c = a - 1; //4\nlet d = a * 2; //10\nlet e = a / 2; // ‚≠êÔ∏è 2 not 2.5\nlet f = a % 2; //1\n\nlet g = 5.0 / 2.0; //2.5\n</code></pre>\n<blockquote>\n<p>üí° Êìç‰ΩúÁ¨¶ <strong>+</strong> ‰πüË¢´Áî®Êù•ËøõË°åÊï∞ÂàóÂíåÂ≠óÁ¨¶‰∏≤ÁöÑËøûÊé•**</p>\n</blockquote>\n<h2 id=\"ÊØîËæÉÊìç‰ΩúÁ¨¶\"><a href=\"#ÊØîËæÉÊìç‰ΩúÁ¨¶\" class=\"headerlink\" title=\"ÊØîËæÉÊìç‰ΩúÁ¨¶\"></a>ÊØîËæÉÊìç‰ΩúÁ¨¶</h2><p>== != &lt; &gt; &lt;= &gt;=</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = 1;\nlet b = 2;\n\nlet c = a == b; //false\nlet d = a != b; //true\nlet e = a &lt; b; //true\nlet f = a &gt; b; //false\nlet g = a &lt;= a; //true\nlet h = a &gt;= a; //true\n\n// üîé\nlet i = true &gt; false; //true\nlet j = &#39;a&#39; &gt; &#39;A&#39;; //true\n</code></pre>\n<h2 id=\"ÈÄªËæëËøêÁÆóÊìç‰ΩúÁ¨¶\"><a href=\"#ÈÄªËæëËøêÁÆóÊìç‰ΩúÁ¨¶\" class=\"headerlink\" title=\"ÈÄªËæëËøêÁÆóÊìç‰ΩúÁ¨¶\"></a>ÈÄªËæëËøêÁÆóÊìç‰ΩúÁ¨¶</h2><p>! &amp;&amp; ||</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = true;\nlet b = false;\n\nlet c = !a; //false\nlet d = a &amp;&amp; b; //false\nlet e = a || b; //true\n</code></pre>\n<blockquote>\n<p>üîé ÂØπ‰∫éÊï¥ÂûãÊù•ËØ¥Ôºå! Êìç‰ΩúÁ¨¶‰ºöÂú®Êï¥ÂûãÁöÑÂÜÖÂ≠òË°®Á§∫‰∏äÂØπÊØè‰∏Ä‰∏™Áã¨Á´ãbitÂèñÂèç„ÄÇ</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = !-2; //1\nlet b = !-1; //0\nlet c = !0; //-1\nlet d = !1; //-2\n</code></pre>\n<h2 id=\"ÊØîÁâπ‰ΩçÊìç‰ΩúÁ¨¶\"><a href=\"#ÊØîÁâπ‰ΩçÊìç‰ΩúÁ¨¶\" class=\"headerlink\" title=\"ÊØîÁâπ‰ΩçÊìç‰ΩúÁ¨¶\"></a>ÊØîÁâπ‰ΩçÊìç‰ΩúÁ¨¶</h2><p>&amp; | ^ &lt;&lt; &gt;&gt;</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = 1;\nlet b = 2;\n\nlet c = a &amp; b; //0  (01 &amp;&amp; 10 -&gt; 00)\nlet d = a | b; //3  (01 || 10 -&gt; 11)\nlet e = a ^ b; //3  (01 != 10 -&gt; 11)\nlet f = a &lt;&lt; b; //4  (ÂÜÖÂ≠òÂÄºÂ∑¶Áßª‰∏§‰ΩçÔºåÊú´Â∞æÁî®0Ë°•Ë∂≥ -&gt; &#39;01&#39;+&#39;00&#39; -&gt; 100)\nlet g = a &gt;&gt; a; //0  (ÂÜÖÂ≠òÂÄºÂè≥Áßª‰∏§‰ΩçÔºåÊúÄÊú´‰∏§‰ΩçÊà™Êñ≠ÔºåÂ∑¶‰æßÁî®0Ë°•Ë∂≥ -&gt; oÃ∂1Ã∂ -&gt; 0)\n</code></pre>\n<h2 id=\"ËµãÂÄºËøêÁÆóÁ¨¶‰∏éÁ¨¶ÂêàËµãÂÄºËøêÁÆóÁ¨¶\"><a href=\"#ËµãÂÄºËøêÁÆóÁ¨¶‰∏éÁ¨¶ÂêàËµãÂÄºËøêÁÆóÁ¨¶\" class=\"headerlink\" title=\"ËµãÂÄºËøêÁÆóÁ¨¶‰∏éÁ¨¶ÂêàËµãÂÄºËøêÁÆóÁ¨¶\"></a>ËµãÂÄºËøêÁÆóÁ¨¶‰∏éÁ¨¶ÂêàËµãÂÄºËøêÁÆóÁ¨¶</h2><p>Êìç‰ΩúÁ¨¶<code>=</code>Áî®Êù•‰∏∫ÂèòÈáèÂàÜÈÖç‰∏Ä‰∏™Ë°®ËææÂºèÔºà‰∏Ä‰∏™ÂÄºÊàñËÄÖ‰∏Ä‰∏™functionÂ£∞ÊòéÔºâÔºå‰πüÂèØ‰ª•Áî®Êù•‰∏∫‰∏Ä‰∏™Á±ªÂûãÊ†áËØÜÂàÜÈÖçÁ±ªÂûãÂÆö‰πâ„ÄÇÁ¨¶ÂêàËµãÂÄºÊìç‰ΩúÁ¨¶ÊòØÁî±<code>+ - * / % &amp; | ^ &lt;&lt; &gt;&gt;</code>Á≠âÊìç‰ΩúÁ¨¶‰∏≠ÁöÑÂÖ∂‰∏≠‰∏ÄÂëò‰∏éËµãÂÄºÊìç‰ΩúÁ¨¶<code>=</code>ÁªìÂêàËÄåÊàêÁöÑ.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let mut a = 2;\n\na += 5; //2 + 5 = 7\na -= 2; //7 - 2 = 5\na *= 5; //5 * 5 = 25\na /= 2; //25 / 2 = 12 not 12.5\na %= 5; //12 % 5 = 2\n\na &amp;= 2; //10 &amp;&amp; 10 -&gt; 10 -&gt; 2\na |= 5; //010 || 101 -&gt; 111 -&gt; 7\na ^= 2; //111 != 010 -&gt; 101 -&gt; 5\na &lt;&lt;= 1; //&#39;101&#39;+&#39;0&#39; -&gt; 1010 -&gt; 10\na &gt;&gt;= 2; //101Ã∂0Ã∂ -&gt; 10 -&gt; 2\n</code></pre>\n<h2 id=\"Á±ªÂûãËΩ¨Êç¢Êìç‰ΩúÁ¨¶\"><a href=\"#Á±ªÂûãËΩ¨Êç¢Êìç‰ΩúÁ¨¶\" class=\"headerlink\" title=\"Á±ªÂûãËΩ¨Êç¢Êìç‰ΩúÁ¨¶\"></a>Á±ªÂûãËΩ¨Êç¢Êìç‰ΩúÁ¨¶</h2><p>as</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = 15;\nlet b = (a as f64) / 2.0; //7.5\n</code></pre>\n<h2 id=\"ÂÄüÁî®‰∏éËß£ÂºïÁî®Êìç‰ΩúÁ¨¶\"><a href=\"#ÂÄüÁî®‰∏éËß£ÂºïÁî®Êìç‰ΩúÁ¨¶\" class=\"headerlink\" title=\"ÂÄüÁî®‰∏éËß£ÂºïÁî®Êìç‰ΩúÁ¨¶\"></a>ÂÄüÁî®‰∏éËß£ÂºïÁî®Êìç‰ΩúÁ¨¶</h2><p>&amp; &amp;mut *</p>\n<p>Êìç‰ΩúÁ¨¶ <strong>&amp; Êàñ &amp;mut</strong> ‰Ωú‰∏∫ÂÄüÁî®Êìç‰ΩúÁ¨¶‰ΩøÁî®ÔºåÁî®‰ª•‰∏¥Êó∂ÂèñÂæóÊüêÂèòÈáèÁöÑÊâÄÊúâÊùÉÔºåËÄå<strong>*</strong>Êìç‰ΩúÁ¨¶ÂàôÁî®‰ª•Âú®‰ΩøÁî®ÁöÑËøáÁ®ã‰∏≠<strong>Ëß£ÂºïDereferencing</strong>„ÄÇ</p>\n<blockquote>\n<p>üîé Êõ¥Â§ö‰ø°ÊÅØÂèØ‰ª•ÂèÇËÄÉ<a href=\"c1.ownership.html\">ÊâÄÊúâÊùÉ - Ownership</a>, <a href=\"c2.borrowing.html\">ÂÄüÁî® - Borrowing</a> &amp; <a href=\"c3.lifetimes.html\">ÁîüÂëΩÂë®Êúü - Lifetimes</a>Á≠âÁ´†ËäÇ„ÄÇ</p>\n</blockquote>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<h2 id=\"Êï∞Â≠¶ËøêÁÆóÊìç‰ΩúÁ¨¶\"><a href=\"#Êï∞Â≠¶ËøêÁÆóÊìç‰ΩúÁ¨¶\" class=\"headerlink\" title=\"Êï∞Â≠¶ËøêÁÆóÊìç‰ΩúÁ¨¶\"></a>Êï∞Â≠¶ËøêÁÆóÊìç‰ΩúÁ¨¶</h2><p><strong> + - * / %</strong></p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = 5;\nlet b = a + 1; //6\nlet c = a - 1; //4\nlet d = a * 2; //10\nlet e = a / 2; // ‚≠êÔ∏è 2 not 2.5\nlet f = a % 2; //1\n\nlet g = 5.0 / 2.0; //2.5\n</code></pre>\n<blockquote>\n<p>üí° Êìç‰ΩúÁ¨¶ <strong>+</strong> ‰πüË¢´Áî®Êù•ËøõË°åÊï∞ÂàóÂíåÂ≠óÁ¨¶‰∏≤ÁöÑËøûÊé•**</p>\n</blockquote>\n<h2 id=\"ÊØîËæÉÊìç‰ΩúÁ¨¶\"><a href=\"#ÊØîËæÉÊìç‰ΩúÁ¨¶\" class=\"headerlink\" title=\"ÊØîËæÉÊìç‰ΩúÁ¨¶\"></a>ÊØîËæÉÊìç‰ΩúÁ¨¶</h2><p>== != &lt; &gt; &lt;= &gt;=</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = 1;\nlet b = 2;\n\nlet c = a == b; //false\nlet d = a != b; //true\nlet e = a &lt; b; //true\nlet f = a &gt; b; //false\nlet g = a &lt;= a; //true\nlet h = a &gt;= a; //true\n\n// üîé\nlet i = true &gt; false; //true\nlet j = &#39;a&#39; &gt; &#39;A&#39;; //true\n</code></pre>\n<h2 id=\"ÈÄªËæëËøêÁÆóÊìç‰ΩúÁ¨¶\"><a href=\"#ÈÄªËæëËøêÁÆóÊìç‰ΩúÁ¨¶\" class=\"headerlink\" title=\"ÈÄªËæëËøêÁÆóÊìç‰ΩúÁ¨¶\"></a>ÈÄªËæëËøêÁÆóÊìç‰ΩúÁ¨¶</h2><p>! &amp;&amp; ||</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = true;\nlet b = false;\n\nlet c = !a; //false\nlet d = a &amp;&amp; b; //false\nlet e = a || b; //true\n</code></pre>\n<blockquote>\n<p>üîé ÂØπ‰∫éÊï¥ÂûãÊù•ËØ¥Ôºå! Êìç‰ΩúÁ¨¶‰ºöÂú®Êï¥ÂûãÁöÑÂÜÖÂ≠òË°®Á§∫‰∏äÂØπÊØè‰∏Ä‰∏™Áã¨Á´ãbitÂèñÂèç„ÄÇ</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = !-2; //1\nlet b = !-1; //0\nlet c = !0; //-1\nlet d = !1; //-2\n</code></pre>\n<h2 id=\"ÊØîÁâπ‰ΩçÊìç‰ΩúÁ¨¶\"><a href=\"#ÊØîÁâπ‰ΩçÊìç‰ΩúÁ¨¶\" class=\"headerlink\" title=\"ÊØîÁâπ‰ΩçÊìç‰ΩúÁ¨¶\"></a>ÊØîÁâπ‰ΩçÊìç‰ΩúÁ¨¶</h2><p>&amp; | ^ &lt;&lt; &gt;&gt;</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = 1;\nlet b = 2;\n\nlet c = a &amp; b; //0  (01 &amp;&amp; 10 -&gt; 00)\nlet d = a | b; //3  (01 || 10 -&gt; 11)\nlet e = a ^ b; //3  (01 != 10 -&gt; 11)\nlet f = a &lt;&lt; b; //4  (ÂÜÖÂ≠òÂÄºÂ∑¶Áßª‰∏§‰ΩçÔºåÊú´Â∞æÁî®0Ë°•Ë∂≥ -&gt; &#39;01&#39;+&#39;00&#39; -&gt; 100)\nlet g = a &gt;&gt; a; //0  (ÂÜÖÂ≠òÂÄºÂè≥Áßª‰∏§‰ΩçÔºåÊúÄÊú´‰∏§‰ΩçÊà™Êñ≠ÔºåÂ∑¶‰æßÁî®0Ë°•Ë∂≥ -&gt; oÃ∂1Ã∂ -&gt; 0)\n</code></pre>\n<h2 id=\"ËµãÂÄºËøêÁÆóÁ¨¶‰∏éÁ¨¶ÂêàËµãÂÄºËøêÁÆóÁ¨¶\"><a href=\"#ËµãÂÄºËøêÁÆóÁ¨¶‰∏éÁ¨¶ÂêàËµãÂÄºËøêÁÆóÁ¨¶\" class=\"headerlink\" title=\"ËµãÂÄºËøêÁÆóÁ¨¶‰∏éÁ¨¶ÂêàËµãÂÄºËøêÁÆóÁ¨¶\"></a>ËµãÂÄºËøêÁÆóÁ¨¶‰∏éÁ¨¶ÂêàËµãÂÄºËøêÁÆóÁ¨¶</h2><p>Êìç‰ΩúÁ¨¶<code>=</code>Áî®Êù•‰∏∫ÂèòÈáèÂàÜÈÖç‰∏Ä‰∏™Ë°®ËææÂºèÔºà‰∏Ä‰∏™ÂÄºÊàñËÄÖ‰∏Ä‰∏™functionÂ£∞ÊòéÔºâÔºå‰πüÂèØ‰ª•Áî®Êù•‰∏∫‰∏Ä‰∏™Á±ªÂûãÊ†áËØÜÂàÜÈÖçÁ±ªÂûãÂÆö‰πâ„ÄÇÁ¨¶ÂêàËµãÂÄºÊìç‰ΩúÁ¨¶ÊòØÁî±<code>+ - * / % &amp; | ^ &lt;&lt; &gt;&gt;</code>Á≠âÊìç‰ΩúÁ¨¶‰∏≠ÁöÑÂÖ∂‰∏≠‰∏ÄÂëò‰∏éËµãÂÄºÊìç‰ΩúÁ¨¶<code>=</code>ÁªìÂêàËÄåÊàêÁöÑ.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let mut a = 2;\n\na += 5; //2 + 5 = 7\na -= 2; //7 - 2 = 5\na *= 5; //5 * 5 = 25\na /= 2; //25 / 2 = 12 not 12.5\na %= 5; //12 % 5 = 2\n\na &amp;= 2; //10 &amp;&amp; 10 -&gt; 10 -&gt; 2\na |= 5; //010 || 101 -&gt; 111 -&gt; 7\na ^= 2; //111 != 010 -&gt; 101 -&gt; 5\na &lt;&lt;= 1; //&#39;101&#39;+&#39;0&#39; -&gt; 1010 -&gt; 10\na &gt;&gt;= 2; //101Ã∂0Ã∂ -&gt; 10 -&gt; 2\n</code></pre>\n<h2 id=\"Á±ªÂûãËΩ¨Êç¢Êìç‰ΩúÁ¨¶\"><a href=\"#Á±ªÂûãËΩ¨Êç¢Êìç‰ΩúÁ¨¶\" class=\"headerlink\" title=\"Á±ªÂûãËΩ¨Êç¢Êìç‰ΩúÁ¨¶\"></a>Á±ªÂûãËΩ¨Êç¢Êìç‰ΩúÁ¨¶</h2><p>as</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = 15;\nlet b = (a as f64) / 2.0; //7.5\n</code></pre>\n<h2 id=\"ÂÄüÁî®‰∏éËß£ÂºïÁî®Êìç‰ΩúÁ¨¶\"><a href=\"#ÂÄüÁî®‰∏éËß£ÂºïÁî®Êìç‰ΩúÁ¨¶\" class=\"headerlink\" title=\"ÂÄüÁî®‰∏éËß£ÂºïÁî®Êìç‰ΩúÁ¨¶\"></a>ÂÄüÁî®‰∏éËß£ÂºïÁî®Êìç‰ΩúÁ¨¶</h2><p>&amp; &amp;mut *</p>\n<p>Êìç‰ΩúÁ¨¶ <strong>&amp; Êàñ &amp;mut</strong> ‰Ωú‰∏∫ÂÄüÁî®Êìç‰ΩúÁ¨¶‰ΩøÁî®ÔºåÁî®‰ª•‰∏¥Êó∂ÂèñÂæóÊüêÂèòÈáèÁöÑÊâÄÊúâÊùÉÔºåËÄå<strong>*</strong>Êìç‰ΩúÁ¨¶ÂàôÁî®‰ª•Âú®‰ΩøÁî®ÁöÑËøáÁ®ã‰∏≠<strong>Ëß£ÂºïDereferencing</strong>„ÄÇ</p>\n<blockquote>\n<p>üîé Êõ¥Â§ö‰ø°ÊÅØÂèØ‰ª•ÂèÇËÄÉ<a href=\"c1.ownership.html\">ÊâÄÊúâÊùÉ - Ownership</a>, <a href=\"c2.borrowing.html\">ÂÄüÁî® - Borrowing</a> &amp; <a href=\"c3.lifetimes.html\">ÁîüÂëΩÂë®Êúü - Lifetimes</a>Á≠âÁ´†ËäÇ„ÄÇ</p>\n</blockquote>\n"},{"title":"Structs","_content":"\n‚≠êÔ∏è Structs are used to **encapsulate related properties** into one unified datatype.\n\nüí° By convention, the name of the struct starts with a capital letter and follows **CamelCase**.\n\nThere are 3 variants of structs,  \n1. **C-like structs**\n  * one or more comma separated name:value pairs\n  * brace-enclosed  list\n  * similar to classes \\(without its methods\\) in OOP languages\n  * because fields have names, we can access them through dot notation\n\n2. **Tuple structs**\n  * one or more comma separated values\n  * parenthesized list like tuples\n  * looks like a named tuples\n\n3. **Unit structs**\n  * a struct with no members at all\n  * it defines a new type but it resembles an empty tuple, \\(\\)\n  * rarely in use,  useful with generics\n\n‚≠êÔ∏è When regarding OOP in Rust, attributes and methods are placed separately on **structs** and **traits**. Structs contain only attributes, traits contain only methods. They are getting connected via **impls**.\n\n>üí°More complex examples can be found on [impls & traits](b5.impls_and_traits.html), [lifetimes](c3.lifetimes.html) and [modules](d3.modules.html) sections.\n\n## C-like structs\n\n```rust\n// Struct Declaration\nstruct Color {\n    red: u8,\n    green: u8,\n    blue: u8\n}\n\nfn main() {\n  // creating an instance\n  let black = Color {red: 0, green: 0, blue: 0};\n\n  // accessing its fields using dot notation\n  println!(\"Black = rgb({}, {}, {})\", black.red, black.green, black.blue); //Black = rgb(0, 0, 0)\n\n  // structs are immutable by default, use `mut` to make it mutable but doesn't support field level mutability\n  let mut link_color = Color {red: 0,green: 0,blue: 255};\n  link_color.blue = 238;\n  println!(\"Link Color = rgb({}, {}, {})\", link_color.red, link_color.green, link_color.blue); //Link Color = rgb(0, 0, 238)\n\n  // copy elements from another instance\n  let blue = Color {blue: 255, .. link_color};\n  println!(\"Blue = rgb({}, {}, {})\", blue.red, blue.green, blue.blue); //Blue = rgb(0, 0, 255)\n\n  // destructure the instance using a `let` binding, this will not destruct blue instance\n  let Color {red: r, green: g, blue: b} = blue;\n  println!(\"Blue = rgb({}, {}, {})\", r, g, b); //Blue = rgb(0, 0, 255)\n\n  // creating an instance via functions & accessing its fields\n  let midnightblue = get_midnightblue_color();\n  println!(\"Midnight Blue = rgb({}, {}, {})\", midnightblue.red, midnightblue.green, midnightblue.blue); //Midnight Blue = rgb(25, 25, 112)\n\n  // destructure the instance using a `let` binding\n  let Color {red: r, green: g, blue: b} = get_midnightblue_color();\n  println!(\"Midnight Blue = rgb({}, {}, {})\", r, g, b); //Midnight Blue = rgb(25, 25, 112)\n}\n\nfn get_midnightblue_color() -> Color {\n    Color {red: 25, green: 25, blue: 112}\n}\n```\n\n## Tuple structs\n\n‚≠êÔ∏è When a tuple struct  has only one element, we call it **new type pattern**. Because it helps to create a new type.\n\n```rust\nstruct Color (u8, u8, u8);\nstruct Kilometers(i32);\n\nfn main() {\n  // creating an instance\n  let black = Color (0, 0, 0);\n\n  // destructure the instance using a `let` binding, this will not destruct black instance\n  let Color (r, g, b) = black;\n  println!(\"Black = rgb({}, {}, {})\", r, g, b); //black = rgb(0, 0, 0);\n\n  //newtype pattern\n  let distance = Kilometers(20);\n  // destructure the instance using a `let` binding\n  let Kilometers(distance_in_km) = distance;\n  println!(\"The distance: {} km\", distance_in_km); //The distance: 20 km\n}\n```\n\n## Unit structs\n\nThis is rarely useful on its own, but in combination with other features it can become useful.\n\n> [üìñ](https://doc.rust-lang.org/book/first-edition/structs.html) ex: A library may ask you to create a structure that implements a certain trait to handle events. If you don‚Äôt have any data you need to store in the structure, you can create a unit-like struct.\n\n```rust\nstruct Electron;\n\nfn main() {\n  let x = Electron;\n}\n```\n","source":"docs/zh-cn/b2.structs.md","raw":"title: Structs\n---\n\n‚≠êÔ∏è Structs are used to **encapsulate related properties** into one unified datatype.\n\nüí° By convention, the name of the struct starts with a capital letter and follows **CamelCase**.\n\nThere are 3 variants of structs,  \n1. **C-like structs**\n  * one or more comma separated name:value pairs\n  * brace-enclosed  list\n  * similar to classes \\(without its methods\\) in OOP languages\n  * because fields have names, we can access them through dot notation\n\n2. **Tuple structs**\n  * one or more comma separated values\n  * parenthesized list like tuples\n  * looks like a named tuples\n\n3. **Unit structs**\n  * a struct with no members at all\n  * it defines a new type but it resembles an empty tuple, \\(\\)\n  * rarely in use,  useful with generics\n\n‚≠êÔ∏è When regarding OOP in Rust, attributes and methods are placed separately on **structs** and **traits**. Structs contain only attributes, traits contain only methods. They are getting connected via **impls**.\n\n>üí°More complex examples can be found on [impls & traits](b5.impls_and_traits.html), [lifetimes](c3.lifetimes.html) and [modules](d3.modules.html) sections.\n\n## C-like structs\n\n```rust\n// Struct Declaration\nstruct Color {\n    red: u8,\n    green: u8,\n    blue: u8\n}\n\nfn main() {\n  // creating an instance\n  let black = Color {red: 0, green: 0, blue: 0};\n\n  // accessing its fields using dot notation\n  println!(\"Black = rgb({}, {}, {})\", black.red, black.green, black.blue); //Black = rgb(0, 0, 0)\n\n  // structs are immutable by default, use `mut` to make it mutable but doesn't support field level mutability\n  let mut link_color = Color {red: 0,green: 0,blue: 255};\n  link_color.blue = 238;\n  println!(\"Link Color = rgb({}, {}, {})\", link_color.red, link_color.green, link_color.blue); //Link Color = rgb(0, 0, 238)\n\n  // copy elements from another instance\n  let blue = Color {blue: 255, .. link_color};\n  println!(\"Blue = rgb({}, {}, {})\", blue.red, blue.green, blue.blue); //Blue = rgb(0, 0, 255)\n\n  // destructure the instance using a `let` binding, this will not destruct blue instance\n  let Color {red: r, green: g, blue: b} = blue;\n  println!(\"Blue = rgb({}, {}, {})\", r, g, b); //Blue = rgb(0, 0, 255)\n\n  // creating an instance via functions & accessing its fields\n  let midnightblue = get_midnightblue_color();\n  println!(\"Midnight Blue = rgb({}, {}, {})\", midnightblue.red, midnightblue.green, midnightblue.blue); //Midnight Blue = rgb(25, 25, 112)\n\n  // destructure the instance using a `let` binding\n  let Color {red: r, green: g, blue: b} = get_midnightblue_color();\n  println!(\"Midnight Blue = rgb({}, {}, {})\", r, g, b); //Midnight Blue = rgb(25, 25, 112)\n}\n\nfn get_midnightblue_color() -> Color {\n    Color {red: 25, green: 25, blue: 112}\n}\n```\n\n## Tuple structs\n\n‚≠êÔ∏è When a tuple struct  has only one element, we call it **new type pattern**. Because it helps to create a new type.\n\n```rust\nstruct Color (u8, u8, u8);\nstruct Kilometers(i32);\n\nfn main() {\n  // creating an instance\n  let black = Color (0, 0, 0);\n\n  // destructure the instance using a `let` binding, this will not destruct black instance\n  let Color (r, g, b) = black;\n  println!(\"Black = rgb({}, {}, {})\", r, g, b); //black = rgb(0, 0, 0);\n\n  //newtype pattern\n  let distance = Kilometers(20);\n  // destructure the instance using a `let` binding\n  let Kilometers(distance_in_km) = distance;\n  println!(\"The distance: {} km\", distance_in_km); //The distance: 20 km\n}\n```\n\n## Unit structs\n\nThis is rarely useful on its own, but in combination with other features it can become useful.\n\n> [üìñ](https://doc.rust-lang.org/book/first-edition/structs.html) ex: A library may ask you to create a structure that implements a certain trait to handle events. If you don‚Äôt have any data you need to store in the structure, you can create a unit-like struct.\n\n```rust\nstruct Electron;\n\nfn main() {\n  let x = Electron;\n}\n```\n","date":"2019-03-19T14:50:31.983Z","updated":"2019-03-19T14:50:31.983Z","path":"docs/zh-cn/b2.structs.html","comments":1,"layout":"page","_id":"cjtfwbj0t0019dwgpb7flqj20","content":"<p>‚≠êÔ∏è Structs are used to <strong>encapsulate related properties</strong> into one unified datatype.</p>\n<p>üí° By convention, the name of the struct starts with a capital letter and follows <strong>CamelCase</strong>.</p>\n<p>There are 3 variants of structs,  </p>\n<ol>\n<li><p><strong>C-like structs</strong></p>\n<ul>\n<li>one or more comma separated name:value pairs</li>\n<li>brace-enclosed  list</li>\n<li>similar to classes (without its methods) in OOP languages</li>\n<li>because fields have names, we can access them through dot notation</li>\n</ul>\n</li>\n<li><p><strong>Tuple structs</strong></p>\n<ul>\n<li>one or more comma separated values</li>\n<li>parenthesized list like tuples</li>\n<li>looks like a named tuples</li>\n</ul>\n</li>\n<li><p><strong>Unit structs</strong></p>\n<ul>\n<li>a struct with no members at all</li>\n<li>it defines a new type but it resembles an empty tuple, ()</li>\n<li>rarely in use,  useful with generics</li>\n</ul>\n</li>\n</ol>\n<p>‚≠êÔ∏è When regarding OOP in Rust, attributes and methods are placed separately on <strong>structs</strong> and <strong>traits</strong>. Structs contain only attributes, traits contain only methods. They are getting connected via <strong>impls</strong>.</p>\n<blockquote>\n<p>üí°More complex examples can be found on <a href=\"b5.impls_and_traits.html\">impls &amp; traits</a>, <a href=\"c3.lifetimes.html\">lifetimes</a> and <a href=\"d3.modules.html\">modules</a> sections.</p>\n</blockquote>\n<h2 id=\"C-like-structs\"><a href=\"#C-like-structs\" class=\"headerlink\" title=\"C-like structs\"></a>C-like structs</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Struct Declaration\nstruct Color {\n    red: u8,\n    green: u8,\n    blue: u8\n}\n\nfn main() {\n  // creating an instance\n  let black = Color {red: 0, green: 0, blue: 0};\n\n  // accessing its fields using dot notation\n  println!(&quot;Black = rgb({}, {}, {})&quot;, black.red, black.green, black.blue); //Black = rgb(0, 0, 0)\n\n  // structs are immutable by default, use `mut` to make it mutable but doesn&#39;t support field level mutability\n  let mut link_color = Color {red: 0,green: 0,blue: 255};\n  link_color.blue = 238;\n  println!(&quot;Link Color = rgb({}, {}, {})&quot;, link_color.red, link_color.green, link_color.blue); //Link Color = rgb(0, 0, 238)\n\n  // copy elements from another instance\n  let blue = Color {blue: 255, .. link_color};\n  println!(&quot;Blue = rgb({}, {}, {})&quot;, blue.red, blue.green, blue.blue); //Blue = rgb(0, 0, 255)\n\n  // destructure the instance using a `let` binding, this will not destruct blue instance\n  let Color {red: r, green: g, blue: b} = blue;\n  println!(&quot;Blue = rgb({}, {}, {})&quot;, r, g, b); //Blue = rgb(0, 0, 255)\n\n  // creating an instance via functions &amp; accessing its fields\n  let midnightblue = get_midnightblue_color();\n  println!(&quot;Midnight Blue = rgb({}, {}, {})&quot;, midnightblue.red, midnightblue.green, midnightblue.blue); //Midnight Blue = rgb(25, 25, 112)\n\n  // destructure the instance using a `let` binding\n  let Color {red: r, green: g, blue: b} = get_midnightblue_color();\n  println!(&quot;Midnight Blue = rgb({}, {}, {})&quot;, r, g, b); //Midnight Blue = rgb(25, 25, 112)\n}\n\nfn get_midnightblue_color() -&gt; Color {\n    Color {red: 25, green: 25, blue: 112}\n}\n</code></pre>\n<h2 id=\"Tuple-structs\"><a href=\"#Tuple-structs\" class=\"headerlink\" title=\"Tuple structs\"></a>Tuple structs</h2><p>‚≠êÔ∏è When a tuple struct  has only one element, we call it <strong>new type pattern</strong>. Because it helps to create a new type.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Color (u8, u8, u8);\nstruct Kilometers(i32);\n\nfn main() {\n  // creating an instance\n  let black = Color (0, 0, 0);\n\n  // destructure the instance using a `let` binding, this will not destruct black instance\n  let Color (r, g, b) = black;\n  println!(&quot;Black = rgb({}, {}, {})&quot;, r, g, b); //black = rgb(0, 0, 0);\n\n  //newtype pattern\n  let distance = Kilometers(20);\n  // destructure the instance using a `let` binding\n  let Kilometers(distance_in_km) = distance;\n  println!(&quot;The distance: {} km&quot;, distance_in_km); //The distance: 20 km\n}\n</code></pre>\n<h2 id=\"Unit-structs\"><a href=\"#Unit-structs\" class=\"headerlink\" title=\"Unit structs\"></a>Unit structs</h2><p>This is rarely useful on its own, but in combination with other features it can become useful.</p>\n<blockquote>\n<p><a href=\"https://doc.rust-lang.org/book/first-edition/structs.html\" target=\"_blank\" rel=\"noopener\">üìñ</a> ex: A library may ask you to create a structure that implements a certain trait to handle events. If you don‚Äôt have any data you need to store in the structure, you can create a unit-like struct.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Electron;\n\nfn main() {\n  let x = Electron;\n}\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<p>‚≠êÔ∏è Structs are used to <strong>encapsulate related properties</strong> into one unified datatype.</p>\n<p>üí° By convention, the name of the struct starts with a capital letter and follows <strong>CamelCase</strong>.</p>\n<p>There are 3 variants of structs,  </p>\n<ol>\n<li><p><strong>C-like structs</strong></p>\n<ul>\n<li>one or more comma separated name:value pairs</li>\n<li>brace-enclosed  list</li>\n<li>similar to classes (without its methods) in OOP languages</li>\n<li>because fields have names, we can access them through dot notation</li>\n</ul>\n</li>\n<li><p><strong>Tuple structs</strong></p>\n<ul>\n<li>one or more comma separated values</li>\n<li>parenthesized list like tuples</li>\n<li>looks like a named tuples</li>\n</ul>\n</li>\n<li><p><strong>Unit structs</strong></p>\n<ul>\n<li>a struct with no members at all</li>\n<li>it defines a new type but it resembles an empty tuple, ()</li>\n<li>rarely in use,  useful with generics</li>\n</ul>\n</li>\n</ol>\n<p>‚≠êÔ∏è When regarding OOP in Rust, attributes and methods are placed separately on <strong>structs</strong> and <strong>traits</strong>. Structs contain only attributes, traits contain only methods. They are getting connected via <strong>impls</strong>.</p>\n<blockquote>\n<p>üí°More complex examples can be found on <a href=\"b5.impls_and_traits.html\">impls &amp; traits</a>, <a href=\"c3.lifetimes.html\">lifetimes</a> and <a href=\"d3.modules.html\">modules</a> sections.</p>\n</blockquote>\n<h2 id=\"C-like-structs\"><a href=\"#C-like-structs\" class=\"headerlink\" title=\"C-like structs\"></a>C-like structs</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Struct Declaration\nstruct Color {\n    red: u8,\n    green: u8,\n    blue: u8\n}\n\nfn main() {\n  // creating an instance\n  let black = Color {red: 0, green: 0, blue: 0};\n\n  // accessing its fields using dot notation\n  println!(&quot;Black = rgb({}, {}, {})&quot;, black.red, black.green, black.blue); //Black = rgb(0, 0, 0)\n\n  // structs are immutable by default, use `mut` to make it mutable but doesn&#39;t support field level mutability\n  let mut link_color = Color {red: 0,green: 0,blue: 255};\n  link_color.blue = 238;\n  println!(&quot;Link Color = rgb({}, {}, {})&quot;, link_color.red, link_color.green, link_color.blue); //Link Color = rgb(0, 0, 238)\n\n  // copy elements from another instance\n  let blue = Color {blue: 255, .. link_color};\n  println!(&quot;Blue = rgb({}, {}, {})&quot;, blue.red, blue.green, blue.blue); //Blue = rgb(0, 0, 255)\n\n  // destructure the instance using a `let` binding, this will not destruct blue instance\n  let Color {red: r, green: g, blue: b} = blue;\n  println!(&quot;Blue = rgb({}, {}, {})&quot;, r, g, b); //Blue = rgb(0, 0, 255)\n\n  // creating an instance via functions &amp; accessing its fields\n  let midnightblue = get_midnightblue_color();\n  println!(&quot;Midnight Blue = rgb({}, {}, {})&quot;, midnightblue.red, midnightblue.green, midnightblue.blue); //Midnight Blue = rgb(25, 25, 112)\n\n  // destructure the instance using a `let` binding\n  let Color {red: r, green: g, blue: b} = get_midnightblue_color();\n  println!(&quot;Midnight Blue = rgb({}, {}, {})&quot;, r, g, b); //Midnight Blue = rgb(25, 25, 112)\n}\n\nfn get_midnightblue_color() -&gt; Color {\n    Color {red: 25, green: 25, blue: 112}\n}\n</code></pre>\n<h2 id=\"Tuple-structs\"><a href=\"#Tuple-structs\" class=\"headerlink\" title=\"Tuple structs\"></a>Tuple structs</h2><p>‚≠êÔ∏è When a tuple struct  has only one element, we call it <strong>new type pattern</strong>. Because it helps to create a new type.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Color (u8, u8, u8);\nstruct Kilometers(i32);\n\nfn main() {\n  // creating an instance\n  let black = Color (0, 0, 0);\n\n  // destructure the instance using a `let` binding, this will not destruct black instance\n  let Color (r, g, b) = black;\n  println!(&quot;Black = rgb({}, {}, {})&quot;, r, g, b); //black = rgb(0, 0, 0);\n\n  //newtype pattern\n  let distance = Kilometers(20);\n  // destructure the instance using a `let` binding\n  let Kilometers(distance_in_km) = distance;\n  println!(&quot;The distance: {} km&quot;, distance_in_km); //The distance: 20 km\n}\n</code></pre>\n<h2 id=\"Unit-structs\"><a href=\"#Unit-structs\" class=\"headerlink\" title=\"Unit structs\"></a>Unit structs</h2><p>This is rarely useful on its own, but in combination with other features it can become useful.</p>\n<blockquote>\n<p><a href=\"https://doc.rust-lang.org/book/first-edition/structs.html\" target=\"_blank\" rel=\"noopener\">üìñ</a> ex: A library may ask you to create a structure that implements a certain trait to handle events. If you don‚Äôt have any data you need to store in the structure, you can create a unit-like struct.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Electron;\n\nfn main() {\n  let x = Electron;\n}\n</code></pre>\n"},{"title":"Vectors","_content":"\nIf you remember, array is a  fixed-size list of elements, of same data type. Even with mut, its element count can not be changed. A vector is kind of **a re-sizable array** but **all elements must be in the same type**.\n\n‚≠êÔ∏è It‚Äôs a generic type, written as **`Vec<T>`**¬†. T can have any type, ex. The type of a Vec of i32s is `Vec<i32>`. Also, Vectors always allocate their data in dynamically allocated heap.\n\n### Create empty vector\n\n```rust\nlet mut a = Vec::new(); //1.with new() keyword\nlet mut b = vec![]; //2.using the vec! macro\n```\n\n### Create with data types\n\n```rust\nlet mut a2: Vec<i32> = Vec::new();\nlet mut b2: Vec<i32> = vec![];\nlet mut b3 = vec![1i32, 2, 3];//sufixing 1st value with data type\n\nlet mut b4 = vec![1, 2, 3];\nlet mut b5: Vec<i32> = vec![1, 2, 3];\nlet mut b6  = vec![1i32, 2, 3];\nlet mut b7 = vec![0; 10]; //ten zeroes\n```\n\n### Access and change data\n\n```rust\n//Accessing and changing exsisting data\nlet mut c = vec![5, 4, 3, 2, 1];\nc[0] = 1;\nc[1] = 2;\n//c[6] = 2; can't assign values this way, index out of bounds\nprintln!(\"{:?}\", c); //[1, 2, 3, 2, 1]\n\n//push and pop\nlet mut d: Vec<i32> = Vec::new();\nd.push(1); //[1] : Add an element to the end\nd.push(2); //[1, 2]\nd.pop(); //[1] : : Remove an element from the end\n\n\n// üîé Capacity and reallocation\nlet mut e: Vec<i32> = Vec::with_capacity(10);\nprintln!(\"Length: {}, Capacity : {}\", e.len(), e.capacity()); //Length: 0, Capacity : 10\n\n// These are all done without reallocating...\nfor i in 0..10 {\n    e.push(i);\n}\n// ...but this may make the vector reallocate\ne.push(11);\n```\n\n‚≠êÔ∏è Mainly a vector represent 3 things,\n- a **pointer** to the data\n- **No of elements** currently have(**length**)\n- **capacity** (Amount of space allocated for any future elements). \n\nIf the length of a vector exceeds its capacity, its capacity will be increased automatically. But its elements will be reallocated(which can be slow). So always use Vec::**with_capacity** whenever it‚Äôs possible.\n\n> üí° **String** data type is a UTF-8 encoded vector. But you can not index into a String because of encoding.\n\n\nüíØ Vectors can be used with iterators in three ways,\n\n```rust\nlet mut v = vec![1, 2, 3, 4, 5];\n\nfor i in &v {\n    println!(\"A reference to {}\", i);\n}\n\nfor i in &mut v {\n    println!(\"A mutable reference to {}\", i);\n}\n\nfor i in v {\n    println!(\"Take ownership of the vector and its element {}\", i);\n}\n```\n","source":"docs/zh-cn/b1.vectors.md","raw":"title: Vectors\n---\n\nIf you remember, array is a  fixed-size list of elements, of same data type. Even with mut, its element count can not be changed. A vector is kind of **a re-sizable array** but **all elements must be in the same type**.\n\n‚≠êÔ∏è It‚Äôs a generic type, written as **`Vec<T>`**¬†. T can have any type, ex. The type of a Vec of i32s is `Vec<i32>`. Also, Vectors always allocate their data in dynamically allocated heap.\n\n### Create empty vector\n\n```rust\nlet mut a = Vec::new(); //1.with new() keyword\nlet mut b = vec![]; //2.using the vec! macro\n```\n\n### Create with data types\n\n```rust\nlet mut a2: Vec<i32> = Vec::new();\nlet mut b2: Vec<i32> = vec![];\nlet mut b3 = vec![1i32, 2, 3];//sufixing 1st value with data type\n\nlet mut b4 = vec![1, 2, 3];\nlet mut b5: Vec<i32> = vec![1, 2, 3];\nlet mut b6  = vec![1i32, 2, 3];\nlet mut b7 = vec![0; 10]; //ten zeroes\n```\n\n### Access and change data\n\n```rust\n//Accessing and changing exsisting data\nlet mut c = vec![5, 4, 3, 2, 1];\nc[0] = 1;\nc[1] = 2;\n//c[6] = 2; can't assign values this way, index out of bounds\nprintln!(\"{:?}\", c); //[1, 2, 3, 2, 1]\n\n//push and pop\nlet mut d: Vec<i32> = Vec::new();\nd.push(1); //[1] : Add an element to the end\nd.push(2); //[1, 2]\nd.pop(); //[1] : : Remove an element from the end\n\n\n// üîé Capacity and reallocation\nlet mut e: Vec<i32> = Vec::with_capacity(10);\nprintln!(\"Length: {}, Capacity : {}\", e.len(), e.capacity()); //Length: 0, Capacity : 10\n\n// These are all done without reallocating...\nfor i in 0..10 {\n    e.push(i);\n}\n// ...but this may make the vector reallocate\ne.push(11);\n```\n\n‚≠êÔ∏è Mainly a vector represent 3 things,\n- a **pointer** to the data\n- **No of elements** currently have(**length**)\n- **capacity** (Amount of space allocated for any future elements). \n\nIf the length of a vector exceeds its capacity, its capacity will be increased automatically. But its elements will be reallocated(which can be slow). So always use Vec::**with_capacity** whenever it‚Äôs possible.\n\n> üí° **String** data type is a UTF-8 encoded vector. But you can not index into a String because of encoding.\n\n\nüíØ Vectors can be used with iterators in three ways,\n\n```rust\nlet mut v = vec![1, 2, 3, 4, 5];\n\nfor i in &v {\n    println!(\"A reference to {}\", i);\n}\n\nfor i in &mut v {\n    println!(\"A mutable reference to {}\", i);\n}\n\nfor i in v {\n    println!(\"Take ownership of the vector and its element {}\", i);\n}\n```\n","date":"2019-03-19T14:50:31.983Z","updated":"2019-03-19T14:50:31.983Z","path":"docs/zh-cn/b1.vectors.html","comments":1,"layout":"page","_id":"cjtfwbj0t001adwgpslrthp7r","content":"<p>If you remember, array is a  fixed-size list of elements, of same data type. Even with mut, its element count can not be changed. A vector is kind of <strong>a re-sizable array</strong> but <strong>all elements must be in the same type</strong>.</p>\n<p>‚≠êÔ∏è It‚Äôs a generic type, written as <strong><code>Vec&lt;T&gt;</code></strong> . T can have any type, ex. The type of a Vec of i32s is <code>Vec&lt;i32&gt;</code>. Also, Vectors always allocate their data in dynamically allocated heap.</p>\n<h3 id=\"Create-empty-vector\"><a href=\"#Create-empty-vector\" class=\"headerlink\" title=\"Create empty vector\"></a>Create empty vector</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let mut a = Vec::new(); //1.with new() keyword\nlet mut b = vec![]; //2.using the vec! macro\n</code></pre>\n<h3 id=\"Create-with-data-types\"><a href=\"#Create-with-data-types\" class=\"headerlink\" title=\"Create with data types\"></a>Create with data types</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let mut a2: Vec&lt;i32&gt; = Vec::new();\nlet mut b2: Vec&lt;i32&gt; = vec![];\nlet mut b3 = vec![1i32, 2, 3];//sufixing 1st value with data type\n\nlet mut b4 = vec![1, 2, 3];\nlet mut b5: Vec&lt;i32&gt; = vec![1, 2, 3];\nlet mut b6  = vec![1i32, 2, 3];\nlet mut b7 = vec![0; 10]; //ten zeroes\n</code></pre>\n<h3 id=\"Access-and-change-data\"><a href=\"#Access-and-change-data\" class=\"headerlink\" title=\"Access and change data\"></a>Access and change data</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">//Accessing and changing exsisting data\nlet mut c = vec![5, 4, 3, 2, 1];\nc[0] = 1;\nc[1] = 2;\n//c[6] = 2; can&#39;t assign values this way, index out of bounds\nprintln!(&quot;{:?}&quot;, c); //[1, 2, 3, 2, 1]\n\n//push and pop\nlet mut d: Vec&lt;i32&gt; = Vec::new();\nd.push(1); //[1] : Add an element to the end\nd.push(2); //[1, 2]\nd.pop(); //[1] : : Remove an element from the end\n\n\n// üîé Capacity and reallocation\nlet mut e: Vec&lt;i32&gt; = Vec::with_capacity(10);\nprintln!(&quot;Length: {}, Capacity : {}&quot;, e.len(), e.capacity()); //Length: 0, Capacity : 10\n\n// These are all done without reallocating...\nfor i in 0..10 {\n    e.push(i);\n}\n// ...but this may make the vector reallocate\ne.push(11);\n</code></pre>\n<p>‚≠êÔ∏è Mainly a vector represent 3 things,</p>\n<ul>\n<li>a <strong>pointer</strong> to the data</li>\n<li><strong>No of elements</strong> currently have(<strong>length</strong>)</li>\n<li><strong>capacity</strong> (Amount of space allocated for any future elements). </li>\n</ul>\n<p>If the length of a vector exceeds its capacity, its capacity will be increased automatically. But its elements will be reallocated(which can be slow). So always use Vec::<strong>with_capacity</strong> whenever it‚Äôs possible.</p>\n<blockquote>\n<p>üí° <strong>String</strong> data type is a UTF-8 encoded vector. But you can not index into a String because of encoding.</p>\n</blockquote>\n<p>üíØ Vectors can be used with iterators in three ways,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let mut v = vec![1, 2, 3, 4, 5];\n\nfor i in &amp;v {\n    println!(&quot;A reference to {}&quot;, i);\n}\n\nfor i in &amp;mut v {\n    println!(&quot;A mutable reference to {}&quot;, i);\n}\n\nfor i in v {\n    println!(&quot;Take ownership of the vector and its element {}&quot;, i);\n}\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<p>If you remember, array is a  fixed-size list of elements, of same data type. Even with mut, its element count can not be changed. A vector is kind of <strong>a re-sizable array</strong> but <strong>all elements must be in the same type</strong>.</p>\n<p>‚≠êÔ∏è It‚Äôs a generic type, written as <strong><code>Vec&lt;T&gt;</code></strong> . T can have any type, ex. The type of a Vec of i32s is <code>Vec&lt;i32&gt;</code>. Also, Vectors always allocate their data in dynamically allocated heap.</p>\n<h3 id=\"Create-empty-vector\"><a href=\"#Create-empty-vector\" class=\"headerlink\" title=\"Create empty vector\"></a>Create empty vector</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let mut a = Vec::new(); //1.with new() keyword\nlet mut b = vec![]; //2.using the vec! macro\n</code></pre>\n<h3 id=\"Create-with-data-types\"><a href=\"#Create-with-data-types\" class=\"headerlink\" title=\"Create with data types\"></a>Create with data types</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let mut a2: Vec&lt;i32&gt; = Vec::new();\nlet mut b2: Vec&lt;i32&gt; = vec![];\nlet mut b3 = vec![1i32, 2, 3];//sufixing 1st value with data type\n\nlet mut b4 = vec![1, 2, 3];\nlet mut b5: Vec&lt;i32&gt; = vec![1, 2, 3];\nlet mut b6  = vec![1i32, 2, 3];\nlet mut b7 = vec![0; 10]; //ten zeroes\n</code></pre>\n<h3 id=\"Access-and-change-data\"><a href=\"#Access-and-change-data\" class=\"headerlink\" title=\"Access and change data\"></a>Access and change data</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">//Accessing and changing exsisting data\nlet mut c = vec![5, 4, 3, 2, 1];\nc[0] = 1;\nc[1] = 2;\n//c[6] = 2; can&#39;t assign values this way, index out of bounds\nprintln!(&quot;{:?}&quot;, c); //[1, 2, 3, 2, 1]\n\n//push and pop\nlet mut d: Vec&lt;i32&gt; = Vec::new();\nd.push(1); //[1] : Add an element to the end\nd.push(2); //[1, 2]\nd.pop(); //[1] : : Remove an element from the end\n\n\n// üîé Capacity and reallocation\nlet mut e: Vec&lt;i32&gt; = Vec::with_capacity(10);\nprintln!(&quot;Length: {}, Capacity : {}&quot;, e.len(), e.capacity()); //Length: 0, Capacity : 10\n\n// These are all done without reallocating...\nfor i in 0..10 {\n    e.push(i);\n}\n// ...but this may make the vector reallocate\ne.push(11);\n</code></pre>\n<p>‚≠êÔ∏è Mainly a vector represent 3 things,</p>\n<ul>\n<li>a <strong>pointer</strong> to the data</li>\n<li><strong>No of elements</strong> currently have(<strong>length</strong>)</li>\n<li><strong>capacity</strong> (Amount of space allocated for any future elements). </li>\n</ul>\n<p>If the length of a vector exceeds its capacity, its capacity will be increased automatically. But its elements will be reallocated(which can be slow). So always use Vec::<strong>with_capacity</strong> whenever it‚Äôs possible.</p>\n<blockquote>\n<p>üí° <strong>String</strong> data type is a UTF-8 encoded vector. But you can not index into a String because of encoding.</p>\n</blockquote>\n<p>üíØ Vectors can be used with iterators in three ways,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let mut v = vec![1, 2, 3, 4, 5];\n\nfor i in &amp;v {\n    println!(&quot;A reference to {}&quot;, i);\n}\n\nfor i in &amp;mut v {\n    println!(&quot;A mutable reference to {}&quot;, i);\n}\n\nfor i in v {\n    println!(&quot;Take ownership of the vector and its element {}&quot;, i);\n}\n</code></pre>\n"},{"title":"Generics","_content":"\n> [üìñ](https://doc.rust-lang.org/beta/book/first-edition/generics.html) Sometimes, when writing a function or data type, we may want it to work for multiple types of arguments. In Rust, we can do this with generics.\n\nüí≠ The concept is, instead of declaring a specific data type we use an uppercase letter(or CamelCase identifier). ex, **instead x¬†: u8** we use **x¬†: T**¬†. but we have to inform to the compiler that T is a generic type(can be any type) by adding `<T>` at first.\n\n### Generalizing functions\n\n```rust\nfn takes_anything<T>(x: T) { // x has type T, T is a generic type\n}\n\nfn takes_two_of_the_same_things<T>(x: T, y: T) { // both x and y has same type\n}\n\nfn takes_two_things<T, U>(x: T, y: U) { // multiple types\n}\n```\n\n### Generalizing structs\n\n```rust\nstruct Point<T> {\n  x: T,\n  y: T,\n}\n\nfn main() {\n  let point_a = Point { x: 0, y: 0 }; // T is a int type\n  let point_b = Point { x: 0.0, y: 0.0 }; // T is a float type\n}\n\n// üîé When addding an implementation for a generic struct, the type parameters should be declared after the impl as well\n// impl<T> Point<T> {\n```\n\n### Generalizing enums\n\n```rust\nenum Option<T> {\n    Some(T),\n    None,\n}\n\nenum Result<T, E> {\n    Ok(T),\n    Err(E),\n}\n```\n\n> ‚≠êÔ∏è Above [Option](https://doc.rust-lang.org/std/option/index.html) and [Result](https://doc.rust-lang.org/std/result/index.html) types are kind of special generic types which are already defined in Rust‚Äôs standard library.¬†\n  * An **optional value** can have either **Some** value or no value/ **None**.\n  * A **result** can represent either success/ **Ok** or failure/ **Err**\n\n #### Usages of Option\n \n```rust\n// 01 - - - - - - - - - - - - - - - - - - - - - -\nfn get_id_by_username(username: &str) -> Option<usize> {\n    //if username can be found in the system, set userId\n        return Some(userId);\n    //else\n        None\n}\n\n//üí≠ So on above function, instead of setting return type as usize\n// set return type as Option<usize>\n//Instead of return userId, return Some(userId)\n// else None (üí°remember? last return statement no need return keyword and ending ;)\n\n// 02 - - - - - - - - - - - - - - - - - - - - - -\nstruct Task {\n    title: String,\n    assignee: Option<Person>,\n}\n\n//üí≠ Instead of assignee: Person, we use Option<Person>\n//Because the task has not been assigned to a specific person\n\n// - - - - - - - - - - - - - - - - - - - - - - -\n//when using Option types as return types on functions\n// we can use pattern matching to catch the relevant return type(Some/None) when calling them\n\nfn main() {\n    let username = \"anonymous\";\n    match get_id_by_username(username) {\n        None => println!(\"User not found\"),\n        Some(i) => println!(\"User Id: {}\", i)\n    }\n}\n```\n\n #### Usages of Result\n \n> [üìñ](https://doc.rust-lang.org/book/first-edition/error-handling.html) The Option type is a way to use Rust‚Äôs type system to express the possibility of absence. Result expresses the possibility of error.\n\n```rust\n// - - - - - - - - - - - - - - - - - - - - - -\nfn get_word_count_from_file(file_name: &str) -> Result<u32, &str> {\n  //if the file is not found on the system, return error\n    return Err(\"File can not be found!\")\n  //else, count and return the word count\n    //let mut word_count: u32; ....\n    Ok(word_count)\n}\n\n//üí≠ on above function,\n// instead panic(break) the app, when a file can not be found; return Err(something)\n// or when it could get the relevant data; return Ok(data)\n\n\n// - - - - - - - - - - - - - - - - - - - - - - -\n// we can use pattern matching to catch the relevant return type(Ok/Err) when calling it\n\nfn main() {\n    let mut file_name = \"file_a\";\n    match get_word_count_from_file(file_name) {\n        Ok(i) => println!(\"Word Count: {}\", i),\n        Err(e) => println!(\"Error: {}\", e)\n    }\n}\n```\n\n\n> üîé Many useful methods have been implemented around Option and Result types. More information can be found on [std::option::Option](https://doc.rust-lang.org/std/option/enum.Option.html) and [std::result::Result](https://doc.rust-lang.org/std/result/enum.Result.html) pages on Rust doc.\n\n‚≠êÔ∏è Also **more practical examples** of options & results can be found on [Error Handling](https://doc.rust-lang.org/book/first-edition/error-handling.html) section in  Rust doc.\n","source":"docs/zh-cn/b4.generics.md","raw":"title: Generics\n---\n\n> [üìñ](https://doc.rust-lang.org/beta/book/first-edition/generics.html) Sometimes, when writing a function or data type, we may want it to work for multiple types of arguments. In Rust, we can do this with generics.\n\nüí≠ The concept is, instead of declaring a specific data type we use an uppercase letter(or CamelCase identifier). ex, **instead x¬†: u8** we use **x¬†: T**¬†. but we have to inform to the compiler that T is a generic type(can be any type) by adding `<T>` at first.\n\n### Generalizing functions\n\n```rust\nfn takes_anything<T>(x: T) { // x has type T, T is a generic type\n}\n\nfn takes_two_of_the_same_things<T>(x: T, y: T) { // both x and y has same type\n}\n\nfn takes_two_things<T, U>(x: T, y: U) { // multiple types\n}\n```\n\n### Generalizing structs\n\n```rust\nstruct Point<T> {\n  x: T,\n  y: T,\n}\n\nfn main() {\n  let point_a = Point { x: 0, y: 0 }; // T is a int type\n  let point_b = Point { x: 0.0, y: 0.0 }; // T is a float type\n}\n\n// üîé When addding an implementation for a generic struct, the type parameters should be declared after the impl as well\n// impl<T> Point<T> {\n```\n\n### Generalizing enums\n\n```rust\nenum Option<T> {\n    Some(T),\n    None,\n}\n\nenum Result<T, E> {\n    Ok(T),\n    Err(E),\n}\n```\n\n> ‚≠êÔ∏è Above [Option](https://doc.rust-lang.org/std/option/index.html) and [Result](https://doc.rust-lang.org/std/result/index.html) types are kind of special generic types which are already defined in Rust‚Äôs standard library.¬†\n  * An **optional value** can have either **Some** value or no value/ **None**.\n  * A **result** can represent either success/ **Ok** or failure/ **Err**\n\n #### Usages of Option\n \n```rust\n// 01 - - - - - - - - - - - - - - - - - - - - - -\nfn get_id_by_username(username: &str) -> Option<usize> {\n    //if username can be found in the system, set userId\n        return Some(userId);\n    //else\n        None\n}\n\n//üí≠ So on above function, instead of setting return type as usize\n// set return type as Option<usize>\n//Instead of return userId, return Some(userId)\n// else None (üí°remember? last return statement no need return keyword and ending ;)\n\n// 02 - - - - - - - - - - - - - - - - - - - - - -\nstruct Task {\n    title: String,\n    assignee: Option<Person>,\n}\n\n//üí≠ Instead of assignee: Person, we use Option<Person>\n//Because the task has not been assigned to a specific person\n\n// - - - - - - - - - - - - - - - - - - - - - - -\n//when using Option types as return types on functions\n// we can use pattern matching to catch the relevant return type(Some/None) when calling them\n\nfn main() {\n    let username = \"anonymous\";\n    match get_id_by_username(username) {\n        None => println!(\"User not found\"),\n        Some(i) => println!(\"User Id: {}\", i)\n    }\n}\n```\n\n #### Usages of Result\n \n> [üìñ](https://doc.rust-lang.org/book/first-edition/error-handling.html) The Option type is a way to use Rust‚Äôs type system to express the possibility of absence. Result expresses the possibility of error.\n\n```rust\n// - - - - - - - - - - - - - - - - - - - - - -\nfn get_word_count_from_file(file_name: &str) -> Result<u32, &str> {\n  //if the file is not found on the system, return error\n    return Err(\"File can not be found!\")\n  //else, count and return the word count\n    //let mut word_count: u32; ....\n    Ok(word_count)\n}\n\n//üí≠ on above function,\n// instead panic(break) the app, when a file can not be found; return Err(something)\n// or when it could get the relevant data; return Ok(data)\n\n\n// - - - - - - - - - - - - - - - - - - - - - - -\n// we can use pattern matching to catch the relevant return type(Ok/Err) when calling it\n\nfn main() {\n    let mut file_name = \"file_a\";\n    match get_word_count_from_file(file_name) {\n        Ok(i) => println!(\"Word Count: {}\", i),\n        Err(e) => println!(\"Error: {}\", e)\n    }\n}\n```\n\n\n> üîé Many useful methods have been implemented around Option and Result types. More information can be found on [std::option::Option](https://doc.rust-lang.org/std/option/enum.Option.html) and [std::result::Result](https://doc.rust-lang.org/std/result/enum.Result.html) pages on Rust doc.\n\n‚≠êÔ∏è Also **more practical examples** of options & results can be found on [Error Handling](https://doc.rust-lang.org/book/first-edition/error-handling.html) section in  Rust doc.\n","date":"2019-03-19T14:50:31.984Z","updated":"2019-03-19T14:50:31.984Z","path":"docs/zh-cn/b4.generics.html","comments":1,"layout":"page","_id":"cjtfwbj0u001bdwgpsqvdxo62","content":"<blockquote>\n<p><a href=\"https://doc.rust-lang.org/beta/book/first-edition/generics.html\" target=\"_blank\" rel=\"noopener\">üìñ</a> Sometimes, when writing a function or data type, we may want it to work for multiple types of arguments. In Rust, we can do this with generics.</p>\n</blockquote>\n<p>üí≠ The concept is, instead of declaring a specific data type we use an uppercase letter(or CamelCase identifier). ex, <strong>instead x : u8</strong> we use <strong>x : T</strong> . but we have to inform to the compiler that T is a generic type(can be any type) by adding <code>&lt;T&gt;</code> at first.</p>\n<h3 id=\"Generalizing-functions\"><a href=\"#Generalizing-functions\" class=\"headerlink\" title=\"Generalizing functions\"></a>Generalizing functions</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn takes_anything&lt;T&gt;(x: T) { // x has type T, T is a generic type\n}\n\nfn takes_two_of_the_same_things&lt;T&gt;(x: T, y: T) { // both x and y has same type\n}\n\nfn takes_two_things&lt;T, U&gt;(x: T, y: U) { // multiple types\n}\n</code></pre>\n<h3 id=\"Generalizing-structs\"><a href=\"#Generalizing-structs\" class=\"headerlink\" title=\"Generalizing structs\"></a>Generalizing structs</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Point&lt;T&gt; {\n  x: T,\n  y: T,\n}\n\nfn main() {\n  let point_a = Point { x: 0, y: 0 }; // T is a int type\n  let point_b = Point { x: 0.0, y: 0.0 }; // T is a float type\n}\n\n// üîé When addding an implementation for a generic struct, the type parameters should be declared after the impl as well\n// impl&lt;T&gt; Point&lt;T&gt; {\n</code></pre>\n<h3 id=\"Generalizing-enums\"><a href=\"#Generalizing-enums\" class=\"headerlink\" title=\"Generalizing enums\"></a>Generalizing enums</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">enum Option&lt;T&gt; {\n    Some(T),\n    None,\n}\n\nenum Result&lt;T, E&gt; {\n    Ok(T),\n    Err(E),\n}\n</code></pre>\n<blockquote>\n<p>‚≠êÔ∏è Above <a href=\"https://doc.rust-lang.org/std/option/index.html\" target=\"_blank\" rel=\"noopener\">Option</a> and <a href=\"https://doc.rust-lang.org/std/result/index.html\" target=\"_blank\" rel=\"noopener\">Result</a> types are kind of special generic types which are already defined in Rust‚Äôs standard library. </p>\n<ul>\n<li>An <strong>optional value</strong> can have either <strong>Some</strong> value or no value/ <strong>None</strong>.</li>\n<li>A <strong>result</strong> can represent either success/ <strong>Ok</strong> or failure/ <strong>Err</strong></li>\n</ul>\n</blockquote>\n<h4 id=\"Usages-of-Option\"><a href=\"#Usages-of-Option\" class=\"headerlink\" title=\"Usages of Option\"></a>Usages of Option</h4><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// 01 - - - - - - - - - - - - - - - - - - - - - -\nfn get_id_by_username(username: &amp;str) -&gt; Option&lt;usize&gt; {\n    //if username can be found in the system, set userId\n        return Some(userId);\n    //else\n        None\n}\n\n//üí≠ So on above function, instead of setting return type as usize\n// set return type as Option&lt;usize&gt;\n//Instead of return userId, return Some(userId)\n// else None (üí°remember? last return statement no need return keyword and ending ;)\n\n// 02 - - - - - - - - - - - - - - - - - - - - - -\nstruct Task {\n    title: String,\n    assignee: Option&lt;Person&gt;,\n}\n\n//üí≠ Instead of assignee: Person, we use Option&lt;Person&gt;\n//Because the task has not been assigned to a specific person\n\n// - - - - - - - - - - - - - - - - - - - - - - -\n//when using Option types as return types on functions\n// we can use pattern matching to catch the relevant return type(Some/None) when calling them\n\nfn main() {\n    let username = &quot;anonymous&quot;;\n    match get_id_by_username(username) {\n        None =&gt; println!(&quot;User not found&quot;),\n        Some(i) =&gt; println!(&quot;User Id: {}&quot;, i)\n    }\n}\n</code></pre>\n<h4 id=\"Usages-of-Result\"><a href=\"#Usages-of-Result\" class=\"headerlink\" title=\"Usages of Result\"></a>Usages of Result</h4><blockquote>\n<p><a href=\"https://doc.rust-lang.org/book/first-edition/error-handling.html\" target=\"_blank\" rel=\"noopener\">üìñ</a> The Option type is a way to use Rust‚Äôs type system to express the possibility of absence. Result expresses the possibility of error.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// - - - - - - - - - - - - - - - - - - - - - -\nfn get_word_count_from_file(file_name: &amp;str) -&gt; Result&lt;u32, &amp;str&gt; {\n  //if the file is not found on the system, return error\n    return Err(&quot;File can not be found!&quot;)\n  //else, count and return the word count\n    //let mut word_count: u32; ....\n    Ok(word_count)\n}\n\n//üí≠ on above function,\n// instead panic(break) the app, when a file can not be found; return Err(something)\n// or when it could get the relevant data; return Ok(data)\n\n\n// - - - - - - - - - - - - - - - - - - - - - - -\n// we can use pattern matching to catch the relevant return type(Ok/Err) when calling it\n\nfn main() {\n    let mut file_name = &quot;file_a&quot;;\n    match get_word_count_from_file(file_name) {\n        Ok(i) =&gt; println!(&quot;Word Count: {}&quot;, i),\n        Err(e) =&gt; println!(&quot;Error: {}&quot;, e)\n    }\n}\n</code></pre>\n<blockquote>\n<p>üîé Many useful methods have been implemented around Option and Result types. More information can be found on <a href=\"https://doc.rust-lang.org/std/option/enum.Option.html\" target=\"_blank\" rel=\"noopener\">std::option::Option</a> and <a href=\"https://doc.rust-lang.org/std/result/enum.Result.html\" target=\"_blank\" rel=\"noopener\">std::result::Result</a> pages on Rust doc.</p>\n</blockquote>\n<p>‚≠êÔ∏è Also <strong>more practical examples</strong> of options &amp; results can be found on <a href=\"https://doc.rust-lang.org/book/first-edition/error-handling.html\" target=\"_blank\" rel=\"noopener\">Error Handling</a> section in  Rust doc.</p>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<blockquote>\n<p><a href=\"https://doc.rust-lang.org/beta/book/first-edition/generics.html\" target=\"_blank\" rel=\"noopener\">üìñ</a> Sometimes, when writing a function or data type, we may want it to work for multiple types of arguments. In Rust, we can do this with generics.</p>\n</blockquote>\n<p>üí≠ The concept is, instead of declaring a specific data type we use an uppercase letter(or CamelCase identifier). ex, <strong>instead x : u8</strong> we use <strong>x : T</strong> . but we have to inform to the compiler that T is a generic type(can be any type) by adding <code>&lt;T&gt;</code> at first.</p>\n<h3 id=\"Generalizing-functions\"><a href=\"#Generalizing-functions\" class=\"headerlink\" title=\"Generalizing functions\"></a>Generalizing functions</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn takes_anything&lt;T&gt;(x: T) { // x has type T, T is a generic type\n}\n\nfn takes_two_of_the_same_things&lt;T&gt;(x: T, y: T) { // both x and y has same type\n}\n\nfn takes_two_things&lt;T, U&gt;(x: T, y: U) { // multiple types\n}\n</code></pre>\n<h3 id=\"Generalizing-structs\"><a href=\"#Generalizing-structs\" class=\"headerlink\" title=\"Generalizing structs\"></a>Generalizing structs</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Point&lt;T&gt; {\n  x: T,\n  y: T,\n}\n\nfn main() {\n  let point_a = Point { x: 0, y: 0 }; // T is a int type\n  let point_b = Point { x: 0.0, y: 0.0 }; // T is a float type\n}\n\n// üîé When addding an implementation for a generic struct, the type parameters should be declared after the impl as well\n// impl&lt;T&gt; Point&lt;T&gt; {\n</code></pre>\n<h3 id=\"Generalizing-enums\"><a href=\"#Generalizing-enums\" class=\"headerlink\" title=\"Generalizing enums\"></a>Generalizing enums</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">enum Option&lt;T&gt; {\n    Some(T),\n    None,\n}\n\nenum Result&lt;T, E&gt; {\n    Ok(T),\n    Err(E),\n}\n</code></pre>\n<blockquote>\n<p>‚≠êÔ∏è Above <a href=\"https://doc.rust-lang.org/std/option/index.html\" target=\"_blank\" rel=\"noopener\">Option</a> and <a href=\"https://doc.rust-lang.org/std/result/index.html\" target=\"_blank\" rel=\"noopener\">Result</a> types are kind of special generic types which are already defined in Rust‚Äôs standard library. </p>\n<ul>\n<li>An <strong>optional value</strong> can have either <strong>Some</strong> value or no value/ <strong>None</strong>.</li>\n<li>A <strong>result</strong> can represent either success/ <strong>Ok</strong> or failure/ <strong>Err</strong></li>\n</ul>\n</blockquote>\n<h4 id=\"Usages-of-Option\"><a href=\"#Usages-of-Option\" class=\"headerlink\" title=\"Usages of Option\"></a>Usages of Option</h4><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// 01 - - - - - - - - - - - - - - - - - - - - - -\nfn get_id_by_username(username: &amp;str) -&gt; Option&lt;usize&gt; {\n    //if username can be found in the system, set userId\n        return Some(userId);\n    //else\n        None\n}\n\n//üí≠ So on above function, instead of setting return type as usize\n// set return type as Option&lt;usize&gt;\n//Instead of return userId, return Some(userId)\n// else None (üí°remember? last return statement no need return keyword and ending ;)\n\n// 02 - - - - - - - - - - - - - - - - - - - - - -\nstruct Task {\n    title: String,\n    assignee: Option&lt;Person&gt;,\n}\n\n//üí≠ Instead of assignee: Person, we use Option&lt;Person&gt;\n//Because the task has not been assigned to a specific person\n\n// - - - - - - - - - - - - - - - - - - - - - - -\n//when using Option types as return types on functions\n// we can use pattern matching to catch the relevant return type(Some/None) when calling them\n\nfn main() {\n    let username = &quot;anonymous&quot;;\n    match get_id_by_username(username) {\n        None =&gt; println!(&quot;User not found&quot;),\n        Some(i) =&gt; println!(&quot;User Id: {}&quot;, i)\n    }\n}\n</code></pre>\n<h4 id=\"Usages-of-Result\"><a href=\"#Usages-of-Result\" class=\"headerlink\" title=\"Usages of Result\"></a>Usages of Result</h4><blockquote>\n<p><a href=\"https://doc.rust-lang.org/book/first-edition/error-handling.html\" target=\"_blank\" rel=\"noopener\">üìñ</a> The Option type is a way to use Rust‚Äôs type system to express the possibility of absence. Result expresses the possibility of error.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// - - - - - - - - - - - - - - - - - - - - - -\nfn get_word_count_from_file(file_name: &amp;str) -&gt; Result&lt;u32, &amp;str&gt; {\n  //if the file is not found on the system, return error\n    return Err(&quot;File can not be found!&quot;)\n  //else, count and return the word count\n    //let mut word_count: u32; ....\n    Ok(word_count)\n}\n\n//üí≠ on above function,\n// instead panic(break) the app, when a file can not be found; return Err(something)\n// or when it could get the relevant data; return Ok(data)\n\n\n// - - - - - - - - - - - - - - - - - - - - - - -\n// we can use pattern matching to catch the relevant return type(Ok/Err) when calling it\n\nfn main() {\n    let mut file_name = &quot;file_a&quot;;\n    match get_word_count_from_file(file_name) {\n        Ok(i) =&gt; println!(&quot;Word Count: {}&quot;, i),\n        Err(e) =&gt; println!(&quot;Error: {}&quot;, e)\n    }\n}\n</code></pre>\n<blockquote>\n<p>üîé Many useful methods have been implemented around Option and Result types. More information can be found on <a href=\"https://doc.rust-lang.org/std/option/enum.Option.html\" target=\"_blank\" rel=\"noopener\">std::option::Option</a> and <a href=\"https://doc.rust-lang.org/std/result/enum.Result.html\" target=\"_blank\" rel=\"noopener\">std::result::Result</a> pages on Rust doc.</p>\n</blockquote>\n<p>‚≠êÔ∏è Also <strong>more practical examples</strong> of options &amp; results can be found on <a href=\"https://doc.rust-lang.org/book/first-edition/error-handling.html\" target=\"_blank\" rel=\"noopener\">Error Handling</a> section in  Rust doc.</p>\n"},{"title":"Impls & Traits","_content":"\nüí° When we discussed about **C-like structs**, I mentioned that those are **similar to classes** in OOP languages, **but without their methods**. **impls** are **used to define methods** for Rust structs and enums.\n\nüí° **Traits** are kind of **similar to interfaces** in OOP languages. They are used to define the functionality a type must provide. Multiple traits can be implemented for a single type.\n\n‚≠êÔ∏èÔ∏è But traits **can also include default implementations of methods**. Default methods can be overriden when implementing types.\n\n### Impls without traits\n\n```rust\nstruct Player {\n    first_name: String,\n    last_name: String,\n}\n\nimpl Player {\n    fn full_name(&self) -> String {\n        format!(\"{} {}\", self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_1 = Player {\n        first_name: \"Rafael\".to_string(),\n        last_name: \"Nadal\".to_string(),\n    };\n\n    println!(\"Player 01: {}\", player_1.full_name());\n}\n\n// ‚≠êÔ∏è Implementation must appear in the same crate as the self type\n\n// üí° And also in Rust, new traits can be implemented for existing types even for types like i8, f64 and etc.\n// Same way existing traits can be implemented for new types you are creating.\n// But we can not implement existing traits into existing types\n```\n\n### Impls & traits, without default methods\n\n```rust\nstruct Player {\n    first_name: String,\n    last_name: String,\n}\n\ntrait FullName {\n    fn full_name(&self) -> String;\n}\n\nimpl FullName for Player {\n    fn full_name(&self) -> String {\n        format!(\"{} {}\", self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_2 = Player {\n        first_name: \"Roger\".to_string(),\n        last_name: \"Federer\".to_string(),\n    };\n\n    println!(\"Player 02: {}\", player_2.full_name());\n}\n\n// üîé Other than functions, traits can contain constants and types\n```\n\n### Impls, traits & default methods\n\n```rust\ntrait Foo {\n    fn bar(&self);\n    fn baz(&self) { println!(\"We called baz.\"); }\n}\n```\n\n‚≠êÔ∏è As you can see methods take a **special first parameter**, the type itself. It can be **either self, &self, or &mut self**; self if it‚Äôs a value on the stack (taking ownership), &self if it‚Äôs a reference, and &mut self if it‚Äôs a mutable reference.\n\n### Impls with Associated functions\n\nSome other languages support **static methods**. At such times, we **call a function directly** through the class without creating an object. In Rust, we call them Associated Functions. we use¬†**::**  instead of¬†. when calling them from struct.\nex. Person::new(‚ÄúElon Musk Jr‚Äù);\n\n\n```rust\nstruct Player {\n    first_name: String,\n    last_name: String,\n}\n\nimpl Player {\n    fn new(first_name: String, last_name: String) -> Player {\n        Player {\n            first_name : first_name,\n            last_name : last_name,\n        }\n    }\n\n    fn full_name(&self) -> String {\n        format!(\"{} {}\", self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_name = Player::new(\"Serena\".to_string(), \"Williams\".to_string()).full_name();\n    println!(\"Player: {}\", player_name);\n}\n\n// we have used :: notation for `new()` and . notation for `full_name()`\n\n// üîé Also in here we have used `Method Chaining`. Instead of using two statements for new() and full_name()\n// calls, we can use a single statement with Method Chaining.\n// ex. player.add_points(2).get_point_count();\n```\n\n### Traits with generics\n\n```rust\ntrait From<T> {\n    fn from(T) -> Self;\n}\n    impl From<u8> for u16 {\n        //...\n    }\n    impl From<u8> for u32{\n        //...\n    }\n    \n//should specify after the trait name like generic functions\n```\n\n### Traits inheritance\n\n```rust\ntrait Person {\n    fn full_name(&self) -> String;\n}\n\n    trait Employee : Person { //Employee inherit from person trait\n      fn job_title(&self) -> String;\n    }\n\n    trait ExpatEmployee : Employee + Expat { //ExpatEmployee inherit from Employee and Expat traits\n      fn additional_tax(&self) -> f64;\n    }\n```\n\n### Trait objects\n\nüîé While Rust favors static dispatch, it also supports dynamic dispatch through a mechanism called ‚Äòtrait objects.‚Äô\n\n> [üÖÜ](https://en.wikipedia.org/wiki/Dynamic_dispatch) **Dynamic dispatch** is the process of selecting which implementation of a polymorphic operation (method or function) to call at run time.\n\n\n```rust\ntrait GetSound {\n    fn get_sound(&self) -> String;\n}\n\nstruct Cat {\n    sound: String,\n}\n    impl GetSound for Cat {\n        fn get_sound(&self) -> String {\n            self.sound.clone()\n        }\n    }\n\nstruct Bell {\n    sound: String,\n}\n    impl GetSound for Bell {\n        fn get_sound(&self) -> String {\n            self.sound.clone()\n        }\n    }\n\n\nfn make_sound<T: GetSound>(t: &T) {\n    println!(\"{}!\", t.get_sound())\n}\n\nfn main() {\n    let kitty = Cat { sound: \"Meow\".to_string() };\n    let the_bell = Bell { sound: \"Ding Dong\".to_string() };\n\n    make_sound(&kitty); // Meow!\n    make_sound(&the_bell); // Ding Dong!\n}\n```\n","source":"docs/zh-cn/b5.impls_and_traits.md","raw":"title: Impls & Traits\n---\n\nüí° When we discussed about **C-like structs**, I mentioned that those are **similar to classes** in OOP languages, **but without their methods**. **impls** are **used to define methods** for Rust structs and enums.\n\nüí° **Traits** are kind of **similar to interfaces** in OOP languages. They are used to define the functionality a type must provide. Multiple traits can be implemented for a single type.\n\n‚≠êÔ∏èÔ∏è But traits **can also include default implementations of methods**. Default methods can be overriden when implementing types.\n\n### Impls without traits\n\n```rust\nstruct Player {\n    first_name: String,\n    last_name: String,\n}\n\nimpl Player {\n    fn full_name(&self) -> String {\n        format!(\"{} {}\", self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_1 = Player {\n        first_name: \"Rafael\".to_string(),\n        last_name: \"Nadal\".to_string(),\n    };\n\n    println!(\"Player 01: {}\", player_1.full_name());\n}\n\n// ‚≠êÔ∏è Implementation must appear in the same crate as the self type\n\n// üí° And also in Rust, new traits can be implemented for existing types even for types like i8, f64 and etc.\n// Same way existing traits can be implemented for new types you are creating.\n// But we can not implement existing traits into existing types\n```\n\n### Impls & traits, without default methods\n\n```rust\nstruct Player {\n    first_name: String,\n    last_name: String,\n}\n\ntrait FullName {\n    fn full_name(&self) -> String;\n}\n\nimpl FullName for Player {\n    fn full_name(&self) -> String {\n        format!(\"{} {}\", self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_2 = Player {\n        first_name: \"Roger\".to_string(),\n        last_name: \"Federer\".to_string(),\n    };\n\n    println!(\"Player 02: {}\", player_2.full_name());\n}\n\n// üîé Other than functions, traits can contain constants and types\n```\n\n### Impls, traits & default methods\n\n```rust\ntrait Foo {\n    fn bar(&self);\n    fn baz(&self) { println!(\"We called baz.\"); }\n}\n```\n\n‚≠êÔ∏è As you can see methods take a **special first parameter**, the type itself. It can be **either self, &self, or &mut self**; self if it‚Äôs a value on the stack (taking ownership), &self if it‚Äôs a reference, and &mut self if it‚Äôs a mutable reference.\n\n### Impls with Associated functions\n\nSome other languages support **static methods**. At such times, we **call a function directly** through the class without creating an object. In Rust, we call them Associated Functions. we use¬†**::**  instead of¬†. when calling them from struct.\nex. Person::new(‚ÄúElon Musk Jr‚Äù);\n\n\n```rust\nstruct Player {\n    first_name: String,\n    last_name: String,\n}\n\nimpl Player {\n    fn new(first_name: String, last_name: String) -> Player {\n        Player {\n            first_name : first_name,\n            last_name : last_name,\n        }\n    }\n\n    fn full_name(&self) -> String {\n        format!(\"{} {}\", self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_name = Player::new(\"Serena\".to_string(), \"Williams\".to_string()).full_name();\n    println!(\"Player: {}\", player_name);\n}\n\n// we have used :: notation for `new()` and . notation for `full_name()`\n\n// üîé Also in here we have used `Method Chaining`. Instead of using two statements for new() and full_name()\n// calls, we can use a single statement with Method Chaining.\n// ex. player.add_points(2).get_point_count();\n```\n\n### Traits with generics\n\n```rust\ntrait From<T> {\n    fn from(T) -> Self;\n}\n    impl From<u8> for u16 {\n        //...\n    }\n    impl From<u8> for u32{\n        //...\n    }\n    \n//should specify after the trait name like generic functions\n```\n\n### Traits inheritance\n\n```rust\ntrait Person {\n    fn full_name(&self) -> String;\n}\n\n    trait Employee : Person { //Employee inherit from person trait\n      fn job_title(&self) -> String;\n    }\n\n    trait ExpatEmployee : Employee + Expat { //ExpatEmployee inherit from Employee and Expat traits\n      fn additional_tax(&self) -> f64;\n    }\n```\n\n### Trait objects\n\nüîé While Rust favors static dispatch, it also supports dynamic dispatch through a mechanism called ‚Äòtrait objects.‚Äô\n\n> [üÖÜ](https://en.wikipedia.org/wiki/Dynamic_dispatch) **Dynamic dispatch** is the process of selecting which implementation of a polymorphic operation (method or function) to call at run time.\n\n\n```rust\ntrait GetSound {\n    fn get_sound(&self) -> String;\n}\n\nstruct Cat {\n    sound: String,\n}\n    impl GetSound for Cat {\n        fn get_sound(&self) -> String {\n            self.sound.clone()\n        }\n    }\n\nstruct Bell {\n    sound: String,\n}\n    impl GetSound for Bell {\n        fn get_sound(&self) -> String {\n            self.sound.clone()\n        }\n    }\n\n\nfn make_sound<T: GetSound>(t: &T) {\n    println!(\"{}!\", t.get_sound())\n}\n\nfn main() {\n    let kitty = Cat { sound: \"Meow\".to_string() };\n    let the_bell = Bell { sound: \"Ding Dong\".to_string() };\n\n    make_sound(&kitty); // Meow!\n    make_sound(&the_bell); // Ding Dong!\n}\n```\n","date":"2019-03-19T14:50:31.984Z","updated":"2019-03-19T14:50:31.984Z","path":"docs/zh-cn/b5.impls_and_traits.html","comments":1,"layout":"page","_id":"cjtfwbj0u001cdwgpivlw7oqm","content":"<p>üí° When we discussed about <strong>C-like structs</strong>, I mentioned that those are <strong>similar to classes</strong> in OOP languages, <strong>but without their methods</strong>. <strong>impls</strong> are <strong>used to define methods</strong> for Rust structs and enums.</p>\n<p>üí° <strong>Traits</strong> are kind of <strong>similar to interfaces</strong> in OOP languages. They are used to define the functionality a type must provide. Multiple traits can be implemented for a single type.</p>\n<p>‚≠êÔ∏èÔ∏è But traits <strong>can also include default implementations of methods</strong>. Default methods can be overriden when implementing types.</p>\n<h3 id=\"Impls-without-traits\"><a href=\"#Impls-without-traits\" class=\"headerlink\" title=\"Impls without traits\"></a>Impls without traits</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Player {\n    first_name: String,\n    last_name: String,\n}\n\nimpl Player {\n    fn full_name(&amp;self) -&gt; String {\n        format!(&quot;{} {}&quot;, self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_1 = Player {\n        first_name: &quot;Rafael&quot;.to_string(),\n        last_name: &quot;Nadal&quot;.to_string(),\n    };\n\n    println!(&quot;Player 01: {}&quot;, player_1.full_name());\n}\n\n// ‚≠êÔ∏è Implementation must appear in the same crate as the self type\n\n// üí° And also in Rust, new traits can be implemented for existing types even for types like i8, f64 and etc.\n// Same way existing traits can be implemented for new types you are creating.\n// But we can not implement existing traits into existing types\n</code></pre>\n<h3 id=\"Impls-amp-traits-without-default-methods\"><a href=\"#Impls-amp-traits-without-default-methods\" class=\"headerlink\" title=\"Impls &amp; traits, without default methods\"></a>Impls &amp; traits, without default methods</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Player {\n    first_name: String,\n    last_name: String,\n}\n\ntrait FullName {\n    fn full_name(&amp;self) -&gt; String;\n}\n\nimpl FullName for Player {\n    fn full_name(&amp;self) -&gt; String {\n        format!(&quot;{} {}&quot;, self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_2 = Player {\n        first_name: &quot;Roger&quot;.to_string(),\n        last_name: &quot;Federer&quot;.to_string(),\n    };\n\n    println!(&quot;Player 02: {}&quot;, player_2.full_name());\n}\n\n// üîé Other than functions, traits can contain constants and types\n</code></pre>\n<h3 id=\"Impls-traits-amp-default-methods\"><a href=\"#Impls-traits-amp-default-methods\" class=\"headerlink\" title=\"Impls, traits &amp; default methods\"></a>Impls, traits &amp; default methods</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">trait Foo {\n    fn bar(&amp;self);\n    fn baz(&amp;self) { println!(&quot;We called baz.&quot;); }\n}\n</code></pre>\n<p>‚≠êÔ∏è As you can see methods take a <strong>special first parameter</strong>, the type itself. It can be <strong>either self, &amp;self, or &amp;mut self</strong>; self if it‚Äôs a value on the stack (taking ownership), &amp;self if it‚Äôs a reference, and &amp;mut self if it‚Äôs a mutable reference.</p>\n<h3 id=\"Impls-with-Associated-functions\"><a href=\"#Impls-with-Associated-functions\" class=\"headerlink\" title=\"Impls with Associated functions\"></a>Impls with Associated functions</h3><p>Some other languages support <strong>static methods</strong>. At such times, we <strong>call a function directly</strong> through the class without creating an object. In Rust, we call them Associated Functions. we use <strong>::</strong>  instead of . when calling them from struct.<br>ex. Person::new(‚ÄúElon Musk Jr‚Äù);</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Player {\n    first_name: String,\n    last_name: String,\n}\n\nimpl Player {\n    fn new(first_name: String, last_name: String) -&gt; Player {\n        Player {\n            first_name : first_name,\n            last_name : last_name,\n        }\n    }\n\n    fn full_name(&amp;self) -&gt; String {\n        format!(&quot;{} {}&quot;, self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_name = Player::new(&quot;Serena&quot;.to_string(), &quot;Williams&quot;.to_string()).full_name();\n    println!(&quot;Player: {}&quot;, player_name);\n}\n\n// we have used :: notation for `new()` and . notation for `full_name()`\n\n// üîé Also in here we have used `Method Chaining`. Instead of using two statements for new() and full_name()\n// calls, we can use a single statement with Method Chaining.\n// ex. player.add_points(2).get_point_count();\n</code></pre>\n<h3 id=\"Traits-with-generics\"><a href=\"#Traits-with-generics\" class=\"headerlink\" title=\"Traits with generics\"></a>Traits with generics</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">trait From&lt;T&gt; {\n    fn from(T) -&gt; Self;\n}\n    impl From&lt;u8&gt; for u16 {\n        //...\n    }\n    impl From&lt;u8&gt; for u32{\n        //...\n    }\n\n//should specify after the trait name like generic functions\n</code></pre>\n<h3 id=\"Traits-inheritance\"><a href=\"#Traits-inheritance\" class=\"headerlink\" title=\"Traits inheritance\"></a>Traits inheritance</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">trait Person {\n    fn full_name(&amp;self) -&gt; String;\n}\n\n    trait Employee : Person { //Employee inherit from person trait\n      fn job_title(&amp;self) -&gt; String;\n    }\n\n    trait ExpatEmployee : Employee + Expat { //ExpatEmployee inherit from Employee and Expat traits\n      fn additional_tax(&amp;self) -&gt; f64;\n    }\n</code></pre>\n<h3 id=\"Trait-objects\"><a href=\"#Trait-objects\" class=\"headerlink\" title=\"Trait objects\"></a>Trait objects</h3><p>üîé While Rust favors static dispatch, it also supports dynamic dispatch through a mechanism called ‚Äòtrait objects.‚Äô</p>\n<blockquote>\n<p><a href=\"https://en.wikipedia.org/wiki/Dynamic_dispatch\" target=\"_blank\" rel=\"noopener\">üÖÜ</a> <strong>Dynamic dispatch</strong> is the process of selecting which implementation of a polymorphic operation (method or function) to call at run time.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">trait GetSound {\n    fn get_sound(&amp;self) -&gt; String;\n}\n\nstruct Cat {\n    sound: String,\n}\n    impl GetSound for Cat {\n        fn get_sound(&amp;self) -&gt; String {\n            self.sound.clone()\n        }\n    }\n\nstruct Bell {\n    sound: String,\n}\n    impl GetSound for Bell {\n        fn get_sound(&amp;self) -&gt; String {\n            self.sound.clone()\n        }\n    }\n\n\nfn make_sound&lt;T: GetSound&gt;(t: &amp;T) {\n    println!(&quot;{}!&quot;, t.get_sound())\n}\n\nfn main() {\n    let kitty = Cat { sound: &quot;Meow&quot;.to_string() };\n    let the_bell = Bell { sound: &quot;Ding Dong&quot;.to_string() };\n\n    make_sound(&amp;kitty); // Meow!\n    make_sound(&amp;the_bell); // Ding Dong!\n}\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<p>üí° When we discussed about <strong>C-like structs</strong>, I mentioned that those are <strong>similar to classes</strong> in OOP languages, <strong>but without their methods</strong>. <strong>impls</strong> are <strong>used to define methods</strong> for Rust structs and enums.</p>\n<p>üí° <strong>Traits</strong> are kind of <strong>similar to interfaces</strong> in OOP languages. They are used to define the functionality a type must provide. Multiple traits can be implemented for a single type.</p>\n<p>‚≠êÔ∏èÔ∏è But traits <strong>can also include default implementations of methods</strong>. Default methods can be overriden when implementing types.</p>\n<h3 id=\"Impls-without-traits\"><a href=\"#Impls-without-traits\" class=\"headerlink\" title=\"Impls without traits\"></a>Impls without traits</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Player {\n    first_name: String,\n    last_name: String,\n}\n\nimpl Player {\n    fn full_name(&amp;self) -&gt; String {\n        format!(&quot;{} {}&quot;, self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_1 = Player {\n        first_name: &quot;Rafael&quot;.to_string(),\n        last_name: &quot;Nadal&quot;.to_string(),\n    };\n\n    println!(&quot;Player 01: {}&quot;, player_1.full_name());\n}\n\n// ‚≠êÔ∏è Implementation must appear in the same crate as the self type\n\n// üí° And also in Rust, new traits can be implemented for existing types even for types like i8, f64 and etc.\n// Same way existing traits can be implemented for new types you are creating.\n// But we can not implement existing traits into existing types\n</code></pre>\n<h3 id=\"Impls-amp-traits-without-default-methods\"><a href=\"#Impls-amp-traits-without-default-methods\" class=\"headerlink\" title=\"Impls &amp; traits, without default methods\"></a>Impls &amp; traits, without default methods</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Player {\n    first_name: String,\n    last_name: String,\n}\n\ntrait FullName {\n    fn full_name(&amp;self) -&gt; String;\n}\n\nimpl FullName for Player {\n    fn full_name(&amp;self) -&gt; String {\n        format!(&quot;{} {}&quot;, self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_2 = Player {\n        first_name: &quot;Roger&quot;.to_string(),\n        last_name: &quot;Federer&quot;.to_string(),\n    };\n\n    println!(&quot;Player 02: {}&quot;, player_2.full_name());\n}\n\n// üîé Other than functions, traits can contain constants and types\n</code></pre>\n<h3 id=\"Impls-traits-amp-default-methods\"><a href=\"#Impls-traits-amp-default-methods\" class=\"headerlink\" title=\"Impls, traits &amp; default methods\"></a>Impls, traits &amp; default methods</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">trait Foo {\n    fn bar(&amp;self);\n    fn baz(&amp;self) { println!(&quot;We called baz.&quot;); }\n}\n</code></pre>\n<p>‚≠êÔ∏è As you can see methods take a <strong>special first parameter</strong>, the type itself. It can be <strong>either self, &amp;self, or &amp;mut self</strong>; self if it‚Äôs a value on the stack (taking ownership), &amp;self if it‚Äôs a reference, and &amp;mut self if it‚Äôs a mutable reference.</p>\n<h3 id=\"Impls-with-Associated-functions\"><a href=\"#Impls-with-Associated-functions\" class=\"headerlink\" title=\"Impls with Associated functions\"></a>Impls with Associated functions</h3><p>Some other languages support <strong>static methods</strong>. At such times, we <strong>call a function directly</strong> through the class without creating an object. In Rust, we call them Associated Functions. we use <strong>::</strong>  instead of . when calling them from struct.<br>ex. Person::new(‚ÄúElon Musk Jr‚Äù);</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Player {\n    first_name: String,\n    last_name: String,\n}\n\nimpl Player {\n    fn new(first_name: String, last_name: String) -&gt; Player {\n        Player {\n            first_name : first_name,\n            last_name : last_name,\n        }\n    }\n\n    fn full_name(&amp;self) -&gt; String {\n        format!(&quot;{} {}&quot;, self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_name = Player::new(&quot;Serena&quot;.to_string(), &quot;Williams&quot;.to_string()).full_name();\n    println!(&quot;Player: {}&quot;, player_name);\n}\n\n// we have used :: notation for `new()` and . notation for `full_name()`\n\n// üîé Also in here we have used `Method Chaining`. Instead of using two statements for new() and full_name()\n// calls, we can use a single statement with Method Chaining.\n// ex. player.add_points(2).get_point_count();\n</code></pre>\n<h3 id=\"Traits-with-generics\"><a href=\"#Traits-with-generics\" class=\"headerlink\" title=\"Traits with generics\"></a>Traits with generics</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">trait From&lt;T&gt; {\n    fn from(T) -&gt; Self;\n}\n    impl From&lt;u8&gt; for u16 {\n        //...\n    }\n    impl From&lt;u8&gt; for u32{\n        //...\n    }\n\n//should specify after the trait name like generic functions\n</code></pre>\n<h3 id=\"Traits-inheritance\"><a href=\"#Traits-inheritance\" class=\"headerlink\" title=\"Traits inheritance\"></a>Traits inheritance</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">trait Person {\n    fn full_name(&amp;self) -&gt; String;\n}\n\n    trait Employee : Person { //Employee inherit from person trait\n      fn job_title(&amp;self) -&gt; String;\n    }\n\n    trait ExpatEmployee : Employee + Expat { //ExpatEmployee inherit from Employee and Expat traits\n      fn additional_tax(&amp;self) -&gt; f64;\n    }\n</code></pre>\n<h3 id=\"Trait-objects\"><a href=\"#Trait-objects\" class=\"headerlink\" title=\"Trait objects\"></a>Trait objects</h3><p>üîé While Rust favors static dispatch, it also supports dynamic dispatch through a mechanism called ‚Äòtrait objects.‚Äô</p>\n<blockquote>\n<p><a href=\"https://en.wikipedia.org/wiki/Dynamic_dispatch\" target=\"_blank\" rel=\"noopener\">üÖÜ</a> <strong>Dynamic dispatch</strong> is the process of selecting which implementation of a polymorphic operation (method or function) to call at run time.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">trait GetSound {\n    fn get_sound(&amp;self) -&gt; String;\n}\n\nstruct Cat {\n    sound: String,\n}\n    impl GetSound for Cat {\n        fn get_sound(&amp;self) -&gt; String {\n            self.sound.clone()\n        }\n    }\n\nstruct Bell {\n    sound: String,\n}\n    impl GetSound for Bell {\n        fn get_sound(&amp;self) -&gt; String {\n            self.sound.clone()\n        }\n    }\n\n\nfn make_sound&lt;T: GetSound&gt;(t: &amp;T) {\n    println!(&quot;{}!&quot;, t.get_sound())\n}\n\nfn main() {\n    let kitty = Cat { sound: &quot;Meow&quot;.to_string() };\n    let the_bell = Bell { sound: &quot;Ding Dong&quot;.to_string() };\n\n    make_sound(&amp;kitty); // Meow!\n    make_sound(&amp;the_bell); // Ding Dong!\n}\n</code></pre>\n"},{"title":"Enums","_content":"\n‚≠êÔ∏è An **enum** is a single type. It contains **variants**, which are possible values of the enum at a given time. For example,\n\n```rust\nenum Day {\n    Sunday,\n    Monday,\n    Tuesday,\n    Wednesday,\n    Thursday,\n    Friday,\n    Saturday\n}\n\n// Day is the enum\n// Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday are the variants\n```\n\n‚≠êÔ∏è Variants can be accessed through¬†:: notation¬†, ex. Day::Sunday\n\n‚≠êÔ∏è Each enum **variant** can have,\n* no data (unit variant)\n* unnamed ordered data (tuple variant)\n* named data (struct variant)\n\n\n```rust\nenum FlashMessage {\n  Success, //a unit variant\n  Warning{ category: i32, message: String }, //a struct variant\n  Error(String) //a tuple variant\n}\n\nfn main() {\n  let mut form_status = FlashMessage::Success;\n  print_flash_message(form_status);\n\n  form_status = FlashMessage::Warning {category: 2, message: String::from(\"Field X is required\")};\n  print_flash_message(form_status);\n\n  form_status = FlashMessage::Error(String::from(\"Connection Error\"));\n  print_flash_message(form_status);\n}\n\nfn print_flash_message(m : FlashMessage) {\n  // pattern matching with enum\n  match m {\n    FlashMessage::Success =>\n      println!(\"Form Submitted correctly\"),\n    FlashMessage::Warning {category, message} => //Destructure, should use same field names\n      println!(\"Warning : {} - {}\", category, message),\n    FlashMessage::Error(msg) =>\n      println!(\"Error : {}\", msg)\n  }\n}\n```\n","source":"docs/zh-cn/b3.enums.md","raw":"title: Enums\n---\n\n‚≠êÔ∏è An **enum** is a single type. It contains **variants**, which are possible values of the enum at a given time. For example,\n\n```rust\nenum Day {\n    Sunday,\n    Monday,\n    Tuesday,\n    Wednesday,\n    Thursday,\n    Friday,\n    Saturday\n}\n\n// Day is the enum\n// Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday are the variants\n```\n\n‚≠êÔ∏è Variants can be accessed through¬†:: notation¬†, ex. Day::Sunday\n\n‚≠êÔ∏è Each enum **variant** can have,\n* no data (unit variant)\n* unnamed ordered data (tuple variant)\n* named data (struct variant)\n\n\n```rust\nenum FlashMessage {\n  Success, //a unit variant\n  Warning{ category: i32, message: String }, //a struct variant\n  Error(String) //a tuple variant\n}\n\nfn main() {\n  let mut form_status = FlashMessage::Success;\n  print_flash_message(form_status);\n\n  form_status = FlashMessage::Warning {category: 2, message: String::from(\"Field X is required\")};\n  print_flash_message(form_status);\n\n  form_status = FlashMessage::Error(String::from(\"Connection Error\"));\n  print_flash_message(form_status);\n}\n\nfn print_flash_message(m : FlashMessage) {\n  // pattern matching with enum\n  match m {\n    FlashMessage::Success =>\n      println!(\"Form Submitted correctly\"),\n    FlashMessage::Warning {category, message} => //Destructure, should use same field names\n      println!(\"Warning : {} - {}\", category, message),\n    FlashMessage::Error(msg) =>\n      println!(\"Error : {}\", msg)\n  }\n}\n```\n","date":"2019-03-19T14:50:31.983Z","updated":"2019-03-19T14:50:31.983Z","path":"docs/zh-cn/b3.enums.html","comments":1,"layout":"page","_id":"cjtfwbj0u001ddwgppvexglti","content":"<p>‚≠êÔ∏è An <strong>enum</strong> is a single type. It contains <strong>variants</strong>, which are possible values of the enum at a given time. For example,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">enum Day {\n    Sunday,\n    Monday,\n    Tuesday,\n    Wednesday,\n    Thursday,\n    Friday,\n    Saturday\n}\n\n// Day is the enum\n// Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday are the variants\n</code></pre>\n<p>‚≠êÔ∏è Variants can be accessed through :: notation , ex. Day::Sunday</p>\n<p>‚≠êÔ∏è Each enum <strong>variant</strong> can have,</p>\n<ul>\n<li>no data (unit variant)</li>\n<li>unnamed ordered data (tuple variant)</li>\n<li>named data (struct variant)</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">enum FlashMessage {\n  Success, //a unit variant\n  Warning{ category: i32, message: String }, //a struct variant\n  Error(String) //a tuple variant\n}\n\nfn main() {\n  let mut form_status = FlashMessage::Success;\n  print_flash_message(form_status);\n\n  form_status = FlashMessage::Warning {category: 2, message: String::from(&quot;Field X is required&quot;)};\n  print_flash_message(form_status);\n\n  form_status = FlashMessage::Error(String::from(&quot;Connection Error&quot;));\n  print_flash_message(form_status);\n}\n\nfn print_flash_message(m : FlashMessage) {\n  // pattern matching with enum\n  match m {\n    FlashMessage::Success =&gt;\n      println!(&quot;Form Submitted correctly&quot;),\n    FlashMessage::Warning {category, message} =&gt; //Destructure, should use same field names\n      println!(&quot;Warning : {} - {}&quot;, category, message),\n    FlashMessage::Error(msg) =&gt;\n      println!(&quot;Error : {}&quot;, msg)\n  }\n}\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<p>‚≠êÔ∏è An <strong>enum</strong> is a single type. It contains <strong>variants</strong>, which are possible values of the enum at a given time. For example,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">enum Day {\n    Sunday,\n    Monday,\n    Tuesday,\n    Wednesday,\n    Thursday,\n    Friday,\n    Saturday\n}\n\n// Day is the enum\n// Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday are the variants\n</code></pre>\n<p>‚≠êÔ∏è Variants can be accessed through :: notation , ex. Day::Sunday</p>\n<p>‚≠êÔ∏è Each enum <strong>variant</strong> can have,</p>\n<ul>\n<li>no data (unit variant)</li>\n<li>unnamed ordered data (tuple variant)</li>\n<li>named data (struct variant)</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">enum FlashMessage {\n  Success, //a unit variant\n  Warning{ category: i32, message: String }, //a struct variant\n  Error(String) //a tuple variant\n}\n\nfn main() {\n  let mut form_status = FlashMessage::Success;\n  print_flash_message(form_status);\n\n  form_status = FlashMessage::Warning {category: 2, message: String::from(&quot;Field X is required&quot;)};\n  print_flash_message(form_status);\n\n  form_status = FlashMessage::Error(String::from(&quot;Connection Error&quot;));\n  print_flash_message(form_status);\n}\n\nfn print_flash_message(m : FlashMessage) {\n  // pattern matching with enum\n  match m {\n    FlashMessage::Success =&gt;\n      println!(&quot;Form Submitted correctly&quot;),\n    FlashMessage::Warning {category, message} =&gt; //Destructure, should use same field names\n      println!(&quot;Warning : {} - {}&quot;, category, message),\n    FlashMessage::Error(msg) =&gt;\n      println!(&quot;Error : {}&quot;, msg)\n  }\n}\n</code></pre>\n"},{"title":"Ownership","_content":"\n```rust\nfn main() {\n    let a = [1, 2, 3];\n    let b = a;\n    println!(\"{:?} {:?}\", a, b); // [1, 2, 3] [1, 2, 3]\n}\n\nfn main() {\n    let a = vec![1, 2, 3];\n    let b = a;\n    println!(\"{:?} {:?}\", a, b); // Error; use of moved value: `a`\n}\n```\n\nIn the above examples, we are just trying to **assign the value of ‚Äòa‚Äô to ‚Äòb‚Äô** . Almost the same code in both code blocks, but having **two different data types**. And the second one gives an error. This is because of the **Ownership**.\n\n\n## What is ownership?\n\n‚≠êÔ∏è Variable bindings have **ownership** of what they‚Äôre bound to. A piece of data can only have **one owner at a time**. When a binding goes out of scope, Rust will free the bound resources. This is how Rust achieves **memory safety**.\n\n> [Ownership \\(noun\\)](https://github.com/nikomatsakis/rust-tutorials-keynote/blob/master/Ownership%20and%20Borrowing.pdf)  \n> The act, state, or right of possessing something.\n\n## Copy types & move types\n‚≠êÔ∏è **When assigning** a variable binding to another variable binding **or when passing it to a function**\\(Without referencing\\), if its data type is a\n\n1. **Copy Type**\n   * Bound resources are **made a copy and assign** or pass it to the function.\n   * The ownership state of the original bindings are set to **‚Äúcopied‚Äù state**.\n   * **Mostly Primitive types**\n2. **Move type**\n   * Bound resources are **moved** to the new variable binding and we **can not access the original variable binding** anymore.\n   * The ownership state of the original bindings are set to **‚Äúmoved‚Äù state**.\n   * **Non-primitive types**\n\n> üîé The functionality of a type is handled by the traits which have been implemented to it. By default, variable bindings have ‚Äòmove semantics.‚Äô However, if a type implements [**core::marker::Copy trait**](https://doc.rust-lang.org/core/marker/trait.Copy.html) , it has a 'copy semantics'.\n\n\nüí° **So in the above second example, ownership of the Vec object moves to ‚Äúb‚Äù and ‚Äúa‚Äù doesn‚Äôt have any ownership to access the resource.**\n","source":"docs/zh-cn/c1.ownership.md","raw":"title: Ownership\n---\n\n```rust\nfn main() {\n    let a = [1, 2, 3];\n    let b = a;\n    println!(\"{:?} {:?}\", a, b); // [1, 2, 3] [1, 2, 3]\n}\n\nfn main() {\n    let a = vec![1, 2, 3];\n    let b = a;\n    println!(\"{:?} {:?}\", a, b); // Error; use of moved value: `a`\n}\n```\n\nIn the above examples, we are just trying to **assign the value of ‚Äòa‚Äô to ‚Äòb‚Äô** . Almost the same code in both code blocks, but having **two different data types**. And the second one gives an error. This is because of the **Ownership**.\n\n\n## What is ownership?\n\n‚≠êÔ∏è Variable bindings have **ownership** of what they‚Äôre bound to. A piece of data can only have **one owner at a time**. When a binding goes out of scope, Rust will free the bound resources. This is how Rust achieves **memory safety**.\n\n> [Ownership \\(noun\\)](https://github.com/nikomatsakis/rust-tutorials-keynote/blob/master/Ownership%20and%20Borrowing.pdf)  \n> The act, state, or right of possessing something.\n\n## Copy types & move types\n‚≠êÔ∏è **When assigning** a variable binding to another variable binding **or when passing it to a function**\\(Without referencing\\), if its data type is a\n\n1. **Copy Type**\n   * Bound resources are **made a copy and assign** or pass it to the function.\n   * The ownership state of the original bindings are set to **‚Äúcopied‚Äù state**.\n   * **Mostly Primitive types**\n2. **Move type**\n   * Bound resources are **moved** to the new variable binding and we **can not access the original variable binding** anymore.\n   * The ownership state of the original bindings are set to **‚Äúmoved‚Äù state**.\n   * **Non-primitive types**\n\n> üîé The functionality of a type is handled by the traits which have been implemented to it. By default, variable bindings have ‚Äòmove semantics.‚Äô However, if a type implements [**core::marker::Copy trait**](https://doc.rust-lang.org/core/marker/trait.Copy.html) , it has a 'copy semantics'.\n\n\nüí° **So in the above second example, ownership of the Vec object moves to ‚Äúb‚Äù and ‚Äúa‚Äù doesn‚Äôt have any ownership to access the resource.**\n","date":"2019-03-19T14:50:31.984Z","updated":"2019-03-19T14:50:31.984Z","path":"docs/zh-cn/c1.ownership.html","comments":1,"layout":"page","_id":"cjtfwbj0v001edwgpo6qfondt","content":"<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let a = [1, 2, 3];\n    let b = a;\n    println!(&quot;{:?} {:?}&quot;, a, b); // [1, 2, 3] [1, 2, 3]\n}\n\nfn main() {\n    let a = vec![1, 2, 3];\n    let b = a;\n    println!(&quot;{:?} {:?}&quot;, a, b); // Error; use of moved value: `a`\n}\n</code></pre>\n<p>In the above examples, we are just trying to <strong>assign the value of ‚Äòa‚Äô to ‚Äòb‚Äô</strong> . Almost the same code in both code blocks, but having <strong>two different data types</strong>. And the second one gives an error. This is because of the <strong>Ownership</strong>.</p>\n<h2 id=\"What-is-ownership\"><a href=\"#What-is-ownership\" class=\"headerlink\" title=\"What is ownership?\"></a>What is ownership?</h2><p>‚≠êÔ∏è Variable bindings have <strong>ownership</strong> of what they‚Äôre bound to. A piece of data can only have <strong>one owner at a time</strong>. When a binding goes out of scope, Rust will free the bound resources. This is how Rust achieves <strong>memory safety</strong>.</p>\n<blockquote>\n<p><a href=\"https://github.com/nikomatsakis/rust-tutorials-keynote/blob/master/Ownership%20and%20Borrowing.pdf\" target=\"_blank\" rel=\"noopener\">Ownership (noun)</a><br>The act, state, or right of possessing something.</p>\n</blockquote>\n<h2 id=\"Copy-types-amp-move-types\"><a href=\"#Copy-types-amp-move-types\" class=\"headerlink\" title=\"Copy types &amp; move types\"></a>Copy types &amp; move types</h2><p>‚≠êÔ∏è <strong>When assigning</strong> a variable binding to another variable binding <strong>or when passing it to a function</strong>(Without referencing), if its data type is a</p>\n<ol>\n<li><strong>Copy Type</strong><ul>\n<li>Bound resources are <strong>made a copy and assign</strong> or pass it to the function.</li>\n<li>The ownership state of the original bindings are set to <strong>‚Äúcopied‚Äù state</strong>.</li>\n<li><strong>Mostly Primitive types</strong></li>\n</ul>\n</li>\n<li><strong>Move type</strong><ul>\n<li>Bound resources are <strong>moved</strong> to the new variable binding and we <strong>can not access the original variable binding</strong> anymore.</li>\n<li>The ownership state of the original bindings are set to <strong>‚Äúmoved‚Äù state</strong>.</li>\n<li><strong>Non-primitive types</strong></li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>üîé The functionality of a type is handled by the traits which have been implemented to it. By default, variable bindings have ‚Äòmove semantics.‚Äô However, if a type implements <a href=\"https://doc.rust-lang.org/core/marker/trait.Copy.html\" target=\"_blank\" rel=\"noopener\"><strong>core::marker::Copy trait</strong></a> , it has a ‚Äòcopy semantics‚Äô.</p>\n</blockquote>\n<p>üí° <strong>So in the above second example, ownership of the Vec object moves to ‚Äúb‚Äù and ‚Äúa‚Äù doesn‚Äôt have any ownership to access the resource.</strong></p>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let a = [1, 2, 3];\n    let b = a;\n    println!(&quot;{:?} {:?}&quot;, a, b); // [1, 2, 3] [1, 2, 3]\n}\n\nfn main() {\n    let a = vec![1, 2, 3];\n    let b = a;\n    println!(&quot;{:?} {:?}&quot;, a, b); // Error; use of moved value: `a`\n}\n</code></pre>\n<p>In the above examples, we are just trying to <strong>assign the value of ‚Äòa‚Äô to ‚Äòb‚Äô</strong> . Almost the same code in both code blocks, but having <strong>two different data types</strong>. And the second one gives an error. This is because of the <strong>Ownership</strong>.</p>\n<h2 id=\"What-is-ownership\"><a href=\"#What-is-ownership\" class=\"headerlink\" title=\"What is ownership?\"></a>What is ownership?</h2><p>‚≠êÔ∏è Variable bindings have <strong>ownership</strong> of what they‚Äôre bound to. A piece of data can only have <strong>one owner at a time</strong>. When a binding goes out of scope, Rust will free the bound resources. This is how Rust achieves <strong>memory safety</strong>.</p>\n<blockquote>\n<p><a href=\"https://github.com/nikomatsakis/rust-tutorials-keynote/blob/master/Ownership%20and%20Borrowing.pdf\" target=\"_blank\" rel=\"noopener\">Ownership (noun)</a><br>The act, state, or right of possessing something.</p>\n</blockquote>\n<h2 id=\"Copy-types-amp-move-types\"><a href=\"#Copy-types-amp-move-types\" class=\"headerlink\" title=\"Copy types &amp; move types\"></a>Copy types &amp; move types</h2><p>‚≠êÔ∏è <strong>When assigning</strong> a variable binding to another variable binding <strong>or when passing it to a function</strong>(Without referencing), if its data type is a</p>\n<ol>\n<li><strong>Copy Type</strong><ul>\n<li>Bound resources are <strong>made a copy and assign</strong> or pass it to the function.</li>\n<li>The ownership state of the original bindings are set to <strong>‚Äúcopied‚Äù state</strong>.</li>\n<li><strong>Mostly Primitive types</strong></li>\n</ul>\n</li>\n<li><strong>Move type</strong><ul>\n<li>Bound resources are <strong>moved</strong> to the new variable binding and we <strong>can not access the original variable binding</strong> anymore.</li>\n<li>The ownership state of the original bindings are set to <strong>‚Äúmoved‚Äù state</strong>.</li>\n<li><strong>Non-primitive types</strong></li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>üîé The functionality of a type is handled by the traits which have been implemented to it. By default, variable bindings have ‚Äòmove semantics.‚Äô However, if a type implements <a href=\"https://doc.rust-lang.org/core/marker/trait.Copy.html\" target=\"_blank\" rel=\"noopener\"><strong>core::marker::Copy trait</strong></a> , it has a ‚Äòcopy semantics‚Äô.</p>\n</blockquote>\n<p>üí° <strong>So in the above second example, ownership of the Vec object moves to ‚Äúb‚Äù and ‚Äúa‚Äù doesn‚Äôt have any ownership to access the resource.</strong></p>\n"},{"title":"Borrowing","_content":"\nIn real life applications, most of the times we have to pass variable bindings to other functions or assign them to another variable bindings. In this case we **referencing** the original binding; **borrow** the data of it.\n\n## What is Borrowing?\n\n> [Borrow \\(verb\\)](https://github.com/nikomatsakis/rust-tutorials-keynote/blob/master/Ownership%20and%20Borrowing.pdf)  \n> To receive something with the promise of returning it.\n\n## Shared & Mutable borrowings\n\n‚≠êÔ∏è There are two types of Borrowing,\n\n1. **Shared Borrowing** `(&T)`\n\n   * A piece of data can be **borrowed by a single or multiple users**, but **data should not be altered**.\n\n2. **Mutable Borrowing** `(&mut T)`\n\n   * A piece of data can be **borrowed and altered by a single user**, but the data should not be accessible for any other users at that time.\n\n## Rules for borrowings\n\nThere are very important rules regarding borrowing,\n\n1. One piece of data can be borrowed **either** as a shared borrow **or** as a mutable borrow **at a given time. But not both at the same time**.\n\n2. Borrowing **applies for both copy types and move types**.\n\n3. The concept of **Liveness** ‚Ü¥\n\n```rust\nfn main() {\n  let mut a = vec![1, 2, 3];\n  let b = &mut a;  //  &mut borrow of a starts here\n                   //  ‚Åù\n  // some code     //  ‚Åù\n  // some code     //  ‚Åù\n}                  //  &mut borrow of a ends here\n\n\nfn main() {\n  let mut a = vec![1, 2, 3];\n  let b = &mut a;  //  &mut borrow of a starts here\n  // some code\n\n  println!(\"{:?}\", a); // trying to access a as a shared borrow, so giving error\n}                  //  &mut borrow of a ends here\n\n\nfn main() {\n  let mut a = vec![1, 2, 3];\n  {\n    let b = &mut a;  //  &mut borrow of a starts here\n    // any other code\n  }                  //  &mut borrow of a ends here\n\n  println!(\"{:?}\", a); // allow to borrow a as a shared borrow\n}\n```\n\nüí° Let‚Äôs see how to use shared and mutable borrowings in examples.\n\n### Examples for Shared Borrowing\n\n```rust\nfn main() {\n    let a = [1, 2, 3];\n    let b = &a;\n    println!(\"{:?} {}\", a, b[0]); // [1, 2, 3] 1\n}\n\n\nfn main() {\n    let a = vec![1, 2, 3];\n    let b = get_first_element(&a);\n\n    println!(\"{:?} {}\", a, b); // [1, 2, 3] 1\n}\n\nfn get_first_element(a: &Vec<i32>) -> i32 {\n    a[0]\n}\n```\n\n### Examples for Mutable Borrowing\n\n```rust\nfn main() {\n    let mut a = [1, 2, 3];\n    let b = &mut a;\n    b[0] = 4;\n    println!(\"{:?}\", b); // [4, 2, 3]\n}\n\n\nfn main() {\n    let mut a = [1, 2, 3];\n    {\n        let b = &mut a;\n        b[0] = 4;\n    }\n\n    println!(\"{:?}\", a); // [4, 2, 3]\n}\n\n\nfn main() {\n    let mut a = vec![1, 2, 3];\n    let b = change_and_get_first_element(&mut a);\n\n    println!(\"{:?} {}\", a, b); // [4, 2, 3] 4\n}\n\nfn change_and_get_first_element(a: &mut Vec<i32>) -> i32 {\n    a[0] = 4;\n    a[0]\n}\n```\n","source":"docs/zh-cn/c2.borrowing.md","raw":"title: Borrowing\n---\n\nIn real life applications, most of the times we have to pass variable bindings to other functions or assign them to another variable bindings. In this case we **referencing** the original binding; **borrow** the data of it.\n\n## What is Borrowing?\n\n> [Borrow \\(verb\\)](https://github.com/nikomatsakis/rust-tutorials-keynote/blob/master/Ownership%20and%20Borrowing.pdf)  \n> To receive something with the promise of returning it.\n\n## Shared & Mutable borrowings\n\n‚≠êÔ∏è There are two types of Borrowing,\n\n1. **Shared Borrowing** `(&T)`\n\n   * A piece of data can be **borrowed by a single or multiple users**, but **data should not be altered**.\n\n2. **Mutable Borrowing** `(&mut T)`\n\n   * A piece of data can be **borrowed and altered by a single user**, but the data should not be accessible for any other users at that time.\n\n## Rules for borrowings\n\nThere are very important rules regarding borrowing,\n\n1. One piece of data can be borrowed **either** as a shared borrow **or** as a mutable borrow **at a given time. But not both at the same time**.\n\n2. Borrowing **applies for both copy types and move types**.\n\n3. The concept of **Liveness** ‚Ü¥\n\n```rust\nfn main() {\n  let mut a = vec![1, 2, 3];\n  let b = &mut a;  //  &mut borrow of a starts here\n                   //  ‚Åù\n  // some code     //  ‚Åù\n  // some code     //  ‚Åù\n}                  //  &mut borrow of a ends here\n\n\nfn main() {\n  let mut a = vec![1, 2, 3];\n  let b = &mut a;  //  &mut borrow of a starts here\n  // some code\n\n  println!(\"{:?}\", a); // trying to access a as a shared borrow, so giving error\n}                  //  &mut borrow of a ends here\n\n\nfn main() {\n  let mut a = vec![1, 2, 3];\n  {\n    let b = &mut a;  //  &mut borrow of a starts here\n    // any other code\n  }                  //  &mut borrow of a ends here\n\n  println!(\"{:?}\", a); // allow to borrow a as a shared borrow\n}\n```\n\nüí° Let‚Äôs see how to use shared and mutable borrowings in examples.\n\n### Examples for Shared Borrowing\n\n```rust\nfn main() {\n    let a = [1, 2, 3];\n    let b = &a;\n    println!(\"{:?} {}\", a, b[0]); // [1, 2, 3] 1\n}\n\n\nfn main() {\n    let a = vec![1, 2, 3];\n    let b = get_first_element(&a);\n\n    println!(\"{:?} {}\", a, b); // [1, 2, 3] 1\n}\n\nfn get_first_element(a: &Vec<i32>) -> i32 {\n    a[0]\n}\n```\n\n### Examples for Mutable Borrowing\n\n```rust\nfn main() {\n    let mut a = [1, 2, 3];\n    let b = &mut a;\n    b[0] = 4;\n    println!(\"{:?}\", b); // [4, 2, 3]\n}\n\n\nfn main() {\n    let mut a = [1, 2, 3];\n    {\n        let b = &mut a;\n        b[0] = 4;\n    }\n\n    println!(\"{:?}\", a); // [4, 2, 3]\n}\n\n\nfn main() {\n    let mut a = vec![1, 2, 3];\n    let b = change_and_get_first_element(&mut a);\n\n    println!(\"{:?} {}\", a, b); // [4, 2, 3] 4\n}\n\nfn change_and_get_first_element(a: &mut Vec<i32>) -> i32 {\n    a[0] = 4;\n    a[0]\n}\n```\n","date":"2019-03-19T14:50:31.984Z","updated":"2019-03-19T14:50:31.984Z","path":"docs/zh-cn/c2.borrowing.html","comments":1,"layout":"page","_id":"cjtfwbj0v001fdwgppxt1rnoy","content":"<p>In real life applications, most of the times we have to pass variable bindings to other functions or assign them to another variable bindings. In this case we <strong>referencing</strong> the original binding; <strong>borrow</strong> the data of it.</p>\n<h2 id=\"What-is-Borrowing\"><a href=\"#What-is-Borrowing\" class=\"headerlink\" title=\"What is Borrowing?\"></a>What is Borrowing?</h2><blockquote>\n<p><a href=\"https://github.com/nikomatsakis/rust-tutorials-keynote/blob/master/Ownership%20and%20Borrowing.pdf\" target=\"_blank\" rel=\"noopener\">Borrow (verb)</a><br>To receive something with the promise of returning it.</p>\n</blockquote>\n<h2 id=\"Shared-amp-Mutable-borrowings\"><a href=\"#Shared-amp-Mutable-borrowings\" class=\"headerlink\" title=\"Shared &amp; Mutable borrowings\"></a>Shared &amp; Mutable borrowings</h2><p>‚≠êÔ∏è There are two types of Borrowing,</p>\n<ol>\n<li><p><strong>Shared Borrowing</strong> <code>(&amp;T)</code></p>\n<ul>\n<li>A piece of data can be <strong>borrowed by a single or multiple users</strong>, but <strong>data should not be altered</strong>.</li>\n</ul>\n</li>\n<li><p><strong>Mutable Borrowing</strong> <code>(&amp;mut T)</code></p>\n<ul>\n<li>A piece of data can be <strong>borrowed and altered by a single user</strong>, but the data should not be accessible for any other users at that time.</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"Rules-for-borrowings\"><a href=\"#Rules-for-borrowings\" class=\"headerlink\" title=\"Rules for borrowings\"></a>Rules for borrowings</h2><p>There are very important rules regarding borrowing,</p>\n<ol>\n<li><p>One piece of data can be borrowed <strong>either</strong> as a shared borrow <strong>or</strong> as a mutable borrow <strong>at a given time. But not both at the same time</strong>.</p>\n</li>\n<li><p>Borrowing <strong>applies for both copy types and move types</strong>.</p>\n</li>\n<li><p>The concept of <strong>Liveness</strong> ‚Ü¥</p>\n</li>\n</ol>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n  let mut a = vec![1, 2, 3];\n  let b = &amp;mut a;  //  &amp;mut borrow of a starts here\n                   //  ‚Åù\n  // some code     //  ‚Åù\n  // some code     //  ‚Åù\n}                  //  &amp;mut borrow of a ends here\n\n\nfn main() {\n  let mut a = vec![1, 2, 3];\n  let b = &amp;mut a;  //  &amp;mut borrow of a starts here\n  // some code\n\n  println!(&quot;{:?}&quot;, a); // trying to access a as a shared borrow, so giving error\n}                  //  &amp;mut borrow of a ends here\n\n\nfn main() {\n  let mut a = vec![1, 2, 3];\n  {\n    let b = &amp;mut a;  //  &amp;mut borrow of a starts here\n    // any other code\n  }                  //  &amp;mut borrow of a ends here\n\n  println!(&quot;{:?}&quot;, a); // allow to borrow a as a shared borrow\n}\n</code></pre>\n<p>üí° Let‚Äôs see how to use shared and mutable borrowings in examples.</p>\n<h3 id=\"Examples-for-Shared-Borrowing\"><a href=\"#Examples-for-Shared-Borrowing\" class=\"headerlink\" title=\"Examples for Shared Borrowing\"></a>Examples for Shared Borrowing</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let a = [1, 2, 3];\n    let b = &amp;a;\n    println!(&quot;{:?} {}&quot;, a, b[0]); // [1, 2, 3] 1\n}\n\n\nfn main() {\n    let a = vec![1, 2, 3];\n    let b = get_first_element(&amp;a);\n\n    println!(&quot;{:?} {}&quot;, a, b); // [1, 2, 3] 1\n}\n\nfn get_first_element(a: &amp;Vec&lt;i32&gt;) -&gt; i32 {\n    a[0]\n}\n</code></pre>\n<h3 id=\"Examples-for-Mutable-Borrowing\"><a href=\"#Examples-for-Mutable-Borrowing\" class=\"headerlink\" title=\"Examples for Mutable Borrowing\"></a>Examples for Mutable Borrowing</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let mut a = [1, 2, 3];\n    let b = &amp;mut a;\n    b[0] = 4;\n    println!(&quot;{:?}&quot;, b); // [4, 2, 3]\n}\n\n\nfn main() {\n    let mut a = [1, 2, 3];\n    {\n        let b = &amp;mut a;\n        b[0] = 4;\n    }\n\n    println!(&quot;{:?}&quot;, a); // [4, 2, 3]\n}\n\n\nfn main() {\n    let mut a = vec![1, 2, 3];\n    let b = change_and_get_first_element(&amp;mut a);\n\n    println!(&quot;{:?} {}&quot;, a, b); // [4, 2, 3] 4\n}\n\nfn change_and_get_first_element(a: &amp;mut Vec&lt;i32&gt;) -&gt; i32 {\n    a[0] = 4;\n    a[0]\n}\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<p>In real life applications, most of the times we have to pass variable bindings to other functions or assign them to another variable bindings. In this case we <strong>referencing</strong> the original binding; <strong>borrow</strong> the data of it.</p>\n<h2 id=\"What-is-Borrowing\"><a href=\"#What-is-Borrowing\" class=\"headerlink\" title=\"What is Borrowing?\"></a>What is Borrowing?</h2><blockquote>\n<p><a href=\"https://github.com/nikomatsakis/rust-tutorials-keynote/blob/master/Ownership%20and%20Borrowing.pdf\" target=\"_blank\" rel=\"noopener\">Borrow (verb)</a><br>To receive something with the promise of returning it.</p>\n</blockquote>\n<h2 id=\"Shared-amp-Mutable-borrowings\"><a href=\"#Shared-amp-Mutable-borrowings\" class=\"headerlink\" title=\"Shared &amp; Mutable borrowings\"></a>Shared &amp; Mutable borrowings</h2><p>‚≠êÔ∏è There are two types of Borrowing,</p>\n<ol>\n<li><p><strong>Shared Borrowing</strong> <code>(&amp;T)</code></p>\n<ul>\n<li>A piece of data can be <strong>borrowed by a single or multiple users</strong>, but <strong>data should not be altered</strong>.</li>\n</ul>\n</li>\n<li><p><strong>Mutable Borrowing</strong> <code>(&amp;mut T)</code></p>\n<ul>\n<li>A piece of data can be <strong>borrowed and altered by a single user</strong>, but the data should not be accessible for any other users at that time.</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"Rules-for-borrowings\"><a href=\"#Rules-for-borrowings\" class=\"headerlink\" title=\"Rules for borrowings\"></a>Rules for borrowings</h2><p>There are very important rules regarding borrowing,</p>\n<ol>\n<li><p>One piece of data can be borrowed <strong>either</strong> as a shared borrow <strong>or</strong> as a mutable borrow <strong>at a given time. But not both at the same time</strong>.</p>\n</li>\n<li><p>Borrowing <strong>applies for both copy types and move types</strong>.</p>\n</li>\n<li><p>The concept of <strong>Liveness</strong> ‚Ü¥</p>\n</li>\n</ol>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n  let mut a = vec![1, 2, 3];\n  let b = &amp;mut a;  //  &amp;mut borrow of a starts here\n                   //  ‚Åù\n  // some code     //  ‚Åù\n  // some code     //  ‚Åù\n}                  //  &amp;mut borrow of a ends here\n\n\nfn main() {\n  let mut a = vec![1, 2, 3];\n  let b = &amp;mut a;  //  &amp;mut borrow of a starts here\n  // some code\n\n  println!(&quot;{:?}&quot;, a); // trying to access a as a shared borrow, so giving error\n}                  //  &amp;mut borrow of a ends here\n\n\nfn main() {\n  let mut a = vec![1, 2, 3];\n  {\n    let b = &amp;mut a;  //  &amp;mut borrow of a starts here\n    // any other code\n  }                  //  &amp;mut borrow of a ends here\n\n  println!(&quot;{:?}&quot;, a); // allow to borrow a as a shared borrow\n}\n</code></pre>\n<p>üí° Let‚Äôs see how to use shared and mutable borrowings in examples.</p>\n<h3 id=\"Examples-for-Shared-Borrowing\"><a href=\"#Examples-for-Shared-Borrowing\" class=\"headerlink\" title=\"Examples for Shared Borrowing\"></a>Examples for Shared Borrowing</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let a = [1, 2, 3];\n    let b = &amp;a;\n    println!(&quot;{:?} {}&quot;, a, b[0]); // [1, 2, 3] 1\n}\n\n\nfn main() {\n    let a = vec![1, 2, 3];\n    let b = get_first_element(&amp;a);\n\n    println!(&quot;{:?} {}&quot;, a, b); // [1, 2, 3] 1\n}\n\nfn get_first_element(a: &amp;Vec&lt;i32&gt;) -&gt; i32 {\n    a[0]\n}\n</code></pre>\n<h3 id=\"Examples-for-Mutable-Borrowing\"><a href=\"#Examples-for-Mutable-Borrowing\" class=\"headerlink\" title=\"Examples for Mutable Borrowing\"></a>Examples for Mutable Borrowing</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let mut a = [1, 2, 3];\n    let b = &amp;mut a;\n    b[0] = 4;\n    println!(&quot;{:?}&quot;, b); // [4, 2, 3]\n}\n\n\nfn main() {\n    let mut a = [1, 2, 3];\n    {\n        let b = &amp;mut a;\n        b[0] = 4;\n    }\n\n    println!(&quot;{:?}&quot;, a); // [4, 2, 3]\n}\n\n\nfn main() {\n    let mut a = vec![1, 2, 3];\n    let b = change_and_get_first_element(&amp;mut a);\n\n    println!(&quot;{:?} {}&quot;, a, b); // [4, 2, 3] 4\n}\n\nfn change_and_get_first_element(a: &amp;mut Vec&lt;i32&gt;) -&gt; i32 {\n    a[0] = 4;\n    a[0]\n}\n</code></pre>\n"},{"title":"Functions","_content":"\nFunctions are the first line of organization in any program.\n\n```rust\nfn main() {\n  greet(); //do one thing\n  ask_location(); //do another thing\n}\n\nfn greet() {\n  println!(\"Hello!\");\n}\n\nfn ask_location() {\n  println!(\"Where are you from?\");\n}\n```\n\nWe can add unit tests in the same file.\n\n```rust\nfn main() {\n    greet();\n}\n\nfn greet() -> String {\n    \"Hello, world!\".to_string()\n}\n\n#[test] // test attribute indicates, this is a test function\nfn test_greet() {\n    assert_eq!(\"Hello, world!\", greet())\n}\n\n// üí° Always put test functions inside a tests module with #[cfg(test)] attribute. \n// cfg(test) module compiles only when running tests. We discuss more about this in next section.\n```\n\n> üí≠ An [attribute](https://doc.rust-lang.org/reference/attributes.html) is a general, free-form **metadatum** that is interpreted according to name, convention, and language and compiler version.","source":"docs/zh-cn/d2.functions.md","raw":"title: Functions\n---\n\nFunctions are the first line of organization in any program.\n\n```rust\nfn main() {\n  greet(); //do one thing\n  ask_location(); //do another thing\n}\n\nfn greet() {\n  println!(\"Hello!\");\n}\n\nfn ask_location() {\n  println!(\"Where are you from?\");\n}\n```\n\nWe can add unit tests in the same file.\n\n```rust\nfn main() {\n    greet();\n}\n\nfn greet() -> String {\n    \"Hello, world!\".to_string()\n}\n\n#[test] // test attribute indicates, this is a test function\nfn test_greet() {\n    assert_eq!(\"Hello, world!\", greet())\n}\n\n// üí° Always put test functions inside a tests module with #[cfg(test)] attribute. \n// cfg(test) module compiles only when running tests. We discuss more about this in next section.\n```\n\n> üí≠ An [attribute](https://doc.rust-lang.org/reference/attributes.html) is a general, free-form **metadatum** that is interpreted according to name, convention, and language and compiler version.","date":"2019-03-19T14:50:31.985Z","updated":"2019-03-19T14:50:31.985Z","path":"docs/zh-cn/d2.functions.html","comments":1,"layout":"page","_id":"cjtfwbj0w001gdwgpgro3j6o2","content":"<p>Functions are the first line of organization in any program.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n  greet(); //do one thing\n  ask_location(); //do another thing\n}\n\nfn greet() {\n  println!(&quot;Hello!&quot;);\n}\n\nfn ask_location() {\n  println!(&quot;Where are you from?&quot;);\n}\n</code></pre>\n<p>We can add unit tests in the same file.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    greet();\n}\n\nfn greet() -&gt; String {\n    &quot;Hello, world!&quot;.to_string()\n}\n\n#[test] // test attribute indicates, this is a test function\nfn test_greet() {\n    assert_eq!(&quot;Hello, world!&quot;, greet())\n}\n\n// üí° Always put test functions inside a tests module with #[cfg(test)] attribute. \n// cfg(test) module compiles only when running tests. We discuss more about this in next section.\n</code></pre>\n<blockquote>\n<p>üí≠ An <a href=\"https://doc.rust-lang.org/reference/attributes.html\" target=\"_blank\" rel=\"noopener\">attribute</a> is a general, free-form <strong>metadatum</strong> that is interpreted according to name, convention, and language and compiler version.</p>\n</blockquote>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<p>Functions are the first line of organization in any program.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n  greet(); //do one thing\n  ask_location(); //do another thing\n}\n\nfn greet() {\n  println!(&quot;Hello!&quot;);\n}\n\nfn ask_location() {\n  println!(&quot;Where are you from?&quot;);\n}\n</code></pre>\n<p>We can add unit tests in the same file.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    greet();\n}\n\nfn greet() -&gt; String {\n    &quot;Hello, world!&quot;.to_string()\n}\n\n#[test] // test attribute indicates, this is a test function\nfn test_greet() {\n    assert_eq!(&quot;Hello, world!&quot;, greet())\n}\n\n// üí° Always put test functions inside a tests module with #[cfg(test)] attribute. \n// cfg(test) module compiles only when running tests. We discuss more about this in next section.\n</code></pre>\n<blockquote>\n<p>üí≠ An <a href=\"https://doc.rust-lang.org/reference/attributes.html\" target=\"_blank\" rel=\"noopener\">attribute</a> is a general, free-form <strong>metadatum</strong> that is interpreted according to name, convention, and language and compiler version.</p>\n</blockquote>\n"},{"title":"Code Organization","_content":"\nWhen a single code block is getting larger, it should be decomposed into smaller pieces and should be organized in a proper manner. Rust supports different levels of code organization.\n\n1. ### Functions\n2. ### Modules\n\n  Can be mapped to a,\n  \n  - **Inline module**\n  - **File** \n  - **Directory hierarchy**\n  \n3. ### Crates\n\n  Can be mapped to a, \n  - **lib.rs file on the same executable crate**\n  - **Dependency crate specified on Cargo.toml**\n    \n    Can be specified from,\n    \n    - **path**\n    - **git repository**\n    - **crates.io**\n4. ### Workspaces\n\n  Helps to manage multiple crates as a single project.\n\n\nLet‚Äôs discuss one by one.\n\n> üí° To make examples more simpler, we use a simple function which prints `‚ÄúHello, world!‚Äù`. But regarding writing testable codes, always try to return the `String` from the function and print it when calling it, instead printing the String inside the function.","source":"docs/zh-cn/d1.code_organization.md","raw":"title: Code Organization\n---\n\nWhen a single code block is getting larger, it should be decomposed into smaller pieces and should be organized in a proper manner. Rust supports different levels of code organization.\n\n1. ### Functions\n2. ### Modules\n\n  Can be mapped to a,\n  \n  - **Inline module**\n  - **File** \n  - **Directory hierarchy**\n  \n3. ### Crates\n\n  Can be mapped to a, \n  - **lib.rs file on the same executable crate**\n  - **Dependency crate specified on Cargo.toml**\n    \n    Can be specified from,\n    \n    - **path**\n    - **git repository**\n    - **crates.io**\n4. ### Workspaces\n\n  Helps to manage multiple crates as a single project.\n\n\nLet‚Äôs discuss one by one.\n\n> üí° To make examples more simpler, we use a simple function which prints `‚ÄúHello, world!‚Äù`. But regarding writing testable codes, always try to return the `String` from the function and print it when calling it, instead printing the String inside the function.","date":"2019-03-19T14:50:31.985Z","updated":"2019-03-19T14:50:31.985Z","path":"docs/zh-cn/d1.code_organization.html","comments":1,"layout":"page","_id":"cjtfwbj0w001hdwgpj48l8ct0","content":"<p>When a single code block is getting larger, it should be decomposed into smaller pieces and should be organized in a proper manner. Rust supports different levels of code organization.</p>\n<ol>\n<li><h3 id=\"Functions\"><a href=\"#Functions\" class=\"headerlink\" title=\"Functions\"></a>Functions</h3></li>\n<li><h3 id=\"Modules\"><a href=\"#Modules\" class=\"headerlink\" title=\"Modules\"></a>Modules</h3><p>Can be mapped to a,</p>\n<ul>\n<li><strong>Inline module</strong></li>\n<li><strong>File</strong> </li>\n<li><strong>Directory hierarchy</strong></li>\n</ul>\n</li>\n<li><h3 id=\"Crates\"><a href=\"#Crates\" class=\"headerlink\" title=\"Crates\"></a>Crates</h3><p>Can be mapped to a, </p>\n<ul>\n<li><strong>lib.rs file on the same executable crate</strong></li>\n<li><p><strong>Dependency crate specified on Cargo.toml</strong></p>\n<p>Can be specified from,</p>\n<ul>\n<li><strong>path</strong></li>\n<li><strong>git repository</strong></li>\n<li><strong>crates.io</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><h3 id=\"Workspaces\"><a href=\"#Workspaces\" class=\"headerlink\" title=\"Workspaces\"></a>Workspaces</h3><p>Helps to manage multiple crates as a single project.</p>\n</li>\n</ol>\n<p>Let‚Äôs discuss one by one.</p>\n<blockquote>\n<p>üí° To make examples more simpler, we use a simple function which prints <code>‚ÄúHello, world!‚Äù</code>. But regarding writing testable codes, always try to return the <code>String</code> from the function and print it when calling it, instead printing the String inside the function.</p>\n</blockquote>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<p>When a single code block is getting larger, it should be decomposed into smaller pieces and should be organized in a proper manner. Rust supports different levels of code organization.</p>\n<ol>\n<li><h3 id=\"Functions\"><a href=\"#Functions\" class=\"headerlink\" title=\"Functions\"></a>Functions</h3></li>\n<li><h3 id=\"Modules\"><a href=\"#Modules\" class=\"headerlink\" title=\"Modules\"></a>Modules</h3><p>Can be mapped to a,</p>\n<ul>\n<li><strong>Inline module</strong></li>\n<li><strong>File</strong> </li>\n<li><strong>Directory hierarchy</strong></li>\n</ul>\n</li>\n<li><h3 id=\"Crates\"><a href=\"#Crates\" class=\"headerlink\" title=\"Crates\"></a>Crates</h3><p>Can be mapped to a, </p>\n<ul>\n<li><strong>lib.rs file on the same executable crate</strong></li>\n<li><p><strong>Dependency crate specified on Cargo.toml</strong></p>\n<p>Can be specified from,</p>\n<ul>\n<li><strong>path</strong></li>\n<li><strong>git repository</strong></li>\n<li><strong>crates.io</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><h3 id=\"Workspaces\"><a href=\"#Workspaces\" class=\"headerlink\" title=\"Workspaces\"></a>Workspaces</h3><p>Helps to manage multiple crates as a single project.</p>\n</li>\n</ol>\n<p>Let‚Äôs discuss one by one.</p>\n<blockquote>\n<p>üí° To make examples more simpler, we use a simple function which prints <code>‚ÄúHello, world!‚Äù</code>. But regarding writing testable codes, always try to return the <code>String</code> from the function and print it when calling it, instead printing the String inside the function.</p>\n</blockquote>\n"},{"title":"Modules","_content":"\n## 01. In same file\n\nRelated code and data are grouped into a module and stored in the same file.\n\n```rust\nfn main() {\n   greetings::hello();\n}\n\nmod greetings {\n  // ‚≠êÔ∏è By default, everything inside a module is private\n  pub fn hello() { // ‚≠êÔ∏è So function has to be public to access from outside\n    println!(\"Hello, world!\");\n  }\n}\n```\n\nModules can also be nested.\n\n```rust\nfn main() { \n  phrases::greetings::hello();\n}\n\nmod phrases { \n  pub mod greetings { \n    pub fn hello() { \n      println!(\"Hello, world!\");\n    }\n  }\n}\n```\n\nPrivate functions can be called from the same module or from a child module.\n\n```rust\n// 01. Calling private functions of the same module\nfn main() {\n  phrases::greet();\n}\n\nmod phrases {\n  pub fn greet() {\n    hello(); //or self::hello();\n  }\n  \n  fn hello() {\n    println!(\"Hello, world!\");\n  }\n}\n\n// 02. Calling private functions of the parent module\nfn main() {\n  phrases::greetings::hello();\n}\n\nmod phrases {\n  fn private_fn() {\n    println!(\"Hello, world!\");\n  }\n  \n  pub mod greetings {\n    pub fn hello() {\n      super::private_fn();\n    }\n  }\n}\n```\n\n> üí° `self` keyword is used to refer same module, while `super` keyword is used to refer parent module. Also, `super` keyword can be used to access root functions from inside a module.\n\n```rust\nfn main() {\n  greetings::hello();\n}\n\nfn hello() {\n  println!(\"Hello, world!\");\n}\n\nmod greetings {\n  pub fn hello() {\n    super::hello();\n  }\n}\n```\n\n> üîé When writing tests it‚Äôs a good practice to write tests inside a test module because of they compile only when running tests.\n\n```rust\nfn greet() -> String {\n    \"Hello, world!\".to_string()\n}\n\n#[cfg(test)] // only compiles when running tests\nmod tests {\n    use super::greet; // import root greet function\n\n    #[test]\n    fn test_greet() {\n        assert_eq!(\"Hello, world!\", greet());\n    }\n}\n```\n\n## 02. In different file, same directory\n\n```rust\n// ‚Ü≥ main.rs\nmod greetings; // import greetings module\n\nfn main() {\n  greetings::hello();\n}\n\n// ‚Ü≥ greetings.rs\n// ‚≠êÔ∏è no need to wrap the code with a mod declaration. File itself acts as a module.\npub fn hello() { // function has to be public to access from outside\n  println!(\"Hello, world!\");\n}\n```\n\nIf we wrap file content with a `mod` declaration, it will act as a nested module.\n\n```rust\n// ‚Ü≥ main.rs\nmod phrases;\n\nfn main() {\n  phrases::greetings::hello();\n}\n\n// ‚Ü≥ phrases.rs\npub mod greetings { // ‚≠êÔ∏è module has to be public to access from outside\n  pub fn hello() {\n    println!(\"Hello, world!\");\n  }\n}\n```\n\n## 03. In different file, different directory\n\n`mod.rs` in the directory module root is the entry point to the directory module. All other files in that directory root, act as sub-modules of the directory module.\n\n```rust\n// ‚Ü≥ main.rs\nmod greetings;\n\nfn main() {\n  greetings::hello();\n}\n\n// ‚Ü≥ greetings/mod.rs\npub fn hello() { // ‚≠êÔ∏è function has to be public to access from outside\n  println!(\"Hello, world!\");\n}\n```\n\nAgain, If we wrap file content with a `mod` declaration, it will act as a nested module.\n\n```rust\n// ‚Ü≥ main.rs\nmod phrases;\n\nfn main() {\n  phrases::greetings::hello();\n}\n\n// ‚Ü≥ phrases/mod.rs\npub mod greetings { // ‚≠êÔ∏è module has to be public to access from outside\n  pub fn hello() {\n    println!(\"Hello, world!\");\n  }\n}\n```\n\nOther files in the directory module act as sub-modules for `mod.rs`.\n\n```rust\n// ‚Ü≥ main.rs\nmod phrases;\n\nfn main() {\n  phrases::hello()\n}\n\n// ‚Ü≥ phrases/mod.rs\nmod greetings;\n\npub fn hello() {\n  greetings::hello()\n}\n\n// ‚Ü≥ phrases/greetings.rs\npub fn hello() {\n  println!(\"Hello, world!\");\n}\n```\n\n‚≠êÔ∏è If you need to access an element of `phrases/greetings.rs` from outside the module, you have to import `greetings` module as a public module.\n\n```rust\n// ‚Ü≥ main.rs\nmod phrases;\n\nfn main() {\n    phrases::greetings::hello();\n}\n\n// ‚Ü≥ phrases/mod.rs\npub mod greetings;  // ‚≠êÔ∏è `pub mod` instead `mod`\n\n// ‚Ü≥ phrases/greetings.rs\npub fn hello() {\n  println!(\"Hello, world!\");\n}\n```\n\n> üîé It‚Äôs unable to import child file modules of directory modules to `main.rs`, so you can‚Äôt use `mod phrases::greetings;` from `main.rs`. But there is a way to import `phrases::greetings::hello()` to `phrases` module by re-exporting `hello` to `phrases` module. So you can call it directly as `phrases::hello()`.\n\n```rust\n// ‚Ü≥ phrases/greetings.rs\npub fn hello() {\n  println!(\"Hello, world!\");\n}\n\n// ‚Ü≥ phrases/mod.rs\npub mod greetings;\n\npub use self::greetings::hello; //re-export greetings::hello to phrases\n\n// ‚Ü≥ main.rs\nmod phrases;\n\nfn main() {\n    phrases::hello(); //you can call hello() directly from phrases\n}\n```\n\nThis allows you to present an external interface that **may not directly map** to your internal code organization. If still it is not clear, don‚Äôt worry; We discuss the usages of `use` on an upcoming section in this post.","source":"docs/zh-cn/d3.modules.md","raw":"title: Modules\n---\n\n## 01. In same file\n\nRelated code and data are grouped into a module and stored in the same file.\n\n```rust\nfn main() {\n   greetings::hello();\n}\n\nmod greetings {\n  // ‚≠êÔ∏è By default, everything inside a module is private\n  pub fn hello() { // ‚≠êÔ∏è So function has to be public to access from outside\n    println!(\"Hello, world!\");\n  }\n}\n```\n\nModules can also be nested.\n\n```rust\nfn main() { \n  phrases::greetings::hello();\n}\n\nmod phrases { \n  pub mod greetings { \n    pub fn hello() { \n      println!(\"Hello, world!\");\n    }\n  }\n}\n```\n\nPrivate functions can be called from the same module or from a child module.\n\n```rust\n// 01. Calling private functions of the same module\nfn main() {\n  phrases::greet();\n}\n\nmod phrases {\n  pub fn greet() {\n    hello(); //or self::hello();\n  }\n  \n  fn hello() {\n    println!(\"Hello, world!\");\n  }\n}\n\n// 02. Calling private functions of the parent module\nfn main() {\n  phrases::greetings::hello();\n}\n\nmod phrases {\n  fn private_fn() {\n    println!(\"Hello, world!\");\n  }\n  \n  pub mod greetings {\n    pub fn hello() {\n      super::private_fn();\n    }\n  }\n}\n```\n\n> üí° `self` keyword is used to refer same module, while `super` keyword is used to refer parent module. Also, `super` keyword can be used to access root functions from inside a module.\n\n```rust\nfn main() {\n  greetings::hello();\n}\n\nfn hello() {\n  println!(\"Hello, world!\");\n}\n\nmod greetings {\n  pub fn hello() {\n    super::hello();\n  }\n}\n```\n\n> üîé When writing tests it‚Äôs a good practice to write tests inside a test module because of they compile only when running tests.\n\n```rust\nfn greet() -> String {\n    \"Hello, world!\".to_string()\n}\n\n#[cfg(test)] // only compiles when running tests\nmod tests {\n    use super::greet; // import root greet function\n\n    #[test]\n    fn test_greet() {\n        assert_eq!(\"Hello, world!\", greet());\n    }\n}\n```\n\n## 02. In different file, same directory\n\n```rust\n// ‚Ü≥ main.rs\nmod greetings; // import greetings module\n\nfn main() {\n  greetings::hello();\n}\n\n// ‚Ü≥ greetings.rs\n// ‚≠êÔ∏è no need to wrap the code with a mod declaration. File itself acts as a module.\npub fn hello() { // function has to be public to access from outside\n  println!(\"Hello, world!\");\n}\n```\n\nIf we wrap file content with a `mod` declaration, it will act as a nested module.\n\n```rust\n// ‚Ü≥ main.rs\nmod phrases;\n\nfn main() {\n  phrases::greetings::hello();\n}\n\n// ‚Ü≥ phrases.rs\npub mod greetings { // ‚≠êÔ∏è module has to be public to access from outside\n  pub fn hello() {\n    println!(\"Hello, world!\");\n  }\n}\n```\n\n## 03. In different file, different directory\n\n`mod.rs` in the directory module root is the entry point to the directory module. All other files in that directory root, act as sub-modules of the directory module.\n\n```rust\n// ‚Ü≥ main.rs\nmod greetings;\n\nfn main() {\n  greetings::hello();\n}\n\n// ‚Ü≥ greetings/mod.rs\npub fn hello() { // ‚≠êÔ∏è function has to be public to access from outside\n  println!(\"Hello, world!\");\n}\n```\n\nAgain, If we wrap file content with a `mod` declaration, it will act as a nested module.\n\n```rust\n// ‚Ü≥ main.rs\nmod phrases;\n\nfn main() {\n  phrases::greetings::hello();\n}\n\n// ‚Ü≥ phrases/mod.rs\npub mod greetings { // ‚≠êÔ∏è module has to be public to access from outside\n  pub fn hello() {\n    println!(\"Hello, world!\");\n  }\n}\n```\n\nOther files in the directory module act as sub-modules for `mod.rs`.\n\n```rust\n// ‚Ü≥ main.rs\nmod phrases;\n\nfn main() {\n  phrases::hello()\n}\n\n// ‚Ü≥ phrases/mod.rs\nmod greetings;\n\npub fn hello() {\n  greetings::hello()\n}\n\n// ‚Ü≥ phrases/greetings.rs\npub fn hello() {\n  println!(\"Hello, world!\");\n}\n```\n\n‚≠êÔ∏è If you need to access an element of `phrases/greetings.rs` from outside the module, you have to import `greetings` module as a public module.\n\n```rust\n// ‚Ü≥ main.rs\nmod phrases;\n\nfn main() {\n    phrases::greetings::hello();\n}\n\n// ‚Ü≥ phrases/mod.rs\npub mod greetings;  // ‚≠êÔ∏è `pub mod` instead `mod`\n\n// ‚Ü≥ phrases/greetings.rs\npub fn hello() {\n  println!(\"Hello, world!\");\n}\n```\n\n> üîé It‚Äôs unable to import child file modules of directory modules to `main.rs`, so you can‚Äôt use `mod phrases::greetings;` from `main.rs`. But there is a way to import `phrases::greetings::hello()` to `phrases` module by re-exporting `hello` to `phrases` module. So you can call it directly as `phrases::hello()`.\n\n```rust\n// ‚Ü≥ phrases/greetings.rs\npub fn hello() {\n  println!(\"Hello, world!\");\n}\n\n// ‚Ü≥ phrases/mod.rs\npub mod greetings;\n\npub use self::greetings::hello; //re-export greetings::hello to phrases\n\n// ‚Ü≥ main.rs\nmod phrases;\n\nfn main() {\n    phrases::hello(); //you can call hello() directly from phrases\n}\n```\n\nThis allows you to present an external interface that **may not directly map** to your internal code organization. If still it is not clear, don‚Äôt worry; We discuss the usages of `use` on an upcoming section in this post.","date":"2019-03-19T14:50:31.985Z","updated":"2019-03-19T14:50:31.985Z","path":"docs/zh-cn/d3.modules.html","comments":1,"layout":"page","_id":"cjtfwbj0x001idwgp1lbn689i","content":"<h2 id=\"01-In-same-file\"><a href=\"#01-In-same-file\" class=\"headerlink\" title=\"01. In same file\"></a>01. In same file</h2><p>Related code and data are grouped into a module and stored in the same file.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n   greetings::hello();\n}\n\nmod greetings {\n  // ‚≠êÔ∏è By default, everything inside a module is private\n  pub fn hello() { // ‚≠êÔ∏è So function has to be public to access from outside\n    println!(&quot;Hello, world!&quot;);\n  }\n}\n</code></pre>\n<p>Modules can also be nested.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() { \n  phrases::greetings::hello();\n}\n\nmod phrases { \n  pub mod greetings { \n    pub fn hello() { \n      println!(&quot;Hello, world!&quot;);\n    }\n  }\n}\n</code></pre>\n<p>Private functions can be called from the same module or from a child module.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// 01. Calling private functions of the same module\nfn main() {\n  phrases::greet();\n}\n\nmod phrases {\n  pub fn greet() {\n    hello(); //or self::hello();\n  }\n\n  fn hello() {\n    println!(&quot;Hello, world!&quot;);\n  }\n}\n\n// 02. Calling private functions of the parent module\nfn main() {\n  phrases::greetings::hello();\n}\n\nmod phrases {\n  fn private_fn() {\n    println!(&quot;Hello, world!&quot;);\n  }\n\n  pub mod greetings {\n    pub fn hello() {\n      super::private_fn();\n    }\n  }\n}\n</code></pre>\n<blockquote>\n<p>üí° <code>self</code> keyword is used to refer same module, while <code>super</code> keyword is used to refer parent module. Also, <code>super</code> keyword can be used to access root functions from inside a module.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n  greetings::hello();\n}\n\nfn hello() {\n  println!(&quot;Hello, world!&quot;);\n}\n\nmod greetings {\n  pub fn hello() {\n    super::hello();\n  }\n}\n</code></pre>\n<blockquote>\n<p>üîé When writing tests it‚Äôs a good practice to write tests inside a test module because of they compile only when running tests.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn greet() -&gt; String {\n    &quot;Hello, world!&quot;.to_string()\n}\n\n#[cfg(test)] // only compiles when running tests\nmod tests {\n    use super::greet; // import root greet function\n\n    #[test]\n    fn test_greet() {\n        assert_eq!(&quot;Hello, world!&quot;, greet());\n    }\n}\n</code></pre>\n<h2 id=\"02-In-different-file-same-directory\"><a href=\"#02-In-different-file-same-directory\" class=\"headerlink\" title=\"02. In different file, same directory\"></a>02. In different file, same directory</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ‚Ü≥ main.rs\nmod greetings; // import greetings module\n\nfn main() {\n  greetings::hello();\n}\n\n// ‚Ü≥ greetings.rs\n// ‚≠êÔ∏è no need to wrap the code with a mod declaration. File itself acts as a module.\npub fn hello() { // function has to be public to access from outside\n  println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<p>If we wrap file content with a <code>mod</code> declaration, it will act as a nested module.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ‚Ü≥ main.rs\nmod phrases;\n\nfn main() {\n  phrases::greetings::hello();\n}\n\n// ‚Ü≥ phrases.rs\npub mod greetings { // ‚≠êÔ∏è module has to be public to access from outside\n  pub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n  }\n}\n</code></pre>\n<h2 id=\"03-In-different-file-different-directory\"><a href=\"#03-In-different-file-different-directory\" class=\"headerlink\" title=\"03. In different file, different directory\"></a>03. In different file, different directory</h2><p><code>mod.rs</code> in the directory module root is the entry point to the directory module. All other files in that directory root, act as sub-modules of the directory module.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ‚Ü≥ main.rs\nmod greetings;\n\nfn main() {\n  greetings::hello();\n}\n\n// ‚Ü≥ greetings/mod.rs\npub fn hello() { // ‚≠êÔ∏è function has to be public to access from outside\n  println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<p>Again, If we wrap file content with a <code>mod</code> declaration, it will act as a nested module.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ‚Ü≥ main.rs\nmod phrases;\n\nfn main() {\n  phrases::greetings::hello();\n}\n\n// ‚Ü≥ phrases/mod.rs\npub mod greetings { // ‚≠êÔ∏è module has to be public to access from outside\n  pub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n  }\n}\n</code></pre>\n<p>Other files in the directory module act as sub-modules for <code>mod.rs</code>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ‚Ü≥ main.rs\nmod phrases;\n\nfn main() {\n  phrases::hello()\n}\n\n// ‚Ü≥ phrases/mod.rs\nmod greetings;\n\npub fn hello() {\n  greetings::hello()\n}\n\n// ‚Ü≥ phrases/greetings.rs\npub fn hello() {\n  println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<p>‚≠êÔ∏è If you need to access an element of <code>phrases/greetings.rs</code> from outside the module, you have to import <code>greetings</code> module as a public module.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ‚Ü≥ main.rs\nmod phrases;\n\nfn main() {\n    phrases::greetings::hello();\n}\n\n// ‚Ü≥ phrases/mod.rs\npub mod greetings;  // ‚≠êÔ∏è `pub mod` instead `mod`\n\n// ‚Ü≥ phrases/greetings.rs\npub fn hello() {\n  println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<blockquote>\n<p>üîé It‚Äôs unable to import child file modules of directory modules to <code>main.rs</code>, so you can‚Äôt use <code>mod phrases::greetings;</code> from <code>main.rs</code>. But there is a way to import <code>phrases::greetings::hello()</code> to <code>phrases</code> module by re-exporting <code>hello</code> to <code>phrases</code> module. So you can call it directly as <code>phrases::hello()</code>.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ‚Ü≥ phrases/greetings.rs\npub fn hello() {\n  println!(&quot;Hello, world!&quot;);\n}\n\n// ‚Ü≥ phrases/mod.rs\npub mod greetings;\n\npub use self::greetings::hello; //re-export greetings::hello to phrases\n\n// ‚Ü≥ main.rs\nmod phrases;\n\nfn main() {\n    phrases::hello(); //you can call hello() directly from phrases\n}\n</code></pre>\n<p>This allows you to present an external interface that <strong>may not directly map</strong> to your internal code organization. If still it is not clear, don‚Äôt worry; We discuss the usages of <code>use</code> on an upcoming section in this post.</p>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<h2 id=\"01-In-same-file\"><a href=\"#01-In-same-file\" class=\"headerlink\" title=\"01. In same file\"></a>01. In same file</h2><p>Related code and data are grouped into a module and stored in the same file.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n   greetings::hello();\n}\n\nmod greetings {\n  // ‚≠êÔ∏è By default, everything inside a module is private\n  pub fn hello() { // ‚≠êÔ∏è So function has to be public to access from outside\n    println!(&quot;Hello, world!&quot;);\n  }\n}\n</code></pre>\n<p>Modules can also be nested.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() { \n  phrases::greetings::hello();\n}\n\nmod phrases { \n  pub mod greetings { \n    pub fn hello() { \n      println!(&quot;Hello, world!&quot;);\n    }\n  }\n}\n</code></pre>\n<p>Private functions can be called from the same module or from a child module.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// 01. Calling private functions of the same module\nfn main() {\n  phrases::greet();\n}\n\nmod phrases {\n  pub fn greet() {\n    hello(); //or self::hello();\n  }\n\n  fn hello() {\n    println!(&quot;Hello, world!&quot;);\n  }\n}\n\n// 02. Calling private functions of the parent module\nfn main() {\n  phrases::greetings::hello();\n}\n\nmod phrases {\n  fn private_fn() {\n    println!(&quot;Hello, world!&quot;);\n  }\n\n  pub mod greetings {\n    pub fn hello() {\n      super::private_fn();\n    }\n  }\n}\n</code></pre>\n<blockquote>\n<p>üí° <code>self</code> keyword is used to refer same module, while <code>super</code> keyword is used to refer parent module. Also, <code>super</code> keyword can be used to access root functions from inside a module.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n  greetings::hello();\n}\n\nfn hello() {\n  println!(&quot;Hello, world!&quot;);\n}\n\nmod greetings {\n  pub fn hello() {\n    super::hello();\n  }\n}\n</code></pre>\n<blockquote>\n<p>üîé When writing tests it‚Äôs a good practice to write tests inside a test module because of they compile only when running tests.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn greet() -&gt; String {\n    &quot;Hello, world!&quot;.to_string()\n}\n\n#[cfg(test)] // only compiles when running tests\nmod tests {\n    use super::greet; // import root greet function\n\n    #[test]\n    fn test_greet() {\n        assert_eq!(&quot;Hello, world!&quot;, greet());\n    }\n}\n</code></pre>\n<h2 id=\"02-In-different-file-same-directory\"><a href=\"#02-In-different-file-same-directory\" class=\"headerlink\" title=\"02. In different file, same directory\"></a>02. In different file, same directory</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ‚Ü≥ main.rs\nmod greetings; // import greetings module\n\nfn main() {\n  greetings::hello();\n}\n\n// ‚Ü≥ greetings.rs\n// ‚≠êÔ∏è no need to wrap the code with a mod declaration. File itself acts as a module.\npub fn hello() { // function has to be public to access from outside\n  println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<p>If we wrap file content with a <code>mod</code> declaration, it will act as a nested module.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ‚Ü≥ main.rs\nmod phrases;\n\nfn main() {\n  phrases::greetings::hello();\n}\n\n// ‚Ü≥ phrases.rs\npub mod greetings { // ‚≠êÔ∏è module has to be public to access from outside\n  pub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n  }\n}\n</code></pre>\n<h2 id=\"03-In-different-file-different-directory\"><a href=\"#03-In-different-file-different-directory\" class=\"headerlink\" title=\"03. In different file, different directory\"></a>03. In different file, different directory</h2><p><code>mod.rs</code> in the directory module root is the entry point to the directory module. All other files in that directory root, act as sub-modules of the directory module.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ‚Ü≥ main.rs\nmod greetings;\n\nfn main() {\n  greetings::hello();\n}\n\n// ‚Ü≥ greetings/mod.rs\npub fn hello() { // ‚≠êÔ∏è function has to be public to access from outside\n  println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<p>Again, If we wrap file content with a <code>mod</code> declaration, it will act as a nested module.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ‚Ü≥ main.rs\nmod phrases;\n\nfn main() {\n  phrases::greetings::hello();\n}\n\n// ‚Ü≥ phrases/mod.rs\npub mod greetings { // ‚≠êÔ∏è module has to be public to access from outside\n  pub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n  }\n}\n</code></pre>\n<p>Other files in the directory module act as sub-modules for <code>mod.rs</code>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ‚Ü≥ main.rs\nmod phrases;\n\nfn main() {\n  phrases::hello()\n}\n\n// ‚Ü≥ phrases/mod.rs\nmod greetings;\n\npub fn hello() {\n  greetings::hello()\n}\n\n// ‚Ü≥ phrases/greetings.rs\npub fn hello() {\n  println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<p>‚≠êÔ∏è If you need to access an element of <code>phrases/greetings.rs</code> from outside the module, you have to import <code>greetings</code> module as a public module.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ‚Ü≥ main.rs\nmod phrases;\n\nfn main() {\n    phrases::greetings::hello();\n}\n\n// ‚Ü≥ phrases/mod.rs\npub mod greetings;  // ‚≠êÔ∏è `pub mod` instead `mod`\n\n// ‚Ü≥ phrases/greetings.rs\npub fn hello() {\n  println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<blockquote>\n<p>üîé It‚Äôs unable to import child file modules of directory modules to <code>main.rs</code>, so you can‚Äôt use <code>mod phrases::greetings;</code> from <code>main.rs</code>. But there is a way to import <code>phrases::greetings::hello()</code> to <code>phrases</code> module by re-exporting <code>hello</code> to <code>phrases</code> module. So you can call it directly as <code>phrases::hello()</code>.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ‚Ü≥ phrases/greetings.rs\npub fn hello() {\n  println!(&quot;Hello, world!&quot;);\n}\n\n// ‚Ü≥ phrases/mod.rs\npub mod greetings;\n\npub use self::greetings::hello; //re-export greetings::hello to phrases\n\n// ‚Ü≥ main.rs\nmod phrases;\n\nfn main() {\n    phrases::hello(); //you can call hello() directly from phrases\n}\n</code></pre>\n<p>This allows you to present an external interface that <strong>may not directly map</strong> to your internal code organization. If still it is not clear, don‚Äôt worry; We discuss the usages of <code>use</code> on an upcoming section in this post.</p>\n"},{"title":"Workspaces","_content":"\nWhen the code base is getting larger, you might need to work with **multiple crates on the same project**. Rust supports this via Workspaces. You can **analyze (`cargo check`), build, run tests or generate docs for all crates** at once by running `cargo` commands from the project root.\n\n‚≠êÔ∏è When working on multiple crates same time, there is a higher possibility to having shared dependencies on crates. To prevent downloading and compiling the same dependency multiple times, Rust uses a **shared build directory** under the project root, while running `cargo build` from the project root.\n\nLet's create a library crate with a simple hello world function and a binary crate which uses the library crate.\n\nAssume we run,\n```bash\nmkdir greetings\ntouch greetings/Cargo.toml\ncargo new greetings/lib --lib\ncargo new greetings/examples/hello\n```\n\nThat generates,\n```\ngreetings\n‚îú‚îÄ‚îÄ Cargo.toml\n‚îú‚îÄ‚îÄ examples\n‚îÇ  ‚îî‚îÄ‚îÄ hello\n‚îÇ     ‚îú‚îÄ‚îÄ Cargo.toml\n‚îÇ     ‚îî‚îÄ‚îÄ src\n‚îÇ        ‚îî‚îÄ‚îÄ main.rs\n‚îî‚îÄ‚îÄ lib\n   ‚îú‚îÄ‚îÄ Cargo.toml\n   ‚îî‚îÄ‚îÄ src\n      ‚îî‚îÄ‚îÄ lib.rs\n```\n\nWe have to modify following files,\n```rust\n// 01. greetings/Cargo.toml to mark as a workspace and to add members\n[workspace]\nmembers = [\n    \"lib\",\n    \"examples/hello\"\n]\n\n// 02.1 greetings/lib/Cargo.toml to change the package name to greetings\n[package]\nname = \"greetings\"\nversion = \"0.1.0\"\nauthors = [\"Dumindu Madunuwan\"]\n\n[dependencies]\n\n// 02.2 greetings/lib/src/lib.rs to add a simple hello world function\npub fn hello() {\n    println!(\"Hello, world!\");\n}\n\n// 03.1 greetings/examples/hello/Cargo.toml to add greetings lib as a dependency\n[package]\nname = \"hello\"\nversion = \"0.1.0\"\nauthors = [\"Dumindu Madunuwan\"]\n\n[dependencies]\ngreetings = { path = \"../../lib\" }\n\n// 03.2 greetings/examples/hello/src/main.rs to import greetings lib and call its hello world function\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n```\n\nüí° On Linux and Mac, you can run `cargo` commands on each carets without changing the working directory all the times via Subshells (A command list embedded between parentheses). For example if you are in the `greetings` directory, even you run `(cd examples/hello && cargo run)` your working directory will be kept  as same in `greetings` folder.\n\n> üîé [rust-lang/rust source folder](https://github.com/rust-lang/rust/tree/master/src) is a good example for a workspace.","source":"docs/zh-cn/d5.workspaces.md","raw":"title: Workspaces\n---\n\nWhen the code base is getting larger, you might need to work with **multiple crates on the same project**. Rust supports this via Workspaces. You can **analyze (`cargo check`), build, run tests or generate docs for all crates** at once by running `cargo` commands from the project root.\n\n‚≠êÔ∏è When working on multiple crates same time, there is a higher possibility to having shared dependencies on crates. To prevent downloading and compiling the same dependency multiple times, Rust uses a **shared build directory** under the project root, while running `cargo build` from the project root.\n\nLet's create a library crate with a simple hello world function and a binary crate which uses the library crate.\n\nAssume we run,\n```bash\nmkdir greetings\ntouch greetings/Cargo.toml\ncargo new greetings/lib --lib\ncargo new greetings/examples/hello\n```\n\nThat generates,\n```\ngreetings\n‚îú‚îÄ‚îÄ Cargo.toml\n‚îú‚îÄ‚îÄ examples\n‚îÇ  ‚îî‚îÄ‚îÄ hello\n‚îÇ     ‚îú‚îÄ‚îÄ Cargo.toml\n‚îÇ     ‚îî‚îÄ‚îÄ src\n‚îÇ        ‚îî‚îÄ‚îÄ main.rs\n‚îî‚îÄ‚îÄ lib\n   ‚îú‚îÄ‚îÄ Cargo.toml\n   ‚îî‚îÄ‚îÄ src\n      ‚îî‚îÄ‚îÄ lib.rs\n```\n\nWe have to modify following files,\n```rust\n// 01. greetings/Cargo.toml to mark as a workspace and to add members\n[workspace]\nmembers = [\n    \"lib\",\n    \"examples/hello\"\n]\n\n// 02.1 greetings/lib/Cargo.toml to change the package name to greetings\n[package]\nname = \"greetings\"\nversion = \"0.1.0\"\nauthors = [\"Dumindu Madunuwan\"]\n\n[dependencies]\n\n// 02.2 greetings/lib/src/lib.rs to add a simple hello world function\npub fn hello() {\n    println!(\"Hello, world!\");\n}\n\n// 03.1 greetings/examples/hello/Cargo.toml to add greetings lib as a dependency\n[package]\nname = \"hello\"\nversion = \"0.1.0\"\nauthors = [\"Dumindu Madunuwan\"]\n\n[dependencies]\ngreetings = { path = \"../../lib\" }\n\n// 03.2 greetings/examples/hello/src/main.rs to import greetings lib and call its hello world function\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n```\n\nüí° On Linux and Mac, you can run `cargo` commands on each carets without changing the working directory all the times via Subshells (A command list embedded between parentheses). For example if you are in the `greetings` directory, even you run `(cd examples/hello && cargo run)` your working directory will be kept  as same in `greetings` folder.\n\n> üîé [rust-lang/rust source folder](https://github.com/rust-lang/rust/tree/master/src) is a good example for a workspace.","date":"2019-03-19T14:50:31.986Z","updated":"2019-03-19T14:50:31.986Z","path":"docs/zh-cn/d5.workspaces.html","comments":1,"layout":"page","_id":"cjtfwbj0x001jdwgpnea4964y","content":"<p>When the code base is getting larger, you might need to work with <strong>multiple crates on the same project</strong>. Rust supports this via Workspaces. You can <strong>analyze (<code>cargo check</code>), build, run tests or generate docs for all crates</strong> at once by running <code>cargo</code> commands from the project root.</p>\n<p>‚≠êÔ∏è When working on multiple crates same time, there is a higher possibility to having shared dependencies on crates. To prevent downloading and compiling the same dependency multiple times, Rust uses a <strong>shared build directory</strong> under the project root, while running <code>cargo build</code> from the project root.</p>\n<p>Let‚Äôs create a library crate with a simple hello world function and a binary crate which uses the library crate.</p>\n<p>Assume we run,</p>\n<p></p><p class=\"code-caption\" data-lang=\"bash\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"bash\">mkdir greetings\ntouch greetings/Cargo.toml\ncargo new greetings/lib --lib\ncargo new greetings/examples/hello\n</code></pre>\n<p>That generates,</p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code>greetings\n‚îú‚îÄ‚îÄ Cargo.toml\n‚îú‚îÄ‚îÄ examples\n‚îÇ  ‚îî‚îÄ‚îÄ hello\n‚îÇ     ‚îú‚îÄ‚îÄ Cargo.toml\n‚îÇ     ‚îî‚îÄ‚îÄ src\n‚îÇ        ‚îî‚îÄ‚îÄ main.rs\n‚îî‚îÄ‚îÄ lib\n   ‚îú‚îÄ‚îÄ Cargo.toml\n   ‚îî‚îÄ‚îÄ src\n      ‚îî‚îÄ‚îÄ lib.rs\n</code></pre><p>We have to modify following files,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// 01. greetings/Cargo.toml to mark as a workspace and to add members\n[workspace]\nmembers = [\n    &quot;lib&quot;,\n    &quot;examples/hello&quot;\n]\n\n// 02.1 greetings/lib/Cargo.toml to change the package name to greetings\n[package]\nname = &quot;greetings&quot;\nversion = &quot;0.1.0&quot;\nauthors = [&quot;Dumindu Madunuwan&quot;]\n\n[dependencies]\n\n// 02.2 greetings/lib/src/lib.rs to add a simple hello world function\npub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n}\n\n// 03.1 greetings/examples/hello/Cargo.toml to add greetings lib as a dependency\n[package]\nname = &quot;hello&quot;\nversion = &quot;0.1.0&quot;\nauthors = [&quot;Dumindu Madunuwan&quot;]\n\n[dependencies]\ngreetings = { path = &quot;../../lib&quot; }\n\n// 03.2 greetings/examples/hello/src/main.rs to import greetings lib and call its hello world function\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n</code></pre>\n<p>üí° On Linux and Mac, you can run <code>cargo</code> commands on each carets without changing the working directory all the times via Subshells (A command list embedded between parentheses). For example if you are in the <code>greetings</code> directory, even you run <code>(cd examples/hello &amp;&amp; cargo run)</code> your working directory will be kept  as same in <code>greetings</code> folder.</p>\n<blockquote>\n<p>üîé <a href=\"https://github.com/rust-lang/rust/tree/master/src\" target=\"_blank\" rel=\"noopener\">rust-lang/rust source folder</a> is a good example for a workspace.</p>\n</blockquote>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<p>When the code base is getting larger, you might need to work with <strong>multiple crates on the same project</strong>. Rust supports this via Workspaces. You can <strong>analyze (<code>cargo check</code>), build, run tests or generate docs for all crates</strong> at once by running <code>cargo</code> commands from the project root.</p>\n<p>‚≠êÔ∏è When working on multiple crates same time, there is a higher possibility to having shared dependencies on crates. To prevent downloading and compiling the same dependency multiple times, Rust uses a <strong>shared build directory</strong> under the project root, while running <code>cargo build</code> from the project root.</p>\n<p>Let‚Äôs create a library crate with a simple hello world function and a binary crate which uses the library crate.</p>\n<p>Assume we run,</p>\n<p></p><p class=\"code-caption\" data-lang=\"bash\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"bash\">mkdir greetings\ntouch greetings/Cargo.toml\ncargo new greetings/lib --lib\ncargo new greetings/examples/hello\n</code></pre>\n<p>That generates,</p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code>greetings\n‚îú‚îÄ‚îÄ Cargo.toml\n‚îú‚îÄ‚îÄ examples\n‚îÇ  ‚îî‚îÄ‚îÄ hello\n‚îÇ     ‚îú‚îÄ‚îÄ Cargo.toml\n‚îÇ     ‚îî‚îÄ‚îÄ src\n‚îÇ        ‚îî‚îÄ‚îÄ main.rs\n‚îî‚îÄ‚îÄ lib\n   ‚îú‚îÄ‚îÄ Cargo.toml\n   ‚îî‚îÄ‚îÄ src\n      ‚îî‚îÄ‚îÄ lib.rs\n</code></pre><p>We have to modify following files,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// 01. greetings/Cargo.toml to mark as a workspace and to add members\n[workspace]\nmembers = [\n    &quot;lib&quot;,\n    &quot;examples/hello&quot;\n]\n\n// 02.1 greetings/lib/Cargo.toml to change the package name to greetings\n[package]\nname = &quot;greetings&quot;\nversion = &quot;0.1.0&quot;\nauthors = [&quot;Dumindu Madunuwan&quot;]\n\n[dependencies]\n\n// 02.2 greetings/lib/src/lib.rs to add a simple hello world function\npub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n}\n\n// 03.1 greetings/examples/hello/Cargo.toml to add greetings lib as a dependency\n[package]\nname = &quot;hello&quot;\nversion = &quot;0.1.0&quot;\nauthors = [&quot;Dumindu Madunuwan&quot;]\n\n[dependencies]\ngreetings = { path = &quot;../../lib&quot; }\n\n// 03.2 greetings/examples/hello/src/main.rs to import greetings lib and call its hello world function\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n</code></pre>\n<p>üí° On Linux and Mac, you can run <code>cargo</code> commands on each carets without changing the working directory all the times via Subshells (A command list embedded between parentheses). For example if you are in the <code>greetings</code> directory, even you run <code>(cd examples/hello &amp;&amp; cargo run)</code> your working directory will be kept  as same in <code>greetings</code> folder.</p>\n<blockquote>\n<p>üîé <a href=\"https://github.com/rust-lang/rust/tree/master/src\" target=\"_blank\" rel=\"noopener\">rust-lang/rust source folder</a> is a good example for a workspace.</p>\n</blockquote>\n"},{"title":"Use","_content":"\nLet's see the main usages of `use` keyword.\n\n\n## 01. Bind a full path to a new name\n\nMainly `use` keyword is used to bind a full path of an element to a new name. So user doesn‚Äôt want to repeat the full path each time.\n\n```rust\n// -- Initial code without use keyword --\nmod phrases { \n  pub mod greetings { \n    pub fn hello() { \n      println!(\"Hello, world!\");\n    }\n  }\n}\n\nfn main() { \n  phrases::greetings::hello(); // using full path\n}\n\n\n// -- Usage of use keyword --\n// 01. create alias for module\nuse phrases::greetings;\nfn main() { \n  greetings::hello();\n}\n\n// 02. create alias for module elements\nuse phrases::greetings::hello;\nfn main() { \n  hello();\n}\n\n// 03. customize names with as keyword\nuse phrases::greetings::hello as greet;\nfn main() { \n  greet();\n}\n```\n\n\n## 02. Import elements to scope\n\nAnother common usage of `use` is importing elements to scope. Remember that, this is also bit similar to creating alias and using it instead of using the full path.\n\n```rust\nfn hello() -> String {\n  \"Hello, world!\".to_string()\n}\n\n#[cfg(test)]\nmod tests {\n  use super::hello; //import hello() into scope\n    \n  #[test]\n  fn test_hello() {\n    assert_eq!(\"Hello, world!\", hello()); //if not using above use statement, we can run same via super::hello()\n  }\n}\n```\n\n> üí° By default, `use` declarations use absolute paths, starting from the crate root. But `self` and `super` declarations make that path relative to the current module.\n\nSame way `use` keyword is used to import the elements of other crates including `std` , Rust‚Äôs [Standard Library](https://github.com/rust-lang/rust/tree/master/src/libstd).\n\n```rust\n// -- 01. importing elements --\nuse std::fs::File;\n\nfn main() {\n    File::create(\"empty.txt\").expect(\"Can not create the file!\");\n}\n\n\n// -- 02. importing module and elements--\nstd::fs::{self, File} //use std::fs; use std::fs::File;\n\nfn main() {\n    fs::create_dir(\"some_dir\").expect(\"Can not create the directry!\");\n    File::create(\"some_dir/empty.txt\").expect(\"Can not create the file!\");\n}\n\n\n// -- 03. importing multiple elements\nuse std::fs::File;\nuse std::io::{BufReader, BufRead}; //use std::io::BufReader; use std::io::BufRead;\n\nfn main() {\n    let file = File::open(\"src/hello.txt\").expect(\"file not found\");\n    let buf_reader = BufReader::new(file);\n\n    for line in buf_reader.lines() {\n        println!(\"{}\", line.unwrap());\n    }\n}\n```\n\n> We **don‚Äôt need** to use `extern crate std;` when using `std` library. We will discuss more about this under Standard Library section.\n\nüí° `use` statements import only what we‚Äôve specified into the scope, instead of importing all elements of a module or crate. So it improves the efficiency of the program.\n\n\n## 03. Re-exporting\n\nAnother special case is `pub use`. When creating a module, you can export things from another module into your module. So after that they can be accessed directly from your module. This is called **re-exporting**.\n\n```rust\n// ‚Ü≥ main.rs\nmod phrases;\n\nfn main() {\n    phrases::hello(); //not directly map\n}\n\n// ‚Ü≥ phrases/mod.rs\npub mod greetings;\n\npub use self::greetings::hello; //re-export greetings::hello to phrases\n\n// ‚Ü≥ phrases/greetings.rs\npub fn hello() {\n  println!(\"Hello, world!\");\n}\n```\n\nThis pattern is quite common in large libraries. It helps to hide the complexity of the internal module structure of the library from users, because users don‚Äôt need to know/follow whole directory map of the elements of the library while working with them.","source":"docs/zh-cn/d6.use.md","raw":"title: Use\n---\n\nLet's see the main usages of `use` keyword.\n\n\n## 01. Bind a full path to a new name\n\nMainly `use` keyword is used to bind a full path of an element to a new name. So user doesn‚Äôt want to repeat the full path each time.\n\n```rust\n// -- Initial code without use keyword --\nmod phrases { \n  pub mod greetings { \n    pub fn hello() { \n      println!(\"Hello, world!\");\n    }\n  }\n}\n\nfn main() { \n  phrases::greetings::hello(); // using full path\n}\n\n\n// -- Usage of use keyword --\n// 01. create alias for module\nuse phrases::greetings;\nfn main() { \n  greetings::hello();\n}\n\n// 02. create alias for module elements\nuse phrases::greetings::hello;\nfn main() { \n  hello();\n}\n\n// 03. customize names with as keyword\nuse phrases::greetings::hello as greet;\nfn main() { \n  greet();\n}\n```\n\n\n## 02. Import elements to scope\n\nAnother common usage of `use` is importing elements to scope. Remember that, this is also bit similar to creating alias and using it instead of using the full path.\n\n```rust\nfn hello() -> String {\n  \"Hello, world!\".to_string()\n}\n\n#[cfg(test)]\nmod tests {\n  use super::hello; //import hello() into scope\n    \n  #[test]\n  fn test_hello() {\n    assert_eq!(\"Hello, world!\", hello()); //if not using above use statement, we can run same via super::hello()\n  }\n}\n```\n\n> üí° By default, `use` declarations use absolute paths, starting from the crate root. But `self` and `super` declarations make that path relative to the current module.\n\nSame way `use` keyword is used to import the elements of other crates including `std` , Rust‚Äôs [Standard Library](https://github.com/rust-lang/rust/tree/master/src/libstd).\n\n```rust\n// -- 01. importing elements --\nuse std::fs::File;\n\nfn main() {\n    File::create(\"empty.txt\").expect(\"Can not create the file!\");\n}\n\n\n// -- 02. importing module and elements--\nstd::fs::{self, File} //use std::fs; use std::fs::File;\n\nfn main() {\n    fs::create_dir(\"some_dir\").expect(\"Can not create the directry!\");\n    File::create(\"some_dir/empty.txt\").expect(\"Can not create the file!\");\n}\n\n\n// -- 03. importing multiple elements\nuse std::fs::File;\nuse std::io::{BufReader, BufRead}; //use std::io::BufReader; use std::io::BufRead;\n\nfn main() {\n    let file = File::open(\"src/hello.txt\").expect(\"file not found\");\n    let buf_reader = BufReader::new(file);\n\n    for line in buf_reader.lines() {\n        println!(\"{}\", line.unwrap());\n    }\n}\n```\n\n> We **don‚Äôt need** to use `extern crate std;` when using `std` library. We will discuss more about this under Standard Library section.\n\nüí° `use` statements import only what we‚Äôve specified into the scope, instead of importing all elements of a module or crate. So it improves the efficiency of the program.\n\n\n## 03. Re-exporting\n\nAnother special case is `pub use`. When creating a module, you can export things from another module into your module. So after that they can be accessed directly from your module. This is called **re-exporting**.\n\n```rust\n// ‚Ü≥ main.rs\nmod phrases;\n\nfn main() {\n    phrases::hello(); //not directly map\n}\n\n// ‚Ü≥ phrases/mod.rs\npub mod greetings;\n\npub use self::greetings::hello; //re-export greetings::hello to phrases\n\n// ‚Ü≥ phrases/greetings.rs\npub fn hello() {\n  println!(\"Hello, world!\");\n}\n```\n\nThis pattern is quite common in large libraries. It helps to hide the complexity of the internal module structure of the library from users, because users don‚Äôt need to know/follow whole directory map of the elements of the library while working with them.","date":"2019-03-19T14:50:31.986Z","updated":"2019-03-19T14:50:31.986Z","path":"docs/zh-cn/d6.use.html","comments":1,"layout":"page","_id":"cjtfwbj0x001kdwgpw5nz7rmn","content":"<p>Let‚Äôs see the main usages of <code>use</code> keyword.</p>\n<h2 id=\"01-Bind-a-full-path-to-a-new-name\"><a href=\"#01-Bind-a-full-path-to-a-new-name\" class=\"headerlink\" title=\"01. Bind a full path to a new name\"></a>01. Bind a full path to a new name</h2><p>Mainly <code>use</code> keyword is used to bind a full path of an element to a new name. So user doesn‚Äôt want to repeat the full path each time.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// -- Initial code without use keyword --\nmod phrases { \n  pub mod greetings { \n    pub fn hello() { \n      println!(&quot;Hello, world!&quot;);\n    }\n  }\n}\n\nfn main() { \n  phrases::greetings::hello(); // using full path\n}\n\n\n// -- Usage of use keyword --\n// 01. create alias for module\nuse phrases::greetings;\nfn main() { \n  greetings::hello();\n}\n\n// 02. create alias for module elements\nuse phrases::greetings::hello;\nfn main() { \n  hello();\n}\n\n// 03. customize names with as keyword\nuse phrases::greetings::hello as greet;\nfn main() { \n  greet();\n}\n</code></pre>\n<h2 id=\"02-Import-elements-to-scope\"><a href=\"#02-Import-elements-to-scope\" class=\"headerlink\" title=\"02. Import elements to scope\"></a>02. Import elements to scope</h2><p>Another common usage of <code>use</code> is importing elements to scope. Remember that, this is also bit similar to creating alias and using it instead of using the full path.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn hello() -&gt; String {\n  &quot;Hello, world!&quot;.to_string()\n}\n\n#[cfg(test)]\nmod tests {\n  use super::hello; //import hello() into scope\n\n  #[test]\n  fn test_hello() {\n    assert_eq!(&quot;Hello, world!&quot;, hello()); //if not using above use statement, we can run same via super::hello()\n  }\n}\n</code></pre>\n<blockquote>\n<p>üí° By default, <code>use</code> declarations use absolute paths, starting from the crate root. But <code>self</code> and <code>super</code> declarations make that path relative to the current module.</p>\n</blockquote>\n<p>Same way <code>use</code> keyword is used to import the elements of other crates including <code>std</code> , Rust‚Äôs <a href=\"https://github.com/rust-lang/rust/tree/master/src/libstd\" target=\"_blank\" rel=\"noopener\">Standard Library</a>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// -- 01. importing elements --\nuse std::fs::File;\n\nfn main() {\n    File::create(&quot;empty.txt&quot;).expect(&quot;Can not create the file!&quot;);\n}\n\n\n// -- 02. importing module and elements--\nstd::fs::{self, File} //use std::fs; use std::fs::File;\n\nfn main() {\n    fs::create_dir(&quot;some_dir&quot;).expect(&quot;Can not create the directry!&quot;);\n    File::create(&quot;some_dir/empty.txt&quot;).expect(&quot;Can not create the file!&quot;);\n}\n\n\n// -- 03. importing multiple elements\nuse std::fs::File;\nuse std::io::{BufReader, BufRead}; //use std::io::BufReader; use std::io::BufRead;\n\nfn main() {\n    let file = File::open(&quot;src/hello.txt&quot;).expect(&quot;file not found&quot;);\n    let buf_reader = BufReader::new(file);\n\n    for line in buf_reader.lines() {\n        println!(&quot;{}&quot;, line.unwrap());\n    }\n}\n</code></pre>\n<blockquote>\n<p>We <strong>don‚Äôt need</strong> to use <code>extern crate std;</code> when using <code>std</code> library. We will discuss more about this under Standard Library section.</p>\n</blockquote>\n<p>üí° <code>use</code> statements import only what we‚Äôve specified into the scope, instead of importing all elements of a module or crate. So it improves the efficiency of the program.</p>\n<h2 id=\"03-Re-exporting\"><a href=\"#03-Re-exporting\" class=\"headerlink\" title=\"03. Re-exporting\"></a>03. Re-exporting</h2><p>Another special case is <code>pub use</code>. When creating a module, you can export things from another module into your module. So after that they can be accessed directly from your module. This is called <strong>re-exporting</strong>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ‚Ü≥ main.rs\nmod phrases;\n\nfn main() {\n    phrases::hello(); //not directly map\n}\n\n// ‚Ü≥ phrases/mod.rs\npub mod greetings;\n\npub use self::greetings::hello; //re-export greetings::hello to phrases\n\n// ‚Ü≥ phrases/greetings.rs\npub fn hello() {\n  println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<p>This pattern is quite common in large libraries. It helps to hide the complexity of the internal module structure of the library from users, because users don‚Äôt need to know/follow whole directory map of the elements of the library while working with them.</p>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<p>Let‚Äôs see the main usages of <code>use</code> keyword.</p>\n<h2 id=\"01-Bind-a-full-path-to-a-new-name\"><a href=\"#01-Bind-a-full-path-to-a-new-name\" class=\"headerlink\" title=\"01. Bind a full path to a new name\"></a>01. Bind a full path to a new name</h2><p>Mainly <code>use</code> keyword is used to bind a full path of an element to a new name. So user doesn‚Äôt want to repeat the full path each time.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// -- Initial code without use keyword --\nmod phrases { \n  pub mod greetings { \n    pub fn hello() { \n      println!(&quot;Hello, world!&quot;);\n    }\n  }\n}\n\nfn main() { \n  phrases::greetings::hello(); // using full path\n}\n\n\n// -- Usage of use keyword --\n// 01. create alias for module\nuse phrases::greetings;\nfn main() { \n  greetings::hello();\n}\n\n// 02. create alias for module elements\nuse phrases::greetings::hello;\nfn main() { \n  hello();\n}\n\n// 03. customize names with as keyword\nuse phrases::greetings::hello as greet;\nfn main() { \n  greet();\n}\n</code></pre>\n<h2 id=\"02-Import-elements-to-scope\"><a href=\"#02-Import-elements-to-scope\" class=\"headerlink\" title=\"02. Import elements to scope\"></a>02. Import elements to scope</h2><p>Another common usage of <code>use</code> is importing elements to scope. Remember that, this is also bit similar to creating alias and using it instead of using the full path.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn hello() -&gt; String {\n  &quot;Hello, world!&quot;.to_string()\n}\n\n#[cfg(test)]\nmod tests {\n  use super::hello; //import hello() into scope\n\n  #[test]\n  fn test_hello() {\n    assert_eq!(&quot;Hello, world!&quot;, hello()); //if not using above use statement, we can run same via super::hello()\n  }\n}\n</code></pre>\n<blockquote>\n<p>üí° By default, <code>use</code> declarations use absolute paths, starting from the crate root. But <code>self</code> and <code>super</code> declarations make that path relative to the current module.</p>\n</blockquote>\n<p>Same way <code>use</code> keyword is used to import the elements of other crates including <code>std</code> , Rust‚Äôs <a href=\"https://github.com/rust-lang/rust/tree/master/src/libstd\" target=\"_blank\" rel=\"noopener\">Standard Library</a>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// -- 01. importing elements --\nuse std::fs::File;\n\nfn main() {\n    File::create(&quot;empty.txt&quot;).expect(&quot;Can not create the file!&quot;);\n}\n\n\n// -- 02. importing module and elements--\nstd::fs::{self, File} //use std::fs; use std::fs::File;\n\nfn main() {\n    fs::create_dir(&quot;some_dir&quot;).expect(&quot;Can not create the directry!&quot;);\n    File::create(&quot;some_dir/empty.txt&quot;).expect(&quot;Can not create the file!&quot;);\n}\n\n\n// -- 03. importing multiple elements\nuse std::fs::File;\nuse std::io::{BufReader, BufRead}; //use std::io::BufReader; use std::io::BufRead;\n\nfn main() {\n    let file = File::open(&quot;src/hello.txt&quot;).expect(&quot;file not found&quot;);\n    let buf_reader = BufReader::new(file);\n\n    for line in buf_reader.lines() {\n        println!(&quot;{}&quot;, line.unwrap());\n    }\n}\n</code></pre>\n<blockquote>\n<p>We <strong>don‚Äôt need</strong> to use <code>extern crate std;</code> when using <code>std</code> library. We will discuss more about this under Standard Library section.</p>\n</blockquote>\n<p>üí° <code>use</code> statements import only what we‚Äôve specified into the scope, instead of importing all elements of a module or crate. So it improves the efficiency of the program.</p>\n<h2 id=\"03-Re-exporting\"><a href=\"#03-Re-exporting\" class=\"headerlink\" title=\"03. Re-exporting\"></a>03. Re-exporting</h2><p>Another special case is <code>pub use</code>. When creating a module, you can export things from another module into your module. So after that they can be accessed directly from your module. This is called <strong>re-exporting</strong>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ‚Ü≥ main.rs\nmod phrases;\n\nfn main() {\n    phrases::hello(); //not directly map\n}\n\n// ‚Ü≥ phrases/mod.rs\npub mod greetings;\n\npub use self::greetings::hello; //re-export greetings::hello to phrases\n\n// ‚Ü≥ phrases/greetings.rs\npub fn hello() {\n  println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<p>This pattern is quite common in large libraries. It helps to hide the complexity of the internal module structure of the library from users, because users don‚Äôt need to know/follow whole directory map of the elements of the library while working with them.</p>\n"},{"title":"Overview","_content":"\nThis is based on the posts I wrote on **Medium**, https://medium.com/learning-rust\n\n[![Rust Playground](images/learning_rust_medium.jpg)](https://medium.com/learning-rust)\n\n> üê£ I am a **Sri Lankan** üá±üá∞ Web Developer who lives in **Vietnam** üáªüá≥. So I am not a native English speaker and just learning Rust, If you found any mistake or something need to be changed, even a spelling or a grammar mistake, feel free to create a pull request. Thanks.","source":"docs/zh-cn/index.md","raw":"title: Overview\n---\n\nThis is based on the posts I wrote on **Medium**, https://medium.com/learning-rust\n\n[![Rust Playground](images/learning_rust_medium.jpg)](https://medium.com/learning-rust)\n\n> üê£ I am a **Sri Lankan** üá±üá∞ Web Developer who lives in **Vietnam** üáªüá≥. So I am not a native English speaker and just learning Rust, If you found any mistake or something need to be changed, even a spelling or a grammar mistake, feel free to create a pull request. Thanks.","date":"2019-03-19T14:50:31.987Z","updated":"2019-03-19T14:50:31.987Z","path":"docs/zh-cn/index.html","comments":1,"layout":"page","_id":"cjtfwbj0y001ldwgp8tmzjjcy","content":"<p>This is based on the posts I wrote on <strong>Medium</strong>, <a href=\"https://medium.com/learning-rust\" target=\"_blank\" rel=\"noopener\">https://medium.com/learning-rust</a></p>\n<p><a href=\"https://medium.com/learning-rust\" target=\"_blank\" rel=\"noopener\"><img src=\"images/learning_rust_medium.jpg\" alt=\"Rust Playground\"></a></p>\n<blockquote>\n<p>üê£ I am a <strong>Sri Lankan</strong> üá±üá∞ Web Developer who lives in <strong>Vietnam</strong> üáªüá≥. So I am not a native English speaker and just learning Rust, If you found any mistake or something need to be changed, even a spelling or a grammar mistake, feel free to create a pull request. Thanks.</p>\n</blockquote>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<p>This is based on the posts I wrote on <strong>Medium</strong>, <a href=\"https://medium.com/learning-rust\" target=\"_blank\" rel=\"noopener\">https://medium.com/learning-rust</a></p>\n<p><a href=\"https://medium.com/learning-rust\" target=\"_blank\" rel=\"noopener\"><img src=\"images/learning_rust_medium.jpg\" alt=\"Rust Playground\"></a></p>\n<blockquote>\n<p>üê£ I am a <strong>Sri Lankan</strong> üá±üá∞ Web Developer who lives in <strong>Vietnam</strong> üáªüá≥. So I am not a native English speaker and just learning Rust, If you found any mistake or something need to be changed, even a spelling or a grammar mistake, feel free to create a pull request. Thanks.</p>\n</blockquote>\n"},{"title":"Standard Library, Primitives and Preludes","_content":"\n‚≠êÔ∏è In Rust, language elements are implemented by not only **`std` library** crate but also **compiler** as well. Examples,\n- **[Primitives](https://doc.rust-lang.org/std/#primitives)** : Defined by the compiler and methods are implemented by `std` library directly on primitives.\n- **[Standard Macros](https://doc.rust-lang.org/std/#macros)** : Defined by both compiler and `std`\n\n**`std`** library has been has divided into **[modules](https://doc.rust-lang.org/std/#modules)**, according to the main areas each covered.\n\n‚≠êÔ∏è While primitives are implemented by the **compiler**, the standard library implements **most useful methods** directly on the primitive types. But some **rarely useful language elements** of some primitives are stored on relevant **`std` modules**. This is why you can see `char`, `str` and integer types on both [primitives](https://doc.rust-lang.org/std/#primitives) and [`std` modules](https://doc.rust-lang.org/std/#modules).\n\n\n## Primitives\n\n```rust\n// Primitives : Defined by the compiler and methods are directly implemented by std\nbool, char, slice, str\n\ni8, i16, i32, i64, i128, isize\nu8, u16, u32, u64, u128, usize\n\nf32, f64\n\narray, tuple\n\npointer, fn, reference\n```\n\n## Standard Macros\n\n```rust\n// Standard Macros also defined by both compiler and std\nprint, println, eprint, eprintln\nformat, format_args\nwrite, writeln\n\nconcat, concat_idents, stringify //concat_idents : nightly-only experimental API\n\ninclude, include_bytes, include_str\n\nassert, assert_eq, assert_ne\ndebug_assert, debug_assert_eq, debug_assert_ne\n\ntry, panic, compile_error, unreachable, unimplemented\n\nfile, line, column, module_path\nenv, option_env\ncfg\n\nselect, thread_local //select : nightly-only experimental API\n\nvec\n```\n\n## Std Modules\n\n```rust\n// std modules\nchar, str\n\ni8, i16, i32, i64, i128, isize\nu8, u16, u32 ,u64, u128, usize\nf32, f64\nnum\n\nvec, slice, hash, heap, collections // heap : nightly-only experimental API\n\nstring, ascii, fmt\n\ndefault\n\nmarker, clone, convert, cmp, iter\n\nops, ffi\n\noption, result, panic, error\n\nio\nfs, path\nmem, thread, sync\nprocess, env\nnet\ntime\nos\n\nptr, boxed, borrow, cell, any, rc\n\nprelude\n\nintrinsics // intrinsics : nightly-only experimental API\nraw // raw : nightly-only experimental API\n```\n\n> üîé When examine [Rust‚Äôs source code](https://github.com/rust-lang/rust), you can see that [`src` directory](https://github.com/rust-lang/rust/tree/master/src) is a **workspace**. Even though its having many library crates, by examine [root Cargo.toml](https://github.com/rust-lang/rust/blob/master/src/Cargo.toml) file you can easily identify that main crates are **[rustc](https://github.com/rust-lang/rust/tree/master/src/rustc)**(compiler) and **[libstd](https://github.com/rust-lang/rust/tree/master/src/libstd)** (std). In libstd/lib.rs std modules have been **re-exported** via `pub use` and the original location of most of std modules is [`src/libcore`](https://github.com/rust-lang/rust/tree/master/src/libcore).\n\n**Few important `std` modules are,**\n- `std::io` - Core **I/O** functionality \n- `std::fs` - **Filesystem** specific functionality\n- `std::path` - **Cross platform path** specific functionality\n- `std::env` - **Process‚Äôs environment** related functionality\n- `std::mem` - **Memory** related functionality\n- `std::net` - **TCP/UDP** communication\n- `std::os` - **OS** specific functionality\n- `std::thread` - Native **threads** specific functionality\n- `std::collections` - Core **Collection types**\n\n> üíØ Refer [Rust Standard Library Documentation](https://doc.rust-lang.org/std/) for more details.\n\n\n## Preludes\n\nEven though Rust `std` contains many modules, by default it doesn‚Äôt load each and every thing of std library on every rust program. Instead, it loads only the **smallest list of things which require for almost every single Rust program**. These are called **[preludes](https://doc.rust-lang.org/std/prelude/)**. They import only,\n\n```rust\n// Reexported core operators\npub use marker::{Copy, Send, Sized, Sync};\npub use ops::{Drop, Fn, FnMut, FnOnce};\n\n// Reexported functions\npub use mem::drop;\n\n// Reexported types and traits\npub use boxed::Box;\npub use borrow::ToOwned;\npub use clone::Clone;\npub use cmp::{PartialEq, PartialOrd, Eq, Ord};\npub use convert::{AsRef, AsMut, Into, From};\npub use default::Default;\npub use iter::{Iterator, Extend, IntoIterator};\npub use iter::{DoubleEndedIterator, ExactSizeIterator};\npub use option::Option::{self, Some, None};\npub use result::Result::{self, Ok, Err};\npub use slice::SliceConcatExt;\npub use string::{String, ToString};\npub use vec::Vec;\n```\n\n> Preludes have been imported explicitly on [`libstd/lib.rs`](https://github.com/rust-lang/rust/blob/master/src/libstd/lib.rs#L353) and the whole list can be seen on [`libstd/prelude/v1.rs`](https://github.com/rust-lang/rust/blob/master/src/libstd/prelude/v1.rs).\n\n‚≠êÔ∏è So technically, Rust inserts,\n- `extern crate std;` : into the **crate root of every crate**\n- `use std::prelude::v1::*;` : into **every module**\n  So you don‚Äôt need to import these each time.\n\n\nThe concept of preludes is quite common on Rust libraries. Even some modules inside `std` crate (ex.libstd/io) and many libraries (ex. [diesel](https://github.com/diesel-rs/diesel/blob/master/diesel/src/lib.rs#L151)) are having their own `prelude` modules.\n\n‚≠êÔ∏è But **preludes** are used to **create a single place to import all important components** which are **required while using the library**. They **do not load automatically** unless you imported them manually. Only `std::prelude` imports automatically in every Rust programs.","source":"docs/zh-cn/d7.std_primitives_and_preludes.md","raw":"title: Standard Library, Primitives and Preludes\n---\n\n‚≠êÔ∏è In Rust, language elements are implemented by not only **`std` library** crate but also **compiler** as well. Examples,\n- **[Primitives](https://doc.rust-lang.org/std/#primitives)** : Defined by the compiler and methods are implemented by `std` library directly on primitives.\n- **[Standard Macros](https://doc.rust-lang.org/std/#macros)** : Defined by both compiler and `std`\n\n**`std`** library has been has divided into **[modules](https://doc.rust-lang.org/std/#modules)**, according to the main areas each covered.\n\n‚≠êÔ∏è While primitives are implemented by the **compiler**, the standard library implements **most useful methods** directly on the primitive types. But some **rarely useful language elements** of some primitives are stored on relevant **`std` modules**. This is why you can see `char`, `str` and integer types on both [primitives](https://doc.rust-lang.org/std/#primitives) and [`std` modules](https://doc.rust-lang.org/std/#modules).\n\n\n## Primitives\n\n```rust\n// Primitives : Defined by the compiler and methods are directly implemented by std\nbool, char, slice, str\n\ni8, i16, i32, i64, i128, isize\nu8, u16, u32, u64, u128, usize\n\nf32, f64\n\narray, tuple\n\npointer, fn, reference\n```\n\n## Standard Macros\n\n```rust\n// Standard Macros also defined by both compiler and std\nprint, println, eprint, eprintln\nformat, format_args\nwrite, writeln\n\nconcat, concat_idents, stringify //concat_idents : nightly-only experimental API\n\ninclude, include_bytes, include_str\n\nassert, assert_eq, assert_ne\ndebug_assert, debug_assert_eq, debug_assert_ne\n\ntry, panic, compile_error, unreachable, unimplemented\n\nfile, line, column, module_path\nenv, option_env\ncfg\n\nselect, thread_local //select : nightly-only experimental API\n\nvec\n```\n\n## Std Modules\n\n```rust\n// std modules\nchar, str\n\ni8, i16, i32, i64, i128, isize\nu8, u16, u32 ,u64, u128, usize\nf32, f64\nnum\n\nvec, slice, hash, heap, collections // heap : nightly-only experimental API\n\nstring, ascii, fmt\n\ndefault\n\nmarker, clone, convert, cmp, iter\n\nops, ffi\n\noption, result, panic, error\n\nio\nfs, path\nmem, thread, sync\nprocess, env\nnet\ntime\nos\n\nptr, boxed, borrow, cell, any, rc\n\nprelude\n\nintrinsics // intrinsics : nightly-only experimental API\nraw // raw : nightly-only experimental API\n```\n\n> üîé When examine [Rust‚Äôs source code](https://github.com/rust-lang/rust), you can see that [`src` directory](https://github.com/rust-lang/rust/tree/master/src) is a **workspace**. Even though its having many library crates, by examine [root Cargo.toml](https://github.com/rust-lang/rust/blob/master/src/Cargo.toml) file you can easily identify that main crates are **[rustc](https://github.com/rust-lang/rust/tree/master/src/rustc)**(compiler) and **[libstd](https://github.com/rust-lang/rust/tree/master/src/libstd)** (std). In libstd/lib.rs std modules have been **re-exported** via `pub use` and the original location of most of std modules is [`src/libcore`](https://github.com/rust-lang/rust/tree/master/src/libcore).\n\n**Few important `std` modules are,**\n- `std::io` - Core **I/O** functionality \n- `std::fs` - **Filesystem** specific functionality\n- `std::path` - **Cross platform path** specific functionality\n- `std::env` - **Process‚Äôs environment** related functionality\n- `std::mem` - **Memory** related functionality\n- `std::net` - **TCP/UDP** communication\n- `std::os` - **OS** specific functionality\n- `std::thread` - Native **threads** specific functionality\n- `std::collections` - Core **Collection types**\n\n> üíØ Refer [Rust Standard Library Documentation](https://doc.rust-lang.org/std/) for more details.\n\n\n## Preludes\n\nEven though Rust `std` contains many modules, by default it doesn‚Äôt load each and every thing of std library on every rust program. Instead, it loads only the **smallest list of things which require for almost every single Rust program**. These are called **[preludes](https://doc.rust-lang.org/std/prelude/)**. They import only,\n\n```rust\n// Reexported core operators\npub use marker::{Copy, Send, Sized, Sync};\npub use ops::{Drop, Fn, FnMut, FnOnce};\n\n// Reexported functions\npub use mem::drop;\n\n// Reexported types and traits\npub use boxed::Box;\npub use borrow::ToOwned;\npub use clone::Clone;\npub use cmp::{PartialEq, PartialOrd, Eq, Ord};\npub use convert::{AsRef, AsMut, Into, From};\npub use default::Default;\npub use iter::{Iterator, Extend, IntoIterator};\npub use iter::{DoubleEndedIterator, ExactSizeIterator};\npub use option::Option::{self, Some, None};\npub use result::Result::{self, Ok, Err};\npub use slice::SliceConcatExt;\npub use string::{String, ToString};\npub use vec::Vec;\n```\n\n> Preludes have been imported explicitly on [`libstd/lib.rs`](https://github.com/rust-lang/rust/blob/master/src/libstd/lib.rs#L353) and the whole list can be seen on [`libstd/prelude/v1.rs`](https://github.com/rust-lang/rust/blob/master/src/libstd/prelude/v1.rs).\n\n‚≠êÔ∏è So technically, Rust inserts,\n- `extern crate std;` : into the **crate root of every crate**\n- `use std::prelude::v1::*;` : into **every module**\n  So you don‚Äôt need to import these each time.\n\n\nThe concept of preludes is quite common on Rust libraries. Even some modules inside `std` crate (ex.libstd/io) and many libraries (ex. [diesel](https://github.com/diesel-rs/diesel/blob/master/diesel/src/lib.rs#L151)) are having their own `prelude` modules.\n\n‚≠êÔ∏è But **preludes** are used to **create a single place to import all important components** which are **required while using the library**. They **do not load automatically** unless you imported them manually. Only `std::prelude` imports automatically in every Rust programs.","date":"2019-03-19T14:50:31.986Z","updated":"2019-03-19T14:50:31.986Z","path":"docs/zh-cn/d7.std_primitives_and_preludes.html","comments":1,"layout":"page","_id":"cjtfwbj0z001mdwgpb9lzlbnv","content":"<p>‚≠êÔ∏è In Rust, language elements are implemented by not only <strong><code>std</code> library</strong> crate but also <strong>compiler</strong> as well. Examples,</p>\n<ul>\n<li><strong><a href=\"https://doc.rust-lang.org/std/#primitives\" target=\"_blank\" rel=\"noopener\">Primitives</a></strong> : Defined by the compiler and methods are implemented by <code>std</code> library directly on primitives.</li>\n<li><strong><a href=\"https://doc.rust-lang.org/std/#macros\" target=\"_blank\" rel=\"noopener\">Standard Macros</a></strong> : Defined by both compiler and <code>std</code></li>\n</ul>\n<p><strong><code>std</code></strong> library has been has divided into <strong><a href=\"https://doc.rust-lang.org/std/#modules\" target=\"_blank\" rel=\"noopener\">modules</a></strong>, according to the main areas each covered.</p>\n<p>‚≠êÔ∏è While primitives are implemented by the <strong>compiler</strong>, the standard library implements <strong>most useful methods</strong> directly on the primitive types. But some <strong>rarely useful language elements</strong> of some primitives are stored on relevant <strong><code>std</code> modules</strong>. This is why you can see <code>char</code>, <code>str</code> and integer types on both <a href=\"https://doc.rust-lang.org/std/#primitives\" target=\"_blank\" rel=\"noopener\">primitives</a> and <a href=\"https://doc.rust-lang.org/std/#modules\" target=\"_blank\" rel=\"noopener\"><code>std</code> modules</a>.</p>\n<h2 id=\"Primitives\"><a href=\"#Primitives\" class=\"headerlink\" title=\"Primitives\"></a>Primitives</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Primitives : Defined by the compiler and methods are directly implemented by std\nbool, char, slice, str\n\ni8, i16, i32, i64, i128, isize\nu8, u16, u32, u64, u128, usize\n\nf32, f64\n\narray, tuple\n\npointer, fn, reference\n</code></pre>\n<h2 id=\"Standard-Macros\"><a href=\"#Standard-Macros\" class=\"headerlink\" title=\"Standard Macros\"></a>Standard Macros</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Standard Macros also defined by both compiler and std\nprint, println, eprint, eprintln\nformat, format_args\nwrite, writeln\n\nconcat, concat_idents, stringify //concat_idents : nightly-only experimental API\n\ninclude, include_bytes, include_str\n\nassert, assert_eq, assert_ne\ndebug_assert, debug_assert_eq, debug_assert_ne\n\ntry, panic, compile_error, unreachable, unimplemented\n\nfile, line, column, module_path\nenv, option_env\ncfg\n\nselect, thread_local //select : nightly-only experimental API\n\nvec\n</code></pre>\n<h2 id=\"Std-Modules\"><a href=\"#Std-Modules\" class=\"headerlink\" title=\"Std Modules\"></a>Std Modules</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// std modules\nchar, str\n\ni8, i16, i32, i64, i128, isize\nu8, u16, u32 ,u64, u128, usize\nf32, f64\nnum\n\nvec, slice, hash, heap, collections // heap : nightly-only experimental API\n\nstring, ascii, fmt\n\ndefault\n\nmarker, clone, convert, cmp, iter\n\nops, ffi\n\noption, result, panic, error\n\nio\nfs, path\nmem, thread, sync\nprocess, env\nnet\ntime\nos\n\nptr, boxed, borrow, cell, any, rc\n\nprelude\n\nintrinsics // intrinsics : nightly-only experimental API\nraw // raw : nightly-only experimental API\n</code></pre>\n<blockquote>\n<p>üîé When examine <a href=\"https://github.com/rust-lang/rust\" target=\"_blank\" rel=\"noopener\">Rust‚Äôs source code</a>, you can see that <a href=\"https://github.com/rust-lang/rust/tree/master/src\" target=\"_blank\" rel=\"noopener\"><code>src</code> directory</a> is a <strong>workspace</strong>. Even though its having many library crates, by examine <a href=\"https://github.com/rust-lang/rust/blob/master/src/Cargo.toml\" target=\"_blank\" rel=\"noopener\">root Cargo.toml</a> file you can easily identify that main crates are <strong><a href=\"https://github.com/rust-lang/rust/tree/master/src/rustc\" target=\"_blank\" rel=\"noopener\">rustc</a></strong>(compiler) and <strong><a href=\"https://github.com/rust-lang/rust/tree/master/src/libstd\" target=\"_blank\" rel=\"noopener\">libstd</a></strong> (std). In libstd/lib.rs std modules have been <strong>re-exported</strong> via <code>pub use</code> and the original location of most of std modules is <a href=\"https://github.com/rust-lang/rust/tree/master/src/libcore\" target=\"_blank\" rel=\"noopener\"><code>src/libcore</code></a>.</p>\n</blockquote>\n<p><strong>Few important <code>std</code> modules are,</strong></p>\n<ul>\n<li><code>std::io</code> - Core <strong>I/O</strong> functionality </li>\n<li><code>std::fs</code> - <strong>Filesystem</strong> specific functionality</li>\n<li><code>std::path</code> - <strong>Cross platform path</strong> specific functionality</li>\n<li><code>std::env</code> - <strong>Process‚Äôs environment</strong> related functionality</li>\n<li><code>std::mem</code> - <strong>Memory</strong> related functionality</li>\n<li><code>std::net</code> - <strong>TCP/UDP</strong> communication</li>\n<li><code>std::os</code> - <strong>OS</strong> specific functionality</li>\n<li><code>std::thread</code> - Native <strong>threads</strong> specific functionality</li>\n<li><code>std::collections</code> - Core <strong>Collection types</strong></li>\n</ul>\n<blockquote>\n<p>üíØ Refer <a href=\"https://doc.rust-lang.org/std/\" target=\"_blank\" rel=\"noopener\">Rust Standard Library Documentation</a> for more details.</p>\n</blockquote>\n<h2 id=\"Preludes\"><a href=\"#Preludes\" class=\"headerlink\" title=\"Preludes\"></a>Preludes</h2><p>Even though Rust <code>std</code> contains many modules, by default it doesn‚Äôt load each and every thing of std library on every rust program. Instead, it loads only the <strong>smallest list of things which require for almost every single Rust program</strong>. These are called <strong><a href=\"https://doc.rust-lang.org/std/prelude/\" target=\"_blank\" rel=\"noopener\">preludes</a></strong>. They import only,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Reexported core operators\npub use marker::{Copy, Send, Sized, Sync};\npub use ops::{Drop, Fn, FnMut, FnOnce};\n\n// Reexported functions\npub use mem::drop;\n\n// Reexported types and traits\npub use boxed::Box;\npub use borrow::ToOwned;\npub use clone::Clone;\npub use cmp::{PartialEq, PartialOrd, Eq, Ord};\npub use convert::{AsRef, AsMut, Into, From};\npub use default::Default;\npub use iter::{Iterator, Extend, IntoIterator};\npub use iter::{DoubleEndedIterator, ExactSizeIterator};\npub use option::Option::{self, Some, None};\npub use result::Result::{self, Ok, Err};\npub use slice::SliceConcatExt;\npub use string::{String, ToString};\npub use vec::Vec;\n</code></pre>\n<blockquote>\n<p>Preludes have been imported explicitly on <a href=\"https://github.com/rust-lang/rust/blob/master/src/libstd/lib.rs#L353\" target=\"_blank\" rel=\"noopener\"><code>libstd/lib.rs</code></a> and the whole list can be seen on <a href=\"https://github.com/rust-lang/rust/blob/master/src/libstd/prelude/v1.rs\" target=\"_blank\" rel=\"noopener\"><code>libstd/prelude/v1.rs</code></a>.</p>\n</blockquote>\n<p>‚≠êÔ∏è So technically, Rust inserts,</p>\n<ul>\n<li><code>extern crate std;</code> : into the <strong>crate root of every crate</strong></li>\n<li><code>use std::prelude::v1::*;</code> : into <strong>every module</strong><br>So you don‚Äôt need to import these each time.</li>\n</ul>\n<p>The concept of preludes is quite common on Rust libraries. Even some modules inside <code>std</code> crate (ex.libstd/io) and many libraries (ex. <a href=\"https://github.com/diesel-rs/diesel/blob/master/diesel/src/lib.rs#L151\" target=\"_blank\" rel=\"noopener\">diesel</a>) are having their own <code>prelude</code> modules.</p>\n<p>‚≠êÔ∏è But <strong>preludes</strong> are used to <strong>create a single place to import all important components</strong> which are <strong>required while using the library</strong>. They <strong>do not load automatically</strong> unless you imported them manually. Only <code>std::prelude</code> imports automatically in every Rust programs.</p>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<p>‚≠êÔ∏è In Rust, language elements are implemented by not only <strong><code>std</code> library</strong> crate but also <strong>compiler</strong> as well. Examples,</p>\n<ul>\n<li><strong><a href=\"https://doc.rust-lang.org/std/#primitives\" target=\"_blank\" rel=\"noopener\">Primitives</a></strong> : Defined by the compiler and methods are implemented by <code>std</code> library directly on primitives.</li>\n<li><strong><a href=\"https://doc.rust-lang.org/std/#macros\" target=\"_blank\" rel=\"noopener\">Standard Macros</a></strong> : Defined by both compiler and <code>std</code></li>\n</ul>\n<p><strong><code>std</code></strong> library has been has divided into <strong><a href=\"https://doc.rust-lang.org/std/#modules\" target=\"_blank\" rel=\"noopener\">modules</a></strong>, according to the main areas each covered.</p>\n<p>‚≠êÔ∏è While primitives are implemented by the <strong>compiler</strong>, the standard library implements <strong>most useful methods</strong> directly on the primitive types. But some <strong>rarely useful language elements</strong> of some primitives are stored on relevant <strong><code>std</code> modules</strong>. This is why you can see <code>char</code>, <code>str</code> and integer types on both <a href=\"https://doc.rust-lang.org/std/#primitives\" target=\"_blank\" rel=\"noopener\">primitives</a> and <a href=\"https://doc.rust-lang.org/std/#modules\" target=\"_blank\" rel=\"noopener\"><code>std</code> modules</a>.</p>\n<h2 id=\"Primitives\"><a href=\"#Primitives\" class=\"headerlink\" title=\"Primitives\"></a>Primitives</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Primitives : Defined by the compiler and methods are directly implemented by std\nbool, char, slice, str\n\ni8, i16, i32, i64, i128, isize\nu8, u16, u32, u64, u128, usize\n\nf32, f64\n\narray, tuple\n\npointer, fn, reference\n</code></pre>\n<h2 id=\"Standard-Macros\"><a href=\"#Standard-Macros\" class=\"headerlink\" title=\"Standard Macros\"></a>Standard Macros</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Standard Macros also defined by both compiler and std\nprint, println, eprint, eprintln\nformat, format_args\nwrite, writeln\n\nconcat, concat_idents, stringify //concat_idents : nightly-only experimental API\n\ninclude, include_bytes, include_str\n\nassert, assert_eq, assert_ne\ndebug_assert, debug_assert_eq, debug_assert_ne\n\ntry, panic, compile_error, unreachable, unimplemented\n\nfile, line, column, module_path\nenv, option_env\ncfg\n\nselect, thread_local //select : nightly-only experimental API\n\nvec\n</code></pre>\n<h2 id=\"Std-Modules\"><a href=\"#Std-Modules\" class=\"headerlink\" title=\"Std Modules\"></a>Std Modules</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// std modules\nchar, str\n\ni8, i16, i32, i64, i128, isize\nu8, u16, u32 ,u64, u128, usize\nf32, f64\nnum\n\nvec, slice, hash, heap, collections // heap : nightly-only experimental API\n\nstring, ascii, fmt\n\ndefault\n\nmarker, clone, convert, cmp, iter\n\nops, ffi\n\noption, result, panic, error\n\nio\nfs, path\nmem, thread, sync\nprocess, env\nnet\ntime\nos\n\nptr, boxed, borrow, cell, any, rc\n\nprelude\n\nintrinsics // intrinsics : nightly-only experimental API\nraw // raw : nightly-only experimental API\n</code></pre>\n<blockquote>\n<p>üîé When examine <a href=\"https://github.com/rust-lang/rust\" target=\"_blank\" rel=\"noopener\">Rust‚Äôs source code</a>, you can see that <a href=\"https://github.com/rust-lang/rust/tree/master/src\" target=\"_blank\" rel=\"noopener\"><code>src</code> directory</a> is a <strong>workspace</strong>. Even though its having many library crates, by examine <a href=\"https://github.com/rust-lang/rust/blob/master/src/Cargo.toml\" target=\"_blank\" rel=\"noopener\">root Cargo.toml</a> file you can easily identify that main crates are <strong><a href=\"https://github.com/rust-lang/rust/tree/master/src/rustc\" target=\"_blank\" rel=\"noopener\">rustc</a></strong>(compiler) and <strong><a href=\"https://github.com/rust-lang/rust/tree/master/src/libstd\" target=\"_blank\" rel=\"noopener\">libstd</a></strong> (std). In libstd/lib.rs std modules have been <strong>re-exported</strong> via <code>pub use</code> and the original location of most of std modules is <a href=\"https://github.com/rust-lang/rust/tree/master/src/libcore\" target=\"_blank\" rel=\"noopener\"><code>src/libcore</code></a>.</p>\n</blockquote>\n<p><strong>Few important <code>std</code> modules are,</strong></p>\n<ul>\n<li><code>std::io</code> - Core <strong>I/O</strong> functionality </li>\n<li><code>std::fs</code> - <strong>Filesystem</strong> specific functionality</li>\n<li><code>std::path</code> - <strong>Cross platform path</strong> specific functionality</li>\n<li><code>std::env</code> - <strong>Process‚Äôs environment</strong> related functionality</li>\n<li><code>std::mem</code> - <strong>Memory</strong> related functionality</li>\n<li><code>std::net</code> - <strong>TCP/UDP</strong> communication</li>\n<li><code>std::os</code> - <strong>OS</strong> specific functionality</li>\n<li><code>std::thread</code> - Native <strong>threads</strong> specific functionality</li>\n<li><code>std::collections</code> - Core <strong>Collection types</strong></li>\n</ul>\n<blockquote>\n<p>üíØ Refer <a href=\"https://doc.rust-lang.org/std/\" target=\"_blank\" rel=\"noopener\">Rust Standard Library Documentation</a> for more details.</p>\n</blockquote>\n<h2 id=\"Preludes\"><a href=\"#Preludes\" class=\"headerlink\" title=\"Preludes\"></a>Preludes</h2><p>Even though Rust <code>std</code> contains many modules, by default it doesn‚Äôt load each and every thing of std library on every rust program. Instead, it loads only the <strong>smallest list of things which require for almost every single Rust program</strong>. These are called <strong><a href=\"https://doc.rust-lang.org/std/prelude/\" target=\"_blank\" rel=\"noopener\">preludes</a></strong>. They import only,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Reexported core operators\npub use marker::{Copy, Send, Sized, Sync};\npub use ops::{Drop, Fn, FnMut, FnOnce};\n\n// Reexported functions\npub use mem::drop;\n\n// Reexported types and traits\npub use boxed::Box;\npub use borrow::ToOwned;\npub use clone::Clone;\npub use cmp::{PartialEq, PartialOrd, Eq, Ord};\npub use convert::{AsRef, AsMut, Into, From};\npub use default::Default;\npub use iter::{Iterator, Extend, IntoIterator};\npub use iter::{DoubleEndedIterator, ExactSizeIterator};\npub use option::Option::{self, Some, None};\npub use result::Result::{self, Ok, Err};\npub use slice::SliceConcatExt;\npub use string::{String, ToString};\npub use vec::Vec;\n</code></pre>\n<blockquote>\n<p>Preludes have been imported explicitly on <a href=\"https://github.com/rust-lang/rust/blob/master/src/libstd/lib.rs#L353\" target=\"_blank\" rel=\"noopener\"><code>libstd/lib.rs</code></a> and the whole list can be seen on <a href=\"https://github.com/rust-lang/rust/blob/master/src/libstd/prelude/v1.rs\" target=\"_blank\" rel=\"noopener\"><code>libstd/prelude/v1.rs</code></a>.</p>\n</blockquote>\n<p>‚≠êÔ∏è So technically, Rust inserts,</p>\n<ul>\n<li><code>extern crate std;</code> : into the <strong>crate root of every crate</strong></li>\n<li><code>use std::prelude::v1::*;</code> : into <strong>every module</strong><br>So you don‚Äôt need to import these each time.</li>\n</ul>\n<p>The concept of preludes is quite common on Rust libraries. Even some modules inside <code>std</code> crate (ex.libstd/io) and many libraries (ex. <a href=\"https://github.com/diesel-rs/diesel/blob/master/diesel/src/lib.rs#L151\" target=\"_blank\" rel=\"noopener\">diesel</a>) are having their own <code>prelude</code> modules.</p>\n<p>‚≠êÔ∏è But <strong>preludes</strong> are used to <strong>create a single place to import all important components</strong> which are <strong>required while using the library</strong>. They <strong>do not load automatically</strong> unless you imported them manually. Only <code>std::prelude</code> imports automatically in every Rust programs.</p>\n"},{"title":"Lifetimes","_content":"\nWhen we are dealing with references, we have to make sure that the referencing data stay alive until we are stop using the references.\n\nThink,\n\n* We have a variable binding, ‚Äú**a**‚Äù.\n* We are referencing the value of ‚Äúa‚Äù, from another variable binding ‚Äú**x**‚Äù.\n  We have to make sure that ‚Äúa‚Äù **lives** until we stop using ‚Äúx‚Äù\n\n> üîé **Memory management** is a form of resource management applied to computer memory. Up until the mid-1990s, the majority of programming languages used **Manual Memory Management** which **requires the programmer to give manual instructions** to identify and deallocate unused objects/ garbage. Around 1959 John McCarthy invented **Garbage collection**\\(GC\\), a form of **Automatic Memory Management**\\(AMM\\). It determines what memory is no longer used and frees it automatically instead of relying on the programmer. However **Objective-C and Swift** provide similar functionality through **Automatic Reference Counting**\\(ARC\\).\n\n## What is Lifetimes?\n\nIn Rust,\n\n* A resource can only have **one owner** at a time. When it goes **out of the scope**, Rust removes it from the Memory.\n* When we want to reuse the same resource, we are **referencing** it/ **borrowing** its content.\n* When dealing with **references**, we have to specify **lifetime annotations** to provide instructions for the **compiler** to set **how long** those referenced resources **should be alive**.\n* ‚≠ê Ô∏èBut because of lifetime annotations make **code more verbose**, in order to make **common patterns** more ergonomic, Rust allows lifetimes to be **elided/omitted** in `fn` definitions. In this case, the compiler assigns lifetime annotations **implicitly**.\n\nLifetime annotations are **checked at compile-time**. Compiler checks when a data is used for the first and the last times. According to that, Rust manages memory in **run time**. This is the major reason of having **slower compilation times** in Rust.\n\n> * Unlike C and C++, **usually** Rust doesn‚Äôt explicitly drop values at all.\n> * Unlike GC, Rust doesn‚Äôt place deallocation calls where the data is no longer referenced.\n> * Rust places deallocation calls where the data is about to go out of the scope and then enforces that no references to that resource exist after that point.\n\n## Usage\n\nLifetimes are denoted with an apostrophe. By convention, a lowercase letter is used for naming. Usually **starts with** `'a` and **follows alphabetic order** when we need to add **multiple lifetime** annotations.\n\nWhen using references,\n\n### 01. On Function Declaration\n\n* Input and output parameters with references should attach lifetimes after `&` sign. ex `..(x: &'a str)` , `..(x: &'a mut str)`\n* After the function name, we should mention that the given lifetimes are generic types. ex `fn foo<'a>(..)` , `fn foo<'a, 'b>(..)`\n\n```rust\n// no inputs, return a reference\nfn function<'a>() -> &'a str {}\n\n// single input\nfn function<'a>(x: &'a str) {}\n\n// single input and output, both has same lifetime\n// output should live at least as long as input exists\nfn function<'a>(x: &'a str) -> &'a str {}\n\n// multiple inputs, only one input and the output share same lifetime\n// output should live at least as long as y exists\nfn function<'a>(x: i32, y: &'a str) -> &'a str {}\n\n// multiple inputs. both inputs and the output share same lifetime\n// output should live at least as long as x and y exist\nfn function<'a>(x: &'a str, y: &'a str) -> &'a str {}\n\n// multiple inputs. inputs can have diffent lifetimes üîé\n// output should live at least as long as x exists\nfn function<'a, 'b>(x: &'a str, y: &'b str) -> &'a str {}\n```\n\n### 02. On Struct or Enum Declaration\n\n* Elements with references should attach lifetimes after `&` sign.\n* After the name of the struct or enum, we should mention that the given lifetimes are generic types.\n\n```rust\n// single element\n// data of x should live at least as long as Struct exists\nstruct Struct<'a> {\n    x: &'a str\n}\n\n// multiple elements\n// data of x and y should live at least as long as Struct exists\nstruct Struct<'a> {\n    x: &'a str,\n    y: &'a str\n}\n\n\n// variant with single element\n// data of the variant should live at least as long as Enum exists\nenum Enum<'a> {\n    Variant(&'a Type)\n}\n```\n\n### 03. With Impls and Traits\n\n```rust\nstruct Struct<'a> {\n    x: &'a str\n}\n    impl<'a> Struct<'a> {\n        fn function<'a>(&self) -> &'a str {\n            self.x\n        }\n    }\n\n\nstruct Struct<'a> {\n    x: &'a str,\n    y: &'a str\n}\n    impl<'a> Struct<'a> {\n        fn new(x: &'a str, y: &'a str) -> Struct<'a> { //no need to specify <'a> after new; impl already has it\n          Struct {\n              x : x,\n              y : y\n          }\n        }\n    }\n\n\n// üîé\nimpl<'a> Trait<'a> for Type\nimpl<'a> Trait for Type<'a>\n```\n\n### 04. With Generic Types\n\n```rust\n// üîé\nfn function<F>(f: F) where for<'a> F: FnOnce(&'a Type)\nstruct Struct<F> where for<'a> F: FnOnce(&'a Type) { x: F }\nenum Enum<F> where for<'a> F: FnOnce(&'a Type) { Variant(F) }\nimpl<F> Struct<F> where for<'a> F: FnOnce(&'a Type) { fn x(&self) -> &F { &self.x } }\n```\n\n## Lifetime Elision\n\nAs I mentioned earlier, in order to make **common patterns** more ergonomic, Rust allows lifetimes to be **elided/omitted**. This process is called **Lifetime Elision**.\n\nüí° For the moment Rust supports Lifetime Elisions only on `fn` definitions. But in the future it will support for `impl` headers as well.\n\nLifetime annotations of `fn` definitions can be elided  \nif its **parameter list** has either,\n\n* **only one input parameter passes by reference**.\n* a parameter with **either** `&self` **or** **&mut self** reference.\n\n```rust\nfn triple(x: &u64) -> u64 { //only one input parameter passes by reference\n    x * 3\n}\n\n\nfn filter(x: u8, y: &str) -> &str { // only one input parameter passes by reference\n    if x > 5 { y } else { \"invalid inputs\" }\n}\n\n\nstruct Player<'a> {\n    id: u8,\n    name: &'a str\n}\n    impl<'a> Player<'a> { //so far Lifetime Elisions are allowed only on fn definitions; but in the future they might support on impl headers as well.\n        fn new(id: u8, name: &str) -> Player { //only one input parameter passes by reference\n            Player {\n                id : id,\n                name : name\n            }\n        }\n\n        fn heading_text(&self) -> String { // a fn definition with &self (or &mut self) reference\n            format!(\"{}: {}\", self.id, self.name)\n        }\n    }\n\nfn main() {\n    let player1 = Player::new(1, \"Serena Williams\");\n    let player1_heading_text = player1.heading_text()\n    println!(\"{}\", player1_heading_text);\n}\n```\n\n> üí° In the Lifetime Elision process of fn definitions,\n>\n> * Each parameter passes by reference is got a distinct lifetime annotation.\n>     ex. `..(x: &str, y: &str)` ‚Üí `..<'a, 'b>(x: &'a str, y: &'b str)`\n> * If the parameter list has only one parameter passes by reference, that lifetime is assigned to all elided lifetimes in the return values of that function.\n>     ex. `..(x: i32, y: &str) -> &str` ‚Üí `..<'a>(x: i32, y: &'a str) -> &'a str`\n> * Even it has multiple parameters pass by reference, if one of them has &self or &mut self, the lifetime of self is assigned to all elided output lifetimes.\n>     ex. `impl Impl{ fn function(&self, x: &str) -> &str {} }` ‚Üí\n>     `impl<'a> Impl<'a>{ fn function(&'a self, x: &'b str) -> &'a str {} }`\n> * For all other cases, we have to write lifetime annotations manually.\n\n## `'static` Annotations\n\n`'static` lifetime annotation is a **reserved** lifetime annotation. These **references are valid for the entire program**. They are saved in the data segment of the binary and the data referred to will never go out of scope.\n\n```rust\nstatic N: i32 = 5; //A constant with 'static lifetime\n\nlet a = \"Hello, world.\"; //a: &'static str\n\n\nfn index() -> &'static str { //No need to mention <'static> ; fn index Ã∂<Ã∂'Ã∂sÃ∂tÃ∂aÃ∂tÃ∂iÃ∂cÃ∂>Ã∂ \n\t\"Hello, world!\"\n}\n```\n\n## Few more examples about usage of Rust lifetimes.\n\n```rust\nfn greeting<'a>() -> &'a str {\n  \"Hi!\"\n}\n\n\nfn fullname<'a>(fname: &'a str, lname: &'a str) -> String {\n  format!(\"{} {}\", fname, lname)\n}\n\n\nstruct Person<'a> {\n    fname: &'a str,\n    lname: &'a str\n}\n  impl<'a> Person<'a> {\n      fn new(fname: &'a str, lname: &'a str) -> Person<'a> { //no need to specify <'a> after new; impl already has it\n          Person {\n              fname : fname,\n              lname : lname\n          }\n      }\n\n      fn fullname(&self) -> String {\n          format!(\"{} {}\", self.fname , self.lname)\n      }\n  }\n\nfn main() {\n    let player = Person::new(\"Serena\", \"Williams\");\n    let player_fullname = player.fullname();\n\n    println!(\"Player: {}\", player_fullname);\n}\n```\n","source":"docs/zh-cn/c3.lifetimes.md","raw":"title: Lifetimes\n---\n\nWhen we are dealing with references, we have to make sure that the referencing data stay alive until we are stop using the references.\n\nThink,\n\n* We have a variable binding, ‚Äú**a**‚Äù.\n* We are referencing the value of ‚Äúa‚Äù, from another variable binding ‚Äú**x**‚Äù.\n  We have to make sure that ‚Äúa‚Äù **lives** until we stop using ‚Äúx‚Äù\n\n> üîé **Memory management** is a form of resource management applied to computer memory. Up until the mid-1990s, the majority of programming languages used **Manual Memory Management** which **requires the programmer to give manual instructions** to identify and deallocate unused objects/ garbage. Around 1959 John McCarthy invented **Garbage collection**\\(GC\\), a form of **Automatic Memory Management**\\(AMM\\). It determines what memory is no longer used and frees it automatically instead of relying on the programmer. However **Objective-C and Swift** provide similar functionality through **Automatic Reference Counting**\\(ARC\\).\n\n## What is Lifetimes?\n\nIn Rust,\n\n* A resource can only have **one owner** at a time. When it goes **out of the scope**, Rust removes it from the Memory.\n* When we want to reuse the same resource, we are **referencing** it/ **borrowing** its content.\n* When dealing with **references**, we have to specify **lifetime annotations** to provide instructions for the **compiler** to set **how long** those referenced resources **should be alive**.\n* ‚≠ê Ô∏èBut because of lifetime annotations make **code more verbose**, in order to make **common patterns** more ergonomic, Rust allows lifetimes to be **elided/omitted** in `fn` definitions. In this case, the compiler assigns lifetime annotations **implicitly**.\n\nLifetime annotations are **checked at compile-time**. Compiler checks when a data is used for the first and the last times. According to that, Rust manages memory in **run time**. This is the major reason of having **slower compilation times** in Rust.\n\n> * Unlike C and C++, **usually** Rust doesn‚Äôt explicitly drop values at all.\n> * Unlike GC, Rust doesn‚Äôt place deallocation calls where the data is no longer referenced.\n> * Rust places deallocation calls where the data is about to go out of the scope and then enforces that no references to that resource exist after that point.\n\n## Usage\n\nLifetimes are denoted with an apostrophe. By convention, a lowercase letter is used for naming. Usually **starts with** `'a` and **follows alphabetic order** when we need to add **multiple lifetime** annotations.\n\nWhen using references,\n\n### 01. On Function Declaration\n\n* Input and output parameters with references should attach lifetimes after `&` sign. ex `..(x: &'a str)` , `..(x: &'a mut str)`\n* After the function name, we should mention that the given lifetimes are generic types. ex `fn foo<'a>(..)` , `fn foo<'a, 'b>(..)`\n\n```rust\n// no inputs, return a reference\nfn function<'a>() -> &'a str {}\n\n// single input\nfn function<'a>(x: &'a str) {}\n\n// single input and output, both has same lifetime\n// output should live at least as long as input exists\nfn function<'a>(x: &'a str) -> &'a str {}\n\n// multiple inputs, only one input and the output share same lifetime\n// output should live at least as long as y exists\nfn function<'a>(x: i32, y: &'a str) -> &'a str {}\n\n// multiple inputs. both inputs and the output share same lifetime\n// output should live at least as long as x and y exist\nfn function<'a>(x: &'a str, y: &'a str) -> &'a str {}\n\n// multiple inputs. inputs can have diffent lifetimes üîé\n// output should live at least as long as x exists\nfn function<'a, 'b>(x: &'a str, y: &'b str) -> &'a str {}\n```\n\n### 02. On Struct or Enum Declaration\n\n* Elements with references should attach lifetimes after `&` sign.\n* After the name of the struct or enum, we should mention that the given lifetimes are generic types.\n\n```rust\n// single element\n// data of x should live at least as long as Struct exists\nstruct Struct<'a> {\n    x: &'a str\n}\n\n// multiple elements\n// data of x and y should live at least as long as Struct exists\nstruct Struct<'a> {\n    x: &'a str,\n    y: &'a str\n}\n\n\n// variant with single element\n// data of the variant should live at least as long as Enum exists\nenum Enum<'a> {\n    Variant(&'a Type)\n}\n```\n\n### 03. With Impls and Traits\n\n```rust\nstruct Struct<'a> {\n    x: &'a str\n}\n    impl<'a> Struct<'a> {\n        fn function<'a>(&self) -> &'a str {\n            self.x\n        }\n    }\n\n\nstruct Struct<'a> {\n    x: &'a str,\n    y: &'a str\n}\n    impl<'a> Struct<'a> {\n        fn new(x: &'a str, y: &'a str) -> Struct<'a> { //no need to specify <'a> after new; impl already has it\n          Struct {\n              x : x,\n              y : y\n          }\n        }\n    }\n\n\n// üîé\nimpl<'a> Trait<'a> for Type\nimpl<'a> Trait for Type<'a>\n```\n\n### 04. With Generic Types\n\n```rust\n// üîé\nfn function<F>(f: F) where for<'a> F: FnOnce(&'a Type)\nstruct Struct<F> where for<'a> F: FnOnce(&'a Type) { x: F }\nenum Enum<F> where for<'a> F: FnOnce(&'a Type) { Variant(F) }\nimpl<F> Struct<F> where for<'a> F: FnOnce(&'a Type) { fn x(&self) -> &F { &self.x } }\n```\n\n## Lifetime Elision\n\nAs I mentioned earlier, in order to make **common patterns** more ergonomic, Rust allows lifetimes to be **elided/omitted**. This process is called **Lifetime Elision**.\n\nüí° For the moment Rust supports Lifetime Elisions only on `fn` definitions. But in the future it will support for `impl` headers as well.\n\nLifetime annotations of `fn` definitions can be elided  \nif its **parameter list** has either,\n\n* **only one input parameter passes by reference**.\n* a parameter with **either** `&self` **or** **&mut self** reference.\n\n```rust\nfn triple(x: &u64) -> u64 { //only one input parameter passes by reference\n    x * 3\n}\n\n\nfn filter(x: u8, y: &str) -> &str { // only one input parameter passes by reference\n    if x > 5 { y } else { \"invalid inputs\" }\n}\n\n\nstruct Player<'a> {\n    id: u8,\n    name: &'a str\n}\n    impl<'a> Player<'a> { //so far Lifetime Elisions are allowed only on fn definitions; but in the future they might support on impl headers as well.\n        fn new(id: u8, name: &str) -> Player { //only one input parameter passes by reference\n            Player {\n                id : id,\n                name : name\n            }\n        }\n\n        fn heading_text(&self) -> String { // a fn definition with &self (or &mut self) reference\n            format!(\"{}: {}\", self.id, self.name)\n        }\n    }\n\nfn main() {\n    let player1 = Player::new(1, \"Serena Williams\");\n    let player1_heading_text = player1.heading_text()\n    println!(\"{}\", player1_heading_text);\n}\n```\n\n> üí° In the Lifetime Elision process of fn definitions,\n>\n> * Each parameter passes by reference is got a distinct lifetime annotation.\n>     ex. `..(x: &str, y: &str)` ‚Üí `..<'a, 'b>(x: &'a str, y: &'b str)`\n> * If the parameter list has only one parameter passes by reference, that lifetime is assigned to all elided lifetimes in the return values of that function.\n>     ex. `..(x: i32, y: &str) -> &str` ‚Üí `..<'a>(x: i32, y: &'a str) -> &'a str`\n> * Even it has multiple parameters pass by reference, if one of them has &self or &mut self, the lifetime of self is assigned to all elided output lifetimes.\n>     ex. `impl Impl{ fn function(&self, x: &str) -> &str {} }` ‚Üí\n>     `impl<'a> Impl<'a>{ fn function(&'a self, x: &'b str) -> &'a str {} }`\n> * For all other cases, we have to write lifetime annotations manually.\n\n## `'static` Annotations\n\n`'static` lifetime annotation is a **reserved** lifetime annotation. These **references are valid for the entire program**. They are saved in the data segment of the binary and the data referred to will never go out of scope.\n\n```rust\nstatic N: i32 = 5; //A constant with 'static lifetime\n\nlet a = \"Hello, world.\"; //a: &'static str\n\n\nfn index() -> &'static str { //No need to mention <'static> ; fn index Ã∂<Ã∂'Ã∂sÃ∂tÃ∂aÃ∂tÃ∂iÃ∂cÃ∂>Ã∂ \n\t\"Hello, world!\"\n}\n```\n\n## Few more examples about usage of Rust lifetimes.\n\n```rust\nfn greeting<'a>() -> &'a str {\n  \"Hi!\"\n}\n\n\nfn fullname<'a>(fname: &'a str, lname: &'a str) -> String {\n  format!(\"{} {}\", fname, lname)\n}\n\n\nstruct Person<'a> {\n    fname: &'a str,\n    lname: &'a str\n}\n  impl<'a> Person<'a> {\n      fn new(fname: &'a str, lname: &'a str) -> Person<'a> { //no need to specify <'a> after new; impl already has it\n          Person {\n              fname : fname,\n              lname : lname\n          }\n      }\n\n      fn fullname(&self) -> String {\n          format!(\"{} {}\", self.fname , self.lname)\n      }\n  }\n\nfn main() {\n    let player = Person::new(\"Serena\", \"Williams\");\n    let player_fullname = player.fullname();\n\n    println!(\"Player: {}\", player_fullname);\n}\n```\n","date":"2019-03-19T14:50:31.985Z","updated":"2019-03-19T14:50:31.985Z","path":"docs/zh-cn/c3.lifetimes.html","comments":1,"layout":"page","_id":"cjtfwbj1g001ndwgpcqw8rwdc","content":"<p>When we are dealing with references, we have to make sure that the referencing data stay alive until we are stop using the references.</p>\n<p>Think,</p>\n<ul>\n<li>We have a variable binding, ‚Äú<strong>a</strong>‚Äù.</li>\n<li>We are referencing the value of ‚Äúa‚Äù, from another variable binding ‚Äú<strong>x</strong>‚Äù.<br>We have to make sure that ‚Äúa‚Äù <strong>lives</strong> until we stop using ‚Äúx‚Äù</li>\n</ul>\n<blockquote>\n<p>üîé <strong>Memory management</strong> is a form of resource management applied to computer memory. Up until the mid-1990s, the majority of programming languages used <strong>Manual Memory Management</strong> which <strong>requires the programmer to give manual instructions</strong> to identify and deallocate unused objects/ garbage. Around 1959 John McCarthy invented <strong>Garbage collection</strong>(GC), a form of <strong>Automatic Memory Management</strong>(AMM). It determines what memory is no longer used and frees it automatically instead of relying on the programmer. However <strong>Objective-C and Swift</strong> provide similar functionality through <strong>Automatic Reference Counting</strong>(ARC).</p>\n</blockquote>\n<h2 id=\"What-is-Lifetimes\"><a href=\"#What-is-Lifetimes\" class=\"headerlink\" title=\"What is Lifetimes?\"></a>What is Lifetimes?</h2><p>In Rust,</p>\n<ul>\n<li>A resource can only have <strong>one owner</strong> at a time. When it goes <strong>out of the scope</strong>, Rust removes it from the Memory.</li>\n<li>When we want to reuse the same resource, we are <strong>referencing</strong> it/ <strong>borrowing</strong> its content.</li>\n<li>When dealing with <strong>references</strong>, we have to specify <strong>lifetime annotations</strong> to provide instructions for the <strong>compiler</strong> to set <strong>how long</strong> those referenced resources <strong>should be alive</strong>.</li>\n<li>‚≠ê Ô∏èBut because of lifetime annotations make <strong>code more verbose</strong>, in order to make <strong>common patterns</strong> more ergonomic, Rust allows lifetimes to be <strong>elided/omitted</strong> in <code>fn</code> definitions. In this case, the compiler assigns lifetime annotations <strong>implicitly</strong>.</li>\n</ul>\n<p>Lifetime annotations are <strong>checked at compile-time</strong>. Compiler checks when a data is used for the first and the last times. According to that, Rust manages memory in <strong>run time</strong>. This is the major reason of having <strong>slower compilation times</strong> in Rust.</p>\n<blockquote>\n<ul>\n<li>Unlike C and C++, <strong>usually</strong> Rust doesn‚Äôt explicitly drop values at all.</li>\n<li>Unlike GC, Rust doesn‚Äôt place deallocation calls where the data is no longer referenced.</li>\n<li>Rust places deallocation calls where the data is about to go out of the scope and then enforces that no references to that resource exist after that point.</li>\n</ul>\n</blockquote>\n<h2 id=\"Usage\"><a href=\"#Usage\" class=\"headerlink\" title=\"Usage\"></a>Usage</h2><p>Lifetimes are denoted with an apostrophe. By convention, a lowercase letter is used for naming. Usually <strong>starts with</strong> <code>&#39;a</code> and <strong>follows alphabetic order</strong> when we need to add <strong>multiple lifetime</strong> annotations.</p>\n<p>When using references,</p>\n<h3 id=\"01-On-Function-Declaration\"><a href=\"#01-On-Function-Declaration\" class=\"headerlink\" title=\"01. On Function Declaration\"></a>01. On Function Declaration</h3><ul>\n<li>Input and output parameters with references should attach lifetimes after <code>&amp;</code> sign. ex <code>..(x: &amp;&#39;a str)</code> , <code>..(x: &amp;&#39;a mut str)</code></li>\n<li>After the function name, we should mention that the given lifetimes are generic types. ex <code>fn foo&lt;&#39;a&gt;(..)</code> , <code>fn foo&lt;&#39;a, &#39;b&gt;(..)</code></li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// no inputs, return a reference\nfn function&lt;&#39;a&gt;() -&gt; &amp;&#39;a str {}\n\n// single input\nfn function&lt;&#39;a&gt;(x: &amp;&#39;a str) {}\n\n// single input and output, both has same lifetime\n// output should live at least as long as input exists\nfn function&lt;&#39;a&gt;(x: &amp;&#39;a str) -&gt; &amp;&#39;a str {}\n\n// multiple inputs, only one input and the output share same lifetime\n// output should live at least as long as y exists\nfn function&lt;&#39;a&gt;(x: i32, y: &amp;&#39;a str) -&gt; &amp;&#39;a str {}\n\n// multiple inputs. both inputs and the output share same lifetime\n// output should live at least as long as x and y exist\nfn function&lt;&#39;a&gt;(x: &amp;&#39;a str, y: &amp;&#39;a str) -&gt; &amp;&#39;a str {}\n\n// multiple inputs. inputs can have diffent lifetimes üîé\n// output should live at least as long as x exists\nfn function&lt;&#39;a, &#39;b&gt;(x: &amp;&#39;a str, y: &amp;&#39;b str) -&gt; &amp;&#39;a str {}\n</code></pre>\n<h3 id=\"02-On-Struct-or-Enum-Declaration\"><a href=\"#02-On-Struct-or-Enum-Declaration\" class=\"headerlink\" title=\"02. On Struct or Enum Declaration\"></a>02. On Struct or Enum Declaration</h3><ul>\n<li>Elements with references should attach lifetimes after <code>&amp;</code> sign.</li>\n<li>After the name of the struct or enum, we should mention that the given lifetimes are generic types.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// single element\n// data of x should live at least as long as Struct exists\nstruct Struct&lt;&#39;a&gt; {\n    x: &amp;&#39;a str\n}\n\n// multiple elements\n// data of x and y should live at least as long as Struct exists\nstruct Struct&lt;&#39;a&gt; {\n    x: &amp;&#39;a str,\n    y: &amp;&#39;a str\n}\n\n\n// variant with single element\n// data of the variant should live at least as long as Enum exists\nenum Enum&lt;&#39;a&gt; {\n    Variant(&amp;&#39;a Type)\n}\n</code></pre>\n<h3 id=\"03-With-Impls-and-Traits\"><a href=\"#03-With-Impls-and-Traits\" class=\"headerlink\" title=\"03. With Impls and Traits\"></a>03. With Impls and Traits</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Struct&lt;&#39;a&gt; {\n    x: &amp;&#39;a str\n}\n    impl&lt;&#39;a&gt; Struct&lt;&#39;a&gt; {\n        fn function&lt;&#39;a&gt;(&amp;self) -&gt; &amp;&#39;a str {\n            self.x\n        }\n    }\n\n\nstruct Struct&lt;&#39;a&gt; {\n    x: &amp;&#39;a str,\n    y: &amp;&#39;a str\n}\n    impl&lt;&#39;a&gt; Struct&lt;&#39;a&gt; {\n        fn new(x: &amp;&#39;a str, y: &amp;&#39;a str) -&gt; Struct&lt;&#39;a&gt; { //no need to specify &lt;&#39;a&gt; after new; impl already has it\n          Struct {\n              x : x,\n              y : y\n          }\n        }\n    }\n\n\n// üîé\nimpl&lt;&#39;a&gt; Trait&lt;&#39;a&gt; for Type\nimpl&lt;&#39;a&gt; Trait for Type&lt;&#39;a&gt;\n</code></pre>\n<h3 id=\"04-With-Generic-Types\"><a href=\"#04-With-Generic-Types\" class=\"headerlink\" title=\"04. With Generic Types\"></a>04. With Generic Types</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// üîé\nfn function&lt;F&gt;(f: F) where for&lt;&#39;a&gt; F: FnOnce(&amp;&#39;a Type)\nstruct Struct&lt;F&gt; where for&lt;&#39;a&gt; F: FnOnce(&amp;&#39;a Type) { x: F }\nenum Enum&lt;F&gt; where for&lt;&#39;a&gt; F: FnOnce(&amp;&#39;a Type) { Variant(F) }\nimpl&lt;F&gt; Struct&lt;F&gt; where for&lt;&#39;a&gt; F: FnOnce(&amp;&#39;a Type) { fn x(&amp;self) -&gt; &amp;F { &amp;self.x } }\n</code></pre>\n<h2 id=\"Lifetime-Elision\"><a href=\"#Lifetime-Elision\" class=\"headerlink\" title=\"Lifetime Elision\"></a>Lifetime Elision</h2><p>As I mentioned earlier, in order to make <strong>common patterns</strong> more ergonomic, Rust allows lifetimes to be <strong>elided/omitted</strong>. This process is called <strong>Lifetime Elision</strong>.</p>\n<p>üí° For the moment Rust supports Lifetime Elisions only on <code>fn</code> definitions. But in the future it will support for <code>impl</code> headers as well.</p>\n<p>Lifetime annotations of <code>fn</code> definitions can be elided<br>if its <strong>parameter list</strong> has either,</p>\n<ul>\n<li><strong>only one input parameter passes by reference</strong>.</li>\n<li>a parameter with <strong>either</strong> <code>&amp;self</code> <strong>or</strong> <strong>&amp;mut self</strong> reference.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn triple(x: &amp;u64) -&gt; u64 { //only one input parameter passes by reference\n    x * 3\n}\n\n\nfn filter(x: u8, y: &amp;str) -&gt; &amp;str { // only one input parameter passes by reference\n    if x &gt; 5 { y } else { &quot;invalid inputs&quot; }\n}\n\n\nstruct Player&lt;&#39;a&gt; {\n    id: u8,\n    name: &amp;&#39;a str\n}\n    impl&lt;&#39;a&gt; Player&lt;&#39;a&gt; { //so far Lifetime Elisions are allowed only on fn definitions; but in the future they might support on impl headers as well.\n        fn new(id: u8, name: &amp;str) -&gt; Player { //only one input parameter passes by reference\n            Player {\n                id : id,\n                name : name\n            }\n        }\n\n        fn heading_text(&amp;self) -&gt; String { // a fn definition with &amp;self (or &amp;mut self) reference\n            format!(&quot;{}: {}&quot;, self.id, self.name)\n        }\n    }\n\nfn main() {\n    let player1 = Player::new(1, &quot;Serena Williams&quot;);\n    let player1_heading_text = player1.heading_text()\n    println!(&quot;{}&quot;, player1_heading_text);\n}\n</code></pre>\n<blockquote>\n<p>üí° In the Lifetime Elision process of fn definitions,</p>\n<ul>\n<li>Each parameter passes by reference is got a distinct lifetime annotation.<br>  ex. <code>..(x: &amp;str, y: &amp;str)</code> ‚Üí <code>..&lt;&#39;a, &#39;b&gt;(x: &amp;&#39;a str, y: &amp;&#39;b str)</code></li>\n<li>If the parameter list has only one parameter passes by reference, that lifetime is assigned to all elided lifetimes in the return values of that function.<br>  ex. <code>..(x: i32, y: &amp;str) -&gt; &amp;str</code> ‚Üí <code>..&lt;&#39;a&gt;(x: i32, y: &amp;&#39;a str) -&gt; &amp;&#39;a str</code></li>\n<li>Even it has multiple parameters pass by reference, if one of them has &amp;self or &amp;mut self, the lifetime of self is assigned to all elided output lifetimes.<br>  ex. <code>impl Impl{ fn function(&amp;self, x: &amp;str) -&gt; &amp;str {} }</code> ‚Üí<br>  <code>impl&lt;&#39;a&gt; Impl&lt;&#39;a&gt;{ fn function(&amp;&#39;a self, x: &amp;&#39;b str) -&gt; &amp;&#39;a str {} }</code></li>\n<li>For all other cases, we have to write lifetime annotations manually.</li>\n</ul>\n</blockquote>\n<h2 id=\"39-static-Annotations\"><a href=\"#39-static-Annotations\" class=\"headerlink\" title=\"&#39;static Annotations\"></a><code>&#39;static</code> Annotations</h2><p><code>&#39;static</code> lifetime annotation is a <strong>reserved</strong> lifetime annotation. These <strong>references are valid for the entire program</strong>. They are saved in the data segment of the binary and the data referred to will never go out of scope.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">static N: i32 = 5; //A constant with &#39;static lifetime\n\nlet a = &quot;Hello, world.&quot;; //a: &amp;&#39;static str\n\n\nfn index() -&gt; &amp;&#39;static str { //No need to mention &lt;&#39;static&gt; ; fn index Ã∂&lt;Ã∂&#39;Ã∂sÃ∂tÃ∂aÃ∂tÃ∂iÃ∂cÃ∂&gt;Ã∂ \n    &quot;Hello, world!&quot;\n}\n</code></pre>\n<h2 id=\"Few-more-examples-about-usage-of-Rust-lifetimes\"><a href=\"#Few-more-examples-about-usage-of-Rust-lifetimes\" class=\"headerlink\" title=\"Few more examples about usage of Rust lifetimes.\"></a>Few more examples about usage of Rust lifetimes.</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn greeting&lt;&#39;a&gt;() -&gt; &amp;&#39;a str {\n  &quot;Hi!&quot;\n}\n\n\nfn fullname&lt;&#39;a&gt;(fname: &amp;&#39;a str, lname: &amp;&#39;a str) -&gt; String {\n  format!(&quot;{} {}&quot;, fname, lname)\n}\n\n\nstruct Person&lt;&#39;a&gt; {\n    fname: &amp;&#39;a str,\n    lname: &amp;&#39;a str\n}\n  impl&lt;&#39;a&gt; Person&lt;&#39;a&gt; {\n      fn new(fname: &amp;&#39;a str, lname: &amp;&#39;a str) -&gt; Person&lt;&#39;a&gt; { //no need to specify &lt;&#39;a&gt; after new; impl already has it\n          Person {\n              fname : fname,\n              lname : lname\n          }\n      }\n\n      fn fullname(&amp;self) -&gt; String {\n          format!(&quot;{} {}&quot;, self.fname , self.lname)\n      }\n  }\n\nfn main() {\n    let player = Person::new(&quot;Serena&quot;, &quot;Williams&quot;);\n    let player_fullname = player.fullname();\n\n    println!(&quot;Player: {}&quot;, player_fullname);\n}\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<p>When we are dealing with references, we have to make sure that the referencing data stay alive until we are stop using the references.</p>\n<p>Think,</p>\n<ul>\n<li>We have a variable binding, ‚Äú<strong>a</strong>‚Äù.</li>\n<li>We are referencing the value of ‚Äúa‚Äù, from another variable binding ‚Äú<strong>x</strong>‚Äù.<br>We have to make sure that ‚Äúa‚Äù <strong>lives</strong> until we stop using ‚Äúx‚Äù</li>\n</ul>\n<blockquote>\n<p>üîé <strong>Memory management</strong> is a form of resource management applied to computer memory. Up until the mid-1990s, the majority of programming languages used <strong>Manual Memory Management</strong> which <strong>requires the programmer to give manual instructions</strong> to identify and deallocate unused objects/ garbage. Around 1959 John McCarthy invented <strong>Garbage collection</strong>(GC), a form of <strong>Automatic Memory Management</strong>(AMM). It determines what memory is no longer used and frees it automatically instead of relying on the programmer. However <strong>Objective-C and Swift</strong> provide similar functionality through <strong>Automatic Reference Counting</strong>(ARC).</p>\n</blockquote>\n<h2 id=\"What-is-Lifetimes\"><a href=\"#What-is-Lifetimes\" class=\"headerlink\" title=\"What is Lifetimes?\"></a>What is Lifetimes?</h2><p>In Rust,</p>\n<ul>\n<li>A resource can only have <strong>one owner</strong> at a time. When it goes <strong>out of the scope</strong>, Rust removes it from the Memory.</li>\n<li>When we want to reuse the same resource, we are <strong>referencing</strong> it/ <strong>borrowing</strong> its content.</li>\n<li>When dealing with <strong>references</strong>, we have to specify <strong>lifetime annotations</strong> to provide instructions for the <strong>compiler</strong> to set <strong>how long</strong> those referenced resources <strong>should be alive</strong>.</li>\n<li>‚≠ê Ô∏èBut because of lifetime annotations make <strong>code more verbose</strong>, in order to make <strong>common patterns</strong> more ergonomic, Rust allows lifetimes to be <strong>elided/omitted</strong> in <code>fn</code> definitions. In this case, the compiler assigns lifetime annotations <strong>implicitly</strong>.</li>\n</ul>\n<p>Lifetime annotations are <strong>checked at compile-time</strong>. Compiler checks when a data is used for the first and the last times. According to that, Rust manages memory in <strong>run time</strong>. This is the major reason of having <strong>slower compilation times</strong> in Rust.</p>\n<blockquote>\n<ul>\n<li>Unlike C and C++, <strong>usually</strong> Rust doesn‚Äôt explicitly drop values at all.</li>\n<li>Unlike GC, Rust doesn‚Äôt place deallocation calls where the data is no longer referenced.</li>\n<li>Rust places deallocation calls where the data is about to go out of the scope and then enforces that no references to that resource exist after that point.</li>\n</ul>\n</blockquote>\n<h2 id=\"Usage\"><a href=\"#Usage\" class=\"headerlink\" title=\"Usage\"></a>Usage</h2><p>Lifetimes are denoted with an apostrophe. By convention, a lowercase letter is used for naming. Usually <strong>starts with</strong> <code>&#39;a</code> and <strong>follows alphabetic order</strong> when we need to add <strong>multiple lifetime</strong> annotations.</p>\n<p>When using references,</p>\n<h3 id=\"01-On-Function-Declaration\"><a href=\"#01-On-Function-Declaration\" class=\"headerlink\" title=\"01. On Function Declaration\"></a>01. On Function Declaration</h3><ul>\n<li>Input and output parameters with references should attach lifetimes after <code>&amp;</code> sign. ex <code>..(x: &amp;&#39;a str)</code> , <code>..(x: &amp;&#39;a mut str)</code></li>\n<li>After the function name, we should mention that the given lifetimes are generic types. ex <code>fn foo&lt;&#39;a&gt;(..)</code> , <code>fn foo&lt;&#39;a, &#39;b&gt;(..)</code></li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// no inputs, return a reference\nfn function&lt;&#39;a&gt;() -&gt; &amp;&#39;a str {}\n\n// single input\nfn function&lt;&#39;a&gt;(x: &amp;&#39;a str) {}\n\n// single input and output, both has same lifetime\n// output should live at least as long as input exists\nfn function&lt;&#39;a&gt;(x: &amp;&#39;a str) -&gt; &amp;&#39;a str {}\n\n// multiple inputs, only one input and the output share same lifetime\n// output should live at least as long as y exists\nfn function&lt;&#39;a&gt;(x: i32, y: &amp;&#39;a str) -&gt; &amp;&#39;a str {}\n\n// multiple inputs. both inputs and the output share same lifetime\n// output should live at least as long as x and y exist\nfn function&lt;&#39;a&gt;(x: &amp;&#39;a str, y: &amp;&#39;a str) -&gt; &amp;&#39;a str {}\n\n// multiple inputs. inputs can have diffent lifetimes üîé\n// output should live at least as long as x exists\nfn function&lt;&#39;a, &#39;b&gt;(x: &amp;&#39;a str, y: &amp;&#39;b str) -&gt; &amp;&#39;a str {}\n</code></pre>\n<h3 id=\"02-On-Struct-or-Enum-Declaration\"><a href=\"#02-On-Struct-or-Enum-Declaration\" class=\"headerlink\" title=\"02. On Struct or Enum Declaration\"></a>02. On Struct or Enum Declaration</h3><ul>\n<li>Elements with references should attach lifetimes after <code>&amp;</code> sign.</li>\n<li>After the name of the struct or enum, we should mention that the given lifetimes are generic types.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// single element\n// data of x should live at least as long as Struct exists\nstruct Struct&lt;&#39;a&gt; {\n    x: &amp;&#39;a str\n}\n\n// multiple elements\n// data of x and y should live at least as long as Struct exists\nstruct Struct&lt;&#39;a&gt; {\n    x: &amp;&#39;a str,\n    y: &amp;&#39;a str\n}\n\n\n// variant with single element\n// data of the variant should live at least as long as Enum exists\nenum Enum&lt;&#39;a&gt; {\n    Variant(&amp;&#39;a Type)\n}\n</code></pre>\n<h3 id=\"03-With-Impls-and-Traits\"><a href=\"#03-With-Impls-and-Traits\" class=\"headerlink\" title=\"03. With Impls and Traits\"></a>03. With Impls and Traits</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Struct&lt;&#39;a&gt; {\n    x: &amp;&#39;a str\n}\n    impl&lt;&#39;a&gt; Struct&lt;&#39;a&gt; {\n        fn function&lt;&#39;a&gt;(&amp;self) -&gt; &amp;&#39;a str {\n            self.x\n        }\n    }\n\n\nstruct Struct&lt;&#39;a&gt; {\n    x: &amp;&#39;a str,\n    y: &amp;&#39;a str\n}\n    impl&lt;&#39;a&gt; Struct&lt;&#39;a&gt; {\n        fn new(x: &amp;&#39;a str, y: &amp;&#39;a str) -&gt; Struct&lt;&#39;a&gt; { //no need to specify &lt;&#39;a&gt; after new; impl already has it\n          Struct {\n              x : x,\n              y : y\n          }\n        }\n    }\n\n\n// üîé\nimpl&lt;&#39;a&gt; Trait&lt;&#39;a&gt; for Type\nimpl&lt;&#39;a&gt; Trait for Type&lt;&#39;a&gt;\n</code></pre>\n<h3 id=\"04-With-Generic-Types\"><a href=\"#04-With-Generic-Types\" class=\"headerlink\" title=\"04. With Generic Types\"></a>04. With Generic Types</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// üîé\nfn function&lt;F&gt;(f: F) where for&lt;&#39;a&gt; F: FnOnce(&amp;&#39;a Type)\nstruct Struct&lt;F&gt; where for&lt;&#39;a&gt; F: FnOnce(&amp;&#39;a Type) { x: F }\nenum Enum&lt;F&gt; where for&lt;&#39;a&gt; F: FnOnce(&amp;&#39;a Type) { Variant(F) }\nimpl&lt;F&gt; Struct&lt;F&gt; where for&lt;&#39;a&gt; F: FnOnce(&amp;&#39;a Type) { fn x(&amp;self) -&gt; &amp;F { &amp;self.x } }\n</code></pre>\n<h2 id=\"Lifetime-Elision\"><a href=\"#Lifetime-Elision\" class=\"headerlink\" title=\"Lifetime Elision\"></a>Lifetime Elision</h2><p>As I mentioned earlier, in order to make <strong>common patterns</strong> more ergonomic, Rust allows lifetimes to be <strong>elided/omitted</strong>. This process is called <strong>Lifetime Elision</strong>.</p>\n<p>üí° For the moment Rust supports Lifetime Elisions only on <code>fn</code> definitions. But in the future it will support for <code>impl</code> headers as well.</p>\n<p>Lifetime annotations of <code>fn</code> definitions can be elided<br>if its <strong>parameter list</strong> has either,</p>\n<ul>\n<li><strong>only one input parameter passes by reference</strong>.</li>\n<li>a parameter with <strong>either</strong> <code>&amp;self</code> <strong>or</strong> <strong>&amp;mut self</strong> reference.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn triple(x: &amp;u64) -&gt; u64 { //only one input parameter passes by reference\n    x * 3\n}\n\n\nfn filter(x: u8, y: &amp;str) -&gt; &amp;str { // only one input parameter passes by reference\n    if x &gt; 5 { y } else { &quot;invalid inputs&quot; }\n}\n\n\nstruct Player&lt;&#39;a&gt; {\n    id: u8,\n    name: &amp;&#39;a str\n}\n    impl&lt;&#39;a&gt; Player&lt;&#39;a&gt; { //so far Lifetime Elisions are allowed only on fn definitions; but in the future they might support on impl headers as well.\n        fn new(id: u8, name: &amp;str) -&gt; Player { //only one input parameter passes by reference\n            Player {\n                id : id,\n                name : name\n            }\n        }\n\n        fn heading_text(&amp;self) -&gt; String { // a fn definition with &amp;self (or &amp;mut self) reference\n            format!(&quot;{}: {}&quot;, self.id, self.name)\n        }\n    }\n\nfn main() {\n    let player1 = Player::new(1, &quot;Serena Williams&quot;);\n    let player1_heading_text = player1.heading_text()\n    println!(&quot;{}&quot;, player1_heading_text);\n}\n</code></pre>\n<blockquote>\n<p>üí° In the Lifetime Elision process of fn definitions,</p>\n<ul>\n<li>Each parameter passes by reference is got a distinct lifetime annotation.<br>  ex. <code>..(x: &amp;str, y: &amp;str)</code> ‚Üí <code>..&lt;&#39;a, &#39;b&gt;(x: &amp;&#39;a str, y: &amp;&#39;b str)</code></li>\n<li>If the parameter list has only one parameter passes by reference, that lifetime is assigned to all elided lifetimes in the return values of that function.<br>  ex. <code>..(x: i32, y: &amp;str) -&gt; &amp;str</code> ‚Üí <code>..&lt;&#39;a&gt;(x: i32, y: &amp;&#39;a str) -&gt; &amp;&#39;a str</code></li>\n<li>Even it has multiple parameters pass by reference, if one of them has &amp;self or &amp;mut self, the lifetime of self is assigned to all elided output lifetimes.<br>  ex. <code>impl Impl{ fn function(&amp;self, x: &amp;str) -&gt; &amp;str {} }</code> ‚Üí<br>  <code>impl&lt;&#39;a&gt; Impl&lt;&#39;a&gt;{ fn function(&amp;&#39;a self, x: &amp;&#39;b str) -&gt; &amp;&#39;a str {} }</code></li>\n<li>For all other cases, we have to write lifetime annotations manually.</li>\n</ul>\n</blockquote>\n<h2 id=\"39-static-Annotations\"><a href=\"#39-static-Annotations\" class=\"headerlink\" title=\"&#39;static Annotations\"></a><code>&#39;static</code> Annotations</h2><p><code>&#39;static</code> lifetime annotation is a <strong>reserved</strong> lifetime annotation. These <strong>references are valid for the entire program</strong>. They are saved in the data segment of the binary and the data referred to will never go out of scope.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">static N: i32 = 5; //A constant with &#39;static lifetime\n\nlet a = &quot;Hello, world.&quot;; //a: &amp;&#39;static str\n\n\nfn index() -&gt; &amp;&#39;static str { //No need to mention &lt;&#39;static&gt; ; fn index Ã∂&lt;Ã∂&#39;Ã∂sÃ∂tÃ∂aÃ∂tÃ∂iÃ∂cÃ∂&gt;Ã∂ \n    &quot;Hello, world!&quot;\n}\n</code></pre>\n<h2 id=\"Few-more-examples-about-usage-of-Rust-lifetimes\"><a href=\"#Few-more-examples-about-usage-of-Rust-lifetimes\" class=\"headerlink\" title=\"Few more examples about usage of Rust lifetimes.\"></a>Few more examples about usage of Rust lifetimes.</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn greeting&lt;&#39;a&gt;() -&gt; &amp;&#39;a str {\n  &quot;Hi!&quot;\n}\n\n\nfn fullname&lt;&#39;a&gt;(fname: &amp;&#39;a str, lname: &amp;&#39;a str) -&gt; String {\n  format!(&quot;{} {}&quot;, fname, lname)\n}\n\n\nstruct Person&lt;&#39;a&gt; {\n    fname: &amp;&#39;a str,\n    lname: &amp;&#39;a str\n}\n  impl&lt;&#39;a&gt; Person&lt;&#39;a&gt; {\n      fn new(fname: &amp;&#39;a str, lname: &amp;&#39;a str) -&gt; Person&lt;&#39;a&gt; { //no need to specify &lt;&#39;a&gt; after new; impl already has it\n          Person {\n              fname : fname,\n              lname : lname\n          }\n      }\n\n      fn fullname(&amp;self) -&gt; String {\n          format!(&quot;{} {}&quot;, self.fname , self.lname)\n      }\n  }\n\nfn main() {\n    let player = Person::new(&quot;Serena&quot;, &quot;Williams&quot;);\n    let player_fullname = player.fullname();\n\n    println!(&quot;Player: {}&quot;, player_fullname);\n}\n</code></pre>\n"},{"title":"Crate","_content":"\n> üí≠ Crates are bit similar to the packages in some other languages. Crates compile individually. If the crate has child file modules, those files will get merged with the crate file and compile as a single unit.\n\n> üí≠ A crate can produce an executable/ a binary or a library. `src/main.rs` is the crate root/ entry point for a binary crate and `src/lib.rs` is the entry point for a library crate.\n\n## 01. lib.rs on executable crate\n\nüí° When writing binary crates, we can move the main functionalities to `src/lib.rs` and use it as a library from `src/main.rs` . This pattern is quite common on executable crates.\n\n```rust\n// # Think we run\ncargo new greetings\ntouch greetings/src/lib.rs\n\n// # It generates,\n.\n‚îú‚îÄ‚îÄ Cargo.toml\n‚îî‚îÄ‚îÄ src\n   ‚îú‚îÄ‚îÄ lib.rs\n   ‚îî‚îÄ‚îÄ main.rs\n\n// # Think we modify following files\n\n// 01. greetings/src/lib.rs\npub fn hello() {\n    println!(\"Hello, world!\");\n}\n\n// 02. greetings/src/main.rs\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n```\n\n> üíØ As I mentioned earlier, in here we use simplest examples to reduce the complexity of learning materials. But this is how we need to write `greetings/src/lib.rs` to make the code more testable.\n\n```rust\n// greetings/src/lib.rs\npub fn hello() -> String {\n  //! This returns Hello, world! String\n  (\"Hello, world!\").to_string()\n}\n\n// 01. Tests for hello()\n#[test] // indicates that this is a test function\nfn test_hello() {\n  assert_eq!(hello(), \"Hello, world!\");\n}\n\n// 02. Tests for hello(), Idiomatic way\n#[cfg(test)] // only compiles when runing tests\nmod tests { // seperates tests from code\n  use super::hello; // import root hello function\n  \n    #[test]\n    fn test_hello() {\n        assert_eq!(hello(), \"Hello, world!\");\n    }\n}\n```\n\n> [üìñ](https://doc.rust-lang.org/book/first-edition/crates-and-modules.html) When importing a crate that has dashes in its name ‚Äúlike-this‚Äù, which is not a valid Rust identifier, it will be converted by changing the dashes to underscores, so you would write `extern crate like_this;`\n\n`lib.rs` can link with multiple files.\n\n```rust\n// # Think we run\ncargo new phrases\ntouch phrases/src/lib.rs\ntouch phrases/src/greetings.rs\n\n// # It generates,\n.\n‚îú‚îÄ‚îÄ Cargo.toml\n‚îî‚îÄ‚îÄ src\n   ‚îú‚îÄ‚îÄ greetings.rs\n   ‚îú‚îÄ‚îÄ lib.rs\n   ‚îî‚îÄ‚îÄ main.rs\n   \n// # Think we modify following files\n\n// 01. phrases/src/greetings.rs\npub fn hello() {\n    println!(\"Hello, world!\");\n}\n\n// 02. phrases/src/main.rs\nextern crate phrases;\n\nfn main() {\n    phrases::greetings::hello();\n}\n\n// 03. phrases/src/lib.rs\npub mod greetings; // ‚≠êÔ∏è import greetings module as a public module\n```\n\n\n## 02. Dependency crate on Cargo.toml\n\nWhen the code in the `lib.rs` file is getting larger, we can move those into a separate library crate and use it as a dependency of the main crate. As we mentioned earlier, a dependency can be specified from a folder path, git repository or by crates.io.\n\n### a. Using folder path\n\nLet‚Äôs see how to create a nested crate and use it as a dependency using folder path,\n\n```rust\n// # Think we run\ncargo new phrases\ncargo new phrases/greetings --lib\n\n// # It generates,\n.\n‚îú‚îÄ‚îÄ Cargo.toml\n‚îú‚îÄ‚îÄ greetings\n‚îÇ  ‚îú‚îÄ‚îÄ Cargo.toml\n‚îÇ  ‚îî‚îÄ‚îÄ src\n‚îÇ     ‚îî‚îÄ‚îÄ lib.rs\n‚îî‚îÄ‚îÄ src\n   ‚îî‚îÄ‚îÄ main.rs\n\n// # Think we modify following files\n\n// 01. phrases/Cargo.toml\n[package]\nname = \"phrases\"\nversion = \"0.1.0\"\nauthors = [\"Dumindu Madunuwan\"]\n\n[dependencies]\ngreetings = { path = \"greetings\" }\n\n// 02. phrases/greetings/src/lib.rs\npub fn hello() {\n    println!(\"Hello, world!\");\n}\n\n// 03. phrases/src/main.rs\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n```\n\n\n### b. Using git repository\n\nIf you want to use a library crate on multiple projects, one way is moving crate code to a git repository and use it as a dependency when needed.\n\n```rust\n// -- Cargo.toml --\n[dependencies]\n\n// 01. Get the latest commit on the master branch\nrocket = { git = \"https://github.com/SergioBenitez/Rocket\" }\n\n// 02. Get the latest commit of a specific branch\nrocket = { git = \"https://github.com/SergioBenitez/Rocket\", branch = \"v0.3\" }\n\n// 03. Get a specific tag\nrocket = { git = \"https://github.com/SergioBenitez/Rocket\", tag = \"v0.3.2\" }\n\n// 04. Get a specific revision (on master or any branch, according to rev)\nrocket = { git = \"https://github.com/SergioBenitez/Rocket\", rev = \"8183f636305cef4adaa9525506c33cbea72d1745\" }\n```\n\n\n### c. Using crates.io\n\nThe other way is uploading it to [crates.io](http://crates.io/) and use it as a dependency when needed.\n\nüöß First, let‚Äôs `create` a simple ‚ÄúHello world‚Äù crate `and upload` it to [crates.io](http://crates.io/).\n\n```rust\n// # Think we run\ncargo new test_crate_hello_world --lib\n\n// # It generates,\n.\n‚îú‚îÄ‚îÄ Cargo.toml\n‚îî‚îÄ‚îÄ src\n   ‚îî‚îÄ‚îÄ lib.rs\n   \n// # Think we modify following files\n\n// 01. test_crate_hello_world/Cargo.toml\n[package]\nname = \"test_crate_hello_world\"\nversion = \"0.1.0\"\nauthors = [\"Dumindu Madunuwan\"]\n\ndescription = \"A Simple Hello World Crate\"\nrepository = \"https://github.com/dumindu/test_crate_hello_world\"\nkeywords = [\"hello\", \"world\"]\nlicense = \"Apache-2.0\"\n\n[dependencies]\n\n// 02. test_crate_hello_world/src/lib.rs\n//! A Simple Hello World Crate\n\n/// This function returns the greeting; Hello, world!\npub fn hello() -> String {\n    (\"Hello, world!\").to_string()\n}\n\n#[cfg(test)]\nmod tests {\n\n    use super::hello;\n    \n    #[test]\n    fn test_hello() {\n        assert_eq!(hello(), \"Hello, world!\");\n    }\n}\n```\n\n> üí≠ **//! doc comments** are used to write crate and module-level documentation. On other places we have to use /// outside of the block. And when uploading a crate to [crates.io](http://crates.io/), cargo generates the documentation from these doc comments and host it on [docs.rs](https://docs.rs/).\n\nüí° We have to add the **description** and **license** fields to Cargo.toml, otherwise we will get `error: api errors: missing or empty metadata fields: description, license. Please see http://doc.crates.io/manifest.html`\n\nTo upload this to crates.io,\n1. We have to create an account on crates.io to acquire an API token\n2. Then run `cargo login <token>` with that API token and cargo publish\n\n[üìñ](http://doc.crates.io/crates-io.html) This is [how it describes on Cargo Docs](http://doc.crates.io/crates-io.html) with more details.\n\n> - You‚Äôll need an account on crates.io to acquire an API token. To do so, [visit the home page](https://crates.io/) and log in via a GitHub account (required for now). After this, visit your [Account Settings](https://crates.io/me) page and run the `cargo login` command specified. \n  Ex. `cargo login abcdefghijklmnopqrstuvwxyz012345`\n- The next step is to package up your crate into a format that can be uploaded to crates.io. For this we‚Äôll use the `cargo package` sub-command.\n- Now, it can be uploaded to crates.io with the `cargo publish` command.\n- If you‚Äôd like to skip the `cargo package` step, the `cargo publish` sub-command will automatically package up the local crate if a copy isn‚Äôt found already.\n\nThe name of our crate is `test_crate_hello_world`. So it can be found on,\nüì¶ [https://**crates.io/crates**/test_crate_hello_world](https://crates.io/crates/test_crate_hello_world)\nüìë [https://**docs.rs**/test_crate_hello_world](https://docs.rs/test_crate_hello_world)\n\n> üíØ crates.io supports readme files as well. To enable it, we have to add the readme field to Cargo.toml. Ex: `readme=\"README.md\"`\n\nüèóÔ∏è Okay then, Let‚Äôs see how we can **use this from an another crate**.\n\n```rust\n// # Think we run\ncargo new greetings\n\n// # It generates,\n.\n‚îú‚îÄ‚îÄ Cargo.toml\n‚îî‚îÄ‚îÄ src\n   ‚îî‚îÄ‚îÄ main.rs\n\n// # Think we modify following files\n\n// 01. greetings/Cargo.toml\n[package]\nname = \"greetings\"\nversion = \"0.1.0\"\nauthors = [\"Dumindu Madunuwan\"]\n\n[dependencies]\ntest_crate_hello_world = \"0.1.0\"\n\n// 02. greetings/src/main.rs\nextern crate test_crate_hello_world;\n\nfn main() {\n    println!(\"{}\", test_crate_hello_world::hello());\n}\n```\n\nBy default, Cargo looks dependencies on crates.io . So we have to add only the crate name and a version string to **Cargo.toml** and then run `cargo build` to fetch the dependencies and compile them.","source":"docs/zh-cn/d4.crates.md","raw":"title: Crate\n---\n\n> üí≠ Crates are bit similar to the packages in some other languages. Crates compile individually. If the crate has child file modules, those files will get merged with the crate file and compile as a single unit.\n\n> üí≠ A crate can produce an executable/ a binary or a library. `src/main.rs` is the crate root/ entry point for a binary crate and `src/lib.rs` is the entry point for a library crate.\n\n## 01. lib.rs on executable crate\n\nüí° When writing binary crates, we can move the main functionalities to `src/lib.rs` and use it as a library from `src/main.rs` . This pattern is quite common on executable crates.\n\n```rust\n// # Think we run\ncargo new greetings\ntouch greetings/src/lib.rs\n\n// # It generates,\n.\n‚îú‚îÄ‚îÄ Cargo.toml\n‚îî‚îÄ‚îÄ src\n   ‚îú‚îÄ‚îÄ lib.rs\n   ‚îî‚îÄ‚îÄ main.rs\n\n// # Think we modify following files\n\n// 01. greetings/src/lib.rs\npub fn hello() {\n    println!(\"Hello, world!\");\n}\n\n// 02. greetings/src/main.rs\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n```\n\n> üíØ As I mentioned earlier, in here we use simplest examples to reduce the complexity of learning materials. But this is how we need to write `greetings/src/lib.rs` to make the code more testable.\n\n```rust\n// greetings/src/lib.rs\npub fn hello() -> String {\n  //! This returns Hello, world! String\n  (\"Hello, world!\").to_string()\n}\n\n// 01. Tests for hello()\n#[test] // indicates that this is a test function\nfn test_hello() {\n  assert_eq!(hello(), \"Hello, world!\");\n}\n\n// 02. Tests for hello(), Idiomatic way\n#[cfg(test)] // only compiles when runing tests\nmod tests { // seperates tests from code\n  use super::hello; // import root hello function\n  \n    #[test]\n    fn test_hello() {\n        assert_eq!(hello(), \"Hello, world!\");\n    }\n}\n```\n\n> [üìñ](https://doc.rust-lang.org/book/first-edition/crates-and-modules.html) When importing a crate that has dashes in its name ‚Äúlike-this‚Äù, which is not a valid Rust identifier, it will be converted by changing the dashes to underscores, so you would write `extern crate like_this;`\n\n`lib.rs` can link with multiple files.\n\n```rust\n// # Think we run\ncargo new phrases\ntouch phrases/src/lib.rs\ntouch phrases/src/greetings.rs\n\n// # It generates,\n.\n‚îú‚îÄ‚îÄ Cargo.toml\n‚îî‚îÄ‚îÄ src\n   ‚îú‚îÄ‚îÄ greetings.rs\n   ‚îú‚îÄ‚îÄ lib.rs\n   ‚îî‚îÄ‚îÄ main.rs\n   \n// # Think we modify following files\n\n// 01. phrases/src/greetings.rs\npub fn hello() {\n    println!(\"Hello, world!\");\n}\n\n// 02. phrases/src/main.rs\nextern crate phrases;\n\nfn main() {\n    phrases::greetings::hello();\n}\n\n// 03. phrases/src/lib.rs\npub mod greetings; // ‚≠êÔ∏è import greetings module as a public module\n```\n\n\n## 02. Dependency crate on Cargo.toml\n\nWhen the code in the `lib.rs` file is getting larger, we can move those into a separate library crate and use it as a dependency of the main crate. As we mentioned earlier, a dependency can be specified from a folder path, git repository or by crates.io.\n\n### a. Using folder path\n\nLet‚Äôs see how to create a nested crate and use it as a dependency using folder path,\n\n```rust\n// # Think we run\ncargo new phrases\ncargo new phrases/greetings --lib\n\n// # It generates,\n.\n‚îú‚îÄ‚îÄ Cargo.toml\n‚îú‚îÄ‚îÄ greetings\n‚îÇ  ‚îú‚îÄ‚îÄ Cargo.toml\n‚îÇ  ‚îî‚îÄ‚îÄ src\n‚îÇ     ‚îî‚îÄ‚îÄ lib.rs\n‚îî‚îÄ‚îÄ src\n   ‚îî‚îÄ‚îÄ main.rs\n\n// # Think we modify following files\n\n// 01. phrases/Cargo.toml\n[package]\nname = \"phrases\"\nversion = \"0.1.0\"\nauthors = [\"Dumindu Madunuwan\"]\n\n[dependencies]\ngreetings = { path = \"greetings\" }\n\n// 02. phrases/greetings/src/lib.rs\npub fn hello() {\n    println!(\"Hello, world!\");\n}\n\n// 03. phrases/src/main.rs\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n```\n\n\n### b. Using git repository\n\nIf you want to use a library crate on multiple projects, one way is moving crate code to a git repository and use it as a dependency when needed.\n\n```rust\n// -- Cargo.toml --\n[dependencies]\n\n// 01. Get the latest commit on the master branch\nrocket = { git = \"https://github.com/SergioBenitez/Rocket\" }\n\n// 02. Get the latest commit of a specific branch\nrocket = { git = \"https://github.com/SergioBenitez/Rocket\", branch = \"v0.3\" }\n\n// 03. Get a specific tag\nrocket = { git = \"https://github.com/SergioBenitez/Rocket\", tag = \"v0.3.2\" }\n\n// 04. Get a specific revision (on master or any branch, according to rev)\nrocket = { git = \"https://github.com/SergioBenitez/Rocket\", rev = \"8183f636305cef4adaa9525506c33cbea72d1745\" }\n```\n\n\n### c. Using crates.io\n\nThe other way is uploading it to [crates.io](http://crates.io/) and use it as a dependency when needed.\n\nüöß First, let‚Äôs `create` a simple ‚ÄúHello world‚Äù crate `and upload` it to [crates.io](http://crates.io/).\n\n```rust\n// # Think we run\ncargo new test_crate_hello_world --lib\n\n// # It generates,\n.\n‚îú‚îÄ‚îÄ Cargo.toml\n‚îî‚îÄ‚îÄ src\n   ‚îî‚îÄ‚îÄ lib.rs\n   \n// # Think we modify following files\n\n// 01. test_crate_hello_world/Cargo.toml\n[package]\nname = \"test_crate_hello_world\"\nversion = \"0.1.0\"\nauthors = [\"Dumindu Madunuwan\"]\n\ndescription = \"A Simple Hello World Crate\"\nrepository = \"https://github.com/dumindu/test_crate_hello_world\"\nkeywords = [\"hello\", \"world\"]\nlicense = \"Apache-2.0\"\n\n[dependencies]\n\n// 02. test_crate_hello_world/src/lib.rs\n//! A Simple Hello World Crate\n\n/// This function returns the greeting; Hello, world!\npub fn hello() -> String {\n    (\"Hello, world!\").to_string()\n}\n\n#[cfg(test)]\nmod tests {\n\n    use super::hello;\n    \n    #[test]\n    fn test_hello() {\n        assert_eq!(hello(), \"Hello, world!\");\n    }\n}\n```\n\n> üí≠ **//! doc comments** are used to write crate and module-level documentation. On other places we have to use /// outside of the block. And when uploading a crate to [crates.io](http://crates.io/), cargo generates the documentation from these doc comments and host it on [docs.rs](https://docs.rs/).\n\nüí° We have to add the **description** and **license** fields to Cargo.toml, otherwise we will get `error: api errors: missing or empty metadata fields: description, license. Please see http://doc.crates.io/manifest.html`\n\nTo upload this to crates.io,\n1. We have to create an account on crates.io to acquire an API token\n2. Then run `cargo login <token>` with that API token and cargo publish\n\n[üìñ](http://doc.crates.io/crates-io.html) This is [how it describes on Cargo Docs](http://doc.crates.io/crates-io.html) with more details.\n\n> - You‚Äôll need an account on crates.io to acquire an API token. To do so, [visit the home page](https://crates.io/) and log in via a GitHub account (required for now). After this, visit your [Account Settings](https://crates.io/me) page and run the `cargo login` command specified. \n  Ex. `cargo login abcdefghijklmnopqrstuvwxyz012345`\n- The next step is to package up your crate into a format that can be uploaded to crates.io. For this we‚Äôll use the `cargo package` sub-command.\n- Now, it can be uploaded to crates.io with the `cargo publish` command.\n- If you‚Äôd like to skip the `cargo package` step, the `cargo publish` sub-command will automatically package up the local crate if a copy isn‚Äôt found already.\n\nThe name of our crate is `test_crate_hello_world`. So it can be found on,\nüì¶ [https://**crates.io/crates**/test_crate_hello_world](https://crates.io/crates/test_crate_hello_world)\nüìë [https://**docs.rs**/test_crate_hello_world](https://docs.rs/test_crate_hello_world)\n\n> üíØ crates.io supports readme files as well. To enable it, we have to add the readme field to Cargo.toml. Ex: `readme=\"README.md\"`\n\nüèóÔ∏è Okay then, Let‚Äôs see how we can **use this from an another crate**.\n\n```rust\n// # Think we run\ncargo new greetings\n\n// # It generates,\n.\n‚îú‚îÄ‚îÄ Cargo.toml\n‚îî‚îÄ‚îÄ src\n   ‚îî‚îÄ‚îÄ main.rs\n\n// # Think we modify following files\n\n// 01. greetings/Cargo.toml\n[package]\nname = \"greetings\"\nversion = \"0.1.0\"\nauthors = [\"Dumindu Madunuwan\"]\n\n[dependencies]\ntest_crate_hello_world = \"0.1.0\"\n\n// 02. greetings/src/main.rs\nextern crate test_crate_hello_world;\n\nfn main() {\n    println!(\"{}\", test_crate_hello_world::hello());\n}\n```\n\nBy default, Cargo looks dependencies on crates.io . So we have to add only the crate name and a version string to **Cargo.toml** and then run `cargo build` to fetch the dependencies and compile them.","date":"2019-03-19T14:50:31.986Z","updated":"2019-03-19T14:50:31.986Z","path":"docs/zh-cn/d4.crates.html","comments":1,"layout":"page","_id":"cjtfwbj1g001odwgpi89ldrhn","content":"<blockquote>\n<p>üí≠ Crates are bit similar to the packages in some other languages. Crates compile individually. If the crate has child file modules, those files will get merged with the crate file and compile as a single unit.</p>\n</blockquote>\n<blockquote>\n<p>üí≠ A crate can produce an executable/ a binary or a library. <code>src/main.rs</code> is the crate root/ entry point for a binary crate and <code>src/lib.rs</code> is the entry point for a library crate.</p>\n</blockquote>\n<h2 id=\"01-lib-rs-on-executable-crate\"><a href=\"#01-lib-rs-on-executable-crate\" class=\"headerlink\" title=\"01. lib.rs on executable crate\"></a>01. lib.rs on executable crate</h2><p>üí° When writing binary crates, we can move the main functionalities to <code>src/lib.rs</code> and use it as a library from <code>src/main.rs</code> . This pattern is quite common on executable crates.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// # Think we run\ncargo new greetings\ntouch greetings/src/lib.rs\n\n// # It generates,\n.\n‚îú‚îÄ‚îÄ Cargo.toml\n‚îî‚îÄ‚îÄ src\n   ‚îú‚îÄ‚îÄ lib.rs\n   ‚îî‚îÄ‚îÄ main.rs\n\n// # Think we modify following files\n\n// 01. greetings/src/lib.rs\npub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n}\n\n// 02. greetings/src/main.rs\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n</code></pre>\n<blockquote>\n<p>üíØ As I mentioned earlier, in here we use simplest examples to reduce the complexity of learning materials. But this is how we need to write <code>greetings/src/lib.rs</code> to make the code more testable.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// greetings/src/lib.rs\npub fn hello() -&gt; String {\n  //! This returns Hello, world! String\n  (&quot;Hello, world!&quot;).to_string()\n}\n\n// 01. Tests for hello()\n#[test] // indicates that this is a test function\nfn test_hello() {\n  assert_eq!(hello(), &quot;Hello, world!&quot;);\n}\n\n// 02. Tests for hello(), Idiomatic way\n#[cfg(test)] // only compiles when runing tests\nmod tests { // seperates tests from code\n  use super::hello; // import root hello function\n\n    #[test]\n    fn test_hello() {\n        assert_eq!(hello(), &quot;Hello, world!&quot;);\n    }\n}\n</code></pre>\n<blockquote>\n<p><a href=\"https://doc.rust-lang.org/book/first-edition/crates-and-modules.html\" target=\"_blank\" rel=\"noopener\">üìñ</a> When importing a crate that has dashes in its name ‚Äúlike-this‚Äù, which is not a valid Rust identifier, it will be converted by changing the dashes to underscores, so you would write <code>extern crate like_this;</code></p>\n</blockquote>\n<p><code>lib.rs</code> can link with multiple files.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// # Think we run\ncargo new phrases\ntouch phrases/src/lib.rs\ntouch phrases/src/greetings.rs\n\n// # It generates,\n.\n‚îú‚îÄ‚îÄ Cargo.toml\n‚îî‚îÄ‚îÄ src\n   ‚îú‚îÄ‚îÄ greetings.rs\n   ‚îú‚îÄ‚îÄ lib.rs\n   ‚îî‚îÄ‚îÄ main.rs\n\n// # Think we modify following files\n\n// 01. phrases/src/greetings.rs\npub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n}\n\n// 02. phrases/src/main.rs\nextern crate phrases;\n\nfn main() {\n    phrases::greetings::hello();\n}\n\n// 03. phrases/src/lib.rs\npub mod greetings; // ‚≠êÔ∏è import greetings module as a public module\n</code></pre>\n<h2 id=\"02-Dependency-crate-on-Cargo-toml\"><a href=\"#02-Dependency-crate-on-Cargo-toml\" class=\"headerlink\" title=\"02. Dependency crate on Cargo.toml\"></a>02. Dependency crate on Cargo.toml</h2><p>When the code in the <code>lib.rs</code> file is getting larger, we can move those into a separate library crate and use it as a dependency of the main crate. As we mentioned earlier, a dependency can be specified from a folder path, git repository or by crates.io.</p>\n<h3 id=\"a-Using-folder-path\"><a href=\"#a-Using-folder-path\" class=\"headerlink\" title=\"a. Using folder path\"></a>a. Using folder path</h3><p>Let‚Äôs see how to create a nested crate and use it as a dependency using folder path,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// # Think we run\ncargo new phrases\ncargo new phrases/greetings --lib\n\n// # It generates,\n.\n‚îú‚îÄ‚îÄ Cargo.toml\n‚îú‚îÄ‚îÄ greetings\n‚îÇ  ‚îú‚îÄ‚îÄ Cargo.toml\n‚îÇ  ‚îî‚îÄ‚îÄ src\n‚îÇ     ‚îî‚îÄ‚îÄ lib.rs\n‚îî‚îÄ‚îÄ src\n   ‚îî‚îÄ‚îÄ main.rs\n\n// # Think we modify following files\n\n// 01. phrases/Cargo.toml\n[package]\nname = &quot;phrases&quot;\nversion = &quot;0.1.0&quot;\nauthors = [&quot;Dumindu Madunuwan&quot;]\n\n[dependencies]\ngreetings = { path = &quot;greetings&quot; }\n\n// 02. phrases/greetings/src/lib.rs\npub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n}\n\n// 03. phrases/src/main.rs\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n</code></pre>\n<h3 id=\"b-Using-git-repository\"><a href=\"#b-Using-git-repository\" class=\"headerlink\" title=\"b. Using git repository\"></a>b. Using git repository</h3><p>If you want to use a library crate on multiple projects, one way is moving crate code to a git repository and use it as a dependency when needed.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// -- Cargo.toml --\n[dependencies]\n\n// 01. Get the latest commit on the master branch\nrocket = { git = &quot;https://github.com/SergioBenitez/Rocket&quot; }\n\n// 02. Get the latest commit of a specific branch\nrocket = { git = &quot;https://github.com/SergioBenitez/Rocket&quot;, branch = &quot;v0.3&quot; }\n\n// 03. Get a specific tag\nrocket = { git = &quot;https://github.com/SergioBenitez/Rocket&quot;, tag = &quot;v0.3.2&quot; }\n\n// 04. Get a specific revision (on master or any branch, according to rev)\nrocket = { git = &quot;https://github.com/SergioBenitez/Rocket&quot;, rev = &quot;8183f636305cef4adaa9525506c33cbea72d1745&quot; }\n</code></pre>\n<h3 id=\"c-Using-crates-io\"><a href=\"#c-Using-crates-io\" class=\"headerlink\" title=\"c. Using crates.io\"></a>c. Using crates.io</h3><p>The other way is uploading it to <a href=\"http://crates.io/\" target=\"_blank\" rel=\"noopener\">crates.io</a> and use it as a dependency when needed.</p>\n<p>üöß First, let‚Äôs <code>create</code> a simple ‚ÄúHello world‚Äù crate <code>and upload</code> it to <a href=\"http://crates.io/\" target=\"_blank\" rel=\"noopener\">crates.io</a>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// # Think we run\ncargo new test_crate_hello_world --lib\n\n// # It generates,\n.\n‚îú‚îÄ‚îÄ Cargo.toml\n‚îî‚îÄ‚îÄ src\n   ‚îî‚îÄ‚îÄ lib.rs\n\n// # Think we modify following files\n\n// 01. test_crate_hello_world/Cargo.toml\n[package]\nname = &quot;test_crate_hello_world&quot;\nversion = &quot;0.1.0&quot;\nauthors = [&quot;Dumindu Madunuwan&quot;]\n\ndescription = &quot;A Simple Hello World Crate&quot;\nrepository = &quot;https://github.com/dumindu/test_crate_hello_world&quot;\nkeywords = [&quot;hello&quot;, &quot;world&quot;]\nlicense = &quot;Apache-2.0&quot;\n\n[dependencies]\n\n// 02. test_crate_hello_world/src/lib.rs\n//! A Simple Hello World Crate\n\n/// This function returns the greeting; Hello, world!\npub fn hello() -&gt; String {\n    (&quot;Hello, world!&quot;).to_string()\n}\n\n#[cfg(test)]\nmod tests {\n\n    use super::hello;\n\n    #[test]\n    fn test_hello() {\n        assert_eq!(hello(), &quot;Hello, world!&quot;);\n    }\n}\n</code></pre>\n<blockquote>\n<p>üí≠ <strong>//! doc comments</strong> are used to write crate and module-level documentation. On other places we have to use /// outside of the block. And when uploading a crate to <a href=\"http://crates.io/\" target=\"_blank\" rel=\"noopener\">crates.io</a>, cargo generates the documentation from these doc comments and host it on <a href=\"https://docs.rs/\" target=\"_blank\" rel=\"noopener\">docs.rs</a>.</p>\n</blockquote>\n<p>üí° We have to add the <strong>description</strong> and <strong>license</strong> fields to Cargo.toml, otherwise we will get <code>error: api errors: missing or empty metadata fields: description, license. Please see http://doc.crates.io/manifest.html</code></p>\n<p>To upload this to crates.io,</p>\n<ol>\n<li>We have to create an account on crates.io to acquire an API token</li>\n<li>Then run <code>cargo login &lt;token&gt;</code> with that API token and cargo publish</li>\n</ol>\n<p><a href=\"http://doc.crates.io/crates-io.html\" target=\"_blank\" rel=\"noopener\">üìñ</a> This is <a href=\"http://doc.crates.io/crates-io.html\" target=\"_blank\" rel=\"noopener\">how it describes on Cargo Docs</a> with more details.</p>\n<blockquote>\n<ul>\n<li>You‚Äôll need an account on crates.io to acquire an API token. To do so, <a href=\"https://crates.io/\" target=\"_blank\" rel=\"noopener\">visit the home page</a> and log in via a GitHub account (required for now). After this, visit your <a href=\"https://crates.io/me\" target=\"_blank\" rel=\"noopener\">Account Settings</a> page and run the <code>cargo login</code> command specified.<br>Ex. <code>cargo login abcdefghijklmnopqrstuvwxyz012345</code></li>\n<li>The next step is to package up your crate into a format that can be uploaded to crates.io. For this we‚Äôll use the <code>cargo package</code> sub-command.</li>\n<li>Now, it can be uploaded to crates.io with the <code>cargo publish</code> command.</li>\n<li>If you‚Äôd like to skip the <code>cargo package</code> step, the <code>cargo publish</code> sub-command will automatically package up the local crate if a copy isn‚Äôt found already.</li>\n</ul>\n</blockquote>\n<p>The name of our crate is <code>test_crate_hello_world</code>. So it can be found on,<br>üì¶ <a href=\"https://crates.io/crates/test_crate_hello_world\" target=\"_blank\" rel=\"noopener\">https://<strong>crates.io/crates</strong>/test_crate_hello_world</a><br>üìë <a href=\"https://docs.rs/test_crate_hello_world\" target=\"_blank\" rel=\"noopener\">https://<strong>docs.rs</strong>/test_crate_hello_world</a></p>\n<blockquote>\n<p>üíØ crates.io supports readme files as well. To enable it, we have to add the readme field to Cargo.toml. Ex: <code>readme=&quot;README.md&quot;</code></p>\n</blockquote>\n<p>üèóÔ∏è Okay then, Let‚Äôs see how we can <strong>use this from an another crate</strong>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// # Think we run\ncargo new greetings\n\n// # It generates,\n.\n‚îú‚îÄ‚îÄ Cargo.toml\n‚îî‚îÄ‚îÄ src\n   ‚îî‚îÄ‚îÄ main.rs\n\n// # Think we modify following files\n\n// 01. greetings/Cargo.toml\n[package]\nname = &quot;greetings&quot;\nversion = &quot;0.1.0&quot;\nauthors = [&quot;Dumindu Madunuwan&quot;]\n\n[dependencies]\ntest_crate_hello_world = &quot;0.1.0&quot;\n\n// 02. greetings/src/main.rs\nextern crate test_crate_hello_world;\n\nfn main() {\n    println!(&quot;{}&quot;, test_crate_hello_world::hello());\n}\n</code></pre>\n<p>By default, Cargo looks dependencies on crates.io . So we have to add only the crate name and a version string to <strong>Cargo.toml</strong> and then run <code>cargo build</code> to fetch the dependencies and compile them.</p>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<blockquote>\n<p>üí≠ Crates are bit similar to the packages in some other languages. Crates compile individually. If the crate has child file modules, those files will get merged with the crate file and compile as a single unit.</p>\n</blockquote>\n<blockquote>\n<p>üí≠ A crate can produce an executable/ a binary or a library. <code>src/main.rs</code> is the crate root/ entry point for a binary crate and <code>src/lib.rs</code> is the entry point for a library crate.</p>\n</blockquote>\n<h2 id=\"01-lib-rs-on-executable-crate\"><a href=\"#01-lib-rs-on-executable-crate\" class=\"headerlink\" title=\"01. lib.rs on executable crate\"></a>01. lib.rs on executable crate</h2><p>üí° When writing binary crates, we can move the main functionalities to <code>src/lib.rs</code> and use it as a library from <code>src/main.rs</code> . This pattern is quite common on executable crates.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// # Think we run\ncargo new greetings\ntouch greetings/src/lib.rs\n\n// # It generates,\n.\n‚îú‚îÄ‚îÄ Cargo.toml\n‚îî‚îÄ‚îÄ src\n   ‚îú‚îÄ‚îÄ lib.rs\n   ‚îî‚îÄ‚îÄ main.rs\n\n// # Think we modify following files\n\n// 01. greetings/src/lib.rs\npub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n}\n\n// 02. greetings/src/main.rs\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n</code></pre>\n<blockquote>\n<p>üíØ As I mentioned earlier, in here we use simplest examples to reduce the complexity of learning materials. But this is how we need to write <code>greetings/src/lib.rs</code> to make the code more testable.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// greetings/src/lib.rs\npub fn hello() -&gt; String {\n  //! This returns Hello, world! String\n  (&quot;Hello, world!&quot;).to_string()\n}\n\n// 01. Tests for hello()\n#[test] // indicates that this is a test function\nfn test_hello() {\n  assert_eq!(hello(), &quot;Hello, world!&quot;);\n}\n\n// 02. Tests for hello(), Idiomatic way\n#[cfg(test)] // only compiles when runing tests\nmod tests { // seperates tests from code\n  use super::hello; // import root hello function\n\n    #[test]\n    fn test_hello() {\n        assert_eq!(hello(), &quot;Hello, world!&quot;);\n    }\n}\n</code></pre>\n<blockquote>\n<p><a href=\"https://doc.rust-lang.org/book/first-edition/crates-and-modules.html\" target=\"_blank\" rel=\"noopener\">üìñ</a> When importing a crate that has dashes in its name ‚Äúlike-this‚Äù, which is not a valid Rust identifier, it will be converted by changing the dashes to underscores, so you would write <code>extern crate like_this;</code></p>\n</blockquote>\n<p><code>lib.rs</code> can link with multiple files.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// # Think we run\ncargo new phrases\ntouch phrases/src/lib.rs\ntouch phrases/src/greetings.rs\n\n// # It generates,\n.\n‚îú‚îÄ‚îÄ Cargo.toml\n‚îî‚îÄ‚îÄ src\n   ‚îú‚îÄ‚îÄ greetings.rs\n   ‚îú‚îÄ‚îÄ lib.rs\n   ‚îî‚îÄ‚îÄ main.rs\n\n// # Think we modify following files\n\n// 01. phrases/src/greetings.rs\npub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n}\n\n// 02. phrases/src/main.rs\nextern crate phrases;\n\nfn main() {\n    phrases::greetings::hello();\n}\n\n// 03. phrases/src/lib.rs\npub mod greetings; // ‚≠êÔ∏è import greetings module as a public module\n</code></pre>\n<h2 id=\"02-Dependency-crate-on-Cargo-toml\"><a href=\"#02-Dependency-crate-on-Cargo-toml\" class=\"headerlink\" title=\"02. Dependency crate on Cargo.toml\"></a>02. Dependency crate on Cargo.toml</h2><p>When the code in the <code>lib.rs</code> file is getting larger, we can move those into a separate library crate and use it as a dependency of the main crate. As we mentioned earlier, a dependency can be specified from a folder path, git repository or by crates.io.</p>\n<h3 id=\"a-Using-folder-path\"><a href=\"#a-Using-folder-path\" class=\"headerlink\" title=\"a. Using folder path\"></a>a. Using folder path</h3><p>Let‚Äôs see how to create a nested crate and use it as a dependency using folder path,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// # Think we run\ncargo new phrases\ncargo new phrases/greetings --lib\n\n// # It generates,\n.\n‚îú‚îÄ‚îÄ Cargo.toml\n‚îú‚îÄ‚îÄ greetings\n‚îÇ  ‚îú‚îÄ‚îÄ Cargo.toml\n‚îÇ  ‚îî‚îÄ‚îÄ src\n‚îÇ     ‚îî‚îÄ‚îÄ lib.rs\n‚îî‚îÄ‚îÄ src\n   ‚îî‚îÄ‚îÄ main.rs\n\n// # Think we modify following files\n\n// 01. phrases/Cargo.toml\n[package]\nname = &quot;phrases&quot;\nversion = &quot;0.1.0&quot;\nauthors = [&quot;Dumindu Madunuwan&quot;]\n\n[dependencies]\ngreetings = { path = &quot;greetings&quot; }\n\n// 02. phrases/greetings/src/lib.rs\npub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n}\n\n// 03. phrases/src/main.rs\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n</code></pre>\n<h3 id=\"b-Using-git-repository\"><a href=\"#b-Using-git-repository\" class=\"headerlink\" title=\"b. Using git repository\"></a>b. Using git repository</h3><p>If you want to use a library crate on multiple projects, one way is moving crate code to a git repository and use it as a dependency when needed.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// -- Cargo.toml --\n[dependencies]\n\n// 01. Get the latest commit on the master branch\nrocket = { git = &quot;https://github.com/SergioBenitez/Rocket&quot; }\n\n// 02. Get the latest commit of a specific branch\nrocket = { git = &quot;https://github.com/SergioBenitez/Rocket&quot;, branch = &quot;v0.3&quot; }\n\n// 03. Get a specific tag\nrocket = { git = &quot;https://github.com/SergioBenitez/Rocket&quot;, tag = &quot;v0.3.2&quot; }\n\n// 04. Get a specific revision (on master or any branch, according to rev)\nrocket = { git = &quot;https://github.com/SergioBenitez/Rocket&quot;, rev = &quot;8183f636305cef4adaa9525506c33cbea72d1745&quot; }\n</code></pre>\n<h3 id=\"c-Using-crates-io\"><a href=\"#c-Using-crates-io\" class=\"headerlink\" title=\"c. Using crates.io\"></a>c. Using crates.io</h3><p>The other way is uploading it to <a href=\"http://crates.io/\" target=\"_blank\" rel=\"noopener\">crates.io</a> and use it as a dependency when needed.</p>\n<p>üöß First, let‚Äôs <code>create</code> a simple ‚ÄúHello world‚Äù crate <code>and upload</code> it to <a href=\"http://crates.io/\" target=\"_blank\" rel=\"noopener\">crates.io</a>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// # Think we run\ncargo new test_crate_hello_world --lib\n\n// # It generates,\n.\n‚îú‚îÄ‚îÄ Cargo.toml\n‚îî‚îÄ‚îÄ src\n   ‚îî‚îÄ‚îÄ lib.rs\n\n// # Think we modify following files\n\n// 01. test_crate_hello_world/Cargo.toml\n[package]\nname = &quot;test_crate_hello_world&quot;\nversion = &quot;0.1.0&quot;\nauthors = [&quot;Dumindu Madunuwan&quot;]\n\ndescription = &quot;A Simple Hello World Crate&quot;\nrepository = &quot;https://github.com/dumindu/test_crate_hello_world&quot;\nkeywords = [&quot;hello&quot;, &quot;world&quot;]\nlicense = &quot;Apache-2.0&quot;\n\n[dependencies]\n\n// 02. test_crate_hello_world/src/lib.rs\n//! A Simple Hello World Crate\n\n/// This function returns the greeting; Hello, world!\npub fn hello() -&gt; String {\n    (&quot;Hello, world!&quot;).to_string()\n}\n\n#[cfg(test)]\nmod tests {\n\n    use super::hello;\n\n    #[test]\n    fn test_hello() {\n        assert_eq!(hello(), &quot;Hello, world!&quot;);\n    }\n}\n</code></pre>\n<blockquote>\n<p>üí≠ <strong>//! doc comments</strong> are used to write crate and module-level documentation. On other places we have to use /// outside of the block. And when uploading a crate to <a href=\"http://crates.io/\" target=\"_blank\" rel=\"noopener\">crates.io</a>, cargo generates the documentation from these doc comments and host it on <a href=\"https://docs.rs/\" target=\"_blank\" rel=\"noopener\">docs.rs</a>.</p>\n</blockquote>\n<p>üí° We have to add the <strong>description</strong> and <strong>license</strong> fields to Cargo.toml, otherwise we will get <code>error: api errors: missing or empty metadata fields: description, license. Please see http://doc.crates.io/manifest.html</code></p>\n<p>To upload this to crates.io,</p>\n<ol>\n<li>We have to create an account on crates.io to acquire an API token</li>\n<li>Then run <code>cargo login &lt;token&gt;</code> with that API token and cargo publish</li>\n</ol>\n<p><a href=\"http://doc.crates.io/crates-io.html\" target=\"_blank\" rel=\"noopener\">üìñ</a> This is <a href=\"http://doc.crates.io/crates-io.html\" target=\"_blank\" rel=\"noopener\">how it describes on Cargo Docs</a> with more details.</p>\n<blockquote>\n<ul>\n<li>You‚Äôll need an account on crates.io to acquire an API token. To do so, <a href=\"https://crates.io/\" target=\"_blank\" rel=\"noopener\">visit the home page</a> and log in via a GitHub account (required for now). After this, visit your <a href=\"https://crates.io/me\" target=\"_blank\" rel=\"noopener\">Account Settings</a> page and run the <code>cargo login</code> command specified.<br>Ex. <code>cargo login abcdefghijklmnopqrstuvwxyz012345</code></li>\n<li>The next step is to package up your crate into a format that can be uploaded to crates.io. For this we‚Äôll use the <code>cargo package</code> sub-command.</li>\n<li>Now, it can be uploaded to crates.io with the <code>cargo publish</code> command.</li>\n<li>If you‚Äôd like to skip the <code>cargo package</code> step, the <code>cargo publish</code> sub-command will automatically package up the local crate if a copy isn‚Äôt found already.</li>\n</ul>\n</blockquote>\n<p>The name of our crate is <code>test_crate_hello_world</code>. So it can be found on,<br>üì¶ <a href=\"https://crates.io/crates/test_crate_hello_world\" target=\"_blank\" rel=\"noopener\">https://<strong>crates.io/crates</strong>/test_crate_hello_world</a><br>üìë <a href=\"https://docs.rs/test_crate_hello_world\" target=\"_blank\" rel=\"noopener\">https://<strong>docs.rs</strong>/test_crate_hello_world</a></p>\n<blockquote>\n<p>üíØ crates.io supports readme files as well. To enable it, we have to add the readme field to Cargo.toml. Ex: <code>readme=&quot;README.md&quot;</code></p>\n</blockquote>\n<p>üèóÔ∏è Okay then, Let‚Äôs see how we can <strong>use this from an another crate</strong>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// # Think we run\ncargo new greetings\n\n// # It generates,\n.\n‚îú‚îÄ‚îÄ Cargo.toml\n‚îî‚îÄ‚îÄ src\n   ‚îî‚îÄ‚îÄ main.rs\n\n// # Think we modify following files\n\n// 01. greetings/Cargo.toml\n[package]\nname = &quot;greetings&quot;\nversion = &quot;0.1.0&quot;\nauthors = [&quot;Dumindu Madunuwan&quot;]\n\n[dependencies]\ntest_crate_hello_world = &quot;0.1.0&quot;\n\n// 02. greetings/src/main.rs\nextern crate test_crate_hello_world;\n\nfn main() {\n    println!(&quot;{}&quot;, test_crate_hello_world::hello());\n}\n</code></pre>\n<p>By default, Cargo looks dependencies on crates.io . So we have to add only the crate name and a version string to <strong>Cargo.toml</strong> and then run <code>cargo build</code> to fetch the dependencies and compile them.</p>\n"}],"Post":[],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}