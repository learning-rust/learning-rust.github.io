<!doctype html><html lang=en-US><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Rust Programming Language Tutorials for Everyone!"><meta name=author content="Dumindu Madunuwan"><meta name=theme-color content="#ffffff" media="(prefers-color-scheme: light)"><meta name=theme-color content="#101010" media="(prefers-color-scheme: dark)"><title>Combinators · Learning Rust</title>
<link rel=canonical href=https://learning-rust.github.io/docs/combinators/><link rel=stylesheet href=/assets/css/docs.min.8e9408609771a441499aa5571a4585b0ca95783b842d5c758af5eef1457b0fe0.css integrity><link rel=manifest href=/manifest.json><link rel=icon href=/favicon/favicon.ico><link rel=icon href=/favicon/favicon-16x16.png sizes=16x16 type=image/png><link rel=icon href=/favicon/favicon-32x32.png sizes=32x32 type=image/png><link rel=apple-touch-icon href=/favicon/apple-touch-icon.png sizes=180x180><script async src="https://www.googletagmanager.com/gtag/js?id=G-FZHQCXSZ89"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-FZHQCXSZ89")</script></head><body><div id=outer-wrapper><div id=aside-wrapper><aside><div><button class=btn><i>❌</i>Close</button></div><a href=https://learning-rust.github.io/ class=site-logo>Learning Rust</a><nav role=navigation><details open><summary>Documentation</summary><ul><li><a href=https://learning-rust.github.io/docs/overview/>Overview</a></li></ul></details><details open><summary>Basics</summary><ul><li><a href=https://learning-rust.github.io/docs/why-rust/>Why Rust?</a></li><li><a href=https://learning-rust.github.io/docs/installation/>Installation</a></li><li><a href=https://learning-rust.github.io/docs/hello-world/>Hello World</a></li><li><a href=https://learning-rust.github.io/docs/cargo-crates-and-basic-project-structure/>Cargo, Crates and Basic Project Structure</a></li><li><a href=https://learning-rust.github.io/docs/comments-and-documenting-the-code/>Comments and Documenting the code</a></li><li><a href=https://learning-rust.github.io/docs/variable-bindings-constants-and-statics/>Variable bindings, Constants and Statics</a></li><li><a href=https://learning-rust.github.io/docs/functions/>Functions</a></li><li><a href=https://learning-rust.github.io/docs/primitive-data-types/>Primitive Data Types</a></li><li><a href=https://learning-rust.github.io/docs/operators/>Operators</a></li><li><a href=https://learning-rust.github.io/docs/control-flows/>Control Flows</a></li></ul></details><details open><summary>Beyond The Basics</summary><ul><li><a href=https://learning-rust.github.io/docs/vectors/>Vectors</a></li><li><a href=https://learning-rust.github.io/docs/structs/>Structs</a></li><li><a href=https://learning-rust.github.io/docs/enums/>Enums</a></li><li><a href=https://learning-rust.github.io/docs/generics/>Generics</a></li><li><a href=https://learning-rust.github.io/docs/impls-and-traits/>Impls and Traits</a></li></ul></details><details open><summary>The Tough Part</summary><ul><li><a href=https://learning-rust.github.io/docs/ownership/>Ownership</a></li><li><a href=https://learning-rust.github.io/docs/borrowing/>Borrowing</a></li><li><a href=https://learning-rust.github.io/docs/lifetimes/>Lifetimes</a></li></ul></details><details open><summary>Let's Get It Started</summary><ul><li><a href=https://learning-rust.github.io/docs/code-organization/>Code Organization</a></li><li><a href=https://learning-rust.github.io/docs/functions-02/>Functions (02)</a></li><li><a href=https://learning-rust.github.io/docs/modules/>Modules</a></li><li><a href=https://learning-rust.github.io/docs/crates/>Crates</a></li><li><a href=https://learning-rust.github.io/docs/workspaces/>Workspaces</a></li><li><a href=https://learning-rust.github.io/docs/use/>Use</a></li><li><a href=https://learning-rust.github.io/docs/std-primitives-and-preludes/>STD, Primitives and Preludes</a></li></ul></details><details open><summary>Error Handling</summary><ul><li><a href=https://learning-rust.github.io/docs/smart-compiler/>Smart Compiler</a></li><li><a href=https://learning-rust.github.io/docs/panicking/>Panicking</a></li><li><a href=https://learning-rust.github.io/docs/option-and-result/>Option and Result</a></li><li><a href=https://learning-rust.github.io/docs/unwrap-and-expect/>Unwrap and Expect</a></li><li><a href=https://learning-rust.github.io/docs/error-and-none-propagation/>Error and None Propagation</a></li><li><a class=active href=https://learning-rust.github.io/docs/combinators/>Combinators</a></li><li><a href=https://learning-rust.github.io/docs/custom-error-types/>Custom Error Types</a></li></ul></details></nav></aside></div><div id=content-wrapper><header><a href=https://learning-rust.github.io/ class=site-logo>Learning Rust</a></header><main><article><nav><button class=btn><i>⬅️</i> On this section</button>
<button class=btn>On this page <i>➡️</i></button></nav><header><h1>Combinators</h1><p></p></header><div id=article-body><h2 id=what-is-a-combinator>What is a combinator?</h2><ul><li><p>One meaning of “combinator” is a more informal sense referring to the <strong>combinator pattern</strong>, a style of organizing libraries centered around the idea of combining things. Usually there is <strong>some type T</strong>, some <strong>functions for constructing “primitive” values of type T</strong>, and some “<strong>combinators</strong>” which can <strong>combine values of type T</strong> in various ways to <strong>build up more complex values of type T</strong>. The other definition is <strong>&ldquo;function with no free variables&rdquo;</strong>.
__ <a href=https://wiki.haskell.org/Combinator target=_blank>wiki.haskell.org</a></p></li><li><p>A combinator is <strong>a function</strong> which <strong>builds program fragments from program fragments</strong>; in a sense the programmer using combinators constructs much of the desired program automatically, rather that writing every detail by hand.
__ John Hughes—<a href=http://www.cse.chalmers.se/~rjmh/Papers/arrows.pdf target=_blank>Generalizing Monads to Arrows</a> via <a href=https://github.com/caiorss/Functional-Programming/blob/master/haskell/Functional_Programming_Concepts.org target=_blank>Functional Programming Concepts</a></p></li></ul><p>The exact definition of &ldquo;combinators&rdquo; in Rust ecosystem is bit unclear. </p><ul><li><p><code>or()</code>, <code>and()</code>, <code>or_else()</code>, <code>and_then()</code></p><ul><li><strong>Combine two values of type T</strong> and <strong>return same type T</strong>.</li></ul></li><li><p><code>filter()</code> for <code>Option</code> types</p><ul><li><strong>Filter type T</strong> by using a closure as a conditional function</li><li><strong>Return same type T</strong></li></ul></li><li><p><code>map()</code>, <code>map_err()</code></p><ul><li><strong>Convert type T by applying a closure</strong>.</li><li>The <strong>data type of the value inside T can be changed</strong>.
ex. <code>Some&lt;&amp;str></code> can be converted to <code>Some&lt;usize></code> or <code>Err&lt;&amp;str></code> to <code>Err&lt;isize></code> and etc.</li></ul></li><li><p><code>map_or()</code>, <code>map_or_else()</code></p><ul><li><strong>Transform type T by applying a closure</strong> & <strong>return the value inside type T</strong>.</li><li>For <strong><code>None</code> and <code>Err</code>, a default value or another closure</strong> is applied.</li></ul></li><li><p><code>ok_or()</code>, <code>ok_or_else()</code> for <code>Option</code> types</p><ul><li><strong>Transform <code>Option</code> type into a <code>Result</code> type</strong>.</li></ul></li><li><p><code>as_ref()</code>, <code>as_mut()</code></p><ul><li><strong>Transform type T into a reference or a mutable reference</strong>.</li></ul></li></ul><h2 id=or-and-and>or() and and()</h2><p>While combining two expressions, which return either <code>Option</code>/ <code>Result</code></p><ul><li><code>or()</code>: If either one got <code>Some</code> or <code>Ok</code>, that value returns immediately.</li><li><code>and()</code>: If both got <code>Some</code> or <code>Ok</code>, the value in the second expression returns. If either one got <code>None</code> or <code>Err</code> that value returns immediately.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>let</span><span class=w> </span><span class=n>s1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=s>&#34;some1&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>let</span><span class=w> </span><span class=n>s2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=s>&#34;some2&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>let</span><span class=w> </span><span class=n>n</span>: <span class=nb>Option</span><span class=o>&lt;&amp;</span><span class=kt>str</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>None</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>let</span><span class=w> </span><span class=n>o1</span>: <span class=nb>Result</span><span class=o>&lt;&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=kt>str</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Ok</span><span class=p>(</span><span class=s>&#34;ok1&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>let</span><span class=w> </span><span class=n>o2</span>: <span class=nb>Result</span><span class=o>&lt;&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=kt>str</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Ok</span><span class=p>(</span><span class=s>&#34;ok2&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>let</span><span class=w> </span><span class=n>e1</span>: <span class=nb>Result</span><span class=o>&lt;&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=kt>str</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Err</span><span class=p>(</span><span class=s>&#34;error1&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>let</span><span class=w> </span><span class=n>e2</span>: <span class=nb>Result</span><span class=o>&lt;&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=kt>str</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Err</span><span class=p>(</span><span class=s>&#34;error2&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>s1</span><span class=p>.</span><span class=n>or</span><span class=p>(</span><span class=n>s2</span><span class=p>),</span><span class=w> </span><span class=n>s1</span><span class=p>);</span><span class=w> </span><span class=c1>// Some1 or Some2 = Some1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>  </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>s1</span><span class=p>.</span><span class=n>or</span><span class=p>(</span><span class=n>n</span><span class=p>),</span><span class=w> </span><span class=n>s1</span><span class=p>);</span><span class=w>  </span><span class=c1>// Some or None = Some
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>  </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>n</span><span class=p>.</span><span class=n>or</span><span class=p>(</span><span class=n>s1</span><span class=p>),</span><span class=w> </span><span class=n>s1</span><span class=p>);</span><span class=w>  </span><span class=c1>// None or Some = Some
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>  </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>n</span><span class=p>.</span><span class=n>or</span><span class=p>(</span><span class=n>n</span><span class=p>),</span><span class=w> </span><span class=n>n</span><span class=p>);</span><span class=w>    </span><span class=c1>// None1 or None2 = None2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>o1</span><span class=p>.</span><span class=n>or</span><span class=p>(</span><span class=n>o2</span><span class=p>),</span><span class=w> </span><span class=n>o1</span><span class=p>);</span><span class=w> </span><span class=c1>// Ok1 or Ok2 = Ok1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>  </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>o1</span><span class=p>.</span><span class=n>or</span><span class=p>(</span><span class=n>e1</span><span class=p>),</span><span class=w> </span><span class=n>o1</span><span class=p>);</span><span class=w> </span><span class=c1>// Ok or Err = Ok
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>  </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>e1</span><span class=p>.</span><span class=n>or</span><span class=p>(</span><span class=n>o1</span><span class=p>),</span><span class=w> </span><span class=n>o1</span><span class=p>);</span><span class=w> </span><span class=c1>// Err or Ok = Ok
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>  </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>e1</span><span class=p>.</span><span class=n>or</span><span class=p>(</span><span class=n>e2</span><span class=p>),</span><span class=w> </span><span class=n>e2</span><span class=p>);</span><span class=w> </span><span class=c1>// Err1 or Err2 = Err2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>s1</span><span class=p>.</span><span class=n>and</span><span class=p>(</span><span class=n>s2</span><span class=p>),</span><span class=w> </span><span class=n>s2</span><span class=p>);</span><span class=w> </span><span class=c1>// Some1 and Some2 = Some2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>  </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>s1</span><span class=p>.</span><span class=n>and</span><span class=p>(</span><span class=n>n</span><span class=p>),</span><span class=w> </span><span class=n>n</span><span class=p>);</span><span class=w>   </span><span class=c1>// Some and None = None
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>  </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>n</span><span class=p>.</span><span class=n>and</span><span class=p>(</span><span class=n>s1</span><span class=p>),</span><span class=w> </span><span class=n>n</span><span class=p>);</span><span class=w>   </span><span class=c1>// None and Some = None
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>  </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>n</span><span class=p>.</span><span class=n>and</span><span class=p>(</span><span class=n>n</span><span class=p>),</span><span class=w> </span><span class=n>n</span><span class=p>);</span><span class=w>    </span><span class=c1>// None1 and None2 = None1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>o1</span><span class=p>.</span><span class=n>and</span><span class=p>(</span><span class=n>o2</span><span class=p>),</span><span class=w> </span><span class=n>o2</span><span class=p>);</span><span class=w> </span><span class=c1>// Ok1 and Ok2 = Ok2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>  </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>o1</span><span class=p>.</span><span class=n>and</span><span class=p>(</span><span class=n>e1</span><span class=p>),</span><span class=w> </span><span class=n>e1</span><span class=p>);</span><span class=w> </span><span class=c1>// Ok and Err = Err
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>  </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>e1</span><span class=p>.</span><span class=n>and</span><span class=p>(</span><span class=n>o1</span><span class=p>),</span><span class=w> </span><span class=n>e1</span><span class=p>);</span><span class=w> </span><span class=c1>// Err and Ok = Err
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>  </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>e1</span><span class=p>.</span><span class=n>and</span><span class=p>(</span><span class=n>e2</span><span class=p>),</span><span class=w> </span><span class=n>e1</span><span class=p>);</span><span class=w> </span><span class=c1>// Err1 and Err2 = Err1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><blockquote><p>🔎 Rust nightly support <a href=https://doc.rust-lang.org/std/option/enum.Option.html#method.xor target=_blank><code>xor()</code></a> for <code>Option</code> types, which returns <code>Some</code> only if one expression got <code>Some</code>, but not both.</p></blockquote><h2 id=or_else>or_else()</h2><p>Similar to <code>or()</code>. The only difference is, the second expression should be a <strong><a href=/docs/functions/#closures>closure</a></strong> which returns same type T.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// or_else with Option
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>s1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=s>&#34;some1&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>s2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=s>&#34;some2&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>fn_some</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=s>&#34;some2&#34;</span><span class=p>);</span><span class=w> </span><span class=c1>// similar to: let fn_some = || -&gt; Option&lt;&amp;str&gt; { Some(&#34;some2&#34;) };
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>n</span>: <span class=nb>Option</span><span class=o>&lt;&amp;</span><span class=kt>str</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>None</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>fn_none</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=nb>None</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>s1</span><span class=p>.</span><span class=n>or_else</span><span class=p>(</span><span class=n>fn_some</span><span class=p>),</span><span class=w> </span><span class=n>s1</span><span class=p>);</span><span class=w>  </span><span class=c1>// Some1 or_else Some2 = Some1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>s1</span><span class=p>.</span><span class=n>or_else</span><span class=p>(</span><span class=n>fn_none</span><span class=p>),</span><span class=w> </span><span class=n>s1</span><span class=p>);</span><span class=w>  </span><span class=c1>// Some or_else None = Some
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>n</span><span class=p>.</span><span class=n>or_else</span><span class=p>(</span><span class=n>fn_some</span><span class=p>),</span><span class=w> </span><span class=n>s2</span><span class=p>);</span><span class=w>   </span><span class=c1>// None or_else Some = Some
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>n</span><span class=p>.</span><span class=n>or_else</span><span class=p>(</span><span class=n>fn_none</span><span class=p>),</span><span class=w> </span><span class=nb>None</span><span class=p>);</span><span class=w> </span><span class=c1>// None1 or_else None2 = None2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// or_else with Result
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>o1</span>: <span class=nb>Result</span><span class=o>&lt;&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=kt>str</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Ok</span><span class=p>(</span><span class=s>&#34;ok1&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>o2</span>: <span class=nb>Result</span><span class=o>&lt;&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=kt>str</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Ok</span><span class=p>(</span><span class=s>&#34;ok2&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>fn_ok</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>|</span><span class=n>_</span><span class=o>|</span><span class=w> </span><span class=nb>Ok</span><span class=p>(</span><span class=s>&#34;ok2&#34;</span><span class=p>);</span><span class=w> </span><span class=c1>// similar to: let fn_ok = |_| -&gt; Result&lt;&amp;str, &amp;str&gt; { Ok(&#34;ok2&#34;) };
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>e1</span>: <span class=nb>Result</span><span class=o>&lt;&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=kt>str</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Err</span><span class=p>(</span><span class=s>&#34;error1&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>e2</span>: <span class=nb>Result</span><span class=o>&lt;&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=kt>str</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Err</span><span class=p>(</span><span class=s>&#34;error2&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>fn_err</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>|</span><span class=n>_</span><span class=o>|</span><span class=w> </span><span class=nb>Err</span><span class=p>(</span><span class=s>&#34;error2&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>o1</span><span class=p>.</span><span class=n>or_else</span><span class=p>(</span><span class=n>fn_ok</span><span class=p>),</span><span class=w> </span><span class=n>o1</span><span class=p>);</span><span class=w>  </span><span class=c1>// Ok1 or_else Ok2 = Ok1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>o1</span><span class=p>.</span><span class=n>or_else</span><span class=p>(</span><span class=n>fn_err</span><span class=p>),</span><span class=w> </span><span class=n>o1</span><span class=p>);</span><span class=w> </span><span class=c1>// Ok or_else Err = Ok
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>e1</span><span class=p>.</span><span class=n>or_else</span><span class=p>(</span><span class=n>fn_ok</span><span class=p>),</span><span class=w> </span><span class=n>o2</span><span class=p>);</span><span class=w>  </span><span class=c1>// Err or_else Ok = Ok
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>e1</span><span class=p>.</span><span class=n>or_else</span><span class=p>(</span><span class=n>fn_err</span><span class=p>),</span><span class=w> </span><span class=n>e2</span><span class=p>);</span><span class=w> </span><span class=c1>// Err1 or_else Err2 = Err2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h2 id=and_then>and_then()</h2><p>Similar to <code>and()</code>. The only difference is, the second expression should be a <strong><a href=/docs/functions/#closures>closure</a></strong> which returns same type T.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// and_then with Option
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>s1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=s>&#34;some1&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>s2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=s>&#34;some2&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>fn_some</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>|</span><span class=n>_</span><span class=o>|</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=s>&#34;some2&#34;</span><span class=p>);</span><span class=w> </span><span class=c1>// similar to: let fn_some = |_| -&gt; Option&lt;&amp;str&gt; { Some(&#34;some2&#34;) };
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>n</span>: <span class=nb>Option</span><span class=o>&lt;&amp;</span><span class=kt>str</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>None</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>fn_none</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>|</span><span class=n>_</span><span class=o>|</span><span class=w> </span><span class=nb>None</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>s1</span><span class=p>.</span><span class=n>and_then</span><span class=p>(</span><span class=n>fn_some</span><span class=p>),</span><span class=w> </span><span class=n>s2</span><span class=p>);</span><span class=w> </span><span class=c1>// Some1 and_then Some2 = Some2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>s1</span><span class=p>.</span><span class=n>and_then</span><span class=p>(</span><span class=n>fn_none</span><span class=p>),</span><span class=w> </span><span class=n>n</span><span class=p>);</span><span class=w>  </span><span class=c1>// Some and_then None = None
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>n</span><span class=p>.</span><span class=n>and_then</span><span class=p>(</span><span class=n>fn_some</span><span class=p>),</span><span class=w> </span><span class=n>n</span><span class=p>);</span><span class=w>   </span><span class=c1>// None and_then Some = None
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>n</span><span class=p>.</span><span class=n>and_then</span><span class=p>(</span><span class=n>fn_none</span><span class=p>),</span><span class=w> </span><span class=n>n</span><span class=p>);</span><span class=w>   </span><span class=c1>// None1 and_then None2 = None1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// and_then with Result
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>o1</span>: <span class=nb>Result</span><span class=o>&lt;&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=kt>str</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Ok</span><span class=p>(</span><span class=s>&#34;ok1&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>o2</span>: <span class=nb>Result</span><span class=o>&lt;&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=kt>str</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Ok</span><span class=p>(</span><span class=s>&#34;ok2&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>fn_ok</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>|</span><span class=n>_</span><span class=o>|</span><span class=w> </span><span class=nb>Ok</span><span class=p>(</span><span class=s>&#34;ok2&#34;</span><span class=p>);</span><span class=w> </span><span class=c1>// similar to: let fn_ok = |_| -&gt; Result&lt;&amp;str, &amp;str&gt; { Ok(&#34;ok2&#34;) };
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>e1</span>: <span class=nb>Result</span><span class=o>&lt;&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=kt>str</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Err</span><span class=p>(</span><span class=s>&#34;error1&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>e2</span>: <span class=nb>Result</span><span class=o>&lt;&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=kt>str</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Err</span><span class=p>(</span><span class=s>&#34;error2&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>fn_err</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>|</span><span class=n>_</span><span class=o>|</span><span class=w> </span><span class=nb>Err</span><span class=p>(</span><span class=s>&#34;error2&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>o1</span><span class=p>.</span><span class=n>and_then</span><span class=p>(</span><span class=n>fn_ok</span><span class=p>),</span><span class=w> </span><span class=n>o2</span><span class=p>);</span><span class=w>  </span><span class=c1>// Ok1 and_then Ok2 = Ok2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>o1</span><span class=p>.</span><span class=n>and_then</span><span class=p>(</span><span class=n>fn_err</span><span class=p>),</span><span class=w> </span><span class=n>e2</span><span class=p>);</span><span class=w> </span><span class=c1>// Ok and_then Err = Err
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>e1</span><span class=p>.</span><span class=n>and_then</span><span class=p>(</span><span class=n>fn_ok</span><span class=p>),</span><span class=w> </span><span class=n>e1</span><span class=p>);</span><span class=w>  </span><span class=c1>// Err and_then Ok = Err
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>e1</span><span class=p>.</span><span class=n>and_then</span><span class=p>(</span><span class=n>fn_err</span><span class=p>),</span><span class=w> </span><span class=n>e1</span><span class=p>);</span><span class=w> </span><span class=c1>// Err1 and_then Err2 = Err1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h2 id=filter>filter()</h2><blockquote><p>💡 Usually in programming languages <code>filter</code> functions are used with arrays or iterators to create a new array/ iterator by filtering own elements via a function/ closure. Rust also provides <a href=https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.filter target=_blank><code>filter()</code> <strong>as an iterator adaptor</strong></a> to apply a closure on each element of an iterator to transform it into another iterator. However in here we are talking about the functionality of <code>filter()</code> with <code>Option</code> types.</p></blockquote><p>The same <code>Some</code> type is returned, only if we pass a <code>Some</code> value and the given closure returned true for it. <code>None</code> is returned, if <code>None</code> type passed or the closure returned false. The closure uses the value inside <code>Some</code> as an argument. Still Rust support <code>filter()</code> only for <code>Option</code> types.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>s1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=mi>3</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>s2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=mi>6</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>None</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>fn_is_even</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>|</span><span class=n>x</span>: <span class=kp>&amp;</span><span class=kt>i8</span><span class=o>|</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>%</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>s1</span><span class=p>.</span><span class=n>filter</span><span class=p>(</span><span class=n>fn_is_even</span><span class=p>),</span><span class=w> </span><span class=n>n</span><span class=p>);</span><span class=w>  </span><span class=c1>// Some(3) -&gt; 3 is not even -&gt; None
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>s2</span><span class=p>.</span><span class=n>filter</span><span class=p>(</span><span class=n>fn_is_even</span><span class=p>),</span><span class=w> </span><span class=n>s2</span><span class=p>);</span><span class=w> </span><span class=c1>// Some(6) -&gt; 6 is even -&gt; Some(6)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>n</span><span class=p>.</span><span class=n>filter</span><span class=p>(</span><span class=n>fn_is_even</span><span class=p>),</span><span class=w> </span><span class=n>n</span><span class=p>);</span><span class=w>   </span><span class=c1>// None -&gt; no value -&gt; None
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h2 id=map-and-map_err>map() and map_err()</h2><blockquote><p>💡 Usually in programming languages <code>map()</code> functions are used with arrays or iterators, <strong>to apply a closure on each element</strong> of the array or iterator. Rust also provides <a href=https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.map target=_blank><code>map()</code> <strong>as an iterator adaptor</strong></a> to apply a closure on each element of an iterator to transform it into another iterator. However in here we are talking about the functionality of <code>map()</code> with <code>Option</code> and <code>Result</code> types.</p></blockquote><ul><li><code>map()</code> : Convert type T by applying a closure. <strong>The data type of <code>Some</code> or <code>Ok</code> blocks can be changed</strong> according to the return type of the closure. Convert <code>Option&lt;T></code> to <code>Option&lt;U></code>, <code>Result&lt;T, E></code> to <code>Result&lt;U, E></code></li></ul><p>⭐ Via <code>map()</code>, only <code>Some</code> and <code>Ok</code> values are getting changed. No affect to the values inside <code>Err</code> (<code>None</code> doesn’t contain any value at all).</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>s1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=s>&#34;abcde&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>s2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=mi>5</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>n1</span>: <span class=nb>Option</span><span class=o>&lt;&amp;</span><span class=kt>str</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>None</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>n2</span>: <span class=nb>Option</span><span class=o>&lt;</span><span class=kt>usize</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>None</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>o1</span>: <span class=nb>Result</span><span class=o>&lt;&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=kt>str</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Ok</span><span class=p>(</span><span class=s>&#34;abcde&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>o2</span>: <span class=nb>Result</span><span class=o>&lt;</span><span class=kt>usize</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=kt>str</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Ok</span><span class=p>(</span><span class=mi>5</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>e1</span>: <span class=nb>Result</span><span class=o>&lt;&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=kt>str</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Err</span><span class=p>(</span><span class=s>&#34;abcde&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>e2</span>: <span class=nb>Result</span><span class=o>&lt;</span><span class=kt>usize</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=kt>str</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Err</span><span class=p>(</span><span class=s>&#34;abcde&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>fn_character_count</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>|</span><span class=n>s</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=o>|</span><span class=w> </span><span class=n>s</span><span class=p>.</span><span class=n>chars</span><span class=p>().</span><span class=n>count</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>s1</span><span class=p>.</span><span class=n>map</span><span class=p>(</span><span class=n>fn_character_count</span><span class=p>),</span><span class=w> </span><span class=n>s2</span><span class=p>);</span><span class=w> </span><span class=c1>// Some1 map = Some2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>n1</span><span class=p>.</span><span class=n>map</span><span class=p>(</span><span class=n>fn_character_count</span><span class=p>),</span><span class=w> </span><span class=n>n2</span><span class=p>);</span><span class=w> </span><span class=c1>// None1 map = None2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>o1</span><span class=p>.</span><span class=n>map</span><span class=p>(</span><span class=n>fn_character_count</span><span class=p>),</span><span class=w> </span><span class=n>o2</span><span class=p>);</span><span class=w> </span><span class=c1>// Ok1 map = Ok2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>e1</span><span class=p>.</span><span class=n>map</span><span class=p>(</span><span class=n>fn_character_count</span><span class=p>),</span><span class=w> </span><span class=n>e2</span><span class=p>);</span><span class=w> </span><span class=c1>// Err1 map = Err2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><ul><li><code>map_err()</code> for <code>Result</code> types : <strong>The data type of <code>Err</code> blocks can be changed</strong> according to the return type of the closure. Convert <code>Result&lt;T, E></code> to <code>Result&lt;T, F></code>.</li></ul><p>⭐ Via <code>map_err()</code>, only <code>Err</code> values are getting changed. No affect to the values inside <code>Ok</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>o1</span>: <span class=nb>Result</span><span class=o>&lt;&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=kt>str</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Ok</span><span class=p>(</span><span class=s>&#34;abcde&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>o2</span>: <span class=nb>Result</span><span class=o>&lt;&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=kt>isize</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Ok</span><span class=p>(</span><span class=s>&#34;abcde&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>e1</span>: <span class=nb>Result</span><span class=o>&lt;&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=kt>str</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Err</span><span class=p>(</span><span class=s>&#34;404&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>e2</span>: <span class=nb>Result</span><span class=o>&lt;&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=kt>isize</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Err</span><span class=p>(</span><span class=mi>404</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>fn_character_count</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>|</span><span class=n>s</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=o>|</span><span class=w> </span>-&gt; <span class=kt>isize</span> <span class=p>{</span><span class=w> </span><span class=n>s</span><span class=p>.</span><span class=n>parse</span><span class=p>().</span><span class=n>unwrap</span><span class=p>()</span><span class=w> </span><span class=p>};</span><span class=w> </span><span class=c1>// convert str to isize
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>o1</span><span class=p>.</span><span class=n>map_err</span><span class=p>(</span><span class=n>fn_character_count</span><span class=p>),</span><span class=w> </span><span class=n>o2</span><span class=p>);</span><span class=w> </span><span class=c1>// Ok1 map = Ok2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>e1</span><span class=p>.</span><span class=n>map_err</span><span class=p>(</span><span class=n>fn_character_count</span><span class=p>),</span><span class=w> </span><span class=n>e2</span><span class=p>);</span><span class=w> </span><span class=c1>// Err1 map = Err2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h2 id=map_or-and-map_or_else>map_or() and map_or_else()</h2><p>Hope you remember the functionality of <a href=/docs/unwrap-and-expect/#unwrap_or-unwrap_or_default-and-unwrap_or_else><code>unwrap_or()</code> and <code>unwrap_or_else()</code></a> functions. These functions also bit similar to them. But <code>map_or()</code> and <code>map_or_else()</code> apply a closure on <code>Some</code> and <code>Ok</code> values and <strong>return the value inside type T</strong>.</p><ul><li><code>map_or()</code> : Support only for <code>Option</code> types (not supporting <code>Result</code>). Apply the closure to the value inside <code>Some</code> and return the output according to the closure. The given default value is returned for <code>None</code> types.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>const</span><span class=w> </span><span class=no>V_DEFAULT</span>: <span class=kt>i8</span> <span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>s</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=mi>10</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>n</span>: <span class=nb>Option</span><span class=o>&lt;</span><span class=kt>i8</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>None</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>fn_closure</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>|</span><span class=n>v</span>: <span class=kt>i8</span><span class=o>|</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mi>2</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>s</span><span class=p>.</span><span class=n>map_or</span><span class=p>(</span><span class=no>V_DEFAULT</span><span class=p>,</span><span class=w> </span><span class=n>fn_closure</span><span class=p>),</span><span class=w> </span><span class=mi>12</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>n</span><span class=p>.</span><span class=n>map_or</span><span class=p>(</span><span class=no>V_DEFAULT</span><span class=p>,</span><span class=w> </span><span class=n>fn_closure</span><span class=p>),</span><span class=w> </span><span class=no>V_DEFAULT</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><ul><li><code>map_or_else()</code> : Support for both <code>Option</code> and <code>Result</code> types (<code>Result</code> still nightly only). Similar to <code>map_or()</code> but should provide another closure instead a default value for the first parameter.</li></ul><p>⭐ <code>None</code> types doesn’t contain any value. So no need to pass anything to the closure as input with <code>Option</code> types. But <code>Err</code> types contain some value inside it. So default closure should able to read it as an input, while using this with <code>Result</code> types.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=cp>#![feature(result_map_or_else)]</span><span class=w> </span><span class=c1>// enable unstable library feature &#39;result_map_or_else&#39; on nightly
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>s</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=mi>10</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>n</span>: <span class=nb>Option</span><span class=o>&lt;</span><span class=kt>i8</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>None</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>fn_closure</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>|</span><span class=n>v</span>: <span class=kt>i8</span><span class=o>|</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mi>2</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>fn_default</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w> </span><span class=c1>// None doesn&#39;t contain any value. So no need to pass anything to closure as input.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>s</span><span class=p>.</span><span class=n>map_or_else</span><span class=p>(</span><span class=n>fn_default</span><span class=p>,</span><span class=w> </span><span class=n>fn_closure</span><span class=p>),</span><span class=w> </span><span class=mi>12</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>n</span><span class=p>.</span><span class=n>map_or_else</span><span class=p>(</span><span class=n>fn_default</span><span class=p>,</span><span class=w> </span><span class=n>fn_closure</span><span class=p>),</span><span class=w> </span><span class=mi>1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>o</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Ok</span><span class=p>(</span><span class=mi>10</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>e</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Err</span><span class=p>(</span><span class=mi>5</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>fn_default_for_result</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>|</span><span class=n>v</span>: <span class=kt>i8</span><span class=o>|</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w> </span><span class=c1>// Err contain some value inside it. So default closure should able to read it as input
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>o</span><span class=p>.</span><span class=n>map_or_else</span><span class=p>(</span><span class=n>fn_default_for_result</span><span class=p>,</span><span class=w> </span><span class=n>fn_closure</span><span class=p>),</span><span class=w> </span><span class=mi>12</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>e</span><span class=p>.</span><span class=n>map_or_else</span><span class=p>(</span><span class=n>fn_default_for_result</span><span class=p>,</span><span class=w> </span><span class=n>fn_closure</span><span class=p>),</span><span class=w> </span><span class=mi>6</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h2 id=ok_or-and-ok_or_else>ok_or() and ok_or_else()</h2><p>As mentioned earlier, <code>ok_or()</code>, <code>ok_or_else()</code> transform <code>Option</code> type into <code>Result</code> type. <strong><code>Some</code> to <code>Ok</code> and <code>None</code> to <code>Err</code></strong>.</p><ul><li><code>ok_or()</code> : A default <code>Err</code> message should pass as argument.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>const</span><span class=w> </span><span class=no>ERR_DEFAULT</span>: <span class=kp>&amp;</span><span class=kt>str</span> <span class=o>=</span><span class=w> </span><span class=s>&#34;error message&#34;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>s</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=s>&#34;abcde&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>n</span>: <span class=nb>Option</span><span class=o>&lt;&amp;</span><span class=kt>str</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>None</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>o</span>: <span class=nb>Result</span><span class=o>&lt;&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=kt>str</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Ok</span><span class=p>(</span><span class=s>&#34;abcde&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>e</span>: <span class=nb>Result</span><span class=o>&lt;&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=kt>str</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Err</span><span class=p>(</span><span class=no>ERR_DEFAULT</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>s</span><span class=p>.</span><span class=n>ok_or</span><span class=p>(</span><span class=no>ERR_DEFAULT</span><span class=p>),</span><span class=w> </span><span class=n>o</span><span class=p>);</span><span class=w> </span><span class=c1>// Some(T) -&gt; Ok(T)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>n</span><span class=p>.</span><span class=n>ok_or</span><span class=p>(</span><span class=no>ERR_DEFAULT</span><span class=p>),</span><span class=w> </span><span class=n>e</span><span class=p>);</span><span class=w> </span><span class=c1>// None -&gt; Err(default)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><ul><li><code>ok_or_else()</code> : Similar to <code>ok_or()</code>. A closure should be passed as the argument.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>s</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=s>&#34;abcde&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>n</span>: <span class=nb>Option</span><span class=o>&lt;&amp;</span><span class=kt>str</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>None</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>fn_err_message</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=s>&#34;error message&#34;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>o</span>: <span class=nb>Result</span><span class=o>&lt;&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=kt>str</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Ok</span><span class=p>(</span><span class=s>&#34;abcde&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>e</span>: <span class=nb>Result</span><span class=o>&lt;&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=kt>str</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Err</span><span class=p>(</span><span class=s>&#34;error message&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>s</span><span class=p>.</span><span class=n>ok_or_else</span><span class=p>(</span><span class=n>fn_err_message</span><span class=p>),</span><span class=w> </span><span class=n>o</span><span class=p>);</span><span class=w> </span><span class=c1>// Some(T) -&gt; Ok(T)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>n</span><span class=p>.</span><span class=n>ok_or_else</span><span class=p>(</span><span class=n>fn_err_message</span><span class=p>),</span><span class=w> </span><span class=n>e</span><span class=p>);</span><span class=w> </span><span class=c1>// None -&gt; Err(default)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h2 id=as_ref-and-as_mut>as_ref() and as_mut()</h2><p>🔎 As mentioned earlier, these functions are used to <strong>borrow type T as a reference or as a mutable reference</strong>.</p><ul><li><code>as_ref()</code> : Convert <code>Option&lt;T></code> to <code>Option&lt;&amp;T></code> and <code>Result&lt;T, E></code> to <code>Result&lt;&amp;T, &amp;E></code></li><li><code>as_mut()</code> : Converts <code>Option&lt;T></code> to <code>Option&lt;&amp;mut T></code> and <code>Result&lt;T, E></code> to <code>Result&lt;&amp;mut T, &amp;mut E></code></li></ul></div><footer><time datetime=2023-11-11><i>🕒</i> Updated: 2023-11-11</time>
<a href=https://learning-rust.github.io/docs/error-and-none-propagation/><i>﹤</i> Previous</a>
<a href=https://learning-rust.github.io/docs/custom-error-types/>Next <i>﹥</i></a></footer></article><aside><div><button class=btn><i>❌</i>Close</button></div><strong>On this page</strong><nav id=TableOfContents><ul><li><a href=#what-is-a-combinator>What is a combinator?</a></li><li><a href=#or-and-and>or() and and()</a></li><li><a href=#or_else>or_else()</a></li><li><a href=#and_then>and_then()</a></li><li><a href=#filter>filter()</a></li><li><a href=#map-and-map_err>map() and map_err()</a></li><li><a href=#map_or-and-map_or_else>map_or() and map_or_else()</a></li><li><a href=#ok_or-and-ok_or_else>ok_or() and ok_or_else()</a></li><li><a href=#as_ref-and-as_mut>as_ref() and as_mut()</a></li></ul></nav></aside></main><footer><div><i>🧑‍💻</i>Built by and copyright<a href=https://github.com/dumindu target=_blank>Dumindu Madunuwan</a><i>📅</i> 2016-2025<i>🚀</i> <a href=https://github.com/learning-rust target=_blank>GitHub</a></div><div><button class=btn><i>☀️</i><i>⁄</i><i>🌑</i></button></div></footer></div></div><div id=body-model-outer></div><script type=text/javascript src=/assets/js/docs.min.12ffdc25c0149ef34e761ee54587f2aae17affcb8375298ad2180851930cb142.js integrity></script></body></html>