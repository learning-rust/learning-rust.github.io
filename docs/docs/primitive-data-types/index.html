<!doctype html><html lang=en-US><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Rust Programming Language Tutorials for Everyone!"><meta name=author content="Dumindu Madunuwan"><meta name=theme-color content="#ffffff" media="(prefers-color-scheme: light)"><meta name=theme-color content="#101010" media="(prefers-color-scheme: dark)"><title>Primitive Data Types ¬∑ Learning Rust</title><link rel=canonical href=https://learning-rust.github.io/docs/primitive-data-types/><link rel=stylesheet href=/assets/css/docs.min.4db9eaa25929981f97ac32c236a2f07db4f9a0c025890e005f5f6f9e1f702614.css integrity><link rel=manifest href=/manifest.json><link rel=icon href=/favicon/favicon.ico><link rel=icon href=/favicon/favicon-16x16.png sizes=16x16 type=image/png><link rel=icon href=/favicon/favicon-32x32.png sizes=32x32 type=image/png><link rel=apple-touch-icon href=/favicon/apple-touch-icon.png sizes=180x180><script async src="https://www.googletagmanager.com/gtag/js?id=G-FZHQCXSZ89"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-FZHQCXSZ89")</script><meta property="og:title" content="Primitive Data Types"><meta property="og:description" content="Primitive Data Types - Rust Programming Language Tutorials for Everyone!"><meta property="og:type" content="article"><meta property="og:url" content="https://learning-rust.github.io/docs/primitive-data-types/"><meta property="og:image" content="https://learning-rust.github.io/docs/primitive-data-types/og.png"><meta property="og:site_name" content="Learning Rust"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="Primitive Data Types"><meta name=twitter:description content="Primitive Data Types - Rust Programming Language Tutorials for Everyone!"><meta name=twitter:image content="https://learning-rust.github.io/docs/primitive-data-types/og.png"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Article","headline":"Primitive Data Types","description":"Primitive Data Types - Rust Programming Language Tutorials for Everyone!","image":"https:\/\/learning-rust.github.io\/docs\/primitive-data-types\/og.png","author":{"@type":"Person","name":"Dumindu Madunuwan","url":"https:\/\/github.com\/dumindu"},"publisher":{"@type":"Organization","name":"Learning Rust","logo":{"@type":"ImageObject","url":"https:\/\/learning-rust.github.io\/"}},"dateModified":"2025-11-03T21:22:05Z","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/learning-rust.github.io\/docs\/primitive-data-types\/"}}</script></head><body><div id=outer-wrapper><div id=aside-wrapper><aside><div><button class=btn><i>‚ùå</i>Close</button></div><a href=https://learning-rust.github.io/ class=site-logo>Learning Rust</a><nav role=navigation><details open><summary>Documentation</summary><ul><li><a href=https://learning-rust.github.io/docs/overview/>Overview</a></li></ul></details><details open><summary>Basics</summary><ul><li><a href=https://learning-rust.github.io/docs/why-rust/>Why Rust?</a></li><li><a href=https://learning-rust.github.io/docs/installation/>Installation</a></li><li><a href=https://learning-rust.github.io/docs/hello-world/>Hello World</a></li><li><a href=https://learning-rust.github.io/docs/cargo-crates-and-basic-project-structure/>Cargo, Crates and Basic Project Structure</a></li><li><a href=https://learning-rust.github.io/docs/comments-and-documenting-the-code/>Comments and Documenting the code</a></li><li><a href=https://learning-rust.github.io/docs/variable-bindings-constants-and-statics/>Variable bindings, Constants and Statics</a></li><li><a href=https://learning-rust.github.io/docs/functions/>Functions</a></li><li><a class=active href=https://learning-rust.github.io/docs/primitive-data-types/>Primitive Data Types</a></li><li><a href=https://learning-rust.github.io/docs/operators/>Operators</a></li><li><a href=https://learning-rust.github.io/docs/control-flows/>Control Flows</a></li></ul></details><details open><summary>Beyond The Basics</summary><ul><li><a href=https://learning-rust.github.io/docs/vectors/>Vectors</a></li><li><a href=https://learning-rust.github.io/docs/structs/>Structs</a></li><li><a href=https://learning-rust.github.io/docs/enums/>Enums</a></li><li><a href=https://learning-rust.github.io/docs/generics/>Generics</a></li><li><a href=https://learning-rust.github.io/docs/impls-and-traits/>Impls and Traits</a></li></ul></details><details open><summary>The Tough Part</summary><ul><li><a href=https://learning-rust.github.io/docs/ownership/>Ownership</a></li><li><a href=https://learning-rust.github.io/docs/borrowing/>Borrowing</a></li><li><a href=https://learning-rust.github.io/docs/lifetimes/>Lifetimes</a></li></ul></details><details open><summary>Let's Get It Started</summary><ul><li><a href=https://learning-rust.github.io/docs/modules/>Modules</a></li><li><a href=https://learning-rust.github.io/docs/crates/>Crates</a></li><li><a href=https://learning-rust.github.io/docs/workspaces/>Workspaces</a></li><li><a href=https://learning-rust.github.io/docs/use/>Use</a></li><li><a href=https://learning-rust.github.io/docs/std-primitives-and-preludes/>STD, Primitives and Preludes</a></li></ul></details><details open><summary>Error Handling</summary><ul><li><a href=https://learning-rust.github.io/docs/smart-compiler/>Smart Compiler</a></li><li><a href=https://learning-rust.github.io/docs/panicking/>Panicking</a></li><li><a href=https://learning-rust.github.io/docs/option-and-result/>Option and Result</a></li><li><a href=https://learning-rust.github.io/docs/unwrap-and-expect/>Unwrap and Expect</a></li><li><a href=https://learning-rust.github.io/docs/error-and-none-propagation/>Error and None Propagation</a></li><li><a href=https://learning-rust.github.io/docs/combinators/>Combinators</a></li><li><a href=https://learning-rust.github.io/docs/custom-error-types/>Custom Error Types</a></li></ul></details></nav></aside></div><div id=content-wrapper><header><a href=https://learning-rust.github.io/ class=site-logo>Learning Rust</a></header><nav role=navigation><select onchange="this.value&&(window.location.href=this.value)"><button>
<selectedcontent></selectedcontent></button><option value=https://learning-rust.github.io/><span aria-hidden><i aria-hidden>üè° </i></span><span>Home</span></option><option value=https://learning-rust.github.io/docs/ selected><span aria-hidden><i aria-hidden>üìñ </i></span><span>Documentation</span></option></select></nav><main><article><nav><button class=btn><i>‚¨ÖÔ∏è</i> On this section</button>
<button class=btn>On this page <i>‚û°Ô∏è</i></button></nav><header><h1>Primitive Data Types</h1></header><div id=article-body><h2 id=bool>bool</h2><p>true or false</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>b</span>: <span class=kt>bool</span> <span class=o>=</span><span class=w> </span><span class=kc>false</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// ‚≠êÔ∏è no TRUE, FALSE, 1, 0
</span></span></span></code></pre></div><p>bool is a single byte(8 bits) in size.</p><h2 id=char>char</h2><p>A single Unicode scalar value</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=sc>&#39;x&#39;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>b</span>: <span class=kt>char</span> <span class=o>=</span><span class=w> </span><span class=sc>&#39;üòé&#39;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// ‚≠êÔ∏è no &#34;x&#34;, only single quotes
</span></span></span></code></pre></div><p>Because of Unicode support, char is not a single byte, but four(32 bits).</p><h2 id=i8-i16-i32-i64-i128>i8, i16, i32, i64, i128</h2><p>8, 16, 32, 64 and 128 bit fixed sized signed(+/-) integer types</p><table><thead><tr><th>DATA TYPE</th><th>MIN</th><th>MAX</th></tr></thead><tbody><tr><td>i8</td><td>-128</td><td>127</td></tr><tr><td>i16</td><td>-32768</td><td>32767</td></tr><tr><td>i32</td><td>-2147483648</td><td>2147483647</td></tr><tr><td>i64</td><td>-9223372036854775808</td><td>9223372036854775807</td></tr><tr><td>i128</td><td>-170141183460469231731687303715884105728</td><td>170141183460469231731687303715884105727</td></tr></tbody></table><p>üí° The min and max values are based on the following equation; <strong>from -(2‚Åø‚Åª¬π) to 2‚Åø‚Åª¬π-1</strong>. You can use <strong><code>MIN</code></strong> and <strong><code>MAX</code></strong> constants to find min and max of each integer type. ex.<code>i8::MIN;</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>10</span><span class=p>;</span><span class=w> </span><span class=c1>// ‚≠êÔ∏è The default integer type in Rust is i32
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>b</span>: <span class=kt>i8</span> <span class=o>=</span><span class=w> </span><span class=o>-</span><span class=mi>128</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><h2 id=u8-u16-u32-u64-u128>u8, u16, u32, u64, u128</h2><p>8, 16, 32, 64 and 128 bit fixed sized unsigned(0/+) integer types</p><table><thead><tr><th>DATA TYPE</th><th>MIN</th><th>MAX</th></tr></thead><tbody><tr><td>u8</td><td>0</td><td>255</td></tr><tr><td>u16</td><td>0</td><td>65535</td></tr><tr><td>u32</td><td>0</td><td>4294967295</td></tr><tr><td>u64</td><td>0</td><td>18446744073709551615</td></tr><tr><td>u128</td><td>0</td><td>340282366920938463463374607431768211455</td></tr></tbody></table><p>üí° The min and max values are based on the following equation; <strong>from 0 to 2‚Åø-1</strong>. Same way you can use <strong><code>MIN</code></strong> and <strong><code>MAX</code></strong> constants to find min and max of each integer type. ex.<code>u8::MAX</code></p><h2 id=isize-usize>isize, usize</h2><p>Pointer sized signed and unsigned integer types</p><p>The actual bit size depends on the computer architecture you are compiling your program for. By default, the sizes are equal to 32 bits on 32-bit platforms and 64 bits on 64-bit platforms. You can use <strong><code>MIN</code></strong> and <strong><code>MAX</code></strong> constants to find min and max of each integer type. ex.<code>isize::MAX</code>.</p><blockquote><p>üîé Search more about <a href=https://rust-lang.github.io/rustup/cross-compilation.html target=_blank>cross-compiling</a> and <a href=https://doc.rust-lang.org/nightly/rustc/platform-support.html target=_blank>supported tiers</a> of Rust programs.</p></blockquote><h2 id=f32-f64>f32, f64</h2><p>32 and 64 bit sized floating point numbers(numbers with decimal points)</p><p>Rust follows IEEE Standard for Binary Floating-Point Arithmetic. The <code>f32</code> type is similar to float(<strong>Single precision</strong>) in other languages, while <code>f64</code> is similar to double(<strong>Double precision</strong>) in other languages.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mf>1.5</span><span class=p>;</span><span class=w> </span><span class=c1>// ‚≠êÔ∏è The default float type in Rust is f64
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>b</span>: <span class=kt>f64</span> <span class=o>=</span><span class=w> </span><span class=mf>2.0</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p>üí° Should avoid using <code>f32</code>, unless you need to reduce memory consumption badly or if you are doing low-level optimization, when targeted hardware does not support for double-precision or when single-precision is faster than double-precision on it.</p><h2 id=array>Array</h2><p>Fixed size list of elements of same data type</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>[</span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>,</span><span class=w> </span><span class=mi>3</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>b</span>: <span class=p>[</span><span class=kt>i32</span><span class=p>;</span><span class=w> </span><span class=mi>3</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>[</span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>,</span><span class=w> </span><span class=mi>3</span><span class=p>];</span><span class=w> </span><span class=c1>// with the data type üí° [Type; NO of elements]
</span></span></span><span class=line><span class=cl><span class=c1>// üí°let b: [i32; 3] = [1, 2]; // Compiling error : mismatched types : expected an array with a size of 3, found one with a size of 2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>c</span>: <span class=p>[</span><span class=kt>i32</span><span class=p>;</span><span class=w> </span><span class=mi>0</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>[];</span><span class=w> </span><span class=c1>// An empty array
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// Accessing and changing elements
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>a</span>: <span class=p>[</span><span class=kt>i32</span><span class=p>;</span><span class=w> </span><span class=mi>3</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>[</span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>,</span><span class=w> </span><span class=mi>3</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>a</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>2</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>a</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>4</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>a</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>6</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// Printing with debug and pretty-print debug specifiers
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{a:?}</span><span class=s>&#34;</span><span class=p>);</span><span class=w> </span><span class=c1>// [2, 4, 6]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{a:#?}</span><span class=s>&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//  [
</span></span></span><span class=line><span class=cl><span class=c1>//      2,
</span></span></span><span class=line><span class=cl><span class=c1>//      4,
</span></span></span><span class=line><span class=cl><span class=c1>//      6,
</span></span></span><span class=line><span class=cl><span class=c1>//  ]
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>[</span><span class=mi>0</span><span class=p>;</span><span class=w> </span><span class=mi>5</span><span class=p>];</span><span class=w>   </span><span class=c1>// [0, 0, 0, 0, 0]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>[</span><span class=s>&#34;x&#34;</span><span class=p>;</span><span class=w> </span><span class=mi>5</span><span class=p>];</span><span class=w> </span><span class=c1>// [&#34;x&#34;, &#34;x&#34;, &#34;x&#34;, &#34;x&#34;, &#34;x&#34;]
</span></span></span></code></pre></div><p>‚≠êÔ∏è Arrays are <strong>immutable</strong> by default and <strong>even with <code>mut</code>, its element count cannot be changed</strong>.</p><blockquote><p>üîé If you are looking for a dynamic/ growable array, you can use <a href=/docs/vectors>vectors</a>. Vectors can contain any type of elements but all elements must be in the same data type.</p></blockquote><h2 id=tuple>Tuple</h2><p>Fixed size ordered list of elements of different(or same) data types</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mf>1.5</span><span class=p>,</span><span class=w> </span><span class=kc>true</span><span class=p>,</span><span class=w> </span><span class=sc>&#39;a&#39;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>b</span>: <span class=p>(</span><span class=kt>i32</span><span class=p>,</span><span class=w> </span><span class=kt>f64</span><span class=p>,</span><span class=w> </span><span class=kt>bool</span><span class=p>,</span><span class=w> </span><span class=kt>char</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mf>1.5</span><span class=p>,</span><span class=w> </span><span class=kc>true</span><span class=p>,</span><span class=w> </span><span class=sc>&#39;a&#39;</span><span class=p>);</span><span class=w> </span><span class=c1>// With the data types
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=mi>0</span><span class=p>,);</span><span class=w> </span><span class=c1>// single-element tuple
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// Accessing and changing elements
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mf>1.5</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>a</span><span class=p>.</span><span class=mi>0</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>2</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>a</span><span class=p>.</span><span class=mi>1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mf>3.0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// Printing with debug and pretty-print debug specifiers
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{a:?}</span><span class=s>&#34;</span><span class=p>);</span><span class=w> </span><span class=c1>// (2, 3.0)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{a:#?}</span><span class=s>&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// (
</span></span></span><span class=line><span class=cl><span class=c1>//   2,
</span></span></span><span class=line><span class=cl><span class=c1>//   3.0,
</span></span></span><span class=line><span class=cl><span class=c1>// )
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// Destructuring
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mf>1.5</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>b</span><span class=p>,</span><span class=w> </span><span class=n>c</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>a</span><span class=p>;</span><span class=w> </span><span class=c1>// b = 1, c = 1.5
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mf>1.5</span><span class=p>,</span><span class=w> </span><span class=kc>true</span><span class=p>,</span><span class=w> </span><span class=sc>&#39;a&#39;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>b</span><span class=p>,</span><span class=w> </span><span class=n>_</span><span class=p>,</span><span class=w> </span><span class=n>_</span><span class=p>,</span><span class=w> </span><span class=n>c</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>a</span><span class=p>;</span><span class=w> </span><span class=c1>// b = 1, c = &#39;a&#39;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>b</span><span class=p>,</span><span class=w> </span><span class=o>..</span><span class=p>,</span><span class=w> </span><span class=n>c</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>a</span><span class=p>;</span><span class=w> </span><span class=c1>// b = 1, c = &#39;a&#39;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>,</span><span class=w> </span><span class=mi>3</span><span class=p>,</span><span class=w> </span><span class=kc>true</span><span class=p>,</span><span class=w> </span><span class=kc>false</span><span class=p>,</span><span class=w> </span><span class=sc>&#39;a&#39;</span><span class=p>,</span><span class=w> </span><span class=sc>&#39;b&#39;</span><span class=p>,</span><span class=w> </span><span class=sc>&#39;c&#39;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>b</span><span class=p>,</span><span class=w> </span><span class=o>..</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>a</span><span class=p>;</span><span class=w> </span><span class=c1>// b = 1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=o>..</span><span class=p>,</span><span class=w> </span><span class=n>c</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>a</span><span class=p>;</span><span class=w> </span><span class=c1>// c = &#39;c&#39;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>e</span><span class=p>,</span><span class=w> </span><span class=n>f</span><span class=p>,</span><span class=w> </span><span class=n>g</span><span class=p>,</span><span class=w> </span><span class=o>..</span><span class=p>,</span><span class=w> </span><span class=n>h</span><span class=p>,</span><span class=w> </span><span class=n>i</span><span class=p>,</span><span class=w> </span><span class=n>j</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>a</span><span class=p>;</span><span class=w> </span><span class=c1>// 1 2 3 &#39;a&#39; &#39;b&#39; &#39;c&#39;
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// Nesting
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mf>1.5</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=p>(</span><span class=mi>2</span><span class=p>,</span><span class=w> </span><span class=mi>4</span><span class=p>),</span><span class=w> </span><span class=mi>6</span><span class=p>);</span><span class=w> </span><span class=c1>// ((1, 1.5), (2, 4), 6)
</span></span></span></code></pre></div><p>‚≠êÔ∏è Tuples are also <strong>immutable</strong> by default and <strong>even with <code>mut</code>, its element count cannot be changed. Also, if you want to change an element‚Äôs value, the new value should have the same data type of previous value</strong>.</p><h2 id=slice>Slice</h2><p>Dynamically-sized reference to another data structure</p><p>Imagine you want to get/ pass a part of an array or any other data structure. Instead of copying it to another array (or same data structure), Rust allows for creating a view/ reference to access only that part of the data. This view/ reference can be mutable or immutable.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>a</span>: <span class=p>[</span><span class=kt>i32</span><span class=p>;</span><span class=w> </span><span class=mi>4</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>[</span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>,</span><span class=w> </span><span class=mi>3</span><span class=p>,</span><span class=w> </span><span class=mi>4</span><span class=p>];</span><span class=w> </span><span class=c1>// Parent Array
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// Slice whole array
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>b</span>: <span class=kp>&amp;</span><span class=p>[</span><span class=kt>i32</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>a</span><span class=p>;</span><span class=w> </span><span class=c1>// data type is optional
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>a</span><span class=p>[</span><span class=mi>0</span><span class=o>..</span><span class=mi>4</span><span class=p>];</span><span class=w> </span><span class=c1>// From 0th position to 4th(excluding)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>d</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>a</span><span class=p>[</span><span class=o>..</span><span class=p>];</span><span class=w> </span><span class=c1>// high or low bounds are optional
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// Slicing part of the array
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>e</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>a</span><span class=p>[</span><span class=mi>1</span><span class=o>..</span><span class=mi>3</span><span class=p>];</span><span class=w> </span><span class=c1>// [2, 3]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>a</span><span class=p>[</span><span class=mi>1</span><span class=o>..</span><span class=p>];</span><span class=w> </span><span class=c1>// [2, 3, 4]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>g</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>a</span><span class=p>[</span><span class=o>..</span><span class=mi>3</span><span class=p>];</span><span class=w> </span><span class=c1>// [1, 2, 3]
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// directly creating a slice
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>h</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=p>[</span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>h</span>: <span class=kp>&amp;</span><span class=p>[</span><span class=kt>i32</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=p>[</span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>];</span><span class=w> </span><span class=c1>// with the datatype
</span></span></span></code></pre></div><h2 id=str>str</h2><p>Unsized UTF-8 sequence of Unicode string slices</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;Hello, world.&#34;</span><span class=p>;</span><span class=w> </span><span class=c1>// a: &amp;&#39;static str
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>b</span>: <span class=kp>&amp;</span><span class=kt>str</span> <span class=o>=</span><span class=w> </span><span class=s>&#34;„Åì„Çì„Å´„Å°„ÅØ, ‰∏ñÁïå!&#34;</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p><code>str</code> is a UTF-8 sequence of Unicode string slice; It&rsquo;s unsized. You can‚Äôt create a variable of type <code>str</code> directly because Rust needs to know sizes at compile time. So, it must always be used behind a pointer ‚Äî like <code>&amp;str</code>, <code>Box&lt;str></code>, or <code>Rc&lt;str></code>.</p><p><code>&amp;str</code> is a fat pointer (a pointer to str and a length). So, it&rsquo;s a sized reference that carries both a pointer and a length.</p><p><code>&'static str</code> is an <code>&amp;str</code> that is statically allocated directly to the read-only data segment in the program binary. The <code>'static</code> lifetime means it lives for the entire program duration.</p><blockquote><p>üíØ <a href=https://doc.rust-lang.org/std/string/struct.String.html target=_blank><code>String</code></a> type is a growable, heap-allocated, UTF-8 encoded string, which can be generated from a <code>&amp;str</code> type, via <a href=https://doc.rust-lang.org/std/string/trait.ToString.html target=_blank><code>to_string()</code></a>, <a href=https://doc.rust-lang.org/std/borrow/trait.ToOwned.html target=_blank><code>to_owned()</code></a> or <a href=https://doc.rust-lang.org/std/string/struct.String.html#method.from target=_blank><code>String::from()</code></a> methods. With <a href><code>as_str()</code></a> method, a <code>String</code> type can be converted to a <code>&amp;str</code> type.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>s</span>: <span class=kp>&amp;</span><span class=kt>str</span> <span class=o>=</span><span class=w> </span><span class=s>&#34;Hello&#34;</span><span class=p>;</span><span class=w> </span><span class=c1>// &amp;str
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>s</span><span class=p>.</span><span class=n>to_string</span><span class=p>();</span><span class=w> </span><span class=c1>// String
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>s</span><span class=p>.</span><span class=n>to_owned</span><span class=p>();</span><span class=w> </span><span class=c1>// String
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>String</span>::<span class=n>from</span><span class=p>(</span><span class=n>s</span><span class=p>);</span><span class=w> </span><span class=c1>// String
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>String</span>::<span class=n>from</span><span class=p>(</span><span class=s>&#34;Hello&#34;</span><span class=p>);</span><span class=w> </span><span class=c1>// String
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>a</span><span class=p>.</span><span class=n>as_str</span><span class=p>();</span><span class=w> </span><span class=c1>// &amp;str
</span></span></span></code></pre></div><p>In the above examples, creating a <code>String</code> from a string slice (<code>&amp;str</code> like <code>"Hello"</code>) via both <code>.to_string()</code> and <code>.to_owned()</code>
are functionally identical. Both call <code>String::from(self)</code> for <code>&amp;str</code>.</p></blockquote><p>üí° In general, you should use <code>String</code> when you need <a href=/docs/ownership><code>ownership</code></a>, and <code>&amp;str</code> when you just need to borrow a string.</p><h2 id=function>Function</h2><p><code>p1</code> is a function pointer to <code>plus_one()</code> in the following code.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>p1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>plus_one</span><span class=p>;</span><span class=w> </span><span class=c1>// Without type declarations
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>p1</span><span class=p>(</span><span class=mi>5</span><span class=p>);</span><span class=w> </span><span class=c1>// 6
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>p1</span>: <span class=nc>fn</span><span class=p>(</span><span class=kt>i32</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>i32</span> <span class=o>=</span><span class=w> </span><span class=n>plus_one</span><span class=p>;</span><span class=w> </span><span class=c1>// With the type declarations
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>p1</span><span class=p>(</span><span class=mi>5</span><span class=p>);</span><span class=w> </span><span class=c1>// 6
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>plus_one</span><span class=p>(</span><span class=n>i</span>: <span class=kt>i32</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>i32</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>i</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mi>1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><hr><h2 id=type-inference>Type Inference</h2><p>The Rust compiler can infer the data type when we don&rsquo;t explicitly specify it. For example, in Rust, the default integer type is <code>i32</code> and the default float type is <code>f64</code>. However, the Rust compiler checks the usage and determines the best data type based on the context.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>10</span><span class=p>;</span><span class=w>   </span><span class=c1>// type inference: i32
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mf>3.14</span><span class=p>;</span><span class=w> </span><span class=c1>// type inference: f64
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w> </span><span class=c1>// type inference: bool
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>8</span><span class=p>;</span><span class=w> </span><span class=c1>// type inference: i8
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>plus_one</span><span class=p>(</span><span class=n>a</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>plus_one</span><span class=p>(</span><span class=n>i</span>: <span class=kt>i8</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>i8</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>i</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mi>1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h2 id=default-byte-sizes-of-data-types>Default Byte Sizes of Data Types</h2><p>We can check the default byte sizes of data types via <code>std::mem::size_of</code>. For example: <code>size_of::&lt;bool>()</code>, <code>size_of::&lt;f32>()</code>, <code>size_of::&lt;&amp;str>()</code>, etc.</p><table><thead><tr><th>Data type</th><th>bytes</th><th>bits</th></tr></thead><tbody><tr><td>bool</td><td>1</td><td>8</td></tr><tr><td>char</td><td>4</td><td>32</td></tr><tr><td>i8 i16 i32 i64 i128</td><td>1, 2, 4, 8, 16</td><td>8, 16, 32, 64, 128</td></tr><tr><td>u8 u16 u32 u64 u128</td><td>1, 2, 4, 8, 16</td><td>8, 16, 32, 64, 128</td></tr><tr><td>isize usize</td><td>8, 8</td><td>64, 64</td></tr><tr><td>f32 f64</td><td>4, 8</td><td>32, 64</td></tr><tr><td>&amp;str</td><td>16</td><td>128</td></tr></tbody></table><h2 id=-before-going-to-the-next>üë®‚Äçüè´ Before going to the next&mldr;</h2><ul><li><p>Other than adding the type annotations to the variables, <strong>for numeric types</strong>, we can append the data type directly to the value as the suffix. Also, to improve the readability of long numbers, we can use <code>_</code> as a divider.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>5</span><span class=k>i8</span><span class=p>;</span><span class=w> </span><span class=c1>// Equals to `let a: i8 = 5;`
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>100_000_000</span><span class=p>;</span><span class=w> </span><span class=c1>// Equals to `let b = 100000000;`
</span></span></span><span class=line><span class=cl><span class=c1>// üí° The placements of _s are not strict. ex. 10000_0000 is also valid.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>pi</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mf>3.141_592_653_59_</span><span class=k>f64</span><span class=p>;</span><span class=w> </span><span class=c1>// Equals to `let pi: f64 = 3.14159265359`
</span></span></span><span class=line><span class=cl><span class=c1>// üí° make sure group digits consistently by underscores avoid warnings
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>const</span><span class=w> </span><span class=no>PI</span>: <span class=kt>f64</span> <span class=o>=</span><span class=w> </span><span class=mf>3.141_592_653_59</span><span class=p>;</span><span class=w> </span><span class=c1>// In the constants and statics, the data type must be annotated in the beginning.
</span></span></span></code></pre></div></li></ul></div><footer><time datetime=2025-11-03><i>üïí</i> Updated: 2025-11-03</time>
<a href=https://learning-rust.github.io/docs/functions/><i>&#8249;</i> Previous</a>
<a href=https://learning-rust.github.io/docs/operators/>Next <i>&#8250;</i></a></footer></article><aside><div><button class=btn><i>‚ùå</i>Close</button></div><strong>On this page</strong><nav id=TableOfContents><ul><li><a href=#bool>bool</a></li><li><a href=#char>char</a></li><li><a href=#i8-i16-i32-i64-i128>i8, i16, i32, i64, i128</a></li><li><a href=#u8-u16-u32-u64-u128>u8, u16, u32, u64, u128</a></li><li><a href=#isize-usize>isize, usize</a></li><li><a href=#f32-f64>f32, f64</a></li><li><a href=#array>Array</a></li><li><a href=#tuple>Tuple</a></li><li><a href=#slice>Slice</a></li><li><a href=#str>str</a></li><li><a href=#function>Function</a></li><li><a href=#type-inference>Type Inference</a></li><li><a href=#default-byte-sizes-of-data-types>Default Byte Sizes of Data Types</a></li><li><a href=#-before-going-to-the-next>üë®‚Äçüè´ Before going to the next&mldr;</a></li></ul></nav></aside></main><footer><div><i>üßë‚Äçüíª</i>Built by and copyright<a href=https://github.com/dumindu target=_blank>Dumindu Madunuwan</a><i>üìÖ</i> 2016-2025<i>üöÄ</i> <a href=https://github.com/learning-rust target=_blank>GitHub</a></div><div><button class=btn><i>‚òÄÔ∏è</i><i>‚ÅÑ</i><i>üåë</i></button></div></footer></div></div><div id=body-model-outer></div><script type=text/javascript src=/assets/js/docs.min.12ffdc25c0149ef34e761ee54587f2aae17affcb8375298ad2180851930cb142.js integrity></script></body></html>