<!doctype html><html lang=en-US><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Rust Programming Language Tutorials for Everyone!"><meta name=author content="Dumindu Madunuwan"><meta name=theme-color content="#ffffff" media="(prefers-color-scheme: light)"><meta name=theme-color content="#101010" media="(prefers-color-scheme: dark)"><title>Functions Â· Learning Rust</title><link rel=canonical href=https://learning-rust.github.io/docs/functions/><link rel=stylesheet href=/assets/css/docs.min.eba769c619f5edb1a317c0125024f8324a47a133eb05309d506ac8c8cc59d354.css integrity><link rel=manifest href=/manifest.json><link rel=icon href=/favicon/favicon.ico><link rel=icon href=/favicon/favicon-16x16.png sizes=16x16 type=image/png><link rel=icon href=/favicon/favicon-32x32.png sizes=32x32 type=image/png><link rel=apple-touch-icon href=/favicon/apple-touch-icon.png sizes=180x180><script async src="https://www.googletagmanager.com/gtag/js?id=G-FZHQCXSZ89"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-FZHQCXSZ89")</script><meta property="og:title" content="Functions"><meta property="og:description" content="Functions - Rust Programming Language Tutorials for Everyone!"><meta property="og:type" content="article"><meta property="og:url" content="https://learning-rust.github.io/docs/functions/"><meta property="og:image" content="https://learning-rust.github.io/docs/functions/og.png"><meta property="og:site_name" content="Learning Rust"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="Functions"><meta name=twitter:description content="Functions - Rust Programming Language Tutorials for Everyone!"><meta name=twitter:image content="https://learning-rust.github.io/docs/functions/og.png"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Article","headline":"Functions","description":"Functions - Rust Programming Language Tutorials for Everyone!","image":"https:\/\/learning-rust.github.io\/docs\/functions\/og.png","author":{"@type":"Person","name":"Dumindu Madunuwan","url":"https:\/\/github.com\/dumindu"},"publisher":{"@type":"Organization","name":"Learning Rust","logo":{"@type":"ImageObject","url":"https:\/\/learning-rust.github.io\/"}},"dateModified":"2025-10-30T20:23:09Z","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/learning-rust.github.io\/docs\/functions\/"}}</script></head><body><div id=outer-wrapper><div id=aside-wrapper><aside><div><button class=btn><i>âŒ</i>Close</button></div><a href=https://learning-rust.github.io/ class=site-logo>Learning Rust</a><nav role=navigation><details open><summary>Documentation</summary><ul><li><a href=https://learning-rust.github.io/docs/overview/>Overview</a></li></ul></details><details open><summary>Basics</summary><ul><li><a href=https://learning-rust.github.io/docs/why-rust/>Why Rust?</a></li><li><a href=https://learning-rust.github.io/docs/installation/>Installation</a></li><li><a href=https://learning-rust.github.io/docs/hello-world/>Hello World</a></li><li><a href=https://learning-rust.github.io/docs/cargo-crates-and-basic-project-structure/>Cargo, Crates and Basic Project Structure</a></li><li><a href=https://learning-rust.github.io/docs/comments-and-documenting-the-code/>Comments and Documenting the code</a></li><li><a href=https://learning-rust.github.io/docs/variable-bindings-constants-and-statics/>Variable bindings, Constants and Statics</a></li><li><a class=active href=https://learning-rust.github.io/docs/functions/>Functions</a></li><li><a href=https://learning-rust.github.io/docs/primitive-data-types/>Primitive Data Types</a></li><li><a href=https://learning-rust.github.io/docs/operators/>Operators</a></li><li><a href=https://learning-rust.github.io/docs/control-flows/>Control Flows</a></li></ul></details><details open><summary>Beyond The Basics</summary><ul><li><a href=https://learning-rust.github.io/docs/vectors/>Vectors</a></li><li><a href=https://learning-rust.github.io/docs/structs/>Structs</a></li><li><a href=https://learning-rust.github.io/docs/enums/>Enums</a></li><li><a href=https://learning-rust.github.io/docs/generics/>Generics</a></li><li><a href=https://learning-rust.github.io/docs/impls-and-traits/>Impls and Traits</a></li></ul></details><details open><summary>The Tough Part</summary><ul><li><a href=https://learning-rust.github.io/docs/ownership/>Ownership</a></li><li><a href=https://learning-rust.github.io/docs/borrowing/>Borrowing</a></li><li><a href=https://learning-rust.github.io/docs/lifetimes/>Lifetimes</a></li></ul></details><details open><summary>Let's Get It Started</summary><ul><li><a href=https://learning-rust.github.io/docs/modules/>Modules</a></li><li><a href=https://learning-rust.github.io/docs/crates/>Crates</a></li><li><a href=https://learning-rust.github.io/docs/workspaces/>Workspaces</a></li><li><a href=https://learning-rust.github.io/docs/use/>Use</a></li><li><a href=https://learning-rust.github.io/docs/std-primitives-and-preludes/>STD, Primitives and Preludes</a></li></ul></details><details open><summary>Error Handling</summary><ul><li><a href=https://learning-rust.github.io/docs/smart-compiler/>Smart Compiler</a></li><li><a href=https://learning-rust.github.io/docs/panicking/>Panicking</a></li><li><a href=https://learning-rust.github.io/docs/option-and-result/>Option and Result</a></li><li><a href=https://learning-rust.github.io/docs/unwrap-and-expect/>Unwrap and Expect</a></li><li><a href=https://learning-rust.github.io/docs/error-and-none-propagation/>Error and None Propagation</a></li><li><a href=https://learning-rust.github.io/docs/combinators/>Combinators</a></li><li><a href=https://learning-rust.github.io/docs/custom-error-types/>Custom Error Types</a></li></ul></details></nav></aside></div><div id=content-wrapper><header><a href=https://learning-rust.github.io/ class=site-logo>Learning Rust</a></header><nav role=navigation><select onchange="this.value&&(window.location.href=this.value)"><button>
<selectedcontent></selectedcontent></button><option value=https://learning-rust.github.io/><span aria-hidden><i aria-hidden>ğŸ¡ </i></span><span>Home</span></option><option value=https://learning-rust.github.io/docs/ selected><span aria-hidden><i aria-hidden>ğŸ“– </i></span><span>Documentation</span></option></select></nav><main><article><nav><button class=btn><i>â¬…ï¸</i> On this section</button>
<button class=btn>On this page <i>â¡ï¸</i></button></nav><header><h1>Functions</h1></header><div id=article-body><h2 id=named-functions>Named Functions</h2><ul><li>Named functions are declared with the keyword <strong><code>fn</code></strong></li><li>When using <strong>arguments</strong>, we <strong>must declare the data types</strong>.</li><li>By default, functions <strong>return an empty <a href=/docs/primitive-data-types/#tuple>tuple</a>/ <code>()</code></strong>. If you want to return a value, the <strong>return type must be specified</strong> after <strong><code>-></code></strong></li></ul><h3 id=hello-world>Hello world</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;Hello, world!&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h3 id=passing-arguments>Passing Arguments</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>print_sum</span><span class=p>(</span><span class=n>a</span>: <span class=kt>i8</span><span class=p>,</span><span class=w> </span><span class=n>b</span>: <span class=kt>i8</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;sum is: </span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>b</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h3 id=returning-values>Returning Values</h3><ul><li><p>Without the <code>return</code> keyword. Only the last expression returns.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>plus_one</span><span class=p>(</span><span class=n>a</span>: <span class=kt>i32</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>i32</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>a</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mi>1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// There is no ending ; in the above line.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=c1>// It means this is an expression which equals to `return a + 1;`.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div></li><li><p>With the <code>return</code> keyword.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>plus_two</span><span class=p>(</span><span class=n>a</span>: <span class=kt>i32</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>i32</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mi>2</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Should use return keyword only on conditional/ early returns.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=c1>// Using return keyword in the last expression is a bad practice.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div></li></ul><h3 id=function-pointers-as-a-data-type>Function Pointers as a Data Type</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>p1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>plus_one</span><span class=p>;</span><span class=w> </span><span class=c1>// Without type declarations
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>p1</span><span class=p>(</span><span class=mi>5</span><span class=p>);</span><span class=w> </span><span class=c1>// 6
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>p1</span>: <span class=nc>fn</span><span class=p>(</span><span class=kt>i32</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>i32</span> <span class=o>=</span><span class=w> </span><span class=n>plus_one</span><span class=p>;</span><span class=w> </span><span class=c1>// With the type declarations
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>p1</span><span class=p>(</span><span class=mi>5</span><span class=p>);</span><span class=w> </span><span class=c1>// 6
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>plus_one</span><span class=p>(</span><span class=n>i</span>: <span class=kt>i32</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>i32</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>i</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mi>1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h2 id=closures>Closures</h2><ul><li>Also known as <strong>anonymous functions</strong> or <strong>lambda functions</strong>.</li><li>The <strong>data types of arguments and returns are optional <a href=#iv-without-optional-type-declarations-creating-and-calling-together>âƒ°â±áµ›</a></strong>.</li></ul><p>Example with a named function, before using closures.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>2</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>get_square_value</span><span class=p>(</span><span class=n>x</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>get_square_value</span><span class=p>(</span><span class=n>i</span>: <span class=kt>i32</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>i32</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>i</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>i</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h3 id=with-optional-type-annotations>With Optional Type Annotations</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>2</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>square</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>|</span><span class=n>i</span>: <span class=kt>i32</span><span class=o>|</span><span class=w> </span>-&gt; <span class=kt>i32</span> <span class=p>{</span><span class=w> </span><span class=c1>// Input parameters are passed inside | | and expression body is wrapped within { }
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=n>i</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>i</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>square</span><span class=p>(</span><span class=n>x</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h3 id=without-type-annotations>Without Type Annotations</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>2</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>square</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>|</span><span class=n>i</span><span class=o>|</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>i</span><span class=p>;</span><span class=w> </span><span class=c1>// { } are optional for single-lined closures
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>square</span><span class=p>(</span><span class=n>x</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h3 id=with-optional-type-annotations-define-and-call-together>With Optional Type Annotations; Define and Call Together</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>2</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>x_square</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>|</span><span class=n>i</span>: <span class=kt>i32</span><span class=o>|</span><span class=w> </span>-&gt; <span class=kt>i32</span> <span class=p>{</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=p>}(</span><span class=n>x</span><span class=p>);</span><span class=w> </span><span class=c1>// { } are mandatory while creating and calling same time.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>x_square</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h3 id=without-type-annotations-define-and-call-together>Without Type Annotations; Define and Call Together</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>2</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>x_square</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>|</span><span class=n>i</span><span class=o>|</span><span class=w> </span>-&gt; <span class=kt>i32</span> <span class=p>{</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=p>}(</span><span class=n>x</span><span class=p>);</span><span class=w> </span><span class=c1>// â­ï¸ The return type is mandatory.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>x_square</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h2 id=test-functions>Test Functions</h2><ul><li>Start the function name with the <code>test_</code> prefix.</li><li>Add with the <code>#[test]</code> attribute, inside a <code>tests</code> module with the <code>#[cfg(test)]</code> attribute.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>greet</span><span class=p>()</span><span class=w> </span>-&gt; <span class=nb>String</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=s>&#34;Hello, world!&#34;</span><span class=p>.</span><span class=n>to_string</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cp>#[cfg(test)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>mod</span> <span class=nn>tests</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>use</span><span class=w> </span><span class=k>super</span>::<span class=n>greet</span><span class=p>;</span><span class=w> </span><span class=c1>// ğŸ’¡ Reimport the greet() function from the parent module.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>test_greet</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=c1>// The test function of greet()
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=s>&#34;Hello, world!&#34;</span><span class=p>,</span><span class=w> </span><span class=n>greet</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h2 id=-before-going-to-the-next>ğŸ‘¨â€ğŸ« Before going to the next&mldr;</h2><ul><li><p>ğŸ’¯ Usage of <code>::</code> and <code>.</code> to call functions in different modules,</p><blockquote><p>ğŸ’­ This is a quick reference about the usage of <code>::</code> and <code>.</code> operators while calling functions. So, please donâ€™t worry about <a href=/docs/structs>structs</a>, <a href=/docs/enums>enums</a>, <a href=/docs/impls-and-traits>traits</a>, or <a href=/docs/impls-and-traits>impls</a> for now. We will discuss them later.</p></blockquote><ul><li><p><strong>Functions</strong> are standalone blocks of code, declare with the <code>fn</code> keyword.</p></li><li><p><strong>Associated functions</strong> are functions that are associated with a particular data type such as structs, enums, or traits via an <strong><code>impl</code></strong> block.</p></li><li><p><strong>Methods</strong> are associated functions with a receiver of <code>self</code>, <code>&amp;self</code>, <code>&amp;mut self</code>, <code>self: Box&lt;Self></code> etc.</p></li></ul><blockquote><p>â­ï¸ To call methods: use the <code>.</code> operator from an instance. ex. <code>steve.intro_name()</code></p><p>â­ï¸ To call associated functions that are not methods: use the <code>::</code> operator from the data type. ex. <code>Person::new()</code>, <code>String::from()</code></p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Person</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>name</span>: <span class=nb>String</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>company_name</span>: <span class=nb>String</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>Person</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=c1>// ğŸ’¡ impls are used to define functions in Rust structs, enums, etc.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=c1>// ğŸ’¡ The constructor (new` is a conventional name, not a keyword)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=k>fn</span> <span class=nf>new</span><span class=p>(</span><span class=n>name</span>: <span class=nb>String</span><span class=p>,</span><span class=w> </span><span class=n>company_name</span>: <span class=nb>String</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Person</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=c1>// an associated function and not a method
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=n>Person</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=n>company_name</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>intro_name</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>String</span> <span class=p>{</span><span class=w> </span><span class=c1>// ğŸ’¡ a method
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=fm>format!</span><span class=p>(</span><span class=s>&#34;I&#39;m </span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>name</span><span class=p>)</span><span class=w> </span><span class=c1>// ğŸ’¡ access fields via `.` operator
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>intro_company</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>String</span> <span class=p>{</span><span class=w> </span><span class=c1>// ğŸ’¡ a method
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=fm>format!</span><span class=p>(</span><span class=s>&#34;I&#39;m from </span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>company_name</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// ğŸ’¡ calling associated functions with `::` operator
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>steve</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Person</span>::<span class=n>new</span><span class=p>(</span><span class=nb>String</span>::<span class=n>from</span><span class=p>(</span><span class=s>&#34;Steve Jobs&#34;</span><span class=p>),</span><span class=w> </span><span class=nb>String</span>::<span class=n>from</span><span class=p>(</span><span class=s>&#34;Apple&#34;</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// ğŸ’¡ calling methods with `.` operator
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{}</span><span class=s>. </span><span class=si>{}</span><span class=s>.&#34;</span><span class=p>,</span><span class=w> </span><span class=n>steve</span><span class=p>.</span><span class=n>intro_name</span><span class=p>(),</span><span class=w> </span><span class=n>steve</span><span class=p>.</span><span class=n>intro_company</span><span class=p>());</span><span class=w> </span><span class=c1>// I&#39;m Steve Jobs. I&#39;m from Apple.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// â­ï¸ methods are also associated functions. So, we can call them with `::` operator as well but need to pass the instance as a parameter.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{}</span><span class=s>. </span><span class=si>{}</span><span class=s>.&#34;</span><span class=p>,</span><span class=w> </span><span class=n>Person</span>::<span class=n>intro_name</span><span class=p>(</span><span class=o>&amp;</span><span class=n>steve</span><span class=p>),</span><span class=w> </span><span class=n>Person</span>::<span class=n>intro_company</span><span class=p>(</span><span class=o>&amp;</span><span class=n>steve</span><span class=p>));</span><span class=w> </span><span class=c1>// I&#39;m Steve Jobs. I&#39;m from Apple.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><ul><li>Other than that, <code>::</code> operator is used to call functions in different modules.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>mod</span> <span class=nn>my_mod</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>greet</span><span class=p>(</span><span class=n>name</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;Hello, </span><span class=si>{name}</span><span class=s>!&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>my_mod</span>::<span class=n>greet</span><span class=p>(</span><span class=s>&#34;Steve Jobs&#34;</span><span class=p>);</span><span class=w> </span><span class=c1>// Hello, Steve Jobs!
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><blockquote><p>ğŸ” Refer <a href=/docs/operators/#path-separator-and-member-access-operators>path separator and member access operators</a> for more information about the usage of the <code>::</code> and <code>.</code> operators.</p></blockquote></li></ul></div><footer><time datetime=2025-10-30><i>ğŸ•’</i> Updated: 2025-10-30</time>
<a href=https://learning-rust.github.io/docs/variable-bindings-constants-and-statics/><i>&#8249;</i> Previous</a>
<a href=https://learning-rust.github.io/docs/primitive-data-types/>Next <i>&#8250;</i></a></footer></article><aside><div><button class=btn><i>âŒ</i>Close</button></div><strong>On this page</strong><nav id=TableOfContents><ul><li><a href=#named-functions>Named Functions</a><ul><li><a href=#hello-world>Hello world</a></li><li><a href=#passing-arguments>Passing Arguments</a></li><li><a href=#returning-values>Returning Values</a></li><li><a href=#function-pointers-as-a-data-type>Function Pointers as a Data Type</a></li></ul></li><li><a href=#closures>Closures</a><ul><li><a href=#with-optional-type-annotations>With Optional Type Annotations</a></li><li><a href=#without-type-annotations>Without Type Annotations</a></li><li><a href=#with-optional-type-annotations-define-and-call-together>With Optional Type Annotations; Define and Call Together</a></li><li><a href=#without-type-annotations-define-and-call-together>Without Type Annotations; Define and Call Together</a></li></ul></li><li><a href=#test-functions>Test Functions</a></li><li><a href=#-before-going-to-the-next>ğŸ‘¨â€ğŸ« Before going to the next&mldr;</a></li></ul></nav></aside></main><footer><div><i>ğŸ§‘â€ğŸ’»</i>Built by and copyright<a href=https://github.com/dumindu target=_blank>Dumindu Madunuwan</a><i>ğŸ“…</i> 2016-2025<i>ğŸš€</i> <a href=https://github.com/learning-rust target=_blank>GitHub</a></div><div><button class=btn><i>â˜€ï¸</i><i>â„</i><i>ğŸŒ‘</i></button></div></footer></div></div><div id=body-model-outer></div><script type=text/javascript src=/assets/js/docs.min.12ffdc25c0149ef34e761ee54587f2aae17affcb8375298ad2180851930cb142.js integrity></script></body></html>