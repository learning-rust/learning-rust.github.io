---
title: Generics
slug: generics
---

The core concept of Rust generics is abstraction over types. In other words, we can write code that can operate on any data type without specifying the exact type but uppercase letter (or [PascalCase](https://en.wikipedia.org/wiki/Camel_case) identifier). In the compile time Rust ensures the type safety and generates optimized code for each concrete type used in the code.

For example, 
- Instead of `x: u8` we use **`x: T`**. 
- And inform the compiler that `T` is a generic type (can be any type) by adding **`<T>`** at first.

> ğŸ’¡ Using T, U, V ... as generic type names is quite a convention. We can use any PascalCase names as well.

## Functions

### With One Generic Type

ğŸ’¡ For simplicity, `fn first` accepts two arguments of the same type `T` and returns the first argument. As we don't use the second argument in the function, we prefix it with `_`, to prevent `unused_variables` warning.

```rust
fn first<T>(x: T, _y: T) -> T { // ğŸ’¡ Instead of specific type, we use T and add <T> at first
    x
}

fn main() {
    let a: i8 = first(0, -1);
    let b: i32 = first(1, 2);
    let c: bool = first(true, false);
    let d: String = first("01".to_string(), "02".to_string());

    println!("{a} {b} {c} {d}"); // 0 1 true 01
}
```

### With Multiple Generic Types

```rust
fn first<T, U>(x: T, _y: U) -> T {
    x
}

fn main() {
    let a: i8 = first(0i8, -1i32); // x: i8, y: i32
    let b: i32 = first(1i32, 2i64); // x: i32, y: i64

    let c: bool = first(true, false); // x: bool, y: bool 
    // â­ï¸ Even funtions with multiple generic types, we can have same type.

    println!("{a} {b} {c}"); // 0 1 true
}
```

### With Trait Bounds

`{}` requires the `std::fmt::Display` trait and `{:?}` requires the `std::fmt::Debug` trait. We have to set `T: Display` or `T: Debug` or both `T: Display + Debug` to tell the compiler that `T` satisfy the requirements for either operation.

```rust
use std::fmt::{Debug, Display};

fn print_together<T: Display + Debug>(x: T, y: T) {
    println!("{} {:?}", x, y);
}

fn main() {
    print_together(0, 1); // 0 1
    print_together("001", "002"); // 001 "002"
}
```

## With Structs

```rust
use std::fmt::Display;

struct Point<T: Display> {
    x: T,
    y: T,
}

fn main() {
    let a = Point { x: 0_i8, y: 1 }; // x, y: i8
    let b = Point { x: 0.0001_f64, y: 0.0002 }; // x, y: f64

    println!("{} {}", a.x, a.y); // 0 1
    println!("{} {}", b.x, b.y); // 0.0001 0.0002
}
```

ğŸ’¯ When adding an implementation for a generic struct, the type parameters should be declared after the impl as well. Ex, `impl<T> Point<T>`

## With Enums

```rust
// An output can have either Some value or no value/ None.
enum Option<T> { // T is a generic and it can contain any type of value.
    Some(T),
    None,
}

// A result can represent either success/ Ok or failure/ Err.
enum Result<T, E> { // T and E are generics. T can contain any type of value, E can be any error.
    Ok(T),
    Err(E),
}
```

â­ï¸ [Option](https://doc.rust-lang.org/std/option/index.html) and [Result](https://doc.rust-lang.org/std/result/index.html) types are kind of special generic types which are already defined in Rustâ€™s standard library.
- An **optional value** can have either **Some** value or no value/ **None**. Express the possibility of absence.
- A **result** can represent either success/ **Ok** or failure/ **Err**. Expresses the possibility of failure.

### Option

```rust
struct Task {
    title: String,
    assignee: Option<Person>, // ğŸ’¡ Instead of `assignee: Person`, we use `assignee: Option<Person>` as the assignee can be `None`.
}
```
 
```rust
fn get_id_by_username(username: &str) -> Option<usize> { // ğŸ’¡ Instead of setting return type as `usize`, set it `Option<usize>`
    // if username can be found in the system, return userId
        return Some(userId); // ğŸ’¡ Instead of return userId, return Some(userId)

    // else
        None // ğŸ’¡ The last return statement no need `return` keyword and ending `;`
}

fn main() {
    let username = "anonymous";
    match get_id_by_username(username) { // ğŸ’¡ We can use pattern matching to catch the relevant return type (Some/None)
        None => println!("User not found"),
        Some(i) => println!("User Id: {}", i),
    }
}
```

### Result

```rust
fn get_word_count_from_file(file_name: &str) -> Result<u32, &str> { // ğŸ’¡ Instead of setting return type as `u32`, set it `Result<u32, &str>`
    // if the file is not found on the system, return error
        return Err("File can not be found!"); // ğŸ’¡ Instead panic/ break when the file can not be found; return Err(something)

    // else, count and return the word count
        Ok(word_count) // ğŸ’¡ Instead of return `word_count`, return `Ok(word_count)`
        // ğŸ’¡ The last return statement no need `return` keyword and ending `;`
}

fn main() {
    let mut file_name = "file_a";
    match get_word_count_from_file(file_name) { // ğŸ’¡ We can use pattern matching to catch the relevant return type (Ok/Err)
        Ok(i) => println!("Word Count: {}", i),
        Err(e) => println!("Error: {}", e)
    }
}
```

ğŸ’­ This is a quick reference about the `Option` and `Result` as enums. Please donâ€™t worry about them much now, as we will discuss them later.
