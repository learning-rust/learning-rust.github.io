---
title: Operators
slug: operators
---

## Arithmetic Operators

`+ - * / %`

```rust
let a = 5;
let b = a + 1; // 6
let c = a - 1; // 4
let d = a * 2; // 10
let e = a / 2; // â­ï¸ 2 not 2.5
let f = a % 2; // 1

let g = 5.0 / 2.0; // 2.5
```

## Comparison Operators

`== != < > <= >=`

```rust
let a = 1;
let b = 2;

let c = a == b; // false
let d = a != b; // true
let e = a < b; // true
let f = a > b; // false
let g = a <= a; // true
let h = a >= a; // true

// ğŸ”
let i = true > false; // true
let j = 'a' > 'A'; // true
```

## Logical Operators

`! && ||`

```rust
let a = true;
let b = false;

let c = !a; // false
let d = a && b; // false
let e = a || b; // true
```

> ğŸ” On integer types,`!` inverts the individual bits in the twoâ€™s complement representation of the value.
>
> ```rust
> let a = !-2; // 1
> let b = !-1; // 0
> let c = !0; // -1
> let d = !1; // -2
> ```

## Bitwise Operators

`& | ^ << >>`

```rust
let a = 1;
let b = 2;

let c = a & b; // 0  (01 && 10 -> 00)
let d = a | b; // 3  (01 || 10 -> 11)
let e = a ^ b; // 3  (01 != 10 -> 11)
let f = a << b; // 4  (Add b number of 0s to the end of a -> '01'+'00' -> 100)
let g = a >> b; // 0  (Remove b number of bits from the end of a -> oÌ¶1Ì¶ -> 0)
```

## Assignment and Compound Assignment Operators

The `=` operator is used to assign a name to a value or a function. Compound Assignment Operators are created by composing one of `+ - * / % & | ^ << >>` operators with `=` operator.

```rust
let mut a = 2;

a += 5; // 2 + 5 = 7
a -= 2; // 7 - 2 = 5
a *= 5; // 5 * 5 = 25
a /= 2; // 25 / 2 = 12 not 12.5
a %= 5; // 12 % 5 = 2

a &= 2; // 10 && 10 -> 10 -> 2
a |= 5; // 010 || 101 -> 111 -> 7
a ^= 2; // 111 != 010 -> 101 -> 5
a <<= 1; // '101'+'0' -> 1010 -> 10
a >>= 2; // 101Ì¶0Ì¶ -> 10 -> 2
```

## Type Casting Operator

`as`

```rust
let a = 15;
let b = (a as f64) / 2.0; // 7.5
```

## Borrowing and Dereference Operators

`& &mut *`

ğŸ” The `&` or `&mut` operators are used for **borrowing** and `*` operator for **dereferencing**. For more information, refer [Ownership](/docs/ownership), [Borrowing](/docs/borrowing) & [Lifetimes](/docs/lifetimes) sections.

## Path separator and member access operators

`:: .`

ğŸ” We discussed the usage of the `::` and `.` operators when calling [associated functions and methods](/docs/functions/#-before-going-to-the-next) under [Functions](/docs/functions).

ğŸ’¯ Also, the `::` operator is used to access modules, constants, structs, enums, functions (excluding methods) in std modules, crates or nested/ parent modules and to access variants of enums.

ğŸ’¯ Also, the `.` operator is used to access fields of tuples and structs and to call methods in datatypes.

```rust
use std::collections::HashMap; // ğŸ’¡load HashMap struct from the std::collections module

fn main() {
    // ğŸ’¡ using `HashMap::from()` associated function to create a HashMap
    let best_movies = HashMap::from([
        ("01", "The Shawshank Redemption"),
        ("02", "The Godfather"),
        ("03", "The Dark Knight"),
    ]);

    println!("{:?}", best_movies);
}
```

```rust
println!("{}", std::primitive::u8::MAX); // ğŸ’¡ access MAX constant from the std::primitive::u8
```

```rust
let mut a = (1, "Steve"); // ğŸ’¡ a is a tuple

// ğŸ’¡ access fields via dot operator
a.0 = 2;
a.1 = "Tim";
println!("{} {}", a.0, a.1); // 2 Tim
```

## ğŸ‘¨â€ğŸ« Before going to the next...

- About **string concatenation**,

```rust
let (s1, s2) = ("abc", "123"); // both &str
// All bellow codes return abc123 (in String data type)

// 1. via + operator
let s = String::from(s1) + s2; // String + &str

// 2. via push_str method
let mut s = String::from(s1);
s.push_str(s2); // String + &str

// 3. via format! macro
let s = format!("{s1}{s2}"); // &str/String + &str/String

// 4. via concat method
let s = [s1, s2].concat(); // &str or String array
```
