---
title: Enums
slug: enums
---

- An enum is a single type that contains variants, which represent the possible values of the enum at any given time.
- Can access the variants using the `::` notation and the variant name, ex. Day::Sunday
- An enum variant can have either,
  - No data (a unit variant)
  - Unnamed ordered data (a tuple variant)
  - Named data (a struct variant)

## Definition

### With Unit Variants

```rust
enum Day {
    Sunday,
    Monday,
    Tuesday,
    Wednesday,
    Thursday,
    Friday,
    Saturday,
}
// ðŸ’¡ Day is the enum. Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday are its variants.
```

### With Different Kinds of Variants

```rust
enum FlashMessage {
    Success, // ðŸ’¡ A unit variant (no data)
    Error(u8, String), // ðŸ’¡ A tuple variant (one or more , separated data)
    Warning { field: String, message: String }, // ðŸ’¡ A struct variant (one or more , separated name: value data)
}
```

## Initialization

### With Different Kinds of Variants

```rust
#![allow(dead_code)] // ðŸ’¡ Remove dead_code warnings, as we don't access the elements of variants.

#[derive(Debug)]
enum FlashMessage {
    Success,
    Error(u32, String),
    Warning { field: String, message: String },
}

fn main() {
    // Initialization
    let a = FlashMessage::Success;
    let b = FlashMessage::Error(401, "Unauthorized".to_string());
    let c = FlashMessage::Warning {
        field: "email".to_string(),
        message: "This is required".to_string(),
    };

    // Debug printing
    println!("{a:?}"); // Success
    println!("{b:?}"); // Error(401, "Unauthorized")
    println!("{c:?}"); // Warning { field: "email", message: "This is required" }
    
    // ðŸ’¡ Variable declaration and assignment, separately
    let a: FlashMessage; // Declaration with the type
    a = FlashMessage::Success; // Assignment with the value
    println!("{a:?}"); // Success
}
```

### With a Default Variant

```rust
#[derive(Default)]
enum Hand {
    Left,
    #[default] // ðŸ’¡Set Right as the default variant
    Right,
},

fn main() {
    let a = Hand::default(); // Initialization with the default variant

    assert_eq!(a, Hand::Right); // Hand default value is Right
}

// ðŸ’¡ #[derive(Default)] attribute automatically generates a default implementation for the Default trait for a struct or enum.
```

## Pattern Matching & Destructuring

### By `match`

```rust
#![allow(dead_code)] // ðŸ’¡ Remove dead_code warnings, as we don't use Spring, Summer, Autumn variants in variables.

enum Season {
    Spring,
    Summer,
    Autumn,
    Winter,
}

fn main() {
    let a = Season::Winter;

    // Pattern matching by match
    let result = match a {
        Season::Spring => "â˜€ï¸",
        Season::Summer => "ðŸ",
        Season::Autumn => "ðŸ‚",
        Season::Winter => "â„ï¸",
    };

    println!("{result}"); // â„ï¸
}
```

```rust
#![allow(dead_code)] // ðŸ’¡ Remove dead_code warnings, as we don't access all elements of the variants.

enum FlashMessage {
    Success,
    Error(u32, String),
    Warning { field: String, message: String },
}

fn main() {
    let a = FlashMessage::Error(401, "Unauthorized".to_string());

    let result = match a {
        FlashMessage::Success => "We'll get back to you.".to_string(),
        FlashMessage::Error(_, msg) => msg, // ðŸ’¡ Destructuring only the second element of the tuple variant.
        FlashMessage::Warning { message, .. } => message, // ðŸ’¡ Destructuring only the second field of the struct variant.
    };

    println!("{result}"); // Unauthorized
}
```

### By `if let` and `else if let`

```rust
#![allow(dead_code)] // ðŸ’¡ Remove dead_code warnings, as we don't access the all elements of variants.

enum FlashMessage {
    Success,
    Error(u32, String),
    Warning { field: String, message: String },
}

fn main() {
    let a = FlashMessage::Error(401, "Unauthorized".to_string());

    if let FlashMessage::Error(_, msg) = a {
        println!("{msg}"); // Unauthorized
    } else if let FlashMessage::Warning { message, .. } = a {
        println!("{message}");
    } else {
        println!("We'll get back to you.");
    }
}
```
