---
title: Enums
slug: enums
---

- An enum is a single type that contains variants, which represent the possible values of the enum at any given time.
- By convention, the enum name and its variants' names should follow [`PascalCase`](https://en.wikipedia.org/wiki/Camel_case).
- Can access the variants using the `::` notation and the variant name. ex. Day::Sunday

```rust
enum Day {
    Sunday,
    Monday,
    Tuesday,
    Wednesday,
    Thursday,
    Friday,
    Saturday,
}

// ðŸ’¡ Day is the enum. Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday are its variants.
```

- An enum variant can have either,
  - No data (a unit variant)
  - Unnamed ordered data (a tuple variant)
  - Named data/ fields (a struct variant)
  ```rust
  enum FlashMessage {
      Success, // ðŸ’¡ A unit variant (no data)
      Error(u8, String), // ðŸ’¡ A tuple variant (one or more , separated data)
      Warning { field: String, message: String }, // ðŸ’¡ A struct variant (one or more , separated name: value data)
  }

  // ðŸ’¡ FlashMessage is the emnum, Success, Error, Warning are its variants.
  ```

> ðŸ’¡ In Rust, the term "instantiation" is used to describe the act of creating a concrete instance of a type (struct or enum).
>
> ðŸ’¡ In Rust, the term "field" is used to describe a named component in a C-like struct & struct-like enum variant, and the term "element" is used to describe an unnamed component in a tuple struct & tuple-like enum variant. The term "member" is used to describe both.
>
> ðŸ’¯ More complex examples can be found on [Generics](/docs/generics/), [Impls and Traits](/docs/impls-and-traits), [Lifetimes](/docs/lifetimes) and [Modules](/docs/modules) sections.

## Instantiation

```rust
#![allow(unused)] // ðŸ’¡ skip unused warnings, as we don't read fields in the enums

#[derive(Debug)]
enum FlashMessage { // Definition
    Success,
    Error(u32, String),
    Warning { field: String, message: String },
}

fn main() {
    // 1. Instantiation with separate variable declaration and assignment
    let x: FlashMessage; // Declaration with the data type
    x = FlashMessage::Success;
    println!("{x:?}"); // Success
    
    // 2. Instantiation with a direct variable initialization
    let a = FlashMessage::Success;
    let b = FlashMessage::Error(401, "Unauthorized".to_string());
    let c = FlashMessage::Warning { field: "email".to_string(), message: "This is required".to_string() };

    println!("{a:?}"); // Success
    println!("{b:?}"); // Error(401, "Unauthorized")
    println!("{c:?}"); // Warning { field: "email", message: "This is required" }    
}
```

```rust
// 3. Instantiation with a default variant
#![allow(unused)] // ðŸ’¡ skip unused warnings, as we don't use the all variants of the enum

#[derive(Debug, Default)]
enum Hand {
    Left,
    #[default] // ðŸ’¡Set Right as the default variant
    Right,
}

fn main() {
    let a = Hand::default(); // Instantiation with the default variant
    println!("{a:?}"); // Right
}
```

In Rust, the `#[derive()]` attribute is used to automatically generate an implementation of certain traits for a custom data structure (struct and enum), instead of you writing them by hand. The [`std::fmt::Debug`](https://doc.rust-lang.org/std/fmt/trait.Debug.html) trait allows us to format a value with `{:?}` or `{:#?}` in `println!` and similar macros. The [`std::default::Default`](https://doc.rust-lang.org/std/default/trait.Default.html) trait allows us to create a new instance of a type with the `Type::default()` method. 

## Pattern Matching

### With `match`

```rust
#![allow(unused)] // ðŸ’¡ skip unused warnings, as we don't use the all variants of the enum

enum Season {
    Spring,
    Summer,
    Autumn,
    Winter,
}

fn main() {
    let a = Season::Winter;
    let result = match a {
        Season::Spring => "â˜€ï¸",
        Season::Summer => "ðŸ",
        Season::Autumn => "ðŸ‚",
        Season::Winter => "â„ï¸",
    };

    println!("{result}"); // â„ï¸
}
```

### With `if let`, `else if let`, `else`

`if let` is useful when we only care about handling one (or few) specific patterns and donâ€™t need to explicitly match every possible case.

```rust
#![allow(unused)] // ðŸ’¡ skip unused warnings, as we don't use the all variants of the enum

enum Season {
    Spring,
    Summer,
    Autumn,
    Winter,
}

fn main() {
    let a = Season::Winter;
    let result = if let Season::Spring = a {
        "â˜€ï¸"
    } else if let Season::Summer = a {
        "ðŸ"
    } else if let Season::Autumn = a {
        "ðŸ‚"
    } else if let Season::Winter = a {
        "â„ï¸"
    } else {
        unreachable!()
    };

    println!("{result}"); // â„ï¸
}
```

## Destructuring & Accessing Variants' Members

In Rust, directly accessing an enum variant's fields without any form of pattern matching is not possible. We need to use pattern matching to access the fields by using a `match` expression or `if let` expression.

### With `match`

```rust
#![allow(unused)] // ðŸ’¡ skip unused warnings, as we don't use the all variants of the enum

enum FlashMessage {
    Success,
    Error(u32, String),
    Warning { field: String, message: String },
}

fn main() {
    let a = FlashMessage::Error(401, "Unauthorized".to_string());

    let result = match a {
        FlashMessage::Success => "We'll get back to you.".to_string(),
        FlashMessage::Error(_, msg) => msg, // ðŸ’¡ Destructuring only the second element of the tuple variant.
        FlashMessage::Warning { message, .. } => message, // ðŸ’¡ Destructuring only the second field of the struct variant.
    };

    println!("{result}"); // Unauthorized
}
```

### With `if let`, `else if let`, `else`

`if let` is useful when we only care about handling one (or few) specific patterns and donâ€™t need to explicitly match every possible case.

```rust
#![allow(dead_code)] // ðŸ’¡ Remove dead_code warnings, as we don't access the all elements of variants.

enum FlashMessage {
    Success,
    Error(u32, String),
    Warning { field: String, message: String },
}

fn main() {
    let a = FlashMessage::Error(401, "Unauthorized".to_string());

    if let FlashMessage::Error(_, msg) = a {
        println!("{msg}"); // Unauthorized
    } else if let FlashMessage::Warning { message, .. } = a {
        println!("{message}");
    } else {
        println!("We'll get back to you.");
    }
}
```
