---
title: Structs
slug: structs
---

- Used to **encapsulate related properties into one unified data type**.
- By convention, the name should follow **[PascalCase](https://en.wikipedia.org/wiki/Camel_case)**.
- 3 variants,
  - C-like structs: One or more `,` separated `name: value pairs` enclosed in `{}`

    ```rust
    struct Color {
        red: u8,
        green: u8,
        blue: u8,
    }
    ```

  - Tuple structs: One or more `,` separated `values`  enclosed in `()`

    ```rust
    struct Color(u8, u8, u8);
    ```

  - Unit structs: A struct with no members

    ```rust
    struct Black;
    ```

â­ï¸ When regarding OOP in Rust, attributes and methods are placed separately on **structs** and **traits**. Structs contain only attributes, traits contain only methods. They are getting connected via **impls**.

> ðŸ’¯ More complex examples can be found on [impls & traits](/docs/impls-and-traits), [lifetimes](/docs/lifetimes) and [modules](/docs/modules) sections.

## C-like Structs

- Similar to classes \(without its methods\) in OOP languages.
- Can access fields using the `.`/ dot notation and the field name.

### Definition

```rust
struct Color {
    red: u8,
    green: u8,
    blue: u8,
}
```

### Initialization & Accessing Fields

```rust
struct Color {
    red: u8,
    green: u8,
    blue: u8,
}

fn main() {
    // 1. Initialization
    let white = Color {
        red: 255,
        green: 255,
        blue: 255,
    };

    // 2. Initialization without redundant field names, when using the same variable names
    let (red, green, blue) = (0, 0, 0);
    let black = Color { red, green, blue };

    // 3. Initialization + copy elements from another instance
    let red = Color { red: 255, .. black }; // ðŸ’¡ Copy green and blue from black
    let green = Color { green: 255, .. black }; // ðŸ’¡ Copy red and blue from black
    let mut blue = Color { .. black }; // ðŸ’¡ Copy all elements from black
    blue.blue = 255;

     println!("RGB({}, {}, {})", white.red, white.green, white.blue); // RGB(255, 255, 255)
     println!("RGB({}, {}, {})", black.red, black.green, black.blue); // RGB(0, 0, 0)

     println!("RGB({}, {}, {})", red.red, red.green, red.blue); // RGB(255, 0, 0)
     println!("RGB({}, {}, {})", green.red, green.green, green.blue); // RGB(0, 255, 0)
     println!("RGB({}, {}, {})", blue.red, blue.green, blue.blue); // RGB(0, 0, 255)
}
```

```rust
// 4. Initialization with default values
#[derive(Default)]
struct Person {
    name: String,
    age: f32,
}

fn main() {
    let a = Person::default(); // Initialization with default values

    assert_eq!(a.name, ""); // String default value ""
    assert_eq!(a.age, 0.0); // f32 default value 0.0
}

// ðŸ’¡ #[derive(Default)] attribute automatically generates a default implementation for the Default trait for a struct or enum.
```

ðŸ’¯ 5. We can also use a constructor function inside an `impl` block to initialize a struct.

### Destructuring

```rust
struct Person {
    name: String,
    company_name: String,
}

fn get_steve() -> Person {
    Person {
        name: "Steve Jobs".to_string(),
        company_name: "Apple".to_string(),
    }
}

fn main() {
    let steve = Person {
        name: "Steve Jobs".to_string(),
        company_name: "Apple".to_string(),
    };

    let Person {name: a, company_name: b} = steve; // 1. Destructuring elements to a and b
    println!("{a} {b}"); // Steve Jobs Apple

    let Person {company_name: c, .. } = get_steve(); // 2. Destructuring only selected elements + a struct returned from a function
    println!("{c}"); // Apple
}

// ðŸ’¯ let Person {name: ref a, company_name: ref b} = steve; // add ref keyword, to pass an element as a reference
```

### Debug Printing and Pretty Debug Printing

> ðŸ’¡ `#[derive(Debug)]` attribute is used to automatically generate an implementation of the `Debug trait` for a custom data structure, such as a `struct` or an `enum`.

```rust
#![allow(unused)] // ðŸ’¡ skip unused warnings in crate/ module level

#[derive(Debug)]
struct Person {
    name: String,
    company_name: String,
}

fn main() {
    let (name, company_name) = ("Steve Jobs".to_string(), "Apple".to_string());
    let a = Person { name, company_name };

    println!("{a:?}"); // ðŸ’¡ Debug printing with :? format specifier
    // Person { name: "Steve Jobs", company_name: "Apple" }

    println!("{a:#?}"); // ðŸ’¡ Pretty-debug printing with :#? format specifier
    // Person {
    //     name: "Steve Jobs",
    //     company_name: "Apple",
    // }
}
```

## Tuple Structs

- Looks like a named tuples.
- Can access fields using the `.`/ dot notation and the index number of the field, like on tuples.
- â­ï¸ When a tuple struct has only one element, we call it **newtype pattern**. Because it helps to create a new type.

### Definition

```rust
struct Color(u8, u8, u8);

struct Department(String);
```

### Initialization & Accessing Elements

```rust
struct Color(u8, u8, u8);

struct Department(String);

fn main() {
    let white = Color(255, 255, 255);
    println!("RGB({}, {}, {})", white.0, white.1, white.2); // RGB(255, 255, 255)

    let eng_department = Department("Engineering".to_string());
    println!("{}", eng_department.0); // Engineering
}
```

### Destructuring

```rust
struct Color(u8, u8, u8);

struct Department(String);

fn get_department() -> Department {
    Department("Engineering".to_string())
}

fn main() {
    let white = Color(255, 255, 255);

    let Color(red, green, blue) = white; // ðŸ’¡ let Color(red, blue, .. ) = white; // Destructuring only selected elements
    println!("RGB({}, {}, {})", red, green, blue); // RGB(255, 255, 255)

    let Department(name) = get_department();
    println!("{}", name); // Engineering
}
```

### Debug Printing and Pretty Debug Printing

```rust
#![allow(unused)]

#[derive(Debug)]
struct Department(String);

fn main() {
    let a = Department("Engineering".to_string());

    println!("{a:?}");
    // Department("Engineering")

    println!("{a:#?}");
    // Department(
    //     "Engineering",
    // )
}
```

## Unit Structs

- It defines a new type, but it resembles an empty tuple, \(\)
- This is rarely useful on its own. But in combination with other features (such as generics), it can become useful.

> [ðŸ“–](https://doc.rust-lang.org/book/first-edition/structs.html) ex: A library may ask you to create a structure that implements a certain trait to handle events. If you donâ€™t have any data you need to store in the structure, you can create a unit-like struct.

### Definition & Initialization

```rust
struct Electron;

fn main() {
    let x = Electron;
}
```

### Debug Printing and Pretty Debug Printing

```rust
#[derive(Debug)]
struct Electron;

fn main() {
    let a = Electron;
    println!("{a:?}"); // Electron
    println!("{a:#?}"); // Electron
}
```
